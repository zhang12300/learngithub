###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        06/Feb/2018  21:44:12
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\智能车\程序\下位机程序_摄像头1队\src\Sources\C\Component_C\adc.c
#    Command line =  
#        D:\智能车\程序\下位机程序_摄像头1队\src\Sources\C\Component_C\adc.c -D
#        IAR -D TWR_K60N512 -lCN
#        D:\智能车\程序\下位机程序_摄像头1队\FLASH\List\ -lB
#        D:\智能车\程序\下位机程序_摄像头1队\FLASH\List\ -o
#        D:\智能车\程序\下位机程序_摄像头1队\FLASH\Obj\ --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\智能车\程序\下位机程序_摄像头1队\src\Sources\H\ -I
#        D:\智能车\程序\下位机程序_摄像头1队\src\Sources\H\Component_H\ -I
#        D:\智能车\程序\下位机程序_摄像头1队\src\Sources\H\Frame_H\ -I
#        D:\智能车\程序\下位机程序_摄像头1队\src\Sources\H\Function_H\ -I
#        D:\智能车\程序\下位机程序_摄像头1队\src\Sources\H\SD_H\ -Ol
#        --use_c++_inline
#    List file    =  D:\智能车\程序\下位机程序_摄像头1队\FLASH\List\adc.lst
#    Object file  =  D:\智能车\程序\下位机程序_摄像头1队\FLASH\Obj\adc.o
#
###############################################################################

D:\智能车\程序\下位机程序_摄像头1队\src\Sources\C\Component_C\adc.c
      1          //============================================================================
      2          //文件名称：adc.c  
      3          //功能概要：adc构件源文件
      4          //版权所有：HJF
      5          //版本更新：2011-11-13  V1.0   初始版本
      6          //          2011-11-21   V1.1   规范排版风格
      7          //============================================================================
      8          
      9          #include "adc.h"
     10          
     11          //AD采样结果。

   \                                 In section .bss, align 2
     12          int16 ADResult0 = 0;
   \                     ADResult0:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     13          int16 ADResult1 = 0;
   \                     ADResult1:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     14          int16 ADResult2 = 0;
   \                     ADResult2:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     15          int16 ADResult3 = 0;
   \                     ADResult3:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     16          int16 ADResult4 = 0;
   \                     ADResult4:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     17          int16 ADResult5 = 0;
   \                     ADResult5:
   \   00000000                      DS8 2
     18          

   \                                 In section .bss, align 2
     19          uint16 ADResultCom;    //温漂修正
   \                     ADResultCom:
   \   00000000                      DS8 2
     20          

   \                                 In section .bss, align 4
     21          uint32 GryoFlatCount = 0; //陀螺仪，平路计数。
   \                     GryoFlatCount:
   \   00000000                      DS8 4

   \                                 In section .data, align 1
     22          uint8 GryoFlatFlag = 1;   //陀螺仪，平路标志。1平路，0坡。
   \                     GryoFlatFlag:
   \   00000000   0x01               DC8 1

   \                                 In section .bss, align 4
     23          int16 GyroResult[GyroResultNum];  //陀螺仪，角度储存数组。
   \                     GyroResult:
   \   00000000                      DS8 20

   \                                 In section .bss, align 1
     24          uint8 GyroResultFlag = 0;   //陀螺仪，坡道判断。0平路，1上坡，2下坡。
   \                     GyroResultFlag:
   \   00000000                      DS8 1
     25          
     26          //禁止赛道类型判断

   \                                 In section .bss, align 1
     27          uint8 GyroResultForbidFlag = 0;           //坡道禁止赛道类型判断标志，1表示禁止任何赛道类型判断，0表示不禁止。
   \                     GyroResultForbidFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     28          uint8 GyroResultForbidBackCount = 0;      //坡道禁止赛道类型判断倒计数
   \                     GyroResultForbidBackCount:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
     29          uint8 GyroResultForbidBackCountNum = 50;  //坡道禁止赛道类型判断倒计数载入值
   \                     GyroResultForbidBackCountNum:
   \   00000000   0x32               DC8 50
     30           
     31          //============================================================================
     32          //函数名称：adc_init
     33          //函数返回：0 成功 ，1 失败
     34          //参数说明：MoudelNumber：模块号
     35          //功能概要：AD初始化
     36          //============================================================================

   \                                 In section .text, align 2, keep-with-next
     37          uint8 hw_adc_init(int MoudelNumber)
     38          {
     39              if(MoudelNumber == 0)//模块0
   \                     hw_adc_init: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD109             BNE.N    ??hw_adc_init_0
     40              {
     41              	//打开ADC0模块时钟
     42                  SIM_SCGC6 |= (SIM_SCGC6_ADC0_MASK );
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable3  ;; 0x4004803c
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable3  ;; 0x4004803c
   \   00000012   0x6008             STR      R0,[R1, #+0]
     43              }
     44              else if(MoudelNumber == 1)//模块1
     45              {      
     46              	//打开ADC1模块时钟
     47                  SIM_SCGC3 |= (SIM_SCGC3_ADC1_MASK );
     48              }
     49              else
     50              {
     51                  return 0;
     52              }
     53              
     54              return 1;
   \                     ??hw_adc_init_1: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \                     ??hw_adc_init_2: (+1)
   \   00000016   0x4770             BX       LR               ;; return
   \                     ??hw_adc_init_0: (+1)
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD108             BNE.N    ??hw_adc_init_3
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable3_1  ;; 0x40048030
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable3_1  ;; 0x40048030
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   \   0000002C   0xE7F2             B.N      ??hw_adc_init_1
   \                     ??hw_adc_init_3: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE7F1             B.N      ??hw_adc_init_2
     55          }
     56          
     57          
     58          
     59          //============================================================================
     60          //函数名称：ad_once
     61          //函数返回：16位无符号的AD值 
     62          //参数说明：MoudelNumber：模块号
     63          //               Channel：通道号
     64          //              accuracy：精度
     65          //功能概要：采集一次一路模拟量的AD值    
     66          //============================================================================

   \                                 In section .text, align 2, keep-with-next
     67          uint16 hw_ad_once(int MoudelNumber,int Channel,uint8 accuracy)//采集某路模拟量的AD值
     68          {
   \                     hw_ad_once: (+1)
   \   00000000   0xB410             PUSH     {R4}
     69          		uint16 result = 0;
   \   00000002   0x2300             MOVS     R3,#+0
     70          		uint8 ADCCfg1Mode = 0;
   \   00000004   0x2400             MOVS     R4,#+0
     71          		ADC_MemMapPtr ADCMoudel;//保存ADC模块地址指针
     72          				
     73          		switch(accuracy)
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0x2A08             CMP      R2,#+8
   \   0000000A   0xD006             BEQ.N    ??hw_ad_once_0
   \   0000000C   0x2A0A             CMP      R2,#+10
   \   0000000E   0xD008             BEQ.N    ??hw_ad_once_1
   \   00000010   0x2A0C             CMP      R2,#+12
   \   00000012   0xD004             BEQ.N    ??hw_ad_once_2
   \   00000014   0x2A10             CMP      R2,#+16
   \   00000016   0xD006             BEQ.N    ??hw_ad_once_3
   \   00000018   0xE007             B.N      ??hw_ad_once_4
     74          		{
     75          			 case 8:
     76          			   ADCCfg1Mode = 0x00;
   \                     ??hw_ad_once_0: (+1)
   \   0000001A   0x2400             MOVS     R4,#+0
     77          			   break;
   \   0000001C   0xE006             B.N      ??hw_ad_once_5
     78          			 case 12:
     79          			   ADCCfg1Mode = 0x01;
   \                     ??hw_ad_once_2: (+1)
   \   0000001E   0x2401             MOVS     R4,#+1
     80          			   break;
   \   00000020   0xE004             B.N      ??hw_ad_once_5
     81          			 case 10:
     82          			   ADCCfg1Mode = 0x02;
   \                     ??hw_ad_once_1: (+1)
   \   00000022   0x2402             MOVS     R4,#+2
     83          			   break;
   \   00000024   0xE002             B.N      ??hw_ad_once_5
     84          			 case 16:
     85          			   ADCCfg1Mode = 0x03;
   \                     ??hw_ad_once_3: (+1)
   \   00000026   0x2403             MOVS     R4,#+3
     86          			   break;
   \   00000028   0xE000             B.N      ??hw_ad_once_5
     87          			 default:
     88          			   ADCCfg1Mode = 0x00;
   \                     ??hw_ad_once_4: (+1)
   \   0000002A   0x2400             MOVS     R4,#+0
     89          		}
     90          		
     91          		
     92          		if(MoudelNumber==0)//选择ADC模块0
   \                     ??hw_ad_once_5: (+1)
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD101             BNE.N    ??hw_ad_once_6
     93          		{
     94          		   ADCMoudel = ADC0_BASE_PTR;
   \   00000030   0x....             LDR.N    R0,??DataTable3_2  ;; 0x4003b000
   \   00000032   0xE000             B.N      ??hw_ad_once_7
     95          		}
     96          		else               //选择ADC模块1
     97          		{
     98          		   ADCMoudel = ADC1_BASE_PTR;
   \                     ??hw_ad_once_6: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable3_3  ;; 0x400bb000
     99          		}
    100          		
    101          		//配置正常电源模式，总线时钟，总线时钟4分频，长采样时间使能，设置精度
    102          		ADC_CFG1_REG(ADCMoudel) = ADLPC_NORMAL
    103          								 | ADC_CFG1_ADIV(ADIV_4)
    104          								 | ADLSMP_LONG
    105          								 | ADC_CFG1_MODE(ADCCfg1Mode)
    106          								 | ADC_CFG1_ADICLK(ADICLK_BUS);
   \                     ??hw_ad_once_7: (+1)
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x00A2             LSLS     R2,R4,#+2
   \   0000003A   0xF012 0x020C      ANDS     R2,R2,#0xC
   \   0000003E   0xF052 0x0250      ORRS     R2,R2,#0x50
   \   00000042   0x6082             STR      R2,[R0, #+8]
    107          		   
    108          		//配置禁止异步时钟使能输出，ADxxat通道选择，高速配置，长采样时间   
    109          		ADC_CFG2_REG(ADCMoudel)  =    MUXSEL_ADCA
    110          								 | ADACKEN_DISABLED
    111          								 | ADHSC_HISPEED
    112          								 | ADC_CFG2_ADLSTS(ADLSTS_20) ;
   \   00000044   0x2204             MOVS     R2,#+4
   \   00000046   0x60C2             STR      R2,[R0, #+12]
    113          								
    114          		//设置通道号
    115          		ADC_SC1_REG(ADCMoudel,A) = AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH(Channel);
   \   00000048   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000004C   0xF051 0x0140      ORRS     R1,R1,#0x40
   \   00000050   0x6001             STR      R1,[R0, #+0]
    116          	    //等待转换完成
    117              	while (( ADC_SC1_REG(ADCMoudel,A) & ADC_SC1_COCO_MASK ) != ADC_SC1_COCO_MASK)
   \                     ??hw_ad_once_8: (+1)
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0x0609             LSLS     R1,R1,#+24
   \   00000056   0xD5FC             BPL.N    ??hw_ad_once_8
    118          		{
    119          
    120          		}
    121          	    //读取转化结果
    122          		result = ADC_R_REG(ADCMoudel,A);       
   \   00000058   0x6903             LDR      R3,[R0, #+16]
    123          		//清ADC转换完成标志
    124          		ADC_SC1_REG(ADCMoudel,A) &= ~ADC_SC1_COCO_MASK;
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0xF031 0x0180      BICS     R1,R1,#0x80
   \   00000060   0x6001             STR      R1,[R0, #+0]
    125          
    126              return result;
   \   00000062   0x0018             MOVS     R0,R3
   \   00000064   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000066   0xBC10             POP      {R4}
   \   00000068   0x4770             BX       LR               ;; return
    127          }
    128          
    129          //============================================================================
    130          //函数名称：ad_mid
    131          //函数返回：16位无符号的AD值 
    132          //参数说明：MoudelNumber：模块号
    133          //               Channel：通道号
    134          //              accuracy：精度
    135          //功能概要：中值滤波后的结果(范围:0-4095) 
    136          //============================================================================

   \                                 In section .text, align 2, keep-with-next
    137          uint16 hw_ad_mid(int MoudelNumber,int Channel,uint8 accuracy) 
    138          {
   \                     hw_ad_mid: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    139          	uint16 i,j,k,tmp;
    140          	//1.取3次A/D转换结果
    141          	i = hw_ad_once(MoudelNumber,Channel,accuracy);
   \   0000000A   0x0032             MOVS     R2,R6
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       hw_ad_once
   \   00000016   0x0007             MOVS     R7,R0
    142          	j = hw_ad_once(MoudelNumber,Channel,accuracy);
   \   00000018   0x0032             MOVS     R2,R6
   \   0000001A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       hw_ad_once
   \   00000024   0x4680             MOV      R8,R0
    143          	k = hw_ad_once(MoudelNumber,Channel,accuracy);
   \   00000026   0x0032             MOVS     R2,R6
   \   00000028   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002A   0x0029             MOVS     R1,R5
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       hw_ad_once
   \   00000032   0x0001             MOVS     R1,R0
    144          	//2.取中值
    145          	if (i > j)
   \   00000034   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000038   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000003A   0x45B8             CMP      R8,R7
   \   0000003C   0xD202             BCS.N    ??hw_ad_mid_0
    146          	{
    147          		tmp = i; i = j; j = tmp;
   \   0000003E   0x0038             MOVS     R0,R7
   \   00000040   0x4647             MOV      R7,R8
   \   00000042   0x4680             MOV      R8,R0
    148          	}
    149          	if (k > j) 
   \                     ??hw_ad_mid_0: (+1)
   \   00000044   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000048   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000004A   0x4588             CMP      R8,R1
   \   0000004C   0xD201             BCS.N    ??hw_ad_mid_1
    150          	  tmp = j;
   \   0000004E   0x4640             MOV      R0,R8
   \   00000050   0xE006             B.N      ??hw_ad_mid_2
    151          	else if(k > i) 
   \                     ??hw_ad_mid_1: (+1)
   \   00000052   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000054   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000056   0x428F             CMP      R7,R1
   \   00000058   0xD201             BCS.N    ??hw_ad_mid_3
    152          	  tmp = k;
   \   0000005A   0x0008             MOVS     R0,R1
   \   0000005C   0xE000             B.N      ??hw_ad_mid_2
    153              else 
    154                tmp = i;
   \                     ??hw_ad_mid_3: (+1)
   \   0000005E   0x0038             MOVS     R0,R7
    155          	return tmp;
   \                     ??hw_ad_mid_2: (+1)
   \   00000060   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000062   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    156          }
    157          
    158          //============================================================================
    159          //函数名称：ad_ave
    160          //函数返回：16位无符号的AD值 
    161          //参数说明：MoudelNumber：模块号
    162          //               Channel：通道号
    163          //              accuracy：精度
    164          //                     N:均值滤波次数(范围:0~255)
    165          //功能概要：均值滤波后的结果(范围:0-4095) 
    166          //============================================================================

   \                                 In section .text, align 2, keep-with-next
    167          uint16 hw_ad_ave(int MoudelNumber,int Channel,uint8 accuracy,uint8 N) 
    168          {
   \                     hw_ad_ave: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    169          	uint32 tmp = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
    170          	uint8  i;
    171              for(i = 0; i < N; i++)
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
   \   00000014   0xE009             B.N      ??hw_ad_ave_0
    172          		tmp += hw_ad_mid(MoudelNumber,Channel,accuracy);
   \                     ??hw_ad_ave_1: (+1)
   \   00000016   0x0032             MOVS     R2,R6
   \   00000018   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       hw_ad_mid
   \   00000022   0xFA18 0xF880      UXTAH    R8,R8,R0
   \   00000026   0xF119 0x0901      ADDS     R9,R9,#+1
   \                     ??hw_ad_ave_0: (+1)
   \   0000002A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000002E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000030   0x45B9             CMP      R9,R7
   \   00000032   0xD3F0             BCC.N    ??hw_ad_ave_1
    173          	tmp = tmp / N; 
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0xFBB8 0xF8F7      UDIV     R8,R8,R7
    174              return (uint16)tmp;
   \   0000003A   0x4640             MOV      R0,R8
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    175          }
    176          
    177          
    178          //======================================================================
    179          //函数名：GyroInit
    180          //功  能：陀螺仪初始化
    181          //参  数：
    182          //返  回：
    183          //影  响：
    184          //说  明：
    185          //      
    186          //             
    187          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    188          uint8 GyroInit(void)
    189          {
   \                     GyroInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB0B2             SUB      SP,SP,#+200
    190            uint32 temp;
    191            uint16 adresult[100];
    192            uint8 i, j;
    193            
    194            //G1  ADC0_SE10   <->   PTA7
    195            PORT_PCR_REG(PORTA_BASE_PTR,  7) |= (0|PORT_PCR_MUX(0));
   \   00000004   0x....             LDR.N    R0,??DataTable3_4  ;; 0x4004901c
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x....             LDR.N    R1,??DataTable3_4  ;; 0x4004901c
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    196            //G2  ADC0_SE17   <->   PTE24
    197            //PORT_PCR_REG(PORTE_BASE_PTR, 24) |= (0|PORT_PCR_MUX(0));
    198            //G3  ADC0_SE18   <->   PTE25
    199            //PORT_PCR_REG(PORTE_BASE_PTR, 25) |= (0|PORT_PCR_MUX(0));
    200            
    201            //采样100次。
    202            for(i = 0; i <= 99; i++)
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0xE009             B.N      ??GyroInit_0
    203            {
    204              adresult[i] = hw_ad_mid(0, 10, 16);
   \                     ??GyroInit_1: (+1)
   \   00000010   0x2210             MOVS     R2,#+16
   \   00000012   0x210A             MOVS     R1,#+10
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      BL       hw_ad_mid
   \   0000001A   0xA900             ADD      R1,SP,#+0
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0xF821 0x0014      STRH     R0,[R1, R4, LSL #+1]
    205            }
   \   00000022   0x1C64             ADDS     R4,R4,#+1
   \                     ??GyroInit_0: (+1)
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x2C64             CMP      R4,#+100
   \   00000028   0xDBF2             BLT.N    ??GyroInit_1
    206            
    207            //从小到大冒泡排排序
    208            for(i = 0; i <= 98; i++)
   \   0000002A   0x2400             MOVS     R4,#+0
   \   0000002C   0xE01E             B.N      ??GyroInit_2
    209            {
    210              for(j = i + 1; j <= 99; j++)
    211              {
    212                if(adresult[i] < adresult[j])
   \                     ??GyroInit_3: (+1)
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   00000036   0xAA00             ADD      R2,SP,#+0
   \   00000038   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003A   0xF832 0x2011      LDRH     R2,[R2, R1, LSL #+1]
   \   0000003E   0x4290             CMP      R0,R2
   \   00000040   0xD20F             BCS.N    ??GyroInit_4
    213                {
    214                  temp = adresult[j];
   \   00000042   0xA800             ADD      R0,SP,#+0
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0xF830 0x0011      LDRH     R0,[R0, R1, LSL #+1]
    215                  adresult[j] = adresult[i];
   \   0000004A   0xAA00             ADD      R2,SP,#+0
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0xF832 0x2014      LDRH     R2,[R2, R4, LSL #+1]
   \   00000052   0xAB00             ADD      R3,SP,#+0
   \   00000054   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000056   0xF823 0x2011      STRH     R2,[R3, R1, LSL #+1]
    216                  adresult[i] = temp;
   \   0000005A   0xAA00             ADD      R2,SP,#+0
   \   0000005C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005E   0xF822 0x0014      STRH     R0,[R2, R4, LSL #+1]
    217                }
    218                else
    219                {
    220                }
    221              }
   \                     ??GyroInit_4: (+1)
   \   00000062   0x1C49             ADDS     R1,R1,#+1
   \                     ??GyroInit_5: (+1)
   \   00000064   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000066   0x2964             CMP      R1,#+100
   \   00000068   0xDBE1             BLT.N    ??GyroInit_3
   \   0000006A   0x1C64             ADDS     R4,R4,#+1
   \                     ??GyroInit_2: (+1)
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0x2C63             CMP      R4,#+99
   \   00000070   0xDA01             BGE.N    ??GyroInit_6
   \   00000072   0x1C61             ADDS     R1,R4,#+1
   \   00000074   0xE7F6             B.N      ??GyroInit_5
    222            }
    223            
    224            temp = adresult[25];
   \                     ??GyroInit_6: (+1)
   \   00000076   0xF8BD 0x0032      LDRH     R0,[SP, #+50]
    225            //取中间若干个点求平均值
    226            for(i = 26; i <= 75; i++)
   \   0000007A   0x241A             MOVS     R4,#+26
   \   0000007C   0xE007             B.N      ??GyroInit_7
    227            {
    228              temp = (temp + adresult[i]) / 2;
   \                     ??GyroInit_8: (+1)
   \   0000007E   0xA900             ADD      R1,SP,#+0
   \   00000080   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000082   0xF831 0x1014      LDRH     R1,[R1, R4, LSL #+1]
   \   00000086   0xFA10 0xF081      UXTAH    R0,R0,R1
   \   0000008A   0x0840             LSRS     R0,R0,#+1
    229            }
   \   0000008C   0x1C64             ADDS     R4,R4,#+1
   \                     ??GyroInit_7: (+1)
   \   0000008E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000090   0x2C4C             CMP      R4,#+76
   \   00000092   0xDBF4             BLT.N    ??GyroInit_8
    230            
    231            ADResultCom = temp;
   \   00000094   0x....             LDR.N    R1,??DataTable3_5
   \   00000096   0x8008             STRH     R0,[R1, #+0]
    232            
    233            return 1;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xB032             ADD      SP,SP,#+200
   \   0000009C   0xBD10             POP      {R4,PC}          ;; return
    234          }
    235          
    236          
    237          //编码器处理。AD采集，标志位处理。

   \                                 In section .text, align 2, keep-with-next
    238          uint8 GryoDeal(void)
    239          {
   \                     GryoDeal: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    240            //int16 temp;
    241            uint8 i;
    242          
    243            //3次平均AD采集编码器的返回值，即角速度。
    244            //由于跳变太大，所以除以1000.取千位。//原来这里是除1000的，后来改为除100
    245            ADResult0 = (hw_ad_mid(0, 10, 16) - ADResultCom) / 1000;
   \   00000002   0x2210             MOVS     R2,#+16
   \   00000004   0x210A             MOVS     R1,#+10
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       hw_ad_mid
   \   0000000C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000E   0x....             LDR.N    R1,??DataTable3_5
   \   00000010   0x8809             LDRH     R1,[R1, #+0]
   \   00000012   0x1A40             SUBS     R0,R0,R1
   \   00000014   0xF44F 0x717A      MOV      R1,#+1000
   \   00000018   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000001C   0x....             LDR.N    R1,??DataTable3_6
   \   0000001E   0x8008             STRH     R0,[R1, #+0]
    246            
    247            //滤波。会给判坡带来滞后，不过上坡滞后没有关系，关键是在下坡必须要减速。（上坡加减速是可选的）
    248            ADResult1 = (ADResult1 * 90 + ADResult0 * 10) / 100;
   \   00000020   0x....             LDR.N    R0,??DataTable3_7
   \   00000022   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000026   0x215A             MOVS     R1,#+90
   \   00000028   0xFB10 0xF001      SMULBB   R0,R0,R1
   \   0000002C   0x....             LDR.N    R1,??DataTable3_6
   \   0000002E   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   00000032   0x220A             MOVS     R2,#+10
   \   00000034   0xFB11 0x0002      SMLABB   R0,R1,R2,R0
   \   00000038   0x2164             MOVS     R1,#+100
   \   0000003A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000003E   0x....             LDR.N    R1,??DataTable3_7
   \   00000040   0x8008             STRH     R0,[R1, #+0]
    249            //为了防止跑车过程中温漂上扬，给出1的裕度（其实是1000的裕度）。即-1~+1的变化都被滤掉。
    250            /*
    251            if(ADResult1 < 0)
    252            {
    253              temp = 0 - ADResult1;
    254            }
    255            else
    256            {
    257              temp = ADResult1;
    258            }
    259            
    260            if(temp <= 1)
    261            {
    262              ADResult1 = 0;
    263            }
    264            else
    265            {    
    266            }
    267            */
    268            
    269            
    270            //角速度连续为0的次数的更新。由于经过上下坡后，角度不能回零，
    271            //所以当角速度连续为0（即平路）的次数达到一定次数后，需要手动把角度归零。
    272            if(ADResult1 == 0)
   \   00000042   0x....             LDR.N    R0,??DataTable3_7
   \   00000044   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD105             BNE.N    ??GryoDeal_0
    273            {
    274              //角速度为0次数加1。
    275              GryoFlatCount++;
   \   0000004C   0x....             LDR.N    R0,??DataTable3_8
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x1C40             ADDS     R0,R0,#+1
   \   00000052   0x....             LDR.N    R1,??DataTable3_8
   \   00000054   0x6008             STR      R0,[R1, #+0]
   \   00000056   0xE002             B.N      ??GryoDeal_1
    276            }
    277            else
    278            {
    279              //角速度为0次数清零。
    280              GryoFlatCount = 0;
   \                     ??GryoDeal_0: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x....             LDR.N    R1,??DataTable3_8
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    281            }
    282            
    283            if(GryoFlatCount > GryoFlatFlagNum)
   \                     ??GryoDeal_1: (+1)
   \   0000005E   0x....             LDR.N    R0,??DataTable3_8
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x2810             CMP      R0,#+16
   \   00000064   0xD310             BCC.N    ??GryoDeal_2
    284            {
    285              //大于若干次，判定为平路。角度归零。
    286              //置标志位。
    287              GryoFlatFlag = 1;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x....             LDR.N    R1,??DataTable3_9
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
    288              //角度归零
    289              ADResult2 = 0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x....             LDR.N    R1,??DataTable3_10
   \   00000070   0x8008             STRH     R0,[R1, #+0]
    290              //数组清零，防止因为角度归零引起的跳变误判。
    291              for(i = 0; i <= GyroResultNum - 1; i++)
   \   00000072   0x2000             MOVS     R0,#+0
   \                     ??GryoDeal_3: (+1)
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0x280A             CMP      R0,#+10
   \   00000078   0xDA09             BGE.N    ??GryoDeal_4
    292              {
    293                GyroResult[i] = 0;
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x....             LDR.N    R2,??DataTable3_11
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000080   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
    294              }
   \   00000084   0x1C40             ADDS     R0,R0,#+1
   \   00000086   0xE7F5             B.N      ??GryoDeal_3
    295            }
    296            else
    297            {
    298              GryoFlatFlag = 0;
   \                     ??GryoDeal_2: (+1)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x....             LDR.N    R1,??DataTable3_9
   \   0000008C   0x7008             STRB     R0,[R1, #+0]
    299            }
    300            
    301            
    302            //积分。角速度变成角度。
    303            ADResult2 += ADResult1;
   \                     ??GryoDeal_4: (+1)
   \   0000008E   0x....             LDR.N    R0,??DataTable3_10
   \   00000090   0x8800             LDRH     R0,[R0, #+0]
   \   00000092   0x....             LDR.N    R1,??DataTable3_7
   \   00000094   0x8809             LDRH     R1,[R1, #+0]
   \   00000096   0x1808             ADDS     R0,R1,R0
   \   00000098   0x....             LDR.N    R1,??DataTable3_10
   \   0000009A   0x8008             STRH     R0,[R1, #+0]
    304            
    305            for(i = 0; i <= GyroResultNum - 2; i++)
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xE009             B.N      ??GryoDeal_5
    306            {
    307              GyroResult[i] = GyroResult[i+1];
   \                     ??GryoDeal_6: (+1)
   \   000000A0   0x....             LDR.N    R1,??DataTable3_11
   \   000000A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A4   0xEB11 0x0140      ADDS     R1,R1,R0, LSL #+1
   \   000000A8   0x8849             LDRH     R1,[R1, #+2]
   \   000000AA   0x....             LDR.N    R2,??DataTable3_11
   \   000000AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AE   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
    308            }
   \   000000B2   0x1C40             ADDS     R0,R0,#+1
   \                     ??GryoDeal_5: (+1)
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0x2809             CMP      R0,#+9
   \   000000B8   0xDBF2             BLT.N    ??GryoDeal_6
    309            GyroResult[GyroResultNum-1] = ADResult2;
   \   000000BA   0x....             LDR.N    R0,??DataTable3_10
   \   000000BC   0x8800             LDRH     R0,[R0, #+0]
   \   000000BE   0x....             LDR.N    R1,??DataTable3_11
   \   000000C0   0x8248             STRH     R0,[R1, #+18]
    310            
    311            //均为负值的、你陡的下降沿，上坡标志。
    312            if(
    313              (GyroResult[GyroResultNum-1] < 0)
    314            &&(GyroResult[0] < 0)
    315            &&(GyroResult[0] - GyroResult[GyroResultNum-1] > GyroResultLimit)    //巧妙的逻辑！
    316              )
   \   000000C2   0x....             LDR.N    R0,??DataTable3_11
   \   000000C4   0xF9B0 0x0012      LDRSH    R0,[R0, #+18]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD511             BPL.N    ??GryoDeal_7
   \   000000CC   0x....             LDR.N    R0,??DataTable3_11
   \   000000CE   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD50C             BPL.N    ??GryoDeal_7
   \   000000D6   0x....             LDR.N    R0,??DataTable3_11
   \   000000D8   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   000000DC   0x....             LDR.N    R1,??DataTable3_11
   \   000000DE   0xF9B1 0x1012      LDRSH    R1,[R1, #+18]
   \   000000E2   0x1A40             SUBS     R0,R0,R1
   \   000000E4   0x280E             CMP      R0,#+14
   \   000000E6   0xDB03             BLT.N    ??GryoDeal_7
    317            {
    318              GyroResultFlag = 1;
   \   000000E8   0x2001             MOVS     R0,#+1
   \   000000EA   0x....             LDR.N    R1,??DataTable3_12
   \   000000EC   0x7008             STRB     R0,[R1, #+0]
   \   000000EE   0xE019             B.N      ??GryoDeal_8
    319            }
    320            //均为正值的、陡的上升沿，下坡标志。下坡后容易出现上坡标志。
    321            else if(
    322              (GyroResult[GyroResultNum-1] > 0)
    323            &&(GyroResult[0] > 0)
    324            &&(GyroResult[GyroResultNum-1] - GyroResult[0] > GyroResultLimit)   //巧妙的逻辑！
    325              )
   \                     ??GryoDeal_7: (+1)
   \   000000F0   0x....             LDR.N    R0,??DataTable3_11
   \   000000F2   0xF9B0 0x0012      LDRSH    R0,[R0, #+18]
   \   000000F6   0x2801             CMP      R0,#+1
   \   000000F8   0xDB11             BLT.N    ??GryoDeal_9
   \   000000FA   0x....             LDR.N    R0,??DataTable3_11
   \   000000FC   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000100   0x2801             CMP      R0,#+1
   \   00000102   0xDB0C             BLT.N    ??GryoDeal_9
   \   00000104   0x....             LDR.N    R0,??DataTable3_11
   \   00000106   0xF9B0 0x0012      LDRSH    R0,[R0, #+18]
   \   0000010A   0x....             LDR.N    R1,??DataTable3_11
   \   0000010C   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   00000110   0x1A40             SUBS     R0,R0,R1
   \   00000112   0x280E             CMP      R0,#+14
   \   00000114   0xDB03             BLT.N    ??GryoDeal_9
    326            {
    327              GyroResultFlag = 2;
   \   00000116   0x2002             MOVS     R0,#+2
   \   00000118   0x....             LDR.N    R1,??DataTable3_12
   \   0000011A   0x7008             STRB     R0,[R1, #+0]
   \   0000011C   0xE002             B.N      ??GryoDeal_8
    328            }
    329            //无跳变沿，平路。
    330            else
    331            {
    332              GyroResultFlag = 0;
   \                     ??GryoDeal_9: (+1)
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x....             LDR.N    R1,??DataTable3_12
   \   00000122   0x7008             STRB     R0,[R1, #+0]
    333            }
    334            
    335            //若倒计数不是0，则每次减一，必须放在载入之前。
    336            if(GyroResultForbidBackCount != 0)
   \                     ??GryoDeal_8: (+1)
   \   00000124   0x....             LDR.N    R0,??DataTable3_13
   \   00000126   0x7800             LDRB     R0,[R0, #+0]
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xD004             BEQ.N    ??GryoDeal_10
    337            {
    338              GyroResultForbidBackCount--;
   \   0000012C   0x....             LDR.N    R0,??DataTable3_13
   \   0000012E   0x7800             LDRB     R0,[R0, #+0]
   \   00000130   0x1E40             SUBS     R0,R0,#+1
   \   00000132   0x....             LDR.N    R1,??DataTable3_13
   \   00000134   0x7008             STRB     R0,[R1, #+0]
    339            }
    340            else
    341            {
    342            }
    343            //坡道禁止赛道类型判断标志
    344            //上坡时，将标志置1，中间会经历标志置0，然后会达到标志置2.置2时或倒计数结束时，解除标志。
    345            if(GyroResultFlag == 1)
   \                     ??GryoDeal_10: (+1)
   \   00000136   0x....             LDR.N    R0,??DataTable3_12
   \   00000138   0x7800             LDRB     R0,[R0, #+0]
   \   0000013A   0x2801             CMP      R0,#+1
   \   0000013C   0xD107             BNE.N    ??GryoDeal_11
    346            {
    347              //标志位置位。
    348              GyroResultForbidFlag = 1;
   \   0000013E   0x2001             MOVS     R0,#+1
   \   00000140   0x....             LDR.N    R1,??DataTable3_14
   \   00000142   0x7008             STRB     R0,[R1, #+0]
    349              //倒计数载入
    350              GyroResultForbidBackCount = GyroResultForbidBackCountNum;
   \   00000144   0x....             LDR.N    R0,??DataTable3_15
   \   00000146   0x7800             LDRB     R0,[R0, #+0]
   \   00000148   0x....             LDR.N    R1,??DataTable3_13
   \   0000014A   0x7008             STRB     R0,[R1, #+0]
   \   0000014C   0xE00A             B.N      ??GryoDeal_12
    351            }
    352            //下坡标志了，或者倒计数结束了，就解除标志。
    353            else if(GyroResultFlag == 2 || GyroResultForbidBackCount == 0)
   \                     ??GryoDeal_11: (+1)
   \   0000014E   0x....             LDR.N    R0,??DataTable3_12
   \   00000150   0x7800             LDRB     R0,[R0, #+0]
   \   00000152   0x2802             CMP      R0,#+2
   \   00000154   0xD003             BEQ.N    ??GryoDeal_13
   \   00000156   0x....             LDR.N    R0,??DataTable3_13
   \   00000158   0x7800             LDRB     R0,[R0, #+0]
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xD102             BNE.N    ??GryoDeal_12
    354            {
    355              //解除标志
    356              GyroResultForbidFlag = 0;
   \                     ??GryoDeal_13: (+1)
   \   0000015E   0x2000             MOVS     R0,#+0
   \   00000160   0x....             LDR.N    R1,??DataTable3_14
   \   00000162   0x7008             STRB     R0,[R1, #+0]
    357            }
    358            //平路过程，不用理会。
    359            else
    360            {
    361            }
    362            
    363            return 1;
   \                     ??GryoDeal_12: (+1)
   \   00000164   0x2001             MOVS     R0,#+1
   \   00000166   0xBD02             POP      {R1,PC}          ;; return
    364          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x4003B000         DC32     0x4003b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x400BB000         DC32     0x400bb000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x4004901C         DC32     0x4004901c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     ADResultCom

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     ADResult0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     ADResult1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x........         DC32     GryoFlatCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x........         DC32     GryoFlatFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x........         DC32     ADResult2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   0x........         DC32     GyroResult

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \   00000000   0x........         DC32     GyroResultFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \   00000000   0x........         DC32     GyroResultForbidBackCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_14:
   \   00000000   0x........         DC32     GyroResultForbidFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_15:
   \   00000000   0x........         DC32     GyroResultForbidBackCountNum
    365          
    366          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   GryoDeal
         8   -> hw_ad_mid
     208   GyroInit
       208   -> hw_ad_mid
      32   hw_ad_ave
        32   -> hw_ad_mid
      24   hw_ad_mid
        24   -> hw_ad_once
       4   hw_ad_once
       0   hw_adc_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_15
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
       2  ADResult0
       2  ADResult1
       2  ADResult2
       2  ADResult3
       2  ADResult4
       2  ADResult5
       2  ADResultCom
     360  GryoDeal
       4  GryoFlatCount
       1  GryoFlatFlag
     158  GyroInit
      20  GyroResult
       1  GyroResultFlag
       1  GyroResultForbidBackCount
       1  GyroResultForbidBackCountNum
       1  GyroResultForbidFlag
      66  hw_ad_ave
     102  hw_ad_mid
     106  hw_ad_once
      50  hw_adc_init

 
  41 bytes in section .bss
   2 bytes in section .data
 906 bytes in section .text
 
 906 bytes of CODE memory
  43 bytes of DATA memory

Errors: none
Warnings: none
