###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.3.8024/W32 for ARM        14/Mar/2018  19:37:51
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\C\Function_C\ImagePro.c
#    Command line =  
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\C\Function_C\ImagePro.c
#        -D IAR -D TWR_K60N512 -lCN
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\FLASH\List\ -lB
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\FLASH\List\ -o
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\FLASH\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\H\ -I
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\H\Component_H\
#        -I E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\H\Frame_H\ -I
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\H\Function_H\ -I
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\H\SD_H\ -Ol
#        --use_c++_inline
#    List file    =  
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\FLASH\List\ImagePro.lst
#    Object file  =  
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\FLASH\Obj\ImagePro.o
#
###############################################################################

E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\C\Function_C\ImagePro.c
      1          /******************************************************************************/
      2          /*******************************************************************************
      3            文件名：图像处理程序文件ImagePro.c
      4            功  能：图像处理
      5            日  期：2014.10.09
      6            作  者：HJZ
      7            备  注：
      8          *******************************************************************************/
      9          /******************************************************************************/
     10          
     11          #include "ImagePro.h"
     12          
     13          //uint16 SW0;
     14          //uint16 SW1;
     15          //uint16 SW2;
     16          //uint16 SW3;
     17          //uint16 SW4;
     18          //uint16 SW5;
     19          //uint16 SW6;
     20          //uint16 SW7;
     21          //uint16 SW8;
     22          

   \                                 In section .data, align 1
     23          uint8 limitStopLineBlackXiu = 30;       //与停车线黑色阈值有关的参数
   \                     limitStopLineBlackXiu:
   \   00000000   0x1E               DC8 30

   \                                 In section .bss, align 1
     24          uint8 ShiZhiFlag = 0;               //十字标志
   \                     ShiZhiFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     25          uint8 ShiZhiCount = 0;              //十字计数
   \                     ShiZhiCount:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
     26          uint16 buXianCount = 0;             //补线修正计数
   \                     buXianCount:
   \   00000000                      DS8 2
     27          
     28          

   \                                 In section .bss, align 1
     29          uint8 xiaoZhiDaoFlag = 0;                 //小直道
   \                     xiaoZhiDaoFlag:
   \   00000000                      DS8 1
     30          

   \                                 In section .bss, align 1
     31          uint8 ImgProFailCount = 0;          //图像失败计数
   \                     ImgProFailCount:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     32          uint8 RunOutFlag = 0;               //跑出赛道标志
   \                     RunOutFlag:
   \   00000000                      DS8 1
     33          

   \                                 In section .bss, align 1
     34          uint8 StopLineCheckBeginFlag = 0;       //开始判断停车线标志
   \                     StopLineCheckBeginFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     35          uint8 StopLineCheckTimer = 0;           //停车线计时
   \                     StopLineCheckTimer:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     36          uint8 StopLineCheckFlag = 0;            //停车线标志
   \                     StopLineCheckFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
     37          int16 ErrorCountNow5 = 0;
   \                     ErrorCountNow5:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
     38          uint8 flag000;
   \                     flag000:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     39          int32 flag111;
   \                     flag111:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     40          int flag222;
   \                     flag222:
   \   00000000                      DS8 4
     41          //uint8 countcount;
     42          

   \                                 In section .bss, align 4
     43          int ServoPIDDGetVal;
   \                     ServoPIDDGetVal:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     44          int ServoPIDDGetValOld;
   \                     ServoPIDDGetValOld:
   \   00000000                      DS8 4
     45          
     46          //中心线提取时，实际赛道宽度的一半对应的像素点数。是固定角度后测得的值。

   \                                 In section .rodata, align 4
     47          uint8 const CenterLineHalfWidth[CameraHight] =  
   \                     CenterLineHalfWidth:
   \   00000000   0x40 0x44          DC8 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120
   \              0x48 0x4C    
   \              0x50 0x54    
   \              0x58 0x5C    
   \              0x60 0x64    
   \              0x68 0x6C    
   \              0x70 0x74    
   \              0x78         
   \   0000000F   0x7C 0x80          DC8 124, 128, 132, 136, 140, 143, 147, 150, 153, 156, 159, 162, 165
   \              0x84 0x88    
   \              0x8C 0x8F    
   \              0x93 0x96    
   \              0x99 0x9C    
   \              0x9F 0xA2    
   \              0xA5         
   \   0000001C   0xA8 0xAC          DC8 168, 172, 177, 179, 181, 183, 185, 187, 189, 191, 193, 195, 213
   \              0xB1 0xB3    
   \              0xB5 0xB7    
   \              0xB9 0xBB    
   \              0xBD 0xBF    
   \              0xC1 0xC3    
   \              0xD5         
   \   00000029   0xD8 0xDB          DC8 216, 219, 222, 225, 228, 231, 234, 237, 240, 100, 100, 100, 100
   \              0xDE 0xE1    
   \              0xE4 0xE7    
   \              0xEA 0xED    
   \              0xF0 0x64    
   \              0x64 0x64    
   \              0x64         
   \   00000036   0x64 0x64          DC8 100, 100, 100, 100, 100, 100
   \              0x64 0x64    
   \              0x64 0x64    
     48          {
     49          64, 68, 72, 76, 80, 84, 88, 92, 96, 100,
     50          104,108,112,116,120,124,128,132,136,140,
     51          143,147,150,153,156,159,162,165,168,172,
     52          177,179,181,183,185,187,189,191,193,195,
     53          213,216,219,222,225,228,231,234,237,240,
     54          100,100,100,100,100,100,100,100,100,100
     55          };
     56          
     57          

   \                                 In section .rodata, align 4
     58          uint8 const BlackLeftEdgeStartColOffset[CameraHight] = //向左检测跳变沿的时候，起始列相对CameraRealWidth/2的向右偏移的列数 
   \                     BlackLeftEdgeStartColOffset:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 40
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x28 0x28    
   \   00000016   0x28 0x28          DC8 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40
   \              0x28 0x28    
   \              0x28 0x28    
   \              0x28 0x28    
   \              0x28 0x28    
   \              0x28 0x28    
   \              0x28 0x28    
   \              0x28 0x28    
   \              0x28         
   \   00000027   0x28 0x2B          DC8 40, 43, 43, 45, 45, 48, 48, 50, 50, 53, 53, 55, 55, 58, 58, 60, 60
   \              0x2B 0x2D    
   \              0x2D 0x30    
   \              0x30 0x32    
   \              0x32 0x35    
   \              0x35 0x37    
   \              0x37 0x3A    
   \              0x3A 0x3C    
   \              0x3C         
   \   00000038   0x3F 0x3F          DC8 63, 63, 65, 65
   \              0x41 0x41    
     59          {
     60          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,         //远处20行
     61          40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,         //中间20行
     62          43,43,45,45,48,48,50,50,53,53,55,55,58,58,60,60,63,63,65,65          //近处20行
     63          };
     64          
     65          

   \                                 In section .rodata, align 4
     66          uint8 const BlackRightEdgeStartColOffset[CameraHight] = //向右检测跳变沿的时候，起始列相对CameraRealWidth/2的向左偏移的列数 
   \                     BlackRightEdgeStartColOffset:
   \   00000000   0x0A 0x0A          DC8 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 20, 20, 20, 20, 20, 20, 20
   \              0x0A 0x0A    
   \              0x0A 0x0A    
   \              0x0A 0x0A    
   \              0x0A 0x0A    
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14         
   \   00000011   0x14 0x1E          DC8 20, 30, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40
   \              0x28 0x28    
   \              0x28 0x28    
   \              0x28 0x28    
   \              0x28 0x28    
   \              0x28 0x28    
   \              0x28 0x28    
   \              0x28 0x28    
   \              0x28         
   \   00000022   0x28 0x28          DC8 40, 40, 40, 40, 40, 40, 43, 43, 45, 45, 48, 48, 50, 50, 53, 53, 55
   \              0x28 0x28    
   \              0x28 0x28    
   \              0x2B 0x2B    
   \              0x2D 0x2D    
   \              0x30 0x30    
   \              0x32 0x32    
   \              0x35 0x35    
   \              0x37         
   \   00000033   0x37 0x3A          DC8 55, 58, 58, 60, 60, 63, 63, 65, 65
   \              0x3A 0x3C    
   \              0x3C 0x3F    
   \              0x3F 0x41    
   \              0x41         
     67          {
     68          10,10,10,10,10,10,10,10,10,10,20,20,20,20,20,20,20,20,30,40,         //远处20行
     69          40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,         //中间20行
     70          43,43,45,45,48,48,50,50,53,53,55,55,58,58,60,60,63,63,65,65          //近处20行
     71          };
     72          
     73          //直角弯
     74          //直角弯特殊处理时，对DeviNow的特殊赋值。影响舵机控制。
     75          //应使之较大，使舵机打角较大。
     76          //最多用AngleSpeDealBackCountNumMax次，越高速用的次数越少。

   \                                 In section .rodata, align 4
     77          int16 const AngleSpeDealDeviNow[AngleSpeDealBackCountNum] = 
   \                     AngleSpeDealDeviNow:
   \   00000000   0x0032 0x0064      DC16 50, 100, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 100
   \              0x0082 0x0082
   \              0x0082 0x0082
   \              0x0082 0x0082
   \              0x0082 0x0082
   \              0x0082 0x0082
   \              0x0064       
   \   0000001A   0x0064 0x0064      DC16 100, 100
   \   0000001E   0x00 0x00          DC8 0, 0
     78          {
     79            //100, 100, 100, 100, 100,
     80            //100, 100, 100, 100, 100
     81          50,100,130,130,130,
     82          130,130,130,130,130,
     83          130,130,100,100,100
     84          };
     85          
     86          //直角弯特殊处理时，对DeviNowLevel的特殊赋值。0~6，0偏差最小，6偏差最大。影响舵机和电机控制。
     87          //应使之较大，使速度较慢。
     88          //最多用AngleSpeDealBackCountNumMax次，越高速用的次数越少。
     89          /*
     90          uint8 const AngleSpeDealDeviNowLevel[AngleSpeDealBackCountNum] = 
     91          {
     92            6, 6, 6, 6, 6,
     93            6, 6, 6, 6, 6
     94          };
     95          */
     96          
     97          //直角弯特殊处理时，对SlopeC的特殊赋值。影响电机控制。
     98          //影响SlopeCLevel.0~5，0最直，5最斜。
     99          //应使之较斜，使速度较慢。
    100          //最多用AngleSpeDealBackCountNumMax次，越高速用的次数越少。

   \                                 In section .rodata, align 4
    101          int32 const AngleSpeDealSlopeC[AngleSpeDealBackCountNum] = 
   \                     AngleSpeDealSlopeC:
   \   00000000   0x000005DC         DC32 1500, 2400, 3000, 3000, 3000, 3000, 3000, 3000, 2850, 2550, 2250
   \              0x00000960   
   \              0x00000BB8   
   \              0x00000BB8   
   \              0x00000BB8   
   \              0x00000BB8   
   \              0x00000BB8   
   \              0x00000BB8   
   \              0x00000B22   
   \              0x000009F6   
   \              0x000008CA   
   \   0000002C   0x000007F8         DC32 2040, 1950, 1860, 1800
   \              0x0000079E   
   \              0x00000744   
   \              0x00000708   
    102          {
    103            //3000, 3000, 3000, 3000, 3000,
    104            //3000, 3000, 3000, 3000, 3000
    105          1500,2400,3000,3000,3000,
    106          3000,3000,3000,2850,2550,
    107          2250,2040,1950,1860,1800
    108          };
    109          
    110          //DeviNow低通滤波时的权重,相加之和为100.不可修改。

   \                                 In section .rodata, align 4
    111          uint8 const DeviNowArrayWight[DeviNowArrayNum] = 
   \                     DeviNowArrayWight:
   \   00000000   0x00 0x00          DC8 0, 0, 100, 0
   \              0x64 0x00    
    112          {
    113            0, 0, 100
    114          };
    115          
    116          //DeviNow低通滤波时的储存数组,初始化为0;可修改。

   \                                 In section .bss, align 4
    117          int16 DeviNowArray[DeviNowArrayNum] = 
   \                     DeviNowArray:
   \   00000000                      DS8 8
    118          {
    119            0, 0, 0
    120          };
    121          
    122          
    123          //单线处理
    124          //单线处理时，允许的黑线宽度的最小值。越远则越小。

   \                                 In section .rodata, align 4
    125          uint8 const SingleBlackWidthMin[CameraHight] = 
   \                     SingleBlackWidthMin:
   \   00000000   0x05 0x05          DC8 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x06 0x06    
   \              0x06         
   \   00000017   0x06 0x06          DC8 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7
   \              0x06 0x06    
   \              0x06 0x06    
   \              0x06 0x06    
   \              0x06 0x06    
   \              0x06 0x06    
   \              0x06 0x06    
   \              0x06 0x06    
   \              0x06 0x07    
   \              0x07 0x07    
   \              0x07 0x07    
   \              0x07         
   \   0000002E   0x07 0x07          DC8 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
   \              0x07 0x07    
   \              0x07 0x07    
   \              0x07 0x07    
   \              0x07 0x07    
   \              0x07 0x07    
   \              0x07 0x07    
    126          {
    127          5,5,5,5,5,5,5,5,5,5,
    128          5,5,5,5,5,5,5,5,5,5,
    129          6,6,6,6,6,6,6,6,6,6,
    130          6,6,6,6,6,6,6,6,6,6,
    131          7,7,7,7,7,7,7,7,7,7,
    132          7,7,7,7,7,7,7,7,7,7
    133          };
    134          
    135          //单线处理时，允许的黑线宽度的最大值。越远则越小。

   \                                 In section .rodata, align 4
    136          uint8 const SingleBlackWidthMax[CameraHight] = 
   \                     SingleBlackWidthMax:
   \   00000000   0x14 0x14          DC8 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14         
   \   00000011   0x14 0x14          DC8 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14         
   \   00000022   0x14 0x14          DC8 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14 0x14    
   \              0x14         
   \   00000033   0x14 0x14          DC8 20, 20, 20, 20, 15, 15, 15, 15, 15
   \              0x14 0x14    
   \              0x0F 0x0F    
   \              0x0F 0x0F    
   \              0x0F         
    137          {
    138          20,20,20,20,20,20,20,20,20,20,
    139          20,20,20,20,20,20,20,20,20,20,
    140          20,20,20,20,20,20,20,20,20,20,
    141          20,20,20,20,20,20,20,20,20,20,
    142          20,20,20,20,20,20,20,20,20,20,
    143          20,20,20,20,20,15,15,15,15,15    //最近的几行15列就够了，太多了会采到旁边的赛道。
    144          };
    145          
    146          /*
    147          uint8 const SingleBlackWidthMax[CameraHight] = 
    148          {
    149          1,1,1,1,1,1,1,1,1,1,
    150          1,1,1,1,1,1,1,1,1,1,
    151          1,1,1,1,1,1,1,1,1,1,
    152          1,1,1,1,1,1,1,1,1,1,
    153          1,1,1,1,1,1,1,1,1,1,
    154          1,1,1,1,1,1,1,1,1,1,
    155          };
    156          */
    157          
    158          //畸变矫正
    159           //远处的黑线畸变矫正数组

   \                                 In section .rodata, align 4
    160          int32 const BlackUdisMatrixFar[8] = 
   \                     BlackUdisMatrixFar:
   \   00000000   0x00000B86         DC32 2950, 4062, -243750, 0, 23420, -22387, 0, 32
   \              0x00000FDE   
   \              0xFFFC47DA   
   \              0x00000000   
   \              0x00005B7C   
   \              0xFFFFA88D   
   \              0x00000000   
   \              0x00000020   
    161          {
    162                  2950,
    163                  4062,
    164               -243750,
    165                     0,
    166                 23420,
    167                -22387,
    168                     0,
    169                    32,
    170          };
    171                  //中间处的黑线畸变矫正数组

   \                                 In section .rodata, align 4
    172          int32 const BlackUdisMatrixMiddle[8] = 
   \                     BlackUdisMatrixMiddle:
   \   00000000   0x00000B86         DC32 2950, 4062, -243750, 0, 23420, -22387, 0, 32
   \              0x00000FDE   
   \              0xFFFC47DA   
   \              0x00000000   
   \              0x00005B7C   
   \              0xFFFFA88D   
   \              0x00000000   
   \              0x00000020   
    173          {
    174                  2950,
    175                  4062,
    176               -243750,
    177                     0,
    178                 23420,
    179                -22387,
    180                     0,
    181                    32,
    182          };
    183          
    184                  //近处的黑线畸变矫正数组

   \                                 In section .rodata, align 4
    185          int32 const BlackUdisMatrixLow[8] = 
   \                     BlackUdisMatrixLow:
   \   00000000   0x00000B86         DC32 2950, 4062, -243750, 0, 23420, -22387, 0, 32
   \              0x00000FDE   
   \              0xFFFC47DA   
   \              0x00000000   
   \              0x00005B7C   
   \              0xFFFFA88D   
   \              0x00000000   
   \              0x00000020   
    186          {
    187                 2950,
    188                  4062,
    189               -243750,
    190                     0,
    191                 23420,
    192                -22387,
    193                     0,
    194                    32,
    195          };
    196          
    197          //对左黑线差值阈值的微调，因为越远的地方差值会越小。

   \                                 In section .rodata, align 4
    198          uint8 const LimitLeftWBAdjust[CameraHight] = 
   \                     LimitLeftWBAdjust:
   \   00000000   0x0A 0x0A          DC8 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 5, 5, 5, 5, 5, 5, 5, 5, 5
   \              0x0A 0x0A    
   \              0x0A 0x0A    
   \              0x0A 0x0A    
   \              0x0A 0x0A    
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x05         
   \   00000013   0x05 0x00          DC8 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000002A   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    199          {
    200          10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    201           5,  5,  5,  5,  5,  5,  5,  5,  5,  5,
    202          0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    203          0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    204          0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    205          0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    206          };
    207          
    208          //对右黑线差值阈值的微调，因为越远的地方差值会越小。

   \                                 In section .rodata, align 4
    209          uint8 const LimitRightWBAdjust[CameraHight] = 
   \                     LimitRightWBAdjust:
   \   00000000   0x0A 0x0A          DC8 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 5, 5, 5, 5, 5, 5, 5, 5, 5
   \              0x0A 0x0A    
   \              0x0A 0x0A    
   \              0x0A 0x0A    
   \              0x0A 0x0A    
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x05 0x05    
   \              0x05         
   \   00000013   0x05 0x00          DC8 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000002A   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    210          {
    211          10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    212           5,  5,  5,  5,  5,  5,  5,  5,  5,  5,
    213          0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    214          0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    215          0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    216          0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    217          };
    218          
    219          
    220          

   \                                 In section .data, align 1
    221          uint8 CameraRealLeftCol = CameraWidth/2 - CameraRealWidth/2;    //ImgPut()函数中，320列图像取250列的真正起始列，用以修正机械偏差。
   \                     CameraRealLeftCol:
   \   00000000   0x23               DC8 35
    222          //只有图像处理成功了，才会进行赛道类型判断，才会进行偏差获取，舵机电机控制值才会更新。

   \                                 In section .data, align 1
    223          uint8 ImgProSucceedFlag = 1;                 //图像处理成功标志位，默认为1，若黑线或中心线提取失败，则置0.
   \                     ImgProSucceedFlag:
   \   00000000   0x01               DC8 1

   \                                 In section .data, align 1
    224          uint8 ImgBlackSucceedFlag = 1;                 //黑线提取成功标志位，默认为1，若黑线提取失败，则置0.
   \                     ImgBlackSucceedFlag:
   \   00000000   0x01               DC8 1

   \                                 In section .data, align 1
    225          uint8 ImgCenterSucceedFlag = 1;                //中心线提取成功标志位，默认为1，若中心线提取失败，则置0.
   \                     ImgCenterSucceedFlag:
   \   00000000   0x01               DC8 1
    226          

   \                                 In section .bss, align 4
    227          uint8 ImgNew[CameraHight][CameraRealWidth];       //处理后的图像数据储存数组
   \                     ImgNew:
   \   00000000                      DS8 15000

   \                                 In section .bss, align 4
    228          uint8 BlackLeftLoc[CameraHight][3];       //左黑线位置存储数组,每行3个可疑点， 255为无效值
   \                     BlackLeftLoc:
   \   00000000                      DS8 180

   \                                 In section .bss, align 4
    229          uint8 BlackRightLoc[CameraHight][3];      //右黑线位置存储数组,每行3个可疑点， 255为无效值
   \                     BlackRightLoc:
   \   00000000                      DS8 180
    230          //uint8 MaxValUint8 = 255;             //自定义的无效值

   \                                 In section .data, align 1
    231          uint8 CenterLineResult = 1;             //中心线提取成功标志
   \                     CenterLineResult:
   \   00000000   0x01               DC8 1

   \                                 In section .data, align 1
    232          uint8 CenterKeyLine = 25;                  //固定的要选取的行。
   \                     CenterKeyLine:
   \   00000000   0x19               DC8 25

   \                                 In section .data, align 1
    233          uint8 CenterLocStore = MaxValUint8;         //左右黑线都提取到的时候，保存的CenterLineLoc[CameraHight - 1]。
   \                     CenterLocStore:
   \   00000000   0xFF               DC8 255

   \                                 In section .data, align 1
    234          uint8 CenterHeadLine = MaxValUint8;         //中心线的线头。
   \                     CenterHeadLine:
   \   00000000   0xFF               DC8 255

   \                                 In section .data, align 1
    235          uint8 CenterEndLine = MaxValUint8;          //中心线的线尾。
   \                     CenterEndLine:
   \   00000000   0xFF               DC8 255

   \                                 In section .bss, align 1
    236          uint8 BlackCenEdgeStartCol = 0;             //扫描起点定位点
   \                     BlackCenEdgeStartCol:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    237          uint8 BlackGetPreDir;                       //黑线预扫描方向。0左线头成功，1右线头成功，2左右线头均失败。
   \                     BlackGetPreDir:
   \   00000000                      DS8 1
    238          

   \                                 In section .bss, align 1
    239          uint8 CurveLineChosenC1 = 0;               //曲率求取时，中心线选取的第1行。
   \                     CurveLineChosenC1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    240          uint8 CurveLineChosenC2 = 0;               //曲率求取时，中心线选取的第1行。
   \                     CurveLineChosenC2:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    241          uint8 CurveLineChosenC3 = 0;               //曲率求取时，中心线选取的第1行。
   \                     CurveLineChosenC3:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    242          uint8 CurveLineChosenL1 = 0;               //曲率求取时，左黑线选取的第1行。
   \                     CurveLineChosenL1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    243          uint8 CurveLineChosenL2 = 0;               //曲率求取时，左黑线选取的第1行。
   \                     CurveLineChosenL2:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    244          uint8 CurveLineChosenL3 = 0;               //曲率求取时，左黑线选取的第1行。
   \                     CurveLineChosenL3:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    245          uint8 CurveLineChosenR1 = 0;               //曲率求取时，右黑线选取的第1行。
   \                     CurveLineChosenR1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    246          uint8 CurveLineChosenR2 = 0;               //曲率求取时，右黑线选取的第1行。
   \                     CurveLineChosenR2:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    247          uint8 CurveLineChosenR3 = 0;               //曲率求取时，右黑线选取的第1行。
   \                     CurveLineChosenR3:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
    248          int16 SABCL = 0;                          //曲率求取时，左黑线曲率三角形的面积，顺时针为负，逆时针为正。
   \                     SABCL:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
    249          int16 SABCC = 0;                          //曲率求取时，中心线曲率三角形的面积，顺时针为负，逆时针为正。
   \                     SABCC:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
    250          int16 SABCR = 0;                          //曲率求取时，右黑线曲率三角形的面积，顺时针为负，逆时针为正。
   \                     SABCR:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
    251          int16 CURVEL = 0;                          //曲率求取时，左黑线的曲率，顺时钟为负，逆时针为正。
   \                     CURVEL:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
    252          int16 CURVEC = 0;                          //曲率求取时，中心线的曲率，顺时钟为负，逆时针为正。
   \                     CURVEC:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
    253          int16 CURVER = 0;                          //曲率求取时，右黑线的曲率，顺时钟为负，逆时针为正。
   \                     CURVER:
   \   00000000                      DS8 2
    254          //int16 CurveLeftLimitL = 8;               //赛道类型判断时，通过左黑线曲率判断赛道为左弯的阈值。很敏感，任何硬软件改变后需手动改动此值。
    255          //int16 CurveLeftLimitC = 10;              //赛道类型判断时，通过中心线曲率判断赛道为左弯的阈值。很敏感，任何硬软件改变后需手动改动此值。
    256          //int16 CurveLeftLimitR = 12;              //赛道类型判断时，通过右黑线曲率判断赛道为左弯的阈值。很敏感，任何硬软件改变后需手动改动此值。
    257          //int16 CurveRightLimitL = 12;             //赛道类型判断时，通过左黑线曲率判断赛道为右弯的阈值。很敏感，任何硬软件改变后需手动改动此值。
    258          //int16 CurveRightLimitC = 10;             //赛道类型判断时，通过中心线曲率判断赛道为右弯的阈值。很敏感，任何硬软件改变后需手动改动此值。
    259          //int16 CurveRightLimitR = 8;              //赛道类型判断时，通过右黑线曲率判断赛道为右弯的阈值。很敏感，任何硬软件改变后需手动改动此值。

   \                                 In section .data, align 4
    260          int32 SlopeL = MaxValInt16;                           //斜率求取时，左黑线的斜率。
   \                     SlopeL:
   \   00000000   0x00007FFF         DC32 32767

   \                                 In section .data, align 4
    261          int32 SlopeC = MaxValInt16;                           //斜率求取时，中心线的斜率。
   \                     SlopeC:
   \   00000000   0x00007FFF         DC32 32767

   \                                 In section .data, align 4
    262          int32 SlopeR = MaxValInt16;                           //斜率求取时，右黑线的斜率。
   \                     SlopeR:
   \   00000000   0x00007FFF         DC32 32767
    263          

   \                                 In section .data, align 1
    264          uint8 CurveSlopeFlagL = 1;                  //左黑线曲率、斜率求取的标志位，1成功，0失败(CURVE和Slope均置了无效值)
   \                     CurveSlopeFlagL:
   \   00000000   0x01               DC8 1

   \                                 In section .data, align 1
    265          uint8 CurveSlopeFlagC = 1;                  //中心线曲率、斜率求取的标志位，1成功，0失败(CURVE和Slope均置了无效值)
   \                     CurveSlopeFlagC:
   \   00000000   0x01               DC8 1

   \                                 In section .data, align 1
    266          uint8 CurveSlopeFlagR = 1;                  //右黑线曲率、斜率求取的标志位，1成功，0失败(CURVE和Slope均置了无效值)
   \                     CurveSlopeFlagR:
   \   00000000   0x01               DC8 1
    267          

   \                                 In section .bss, align 1
    268          uint8 ErrorGetSelf;                 //平均值与自身的偏差，也就是curve
   \                     ErrorGetSelf:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    269          uint8 ErrorGetCen;                 //平均值与物理中心线的偏差。
   \                     ErrorGetCen:
   \   00000000                      DS8 1
    270          
    271          //左

   \                                 In section .bss, align 2
    272          uint8 BlackLeftRealWB[2];                  //黑线的实际黑白差值的存储数组，用于计算实际黑白差值的阈值。替代LimitLeftWB
   \                     BlackLeftRealWB:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
    273          uint8 BlackLeftRealB[2];                   //黑线的实际黑点值存储数组，用于计算实际黑点阈值。替代LimitLeftB
   \                     BlackLeftRealB:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
    274          uint8 BlackLeftRealW[2];                   //黑线的实际白点值存储数组，用于计算实际白点阈值。替代LimitLeftW
   \                     BlackLeftRealW:
   \   00000000                      DS8 2
    275          //3个关键值的上下界

   \                                 In section .data, align 1
    276          uint8 LimitLeftWBMin = 35;
   \                     LimitLeftWBMin:
   \   00000000   0x23               DC8 35

   \                                 In section .data, align 1
    277          uint8 LimitLeftWBMax = 90;
   \                     LimitLeftWBMax:
   \   00000000   0x5A               DC8 90

   \                                 In section .data, align 1
    278          uint8 LimitLeftWMin = 90;
   \                     LimitLeftWMin:
   \   00000000   0x5A               DC8 90

   \                                 In section .data, align 1
    279          uint8 LimitLeftWMax = 140;
   \                     LimitLeftWMax:
   \   00000000   0x8C               DC8 140

   \                                 In section .data, align 1
    280          uint8 LimitLeftBMin = 80;
   \                     LimitLeftBMin:
   \   00000000   0x50               DC8 80

   \                                 In section .data, align 1
    281          uint8 LimitLeftBMax = 110;
   \                     LimitLeftBMax:
   \   00000000   0x6E               DC8 110
    282          
    283          
    284          //右

   \                                 In section .bss, align 2
    285          uint8 BlackRightRealWB[2];                  //黑线的实际黑白差值的存储数组，用于计算实际黑白差值的阈值。替代LimitRightWB
   \                     BlackRightRealWB:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
    286          uint8 BlackRightRealB[2];                   //黑线的实际黑点值存储数组，用于计算实际黑点阈值。替代LimitRightB
   \                     BlackRightRealB:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
    287          uint8 BlackRightRealW[2];                   //黑线的实际白点值存储数组，用于计算实际白点阈值。替代LimitRightW
   \                     BlackRightRealW:
   \   00000000                      DS8 2
    288          //3个关键值的上下界

   \                                 In section .data, align 1
    289          uint8 LimitRightWBMin = 35;
   \                     LimitRightWBMin:
   \   00000000   0x23               DC8 35

   \                                 In section .data, align 1
    290          uint8 LimitRightWBMax = 90;
   \                     LimitRightWBMax:
   \   00000000   0x5A               DC8 90

   \                                 In section .data, align 1
    291          uint8 LimitRightWMin = 90;
   \                     LimitRightWMin:
   \   00000000   0x5A               DC8 90

   \                                 In section .data, align 1
    292          uint8 LimitRightWMax = 140;
   \                     LimitRightWMax:
   \   00000000   0x8C               DC8 140

   \                                 In section .data, align 1
    293          uint8 LimitRightBMin = 80;
   \                     LimitRightBMin:
   \   00000000   0x50               DC8 80

   \                                 In section .data, align 1
    294          uint8 LimitRightBMax = 110;
   \                     LimitRightBMax:
   \   00000000   0x6E               DC8 110
    295          
    296           
    297          //左
    298          //小5点斜率储存

   \                                 In section .bss, align 1
    299          uint8 BlackLeft5SlopeIndex = 0;          //左线的小5点斜率储存数组的下标。
   \                     BlackLeft5SlopeIndex:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    300          uint8 BlackLeft5SlopeRow[CameraHight];      //右线的小5点斜率储存，计算小5点斜率时的最远点所在行。
   \                     BlackLeft5SlopeRow:
   \   00000000                      DS8 60

   \                                 In section .bss, align 4
    301          int32 BlackLeft5Slope[CameraHight];      //左线的小5点斜率储存，从近往远储存。大跳变点不会储存进来。
   \                     BlackLeft5Slope:
   \   00000000                      DS8 240
    302          //3个关键值的可改值，可由自适应性算法更改。

   \                                 In section .bss, align 1
    303          uint8 LimitLeftWB;    //黑白像素点的差值，两个点的差必须要大于这个值，才能认为有跳变。
   \                     LimitLeftWB:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    304          uint8 LimitLeftW;      //白点必须要大于此值
   \                     LimitLeftW:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    305          uint8 LimitLeftB;      //黑点必须要小于此值
   \                     LimitLeftB:
   \   00000000                      DS8 1
    306          
    307          //每幅有效图像的左线线头对应的3个阈值，单独储存，每幅有效图像刷新一次。

   \                                 In section .bss, align 1
    308          uint8 LimitLeftHeadWB;    
   \                     LimitLeftHeadWB:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    309          uint8 LimitLeftHeadW;      
   \                     LimitLeftHeadW:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    310          uint8 LimitLeftHeadB;      
   \                     LimitLeftHeadB:
   \   00000000                      DS8 1
    311          

   \                                 In section .bss, align 1
    312          uint8 BlackLeftCrossDone = 0;    //左黑线十字检测标志位 0未进入 1失败 2成功
   \                     BlackLeftCrossDone:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
    313          uint8 BlackLeftDone = 1;          //左黑线提取成功标示位 1成功 0失败
   \                     BlackLeftDone:
   \   00000000   0x01               DC8 1

   \                                 In section .bss, align 1
    314          uint8 BlackLeft3ResetCount = 0;       //由于光线变化太大引起的3个关键值重置的次数。
   \                     BlackLeft3ResetCount:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
    315          uint8 BlackLeftCrossTooLowLine = 3;    //十字再检测时，低于该行就没必要启动再检测程序了。
   \                     BlackLeftCrossTooLowLine:
   \   00000000   0x03               DC8 3

   \                                 In section .bss, align 1
    316          uint8 BlackLeftStep4Flag = 0;          //左黑线需要执行第4阶段的标志位，0未进入，1失败，2成功，3出错。
   \                     BlackLeftStep4Flag:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
    317          uint8 BlackLeftStep4StartLine = MaxValUint8;     //左黑线第4阶段起始行
   \                     BlackLeftStep4StartLine:
   \   00000000   0xFF               DC8 255

   \                                 In section .data, align 1
    318          uint8 BlackLeftHeadLine = MaxValUint8;   //左黑线的线头，从上往下。
   \                     BlackLeftHeadLine:
   \   00000000   0xFF               DC8 255

   \                                 In section .data, align 1
    319          uint8 BlackLeftEndLine = MaxValUint8;    //左黑线的线尾，从上往下。
   \                     BlackLeftEndLine:
   \   00000000   0xFF               DC8 255

   \                                 In section .bss, align 1
    320          uint8 BlackLeftWinPredictStore0 = 0;         //左黑线窗口内检测黑点时，防止预测点更新失败而储存的预测点值0.
   \                     BlackLeftWinPredictStore0:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    321          uint8 BlackLeftWinPredictStore1 = 0;         //左黑线窗口内检测黑点时，防止预测点更新失败而储存的预测点值1.
   \                     BlackLeftWinPredictStore1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    322          uint8 BlackLeftWinPredictStore2 = 0;         //左黑线窗口内检测黑点时，防止预测点更新失败而储存的预测点值2.
   \                     BlackLeftWinPredictStore2:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
    323          uint8 BlackLeftContinueFlag = 1;           //左黑线连续性标志，1连续或采线未成功，0不连续，2出错。
   \                     BlackLeftContinueFlag:
   \   00000000   0x01               DC8 1

   \                                 In section .bss, align 1
    324          uint8 BlackLeftCrossConfirmFlag = 0;  //左十字线头标志。0未进入，1超范围，2成功。默认为未进入。  
   \                     BlackLeftCrossConfirmFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    325          uint8 BlackLeftEdgeStartCol;      //左黑线检测跳变沿时的下一幅图的起始列，每幅图根据上一幅有效图像来估计，需要考虑到单线的宽度。
   \                     BlackLeftEdgeStartCol:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    326          uint8 BlackLeftLastEdgeStartCol;  //左黑线检测跳变沿时的上一幅图的起始列（也就是这一幅图），每幅图根据上一幅有效图像来估计，需要考虑到单线的宽度。
   \                     BlackLeftLastEdgeStartCol:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    327          uint8 BlackLeftStep1ScanRow;      //左黑线第1阶段线头检测时的返回行。
   \                     BlackLeftStep1ScanRow:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    328          uint8 BlackLeftRow1RealLastLine;       //左黑线十字检测，第1段黑线的真实结束行，有可能因为大跳变被删掉，但差别不会超过3行。
   \                     BlackLeftRow1RealLastLine:
   \   00000000                      DS8 1
    329          
    330          //右
    331          //小5点斜率储存

   \                                 In section .bss, align 1
    332          uint8 BlackRight5SlopeIndex = 0;          //右线的小5点斜率储存数组的下标。
   \                     BlackRight5SlopeIndex:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    333          uint8 BlackRight5SlopeRow[CameraHight];      //右线的小5点斜率储存，计算小5点斜率时的最远点所在行。
   \                     BlackRight5SlopeRow:
   \   00000000                      DS8 60

   \                                 In section .bss, align 4
    334          int32 BlackRight5Slope[CameraHight];      //右线的小5点斜率储存，从近往远储存。大跳变点不会储存进来。
   \                     BlackRight5Slope:
   \   00000000                      DS8 240
    335          //3个关键值的可改值，可由自适应性算法更改。

   \                                 In section .bss, align 1
    336          uint8 LimitRightWB;    //黑白像素点的差值，两个点的差必须要大于这个值，才能认为有跳变。
   \                     LimitRightWB:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    337          uint8 LimitRightW;      //白点必须要大于此值
   \                     LimitRightW:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    338          uint8 LimitRightB;      //黑点必须要小于此值
   \                     LimitRightB:
   \   00000000                      DS8 1
    339          
    340          //每幅有效图像的右线线头对应的3个阈值，单独储存，每幅有效图像刷新一次。

   \                                 In section .bss, align 1
    341          uint8 LimitRightHeadWB;    
   \                     LimitRightHeadWB:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    342          uint8 LimitRightHeadW;      
   \                     LimitRightHeadW:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    343          uint8 LimitRightHeadB;      
   \                     LimitRightHeadB:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    344          uint8 BlackRightCrossDone = 0;   //右黑线十字检测标志位 0未进入 1失败 2成功
   \                     BlackRightCrossDone:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
    345          uint8 BlackRightDone = 1;          //右黑线提取成功标示位 1成功 0失败
   \                     BlackRightDone:
   \   00000000   0x01               DC8 1

   \                                 In section .bss, align 1
    346          uint8 BlackRight3ResetCount = 0;       //由于光线变化太大引起的3个关键值重置的次数。
   \                     BlackRight3ResetCount:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
    347          uint8 BlackRightCrossTooLowLine = 3;    //十字再检测时，低于该行就没必要启动再检测程序了。
   \                     BlackRightCrossTooLowLine:
   \   00000000   0x03               DC8 3

   \                                 In section .bss, align 1
    348          uint8 BlackRightStep4Flag = 0;          //右黑线需要执行第4阶段的标志位，0未进入，1失败，2成功，3出错。
   \                     BlackRightStep4Flag:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
    349          uint8 BlackRightStep4StartLine = MaxValUint8;     //右黑线第4阶段起始行
   \                     BlackRightStep4StartLine:
   \   00000000   0xFF               DC8 255

   \                                 In section .data, align 1
    350          uint8 BlackRightHeadLine = MaxValUint8;    //右黑线的线头，从上往下。
   \                     BlackRightHeadLine:
   \   00000000   0xFF               DC8 255

   \                                 In section .data, align 1
    351          uint8 BlackRightEndLine = MaxValUint8;     //右黑线的线尾，从上往下。
   \                     BlackRightEndLine:
   \   00000000   0xFF               DC8 255

   \                                 In section .bss, align 1
    352          uint8 BlackRightWinPredictStore0 = 0;         //右黑线窗口内检测黑点时，防止预测点更新失败而储存的预测点值0.
   \                     BlackRightWinPredictStore0:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    353          uint8 BlackRightWinPredictStore1 = 0;         //右黑线窗口内检测黑点时，防止预测点更新失败而储存的预测点值1.
   \                     BlackRightWinPredictStore1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    354          uint8 BlackRightWinPredictStore2 = 0;         //右黑线窗口内检测黑点时，防止预测点更新失败而储存的预测点值2.
   \                     BlackRightWinPredictStore2:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
    355          uint8 BlackRightContinueFlag = 1;           //右黑线连续性标志，1连续或采线未成功，0不连续，2出错。
   \                     BlackRightContinueFlag:
   \   00000000   0x01               DC8 1

   \                                 In section .bss, align 1
    356          uint8 BlackRightCrossConfirmFlag = 0;  //右十字线头标志。0未进入，1超范围，2成功。默认为未进入。
   \                     BlackRightCrossConfirmFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    357          uint8 BlackRightEdgeStartCol;      //右黑线检测跳变沿时的下一幅图的起始列，每幅图根据上一幅有效图像来估计，需要考虑到单线的宽度。
   \                     BlackRightEdgeStartCol:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    358          uint8 BlackRightLastEdgeStartCol;  //右黑线检测跳变沿时的上一幅图的起始列（也就是这一幅图），每幅图根据上一幅有效图像来估计，需要考虑到单线的宽度。
   \                     BlackRightLastEdgeStartCol:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    359          uint8 BlackRightStep1ScanRow;      //右黑线第1阶段线头检测时的返回行。
   \                     BlackRightStep1ScanRow:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    360          uint8 BlackRightRow1RealLastLine;       //右黑线十字检测，第1段黑线的真实结束行，有可能因为大跳变被删掉，但差别不会超过3行。
   \                     BlackRightRow1RealLastLine:
   \   00000000                      DS8 1
    361          
    362          //紧急停车

   \                                 In section .bss, align 1
    363          uint8 EmergencyStopCount = 0;     //紧急停车计数器。每当图像处理失败时加1，连续计EmergencyStopCountNum个则置标志位。
   \                     EmergencyStopCount:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    364          uint8 EmergencyStopFlag = 0;      //紧急停车标志。1表示紧急停车，会将电机输出置0，只有掉电重开才能置0.
   \                     EmergencyStopFlag:
   \   00000000                      DS8 1
    365          
    366          
    367          //偏差获取
    368          //int16 DeviNow = 0;                  //当前偏差

   \                                 In section .bss, align 1
    369          uint8 DeviFlag = 0;                //偏差求取标志位，告诉程序这次应该写入第几个偏差。
   \                     DeviFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    370          uint8 DeviRowChosen = 0;               //求取偏差时选取的行，若指定范围没选取到则置无效值，若偏差过小，则置为0。
   \                     DeviRowChosen:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    371          uint8 DeviNowLevel = 0;      //当前偏差的绝对值的等级，10个等级，0偏差最小，9偏差最大。
   \                     DeviNowLevel:
   \   00000000                      DS8 1
    372          
    373          //直角黑色区域
    374          //判断

   \                                 In section .bss, align 4
    375          uint8 AngleZoneJudgeRowL[AngleZoneJudgeRowNum];  //直角黑块，根据线头选中的要检测的左线行。
   \                     AngleZoneJudgeRowL:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
    376          uint8 AngleZoneJudgeColL[AngleZoneJudgeRowNum];  //直角黑块，左线定位的所在列。
   \                     AngleZoneJudgeColL:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
    377          uint8 AngleZoneJudgeColLFlag[AngleZoneJudgeRowNum]; //直角黑块，左线该行的有效黑点满足要求时置位。
   \                     AngleZoneJudgeColLFlag:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
    378          uint8 AngleZoneJudgeCountColL[AngleZoneJudgeRowNum]; //直角黑块，左线，记录该行的有效黑点数，以供确定合适的阈值。
   \                     AngleZoneJudgeCountColL:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
    379          uint8 AngleZoneJudgeRowR[AngleZoneJudgeRowNum];  //直角黑块，根据线头选中的要检测的右线行。
   \                     AngleZoneJudgeRowR:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
    380          uint8 AngleZoneJudgeColR[AngleZoneJudgeRowNum];  //直角黑块，右线定位的所在列。
   \                     AngleZoneJudgeColR:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
    381          uint8 AngleZoneJudgeColRFlag[AngleZoneJudgeRowNum]; //直角黑块，右线该行的有效黑点满足要求时置位。
   \                     AngleZoneJudgeColRFlag:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
    382          uint8 AngleZoneJudgeCountColR[AngleZoneJudgeRowNum]; //直角黑块，右线，记录该行的有效黑点数，以供确定合适的阈值。
   \                     AngleZoneJudgeCountColR:
   \   00000000                      DS8 8
    383          //确认

   \                                 In section .bss, align 1
    384          uint8 AngleZoneConfirmLockMeterCount = 0; //直角黑块，锁存后进行的累加计数，用以直角黑块误判后的恢复正常。
   \                     AngleZoneConfirmLockMeterCount:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    385          uint8 AngleZoneConfirmCount = 0;   //对直角黑块确认次数的计数。
   \                     AngleZoneConfirmCount:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    386          uint8 AngleZoneConfirmLockFlag = 0;    //直角黑块判断成功锁存标志位,确认是直角黑块后置位。
   \                     AngleZoneConfirmLockFlag:
   \   00000000                      DS8 1
    387                                                 //有两种情况清零，一是之后的线头差检测成功后，二是一定距离后仍没有检测到线头差。

   \                                 In section .bss, align 4
    388          uint8 AngleZoneConfirmMat[AngleZoneConfirmMatNum];  //直角黑块确认标志存储数组，1表示本次为直角黑块，0表示不是直角黑块。
   \                     AngleZoneConfirmMat:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
    389          uint8 AngleZoneConfirmMatCollect = 0;      //直角黑块，AngleZoneConfirmMat数组中1的个数。
   \                     AngleZoneConfirmMatCollect:
   \   00000000                      DS8 1
    390          //可修改

   \                                 In section .data, align 1
    391          uint8 AngleZoneConfirmMatLimit = 3;         //直角黑块，标志存储数组中直角黑块的个数大于该值时，则锁存为直角黑块。
   \                     AngleZoneConfirmMatLimit:
   \   00000000   0x03               DC8 3
    392          
    393          //直角弯处理

   \                                 In section .bss, align 1
    394          uint8 AngleConfirmCount = 0;   //对直角弯确认次数的计数。
   \                     AngleConfirmCount:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    395          uint8 AngleSpeDealBackCount = 0;  //直角弯最终确认后，特殊情况次数的倒数计数。
   \                     AngleSpeDealBackCount:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    396          uint8 AngleSpeDealDir = 0;        //直角弯方向标志，0左直角弯，1右直角弯，2错误。
   \                     AngleSpeDealDir:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    397          uint8 AngleSpeDealFlag = 0;       //直角弯特殊处理标志，1表示该周期进行了直角弯特殊处理，0表示该周期没有进行直角弯特殊处理。
   \                     AngleSpeDealFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
    398          uint16 AngleConfirmCountMax = 0;   //记录实际直角弯确认次数的最大值，方便调节阈值。
   \                     AngleConfirmCountMax:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
    399          uint8 AngleConfirmLockFlag = 0;    //直角弯判断成功锁存标志位,确认是直角弯后置位，用以确认直角弯特殊处理开始的位置。
   \                     AngleConfirmLockFlag:
   \   00000000                      DS8 1
    400                                             //直角弯锁存期间，不进行特殊赛道判断。

   \                                 In section .bss, align 1
    401          uint8 AngleSpeDealExitJudgeFlag = 0;  //出直角弯判断标志，1已出，0未出
   \                     AngleSpeDealExitJudgeFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    402          uint8 AngleConfirmMat[AngleConfirmMatNum];  //直角弯确认标志存储数组，1表示本次为直角，0表示不是直角。
   \                     AngleConfirmMat:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
    403          uint8 AngleConfirmMatCollect = 0;      //直角弯 ，AngleConfirmMat数组中1的个数。
   \                     AngleConfirmMatCollect:
   \   00000000                      DS8 1
    404          

   \                                 In section .data, align 1
    405          uint8 AngleConfirmMatLimit = 3;         //直角弯标志存储数组中直角的个数大于该值时，则锁存为直角。
   \                     AngleConfirmMatLimit:
   \   00000000   0x03               DC8 3

   \                                 In section .data, align 1
    406          uint8 AngleLongHeadLineStrategy = 1;                //直角弯长线头策略，1表示去掉长线头，0表示不去长线头。
   \                     AngleLongHeadLineStrategy:
   \   00000000   0x01               DC8 1

   \                                 In section .data, align 1
    407          uint8 AngleHeadLineNum = 5;              //左右线头之差大于该值，则有可能为直角弯。
   \                     AngleHeadLineNum:
   \   00000000   0x05               DC8 5
    408          
    409          
    410          //直角弯非障碍物确认。

   \                                 In section .bss, align 1
    411          uint8 AngleStep1NotBrickEndColL;    //直角弯非障碍物确认，左直角梯形，起始行（近行）黑点所在列。
   \                     AngleStep1NotBrickEndColL:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    412          uint8 AngleStep1NotBrickBorderColL; //直角弯非障碍物确认，左直角梯形，直角边所在列。
   \                     AngleStep1NotBrickBorderColL:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    413          uint8 AngleStep1NotBrickEndColR;    //直角弯非障碍物确认，右直角梯形，起始行（近行）黑点所在列。
   \                     AngleStep1NotBrickEndColR:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    414          uint8 AngleStep1NotBrickBorderColR; //直角弯非障碍物确认，右直角梯形，直角边所在列。
   \                     AngleStep1NotBrickBorderColR:
   \   00000000                      DS8 1
    415          
    416          //障碍物

   \                                 In section .bss, align 1
    417          uint8 BrickConfirmCount = 0;   //对障碍物确认次数的计数。
   \                     BrickConfirmCount:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    418          uint8 BrickSpeDealBackCount = 0;  //障碍物最终确认后，特殊情况次数的倒数计数。
   \                     BrickSpeDealBackCount:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    419          uint8 BrickSpeDealDir = 0;        //障碍物位置，0左障碍物，1右障碍物，2错误。
   \                     BrickSpeDealDir:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    420          uint8 BrickSpeDealFlag = 0;       //障碍物特殊处理标志，1表示该周期进行了障碍物特殊处理，0表示该周期没有进行障碍物特殊处理。
   \                     BrickSpeDealFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
    421          uint16 BrickConfirmCountMax = 0;   //记录实际障碍物确认次数的最大值，方便调节阈值。
   \                     BrickConfirmCountMax:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
    422          uint8 BrickConfirmLockFlag = 0;    //障碍物判断成功锁存标志位,确认是障碍物后置位，用以确认障碍物特殊处理开始的位置。
   \                     BrickConfirmLockFlag:
   \   00000000                      DS8 1
    423                                             //障碍物锁存期间，不进行特殊赛道判断。

   \                                 In section .data, align 1
    424          uint8 BrickSpeDealExitJudgeFlag = 1;  //出障碍物判断标志，1表示初始态，2表示当前已经与障碍平行，0退出特殊控制，把控制权交还给普通控制。
   \                     BrickSpeDealExitJudgeFlag:
   \   00000000   0x01               DC8 1
    425                                                //不用每幅图更新，每次过完障碍，会手动写成1.

   \                                 In section .bss, align 4
    426          uint8 BrickConfirmMat0[BrickConfirmMatNum];  //左障碍物确认标志存储数组，1表示本次为障碍物，0表示不是障碍物。
   \                     BrickConfirmMat0:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
    427          uint8 BrickConfirmMatCollect0 = 0;      //左障碍，BrickConfirmMat数组中1的个数。
   \                     BrickConfirmMatCollect0:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    428          uint8 BrickConfirmMat1[BrickConfirmMatNum];  //右障碍物确认标志存储数组，1表示本次为障碍物，0表示不是障碍物。
   \                     BrickConfirmMat1:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
    429          uint8 BrickConfirmMatCollect1 = 0;      //右障碍，BrickConfirmMat数组中1的个数。
   \                     BrickConfirmMatCollect1:
   \   00000000                      DS8 1
    430          

   \                                 In section .bss, align 1
    431          uint8 BrickSpeDealStartJudgeCol;     //障碍，判定是否开始特殊控制时，特定行对应的最小二乘法算出来的列。
   \                     BrickSpeDealStartJudgeCol:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    432          uint8 BrickEndColL;    //障碍物，左直角梯形，起始行（近行）黑点所在列。
   \                     BrickEndColL:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    433          uint8 BrickHeadColL;   //障碍物，左直角梯形，结束行（远行）黑点所在列。
   \                     BrickHeadColL:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    434          uint8 BrickBorderColL; //障碍物，左直角梯形，直角边所在列。
   \                     BrickBorderColL:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    435          uint8 BrickEndColR;    //障碍物，右直角梯形，起始行（近行）黑点所在列。
   \                     BrickEndColR:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    436          uint8 BrickHeadColR;   //障碍物，右直角梯形，结束行（远行）黑点所在列。
   \                     BrickHeadColR:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    437          uint8 BrickBorderColR; //障碍物，右直角梯形，直角边所在列。
   \                     BrickBorderColR:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
    438          uint8 BrickSpeDealCenFlag = 1; //障碍物，中心线特殊处理标志位，每幅图像会预置1。1表示无特殊处理或处理成功，0表示处理失败。
   \                     BrickSpeDealCenFlag:
   \   00000000   0x01               DC8 1

   \                                 In section .bss, align 1
    439          uint8 BrickLineCountNumRecord;
   \                     BrickLineCountNumRecord:
   \   00000000                      DS8 1
    440          //障碍，特殊控制时，偏移的列数。从数字大的开始执行，到数字小的。

   \                                 In section .rodata, align 4
    441          const int BrickSpeDealBias[BrickSpeDealBackCountNum] = 
   \                     BrickSpeDealBias:
   \   00000000   0x0000001E         DC32 30, 30, 30, 25, 25, 25, 25, 25, 20, 20, 20, 15, 5, 0, -2, -5, -10
   \              0x0000001E   
   \              0x0000001E   
   \              0x00000019   
   \              0x00000019   
   \              0x00000019   
   \              0x00000019   
   \              0x00000019   
   \              0x00000014   
   \              0x00000014   
   \              0x00000014   
   \              0x0000000F   
   \              0x00000005   
   \              0x00000000   
   \              0xFFFFFFFE   
   \              0xFFFFFFFB   
   \              0xFFFFFFF6   
   \   00000044   0xFFFFFFF6         DC32 -10, -19, -19
   \              0xFFFFFFED   
   \              0xFFFFFFED   
    442          {
    443            30,30,30,25,25,  
    444            25,25,25,20, 20,
    445             20, 15, 5, 0, -2,
    446             -5, -10, -10, -19, -19
    447          };
    448          

   \                                 In section .data, align 1
    449          uint8 BrickConfirmMatLimit = 3;         //障碍标志存储数组中障碍的个数大于该值时，则锁存为障碍。
   \                     BrickConfirmMatLimit:
   \   00000000   0x03               DC8 3

   \                                 In section .data, align 1
    450          uint8 BrickConfirmFinalColCom = 50;     //障碍躲避时的列修正量（以50为零，左减右加。）比50小表示往中心线靠，比50大表示往外走。
   \                     BrickConfirmFinalColCom:
   \   00000000   0x32               DC8 50
    451          
    452          //单线处理

   \                                 In section .bss, align 1
    453          uint8 SingleBlackAllFlag = 0;   //总幅图像的单线标志，只要有一行检测单线成功，则置1.每幅图像处理前置0.
   \                     SingleBlackAllFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    454          uint8 SingleBlackLastAllFlag = 0;      //上一幅图像的单线标志。
   \                     SingleBlackLastAllFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    455          uint8 SingleDoneFlag = 0;              //单线处理时，单线成功标志位。
   \                     SingleDoneFlag:
   \   00000000                      DS8 1
    456                                   //////////////////////目前还不完善，是每个有效行验证一次，一次成功则视为成功。

   \                                 In section .bss, align 1
    457          uint8 SingleFloorFlag = 0;             //单线处理时，地板判断成功标志位。1该幅图画左线是地板，0不是或没有判断。
   \                     SingleFloorFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    458          uint8 SingleFloorConfirmCount = 0;       //单线处理时，地板判断确认计数值。每幅图归零一次。
   \                     SingleFloorConfirmCount:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    459          uint8 SingleFloorConfirmCountMax = 0;   //单线处理时，地板判断确认计数值的最大值，用于确认最佳确认阈值。每幅图归零一次。
   \                     SingleFloorConfirmCountMax:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    460          uint8 SingleBlackFlag[CameraHight];     //单线处理时，每行的单线判断成功标志。1该行为单线，0该行不是单线。每次图像处理前会置0.
   \                     SingleBlackFlag:
   \   00000000                      DS8 60
    461          
    462          //赛道类型

   \                                 In section .data, align 1
    463          uint8 PathJudgeDone = 1;                   //赛道类型判断成功标志位，1成功，0失败。
   \                     PathJudgeDone:
   \   00000000   0x01               DC8 1

   \                                 In section .bss, align 1
    464          uint8 PathType = PathTypeUnknown;          //未知 直道 左弯 右弯 左直 右直 小S
   \                     PathType:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    465          uint8 PathSmallSDoneFlag = 0;              //赛道类型判断时，小S弯判断成功标志位。1成功，0失败。每幅图赛道类型判断时初始化为0。
   \                     PathSmallSDoneFlag:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
    466          uint8 PathSmallSDir = 1;                   //赛道类型判断时，小S弯起始方向。
   \                     PathSmallSDir:
   \   00000000   0x01               DC8 1
    467          
    468          //畸变矫正

   \                                 In section .bss, align 4
    469          int16 CenterLineLoc[CameraHight];      //中心线位置存储数组, 255为无效值
   \                     CenterLineLoc:
   \   00000000                      DS8 120

   \                                 In section .bss, align 4
    470          LocationUdis BlackUdisLeftLocation[CameraHight];  //畸变矫正后，左黑线的位置储存数组。有正负，包括了行和列。
   \                     BlackUdisLeftLocation:
   \   00000000                      DS8 480

   \                                 In section .bss, align 4
    471          LocationUdis BlackUdisRightLocation[CameraHight]; //畸变矫正后，左黑线的位置储存数组。有正负，包括了行和列。
   \                     BlackUdisRightLocation:
   \   00000000                      DS8 480
    472          //多行控制

   \                                 In section .bss, align 4
    473          int32 DeviFuse = 0;            //多行融合后的偏差。
   \                     DeviFuse:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    474          int32 DeviFuse_old = 0;
   \                     DeviFuse_old:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    475          uint32 DeviFuseArray[10];
   \                     DeviFuseArray:
   \   00000000                      DS8 40

   \                                 In section .bss, align 4
    476          int32 Devi_near,Devi_far;      //近远行偏移量
   \                     Devi_near:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     Devi_far:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    477          int32 DeviPre = 0;                  //上一次偏差
   \                     DeviPre:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    478          int32 DeviPrePre=0;              //上上次偏差
   \                     DeviPrePre:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    479          int32 DeviPrePrePre=0;              //上上上次偏差
   \                     DeviPrePrePre:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    480          int16 ControlRowDeviInit[4];    //各控制行的初始偏差,归一的0~100,0~3分别是base，low，middle，high
   \                     ControlRowDeviInit:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
    481          int16 ControlRowDeviOld[4]; 
   \                     ControlRowDeviOld:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
    482          uint8 BaseRowControlNum;        //近行控制序号，对应于权重数组列下标
   \                     BaseRowControlNum:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    483          uint8 FuzzyDegree;              //隶属度计算辅助变量
   \                     FuzzyDegree:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    484          uint8 ControlRowWeight[4];      //控制行权重系数,模糊计算
   \                     ControlRowWeight:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
    485          uint16 Weight_sum = 0;            //权重系数的和
   \                     Weight_sum:
   \   00000000                      DS8 2
    486          
    487          
    488          
    489          //大斜率检测。

   \                                 In section .bss, align 4
    490          uint8 BlackLeftBigChangeNumx[5];                     //大斜率检测时，横坐标X的储存数组。储存行号。
   \                     BlackLeftBigChangeNumx:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
    491          uint8 BlackLeftBigChangeNumy[5];                     //大斜率检测时，横坐标X的储存数组。储存有效行的黑点所在列。
   \                     BlackLeftBigChangeNumy:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
    492          uint8 BlackLeftBigChangeFlag = 0;              //大斜率检测时，检测到大斜率的标志。每幅图像会清零，但只要有一次检测到则置位。1该幅图像检测到大斜率，0该幅图像没有检测到。
   \                     BlackLeftBigChangeFlag:
   \   00000000                      DS8 1

   \                                 In section .data, align 4
    493          int32 BlackLeftBigChangeSlopeStore = MaxValInt16;    //大斜率检测时，储存的上一次的斜率值。
   \                     BlackLeftBigChangeSlopeStore:
   \   00000000   0x00007FFF         DC32 32767

   \                                 In section .bss, align 1
    494          uint8 BlackLeftBigChangeJumpFlag = 0;                //大斜率检测时，用来跳过程序内的一个小循环。
   \                     BlackLeftBigChangeJumpFlag:
   \   00000000                      DS8 1
    495          

   \                                 In section .bss, align 4
    496          uint8 BlackRightBigChangeNumx[5];                     //大斜率检测时，横坐标X的储存数组。储存行号。
   \                     BlackRightBigChangeNumx:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
    497          uint8 BlackRightBigChangeNumy[5];                     //大斜率检测时，横坐标X的储存数组。储存有效行的黑点所在列。
   \                     BlackRightBigChangeNumy:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
    498          uint8 BlackRightBigChangeFlag = 0;              //大斜率检测时，检测到大斜率的标志。每幅图像会清零，但只要有一次检测到则置位。
   \                     BlackRightBigChangeFlag:
   \   00000000                      DS8 1

   \                                 In section .data, align 4
    499          int32 BlackRightBigChangeSlopeStore = MaxValInt16;    //大斜率检测时，储存的上一次的斜率值。
   \                     BlackRightBigChangeSlopeStore:
   \   00000000   0x00007FFF         DC32 32767

   \                                 In section .bss, align 1
    500          uint8 BlackRightBigChangeJumpFlag = 0;                //大斜率检测时，用来跳过程序内的一个小循环。
   \                     BlackRightBigChangeJumpFlag:
   \   00000000                      DS8 1
    501          

   \                                 In section .bss, align 4
    502          uint8 BlackLeftBigChangeCheckRow[CameraHight];   //大斜率检测时，每行的标志。1表示该行左黑线未通过大跳变检测，0表示通过。
   \                     BlackLeftBigChangeCheckRow:
   \   00000000                      DS8 60

   \                                 In section .bss, align 1
    503          uint8 BlackLeftBigChangeCheckAllRow;             //大斜率检测时，1该幅图像的左黑线存在有某行未通过大跳变检测，0该幅图像每行左黑线均通过大跳变检测。
   \                     BlackLeftBigChangeCheckAllRow:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    504          uint8 BlackRightBigChangeCheckRow[CameraHight];  //大斜率检测时，每行的标志。1表示该行右黑线未通过大跳变检测，0表示通过。
   \                     BlackRightBigChangeCheckRow:
   \   00000000                      DS8 60

   \                                 In section .bss, align 1
    505          uint8 BlackRightBigChangeCheckAllRow;            //大斜率检测时，1该幅图像的右黑线存在有某行未通过大跳变检测，0该幅图像每行右黑线均通过大跳变检测。
   \                     BlackRightBigChangeCheckAllRow:
   \   00000000                      DS8 1
    506          
    507          //回弯检测

   \                                 In section .bss, align 1
    508          uint8 BlackLeftRollCheckFlag = 0;             //回弯检测标志位，0未检测到回弯，1检测到回弯。
   \                     BlackLeftRollCheckFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    509          uint8 BlackRightRollCheckFlag = 0;             //回弯检测标志位，0未检测到回弯，1检测到回弯。
   \                     BlackRightRollCheckFlag:
   \   00000000                      DS8 1
    510          
    511          
    512          
    513          //十字外尾

   \                                 In section .data, align 1
    514          uint8 BlackLeftCrossTailFlag = 2;       //十字外尾标志，0失败，1确认，2未进入。
   \                     BlackLeftCrossTailFlag:
   \   00000000   0x02               DC8 2

   \                                 In section .bss, align 1
    515          uint8 BlackLeftCrossTailEndLine;        //十字外尾，待删除的最远行。
   \                     BlackLeftCrossTailEndLine:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
    516          uint8 BlackRightCrossTailFlag = 2;       //十字外尾标志，0失败，1确认，2未进入。
   \                     BlackRightCrossTailFlag:
   \   00000000   0x02               DC8 2

   \                                 In section .bss, align 1
    517          uint8 BlackRightCrossTailEndLine;        //十字外尾，待删除的最远行。
   \                     BlackRightCrossTailEndLine:
   \   00000000                      DS8 1
    518          
    519          //窗口预测值管理

   \                                 In section .bss, align 4
    520          uint8 BlackLeftPredictL[CameraHight];          //窗口预测值，左线的左边界。
   \                     BlackLeftPredictL:
   \   00000000                      DS8 60

   \                                 In section .bss, align 4
    521          uint8 BlackLeftPredictR[CameraHight];          //窗口预测值，左线的右边界。
   \                     BlackLeftPredictR:
   \   00000000                      DS8 60

   \                                 In section .bss, align 4
    522          uint8 BlackRightPredictL[CameraHight];          //窗口预测值，右线的左边界。
   \                     BlackRightPredictL:
   \   00000000                      DS8 60

   \                                 In section .bss, align 4
    523          uint8 BlackRightPredictR[CameraHight];          //窗口预测值，右线的右边界。
   \                     BlackRightPredictR:
   \   00000000                      DS8 60
    524          
    525          //赛道半宽

   \                                 In section .bss, align 1
    526          uint8 RoadHalfWidth;                              //双线赛道半宽
   \                     RoadHalfWidth:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    527          uint8 RoadHalfWidthLast;                          //上一幅图最终的双线赛道半宽
   \                     RoadHalfWidthLast:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    528          uint8 RoadHalfWidthRecord[CameraHight];           //双线赛道半宽记录
   \                     RoadHalfWidthRecord:
   \   00000000                      DS8 60

   \                                 In section .bss, align 1
    529          uint8 RoadHalfWidthSingle;                        //单线赛道半宽
   \                     RoadHalfWidthSingle:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
    530          uint8 RoadHalfWidthWrongFlag = 2;                 //通过赛道半宽判断出来的单线错误标志，2未进入，1错误，0正确。
   \                     RoadHalfWidthWrongFlag:
   \   00000000   0x02               DC8 2

   \                                 In section .bss, align 1
    531          uint8 RoadHalfWidthWrongDir;                      //单线错误时，0左线悬空，1右线悬空。
   \                     RoadHalfWidthWrongDir:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    532          float RoadHalfWidthCompen;                        //单双线切换的修正系数
   \                     RoadHalfWidthCompen:
   \   00000000                      DS8 4

   \                                 In section .data, align 1
    533          uint8 RoadHalfWidthSwitch = 1;                        //路宽开关，1单线算斜率，取最大值，0单线直接用上次双线的
   \                     RoadHalfWidthSwitch:
   \   00000000   0x01               DC8 1
    534          
    535          
    536          //单线错误

   \                                 In section .bss, align 1
    537          uint8 BlackSingleFlag = 0;   //单线错误标志。0没错误，1有错误。每幅图初始化为0.
   \                     BlackSingleFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    538          uint8 BlackSingleDir;        //单线错误的方向标志，0表示左线悬空，1表示右线悬空。
   \                     BlackSingleDir:
   \   00000000                      DS8 1
    539          
    540          //最终大跳变检测

   \                                 In section .bss, align 1
    541          uint8 BlackBigChangeFinalCheckFlag = 0;  //最终大跳变检测标志位。0未检测到或没必要检测，1检测到左线最终大跳变，2检测到右线最终大跳变
   \                     BlackBigChangeFinalCheckFlag:
   \   00000000                      DS8 1
    542          
    543          //长直道

   \                                 In section .bss, align 1
    544          uint8 PathRealStraightCount = 0;   //连续直道计数
   \                     PathRealStraightCount:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
    545          uint8 PathRealStraightCountLimit = 10;  //连续直道计数阈值，大于该值则确认为长直道。
   \                     PathRealStraightCountLimit:
   \   00000000   0x0A               DC8 10

   \                                 In section .bss, align 1
    546          uint8 PathRealStraightFlag = 0;        //长直道标志，1是长直道，0不是。
   \                     PathRealStraightFlag:
   \   00000000                      DS8 1
    547          
    548          
    549          
    550          
    551          //绝对值求取

   \                                 In section .text, align 2, keep-with-next
    552          int32 AbsInt(int32 val)
    553          {
    554            if(val >= 0)
   \                     AbsInt: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD500             BPL.N    ??AbsInt_0
    555            {
    556              return val;
    557            }
    558            else
    559            {
    560              return (0-val);
   \                     ??AbsInt_1: (+1)
   \   00000004   0x4240             RSBS     R0,R0,#+0
   \                     ??AbsInt_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    561            }
    562          }
    563          
    564          //左右边界限制

   \                                 In section .text, align 2, keep-with-next
    565          int32 BoundaryLimitRe(int32 x, int32 left, int32 right)
    566          {
    567            if(x < left)
   \                     BoundaryLimitRe: (+1)
   \   00000000   0x4288             CMP      R0,R1
   \   00000002   0xDA01             BGE.N    ??BoundaryLimitRe_0
    568            {
    569              return left;
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0xE003             B.N      ??BoundaryLimitRe_1
    570            }
    571            else if(x > right)
   \                     ??BoundaryLimitRe_0: (+1)
   \   00000008   0x4282             CMP      R2,R0
   \   0000000A   0xDA01             BGE.N    ??BoundaryLimitRe_2
    572            {
    573              return right;
   \   0000000C   0x0010             MOVS     R0,R2
   \   0000000E   0xE7FF             B.N      ??BoundaryLimitRe_1
    574            }
    575            else
    576            {
    577              return x;
   \                     ??BoundaryLimitRe_2: (+1)
   \                     ??BoundaryLimitRe_1: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    578            }
    579          }
    580          
    581          //======================================================================
    582          //函数名：MaxRe
    583          //功  能：求取两数最大值
    584          //参  数：第1个数num1, 第2个数num2。
    585          //返  回：2个数中的最大值
    586          //影  响：无
    587          //说  明：1. 两个输入参数无先后顺序。
    588          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    589          int32 MaxRe(int32 a, int32 b)
    590          {
    591            return (a > b ? a : b);
   \                     MaxRe: (+1)
   \   00000000   0x4281             CMP      R1,R0
   \   00000002   0xDB00             BLT.N    ??MaxRe_0
   \                     ??MaxRe_1: (+1)
   \   00000004   0x0008             MOVS     R0,R1
   \                     ??MaxRe_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    592          }
    593          
    594          //======================================================================
    595          //函数名：MinRe
    596          //功  能：求取两数最小值
    597          //参  数：第1个数num1, 第2个数num2。
    598          //返  回：2个数中的最小值
    599          //影  响：无
    600          //说  明：1. 两个输入参数无先后顺序。   
    601          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    602          int32 MinRe(int32 a, int32 b)
    603          {
    604            return (a < b ? a : b);
   \                     MinRe: (+1)
   \   00000000   0x4288             CMP      R0,R1
   \   00000002   0xDB00             BLT.N    ??MinRe_0
   \                     ??MinRe_1: (+1)
   \   00000004   0x0008             MOVS     R0,R1
   \                     ??MinRe_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    605          }
    606          
    607          //======================================================================
    608          //函数名：AbsRe
    609          //功  能：求取两数差值的绝对值
    610          //参  数：第1个数num1, 第2个数num2。
    611          //返  回：2个数的绝对值。
    612          //影  响：无
    613          //说  明：1. 两个输入参数无先后顺序。 
    614          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    615          int32 AbsRe(int32 num1, int32 num2)
    616          {
    617            if(num1 >= num2)
   \                     AbsRe: (+1)
   \   00000000   0x4288             CMP      R0,R1
   \   00000002   0xDB01             BLT.N    ??AbsRe_0
    618            {
    619              return (num1 - num2);  
   \   00000004   0x1A40             SUBS     R0,R0,R1
   \   00000006   0xE000             B.N      ??AbsRe_1
    620            }
    621            else
    622            {
    623              return (num2 - num1);  
   \                     ??AbsRe_0: (+1)
   \   00000008   0x1A08             SUBS     R0,R1,R0
   \                     ??AbsRe_1: (+1)
   \   0000000A   0x4770             BX       LR               ;; return
    624            }
    625          }
    626          
    627          
    628          
    629          //十字检测

   \                                 In section .text, align 2, keep-with-next
    630          int ShiZhiCheck()
    631          {
   \                     ShiZhiCheck: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    632              uint8 startRow = 59;
   \   00000002   0x243B             MOVS     R4,#+59
    633              uint8 row;
    634              uint8 col;
    635              uint32 limitL;
    636              uint32 limitR;
    637              uint32 limit;
    638          
    639              limitL = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    640              limitR = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    641              limit = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    642              if(ShiZhiFlag==0)
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable6
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xF040 0x80ED      BNE.W    ??ShiZhiCheck_0
    643              {
    644                  //要保证黑线采集成功
    645                  if (BlackLeftDone != 1 || BlackRightDone != 1) { return 0; }
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD104             BNE.N    ??ShiZhiCheck_1
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD001             BEQ.N    ??ShiZhiCheck_2
   \                     ??ShiZhiCheck_1: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE109             B.N      ??ShiZhiCheck_3
    646                  //要保证是在直道
    647                  if (AbsInt(SlopeL) < 1700 && AbsInt(SlopeR) < 1700
    648                      && BlackRightCrossDone != 2 && BlackLeftCrossDone != 2
    649                          && BlackRightEndLine > 57 && BlackLeftEndLine > 57)
   \                     ??ShiZhiCheck_2: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x.... 0x....      BL       AbsInt
   \   00000038   0xF240 0x61A4      MOVW     R1,#+1700
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xDA47             BGE.N    ??ShiZhiCheck_4
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x.... 0x....      BL       AbsInt
   \   0000004A   0xF240 0x61A4      MOVW     R1,#+1700
   \   0000004E   0x4288             CMP      R0,R1
   \   00000050   0xDA3E             BGE.N    ??ShiZhiCheck_4
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x2802             CMP      R0,#+2
   \   0000005A   0xD039             BEQ.N    ??ShiZhiCheck_4
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable6_6
   \   00000060   0x7800             LDRB     R0,[R0, #+0]
   \   00000062   0x2802             CMP      R0,#+2
   \   00000064   0xD034             BEQ.N    ??ShiZhiCheck_4
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable6_7
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0x283A             CMP      R0,#+58
   \   0000006E   0xDB2F             BLT.N    ??ShiZhiCheck_4
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable6_8
   \   00000074   0x7800             LDRB     R0,[R0, #+0]
   \   00000076   0x283A             CMP      R0,#+58
   \   00000078   0xDB2A             BLT.N    ??ShiZhiCheck_4
    650                  {
    651                      if (BlackRightHeadLine >= 15 && BlackLeftHeadLine >= 15 && BlackRightHeadLine <= 59 && BlackLeftHeadLine <= 59 && AbsInt(BlackLeftHeadLine - BlackRightHeadLine) <= 10) { }
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable6_9
   \   0000007E   0x7800             LDRB     R0,[R0, #+0]
   \   00000080   0x280F             CMP      R0,#+15
   \   00000082   0xDB19             BLT.N    ??ShiZhiCheck_5
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable6_10
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0x280F             CMP      R0,#+15
   \   0000008C   0xDB14             BLT.N    ??ShiZhiCheck_5
   \   0000008E   0x.... 0x....      LDR.W    R0,??DataTable6_9
   \   00000092   0x7800             LDRB     R0,[R0, #+0]
   \   00000094   0x283C             CMP      R0,#+60
   \   00000096   0xDA0F             BGE.N    ??ShiZhiCheck_5
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable6_10
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x283C             CMP      R0,#+60
   \   000000A0   0xDA0A             BGE.N    ??ShiZhiCheck_5
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable6_10
   \   000000A6   0x7800             LDRB     R0,[R0, #+0]
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable6_9
   \   000000AC   0x7809             LDRB     R1,[R1, #+0]
   \   000000AE   0x1A40             SUBS     R0,R0,R1
   \   000000B0   0x.... 0x....      BL       AbsInt
   \   000000B4   0x280B             CMP      R0,#+11
   \   000000B6   0xDB01             BLT.N    ??ShiZhiCheck_6
    652                      else { return 0; }
   \                     ??ShiZhiCheck_5: (+1)
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xE0C2             B.N      ??ShiZhiCheck_3
    653                  }
    654                  else { return 0; }
    655          
    656                  if (BlackLeftHeadLine >= BlackLeftEndLine) { return 0; }
   \                     ??ShiZhiCheck_6: (+1)
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable6_10
   \   000000C0   0x7800             LDRB     R0,[R0, #+0]
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable6_8
   \   000000C6   0x7809             LDRB     R1,[R1, #+0]
   \   000000C8   0x4288             CMP      R0,R1
   \   000000CA   0xD303             BCC.N    ??ShiZhiCheck_7
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0xE0B8             B.N      ??ShiZhiCheck_3
   \                     ??ShiZhiCheck_4: (+1)
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0xE0B6             B.N      ??ShiZhiCheck_3
    657                  //线所在的列必须在一定范围内
    658                  for (row = BlackLeftEndLine; row >= BlackLeftHeadLine; row--)
   \                     ??ShiZhiCheck_7: (+1)
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable6_8
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0xE012             B.N      ??ShiZhiCheck_8
    659                  {
    660                      if (BlackLeftLoc[row][0] < 10 || BlackLeftLoc[row][0] > 240) { return 0; }
    661                      else
    662                      {
    663                          limitL += ImgNew[row][BlackLeftLoc[row][0] - 9];
   \                     ??ShiZhiCheck_9: (+1)
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable6_11
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0x22FA             MOVS     R2,#+250
   \   000000E4   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   000000E8   0x.... 0x....      LDR.W    R2,??DataTable6_12
   \   000000EC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EE   0x2303             MOVS     R3,#+3
   \   000000F0   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000F4   0x7812             LDRB     R2,[R2, #+0]
   \   000000F6   0x1851             ADDS     R1,R2,R1
   \   000000F8   0xF811 0x1C09      LDRB     R1,[R1, #-9]
   \   000000FC   0xFA54 0xF481      UXTAB    R4,R4,R1
    664                      }
   \   00000100   0x1E40             SUBS     R0,R0,#+1
   \                     ??ShiZhiCheck_8: (+1)
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable6_10
   \   00000106   0x7809             LDRB     R1,[R1, #+0]
   \   00000108   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010A   0x4288             CMP      R0,R1
   \   0000010C   0xD30B             BCC.N    ??ShiZhiCheck_10
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable6_12
   \   00000112   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000114   0x2203             MOVS     R2,#+3
   \   00000116   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   0000011A   0x7809             LDRB     R1,[R1, #+0]
   \   0000011C   0x390A             SUBS     R1,R1,#+10
   \   0000011E   0x29E7             CMP      R1,#+231
   \   00000120   0xD3DC             BCC.N    ??ShiZhiCheck_9
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0xE08D             B.N      ??ShiZhiCheck_3
    665                  }
    666                  for (row = BlackRightEndLine ; row >= BlackRightHeadLine; row--)
   \                     ??ShiZhiCheck_10: (+1)
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable6_7
   \   0000012A   0x7800             LDRB     R0,[R0, #+0]
   \   0000012C   0xE011             B.N      ??ShiZhiCheck_11
    667                  {
    668                      if (BlackRightLoc[row][0] < 10 || BlackRightLoc[row][0] > 240) { return 0; }
    669                      else
    670                      {
    671                          limitR += ImgNew[row][BlackRightLoc[row][0] + 9];
   \                     ??ShiZhiCheck_12: (+1)
   \   0000012E   0x.... 0x....      LDR.W    R1,??DataTable6_11
   \   00000132   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000134   0x22FA             MOVS     R2,#+250
   \   00000136   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   0000013A   0x.... 0x....      LDR.W    R2,??DataTable7
   \   0000013E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000140   0x2303             MOVS     R3,#+3
   \   00000142   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000146   0x7812             LDRB     R2,[R2, #+0]
   \   00000148   0x1851             ADDS     R1,R2,R1
   \   0000014A   0x7A49             LDRB     R1,[R1, #+9]
   \   0000014C   0xFA55 0xF581      UXTAB    R5,R5,R1
    672                      }
   \   00000150   0x1E40             SUBS     R0,R0,#+1
   \                     ??ShiZhiCheck_11: (+1)
   \   00000152   0x.... 0x....      LDR.W    R1,??DataTable6_9
   \   00000156   0x7809             LDRB     R1,[R1, #+0]
   \   00000158   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015A   0x4288             CMP      R0,R1
   \   0000015C   0xD30B             BCC.N    ??ShiZhiCheck_13
   \   0000015E   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000162   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000164   0x2203             MOVS     R2,#+3
   \   00000166   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   0000016A   0x7809             LDRB     R1,[R1, #+0]
   \   0000016C   0x390A             SUBS     R1,R1,#+10
   \   0000016E   0x29E7             CMP      R1,#+231
   \   00000170   0xD3DD             BCC.N    ??ShiZhiCheck_12
   \   00000172   0x2000             MOVS     R0,#+0
   \   00000174   0xE065             B.N      ??ShiZhiCheck_3
    673                  }
    674          
    675                  limit = (limitL + limitR) / (BlackLeftEndLine - BlackLeftHeadLine + 1) / 2;
   \                     ??ShiZhiCheck_13: (+1)
   \   00000176   0x1928             ADDS     R0,R5,R4
   \   00000178   0x.... 0x....      LDR.W    R1,??DataTable6_8
   \   0000017C   0x7809             LDRB     R1,[R1, #+0]
   \   0000017E   0x.... 0x....      LDR.W    R2,??DataTable6_10
   \   00000182   0x7812             LDRB     R2,[R2, #+0]
   \   00000184   0x1A89             SUBS     R1,R1,R2
   \   00000186   0x1C49             ADDS     R1,R1,#+1
   \   00000188   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000018C   0x0846             LSRS     R6,R0,#+1
    676                  startRow = MinRe(BlackLeftHeadLine, BlackRightHeadLine) - 3;
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable6_9
   \   00000192   0x7801             LDRB     R1,[R0, #+0]
   \   00000194   0x.... 0x....      LDR.W    R0,??DataTable6_10
   \   00000198   0x7800             LDRB     R0,[R0, #+0]
   \   0000019A   0x.... 0x....      BL       MinRe
   \   0000019E   0x1EC4             SUBS     R4,R0,#+3
    677                  limit = MaxRe(limit, LimitLeftB) + 10;
   \   000001A0   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   000001A4   0x7801             LDRB     R1,[R0, #+0]
   \   000001A6   0x0030             MOVS     R0,R6
   \   000001A8   0x.... 0x....      BL       MaxRe
   \   000001AC   0xF110 0x060A      ADDS     R6,R0,#+10
    678          
    679                  for (row = startRow; row > startRow - 3; row--)
   \   000001B0   0x0020             MOVS     R0,R4
   \   000001B2   0xE000             B.N      ??ShiZhiCheck_14
   \                     ??ShiZhiCheck_15: (+1)
   \   000001B4   0x1E40             SUBS     R0,R0,#+1
   \                     ??ShiZhiCheck_14: (+1)
   \   000001B6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001B8   0x1EE1             SUBS     R1,R4,#+3
   \   000001BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001BC   0x4281             CMP      R1,R0
   \   000001BE   0xDA11             BGE.N    ??ShiZhiCheck_16
    680                  {
    681                      for (col = 30; col <= 220; col++)
   \   000001C0   0x211E             MOVS     R1,#+30
   \   000001C2   0xE000             B.N      ??ShiZhiCheck_17
   \                     ??ShiZhiCheck_18: (+1)
   \   000001C4   0x1C49             ADDS     R1,R1,#+1
   \                     ??ShiZhiCheck_17: (+1)
   \   000001C6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001C8   0x29DD             CMP      R1,#+221
   \   000001CA   0xDAF3             BGE.N    ??ShiZhiCheck_15
    682                      {
    683                          if (ImgNew[row][col] <= limit) { return 0; }
   \   000001CC   0x.... 0x....      LDR.W    R2,??DataTable6_11
   \   000001D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001D2   0x23FA             MOVS     R3,#+250
   \   000001D4   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000001D8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001DA   0x5C8A             LDRB     R2,[R1, R2]
   \   000001DC   0x4296             CMP      R6,R2
   \   000001DE   0xD3F1             BCC.N    ??ShiZhiCheck_18
   \   000001E0   0x2000             MOVS     R0,#+0
   \   000001E2   0xE02E             B.N      ??ShiZhiCheck_3
    684                      }
    685                  }
    686                  ShiZhiCount = 0;
   \                     ??ShiZhiCheck_16: (+1)
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0x.... 0x....      LDR.W    R1,??DataTable7_2
   \   000001EA   0x7008             STRB     R0,[R1, #+0]
    687                  return 1;
   \   000001EC   0x2001             MOVS     R0,#+1
   \   000001EE   0xE028             B.N      ??ShiZhiCheck_3
    688              }
    689              else
    690              {
    691                  if(BlackLeftLoc[20][0]!=MaxValUint8 && BlackRightLoc[20][0]!=MaxValUint8){return 0;}
   \                     ??ShiZhiCheck_0: (+1)
   \   000001F0   0x.... 0x....      LDR.W    R0,??DataTable6_12
   \   000001F4   0xF890 0x003C      LDRB     R0,[R0, #+60]
   \   000001F8   0x28FF             CMP      R0,#+255
   \   000001FA   0xD007             BEQ.N    ??ShiZhiCheck_19
   \   000001FC   0x.... 0x....      LDR.W    R0,??DataTable7
   \   00000200   0xF890 0x003C      LDRB     R0,[R0, #+60]
   \   00000204   0x28FF             CMP      R0,#+255
   \   00000206   0xD001             BEQ.N    ??ShiZhiCheck_19
   \   00000208   0x2000             MOVS     R0,#+0
   \   0000020A   0xE01A             B.N      ??ShiZhiCheck_3
    692                  else if(BlackRightHeadLine<15 && BlackLeftHeadLine<15){return 0;}
   \                     ??ShiZhiCheck_19: (+1)
   \   0000020C   0x.... 0x....      LDR.W    R0,??DataTable6_9
   \   00000210   0x7800             LDRB     R0,[R0, #+0]
   \   00000212   0x280F             CMP      R0,#+15
   \   00000214   0xDA06             BGE.N    ??ShiZhiCheck_20
   \   00000216   0x.... 0x....      LDR.W    R0,??DataTable6_10
   \   0000021A   0x7800             LDRB     R0,[R0, #+0]
   \   0000021C   0x280F             CMP      R0,#+15
   \   0000021E   0xDA01             BGE.N    ??ShiZhiCheck_20
   \   00000220   0x2000             MOVS     R0,#+0
   \   00000222   0xE00E             B.N      ??ShiZhiCheck_3
    693                  else if(++ShiZhiCount>=6){return 0;}
   \                     ??ShiZhiCheck_20: (+1)
   \   00000224   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \   00000228   0x7800             LDRB     R0,[R0, #+0]
   \   0000022A   0x1C40             ADDS     R0,R0,#+1
   \   0000022C   0x.... 0x....      LDR.W    R1,??DataTable7_2
   \   00000230   0x7008             STRB     R0,[R1, #+0]
   \   00000232   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \   00000236   0x7800             LDRB     R0,[R0, #+0]
   \   00000238   0x2806             CMP      R0,#+6
   \   0000023A   0xDB01             BLT.N    ??ShiZhiCheck_21
   \   0000023C   0x2000             MOVS     R0,#+0
   \   0000023E   0xE000             B.N      ??ShiZhiCheck_3
    694                  else{return 1;}
   \                     ??ShiZhiCheck_21: (+1)
   \   00000240   0x2001             MOVS     R0,#+1
   \                     ??ShiZhiCheck_3: (+1)
   \   00000242   0xBD70             POP      {R4-R6,PC}       ;; return
    695              }
    696          }
    697          
    698          
    699          
    700          
    701          //新加入的停车线检测

   \                                 In section .text, align 2, keep-with-next
    702          uint8 StopLineCheck()
    703          {
   \                     StopLineCheck: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    704              uint8 row;
    705              uint8 col;
    706              uint16 leftCount = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    707              uint16 rightCount = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    708              uint16 centerErrorCount = 0;
   \   00000006   0x2000             MOVS     R0,#+0
    709              uint32 limitStopLineBlack = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    710              
    711              
    712              if(StopLineCheckBeginFlag == 0)
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD10F             BNE.N    ??StopLineCheck_0
    713              {
    714                  if(++StopLineCheckTimer >= 50)
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable7_4
   \   00000020   0x7008             STRB     R0,[R1, #+0]
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x2832             CMP      R0,#+50
   \   0000002A   0xDB11             BLT.N    ??StopLineCheck_1
    715                  {
    716                      StopLineCheckBeginFlag = 1;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable7_3
   \   00000032   0x7008             STRB     R0,[R1, #+0]
    717                  }
    718                  else {return 0;}
    719              }
    720          
    721              
    722              limitStopLineBlack = 0;
   \                     ??StopLineCheck_0: (+1)
   \   00000034   0x2600             MOVS     R6,#+0
    723              centerErrorCount = 0;
   \   00000036   0x2000             MOVS     R0,#+0
    724              //要保证黑线采集成功
    725              if (BlackLeftDone != 1 || BlackRightDone != 1) { return 0; }
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x2801             CMP      R0,#+1
   \   00000040   0xD104             BNE.N    ??StopLineCheck_2
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD003             BEQ.N    ??StopLineCheck_3
   \                     ??StopLineCheck_2: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE157             B.N      ??StopLineCheck_4
   \                     ??StopLineCheck_1: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE155             B.N      ??StopLineCheck_4
    726              //要保证是在直道
    727              if (AbsInt(SlopeL) < 1500 && AbsInt(SlopeR) < 1500 && AbsInt(CURVEL) < 15 && AbsInt(CURVER) < 15
    728                  && BlackRightCrossDone == 0 && BlackLeftCrossDone == 0
    729                      && BlackRightHeadLine < 3 && BlackLeftHeadLine < 3 && BlackRightEndLine > 57 && BlackLeftEndLine > 57
    730                          && BlackLeftCrossDone == 0 && BlackRightCrossDone == 0
    731                           && ShiZhiFlag == 0) { }
   \                     ??StopLineCheck_3: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x.... 0x....      BL       AbsInt
   \   0000005E   0xF240 0x51DC      MOVW     R1,#+1500
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xDA45             BGE.N    ??StopLineCheck_5
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x.... 0x....      BL       AbsInt
   \   00000070   0xF240 0x51DC      MOVW     R1,#+1500
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xDA3C             BGE.N    ??StopLineCheck_5
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable7_5
   \   0000007C   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000080   0x.... 0x....      BL       AbsInt
   \   00000084   0x280F             CMP      R0,#+15
   \   00000086   0xDA34             BGE.N    ??StopLineCheck_5
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable7_6
   \   0000008C   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000090   0x.... 0x....      BL       AbsInt
   \   00000094   0x280F             CMP      R0,#+15
   \   00000096   0xDA2C             BGE.N    ??StopLineCheck_5
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD127             BNE.N    ??StopLineCheck_5
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable6_6
   \   000000A6   0x7800             LDRB     R0,[R0, #+0]
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD122             BNE.N    ??StopLineCheck_5
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable6_9
   \   000000B0   0x7800             LDRB     R0,[R0, #+0]
   \   000000B2   0x2803             CMP      R0,#+3
   \   000000B4   0xDA1D             BGE.N    ??StopLineCheck_5
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable6_10
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0x2803             CMP      R0,#+3
   \   000000BE   0xDA18             BGE.N    ??StopLineCheck_5
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable6_7
   \   000000C4   0x7800             LDRB     R0,[R0, #+0]
   \   000000C6   0x283A             CMP      R0,#+58
   \   000000C8   0xDB13             BLT.N    ??StopLineCheck_5
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable6_8
   \   000000CE   0x7800             LDRB     R0,[R0, #+0]
   \   000000D0   0x283A             CMP      R0,#+58
   \   000000D2   0xDB0E             BLT.N    ??StopLineCheck_5
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable6_6
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD109             BNE.N    ??StopLineCheck_5
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \   000000E2   0x7800             LDRB     R0,[R0, #+0]
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD104             BNE.N    ??StopLineCheck_5
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable6
   \   000000EC   0x7800             LDRB     R0,[R0, #+0]
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD001             BEQ.N    ??StopLineCheck_6
    732              else { return 0; }
   \                     ??StopLineCheck_5: (+1)
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xE104             B.N      ??StopLineCheck_4
    733          
    734              centerErrorCount = 0;
   \                     ??StopLineCheck_6: (+1)
   \   000000F6   0x2000             MOVS     R0,#+0
    735              //检测20-35行之间有没有可疑的停车线
    736              for (row = 59; row >= 20; row--)
   \   000000F8   0x213B             MOVS     R1,#+59
   \   000000FA   0xE020             B.N      ??StopLineCheck_7
    737              {
    738                  //防止下面的判断溢出
    739                  if (BlackLeftLoc[row][0] == MaxValUint8 || BlackRightLoc[row][0] == MaxValUint8)
    740                  {
    741                      centerErrorCount++;
    742                      if (centerErrorCount > 5)
    743                      {
    744                          return 0;
    745                      }
    746                      continue;
    747                  }
    748                  limitStopLineBlack += ImgNew[row][BlackLeftLoc[row][0]];
   \                     ??StopLineCheck_8: (+1)
   \   000000FC   0x.... 0x....      LDR.W    R2,??DataTable6_11
   \   00000100   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000102   0x23FA             MOVS     R3,#+250
   \   00000104   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000108   0x.... 0x....      LDR.W    R3,??DataTable6_12
   \   0000010C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000010E   0x2703             MOVS     R7,#+3
   \   00000110   0xFB07 0x3301      MLA      R3,R7,R1,R3
   \   00000114   0x781B             LDRB     R3,[R3, #+0]
   \   00000116   0x5C9A             LDRB     R2,[R3, R2]
   \   00000118   0xFA56 0xF682      UXTAB    R6,R6,R2
    749                  limitStopLineBlack += ImgNew[row][BlackRightLoc[row][0]];
   \   0000011C   0x.... 0x....      LDR.W    R2,??DataTable6_11
   \   00000120   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000122   0x23FA             MOVS     R3,#+250
   \   00000124   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000128   0x.... 0x....      LDR.W    R3,??DataTable7
   \   0000012C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000012E   0x2703             MOVS     R7,#+3
   \   00000130   0xFB07 0x3301      MLA      R3,R7,R1,R3
   \   00000134   0x781B             LDRB     R3,[R3, #+0]
   \   00000136   0x5C9A             LDRB     R2,[R3, R2]
   \   00000138   0xFA56 0xF682      UXTAB    R6,R6,R2
   \                     ??StopLineCheck_9: (+1)
   \   0000013C   0x1E49             SUBS     R1,R1,#+1
   \                     ??StopLineCheck_7: (+1)
   \   0000013E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000140   0x2914             CMP      R1,#+20
   \   00000142   0xDB18             BLT.N    ??StopLineCheck_10
   \   00000144   0x.... 0x....      LDR.W    R2,??DataTable6_12
   \   00000148   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000014A   0x2303             MOVS     R3,#+3
   \   0000014C   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000150   0x7812             LDRB     R2,[R2, #+0]
   \   00000152   0x2AFF             CMP      R2,#+255
   \   00000154   0xD008             BEQ.N    ??StopLineCheck_11
   \   00000156   0x.... 0x....      LDR.W    R2,??DataTable7
   \   0000015A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000015C   0x2303             MOVS     R3,#+3
   \   0000015E   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000162   0x7812             LDRB     R2,[R2, #+0]
   \   00000164   0x2AFF             CMP      R2,#+255
   \   00000166   0xD1C9             BNE.N    ??StopLineCheck_8
   \                     ??StopLineCheck_11: (+1)
   \   00000168   0x1C40             ADDS     R0,R0,#+1
   \   0000016A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000016C   0x2806             CMP      R0,#+6
   \   0000016E   0xDB01             BLT.N    ??StopLineCheck_12
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0xE0C5             B.N      ??StopLineCheck_4
   \                     ??StopLineCheck_12: (+1)
   \   00000174   0xE7E2             B.N      ??StopLineCheck_9
    750              }
    751              limitStopLineBlack /= (59 - 20 + 1 - centerErrorCount)*2;
   \                     ??StopLineCheck_10: (+1)
   \   00000176   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000178   0xF1D0 0x0028      RSBS     R0,R0,#+40
   \   0000017C   0x0040             LSLS     R0,R0,#+1
   \   0000017E   0xFBB6 0xF6F0      UDIV     R6,R6,R0
    752          
    753              centerErrorCount = 0;
   \   00000182   0x2000             MOVS     R0,#+0
    754              //检测20-35行之间有没有可疑的停车线
    755              for (row = 55; row >= 40; row--)
   \   00000184   0x2137             MOVS     R1,#+55
   \   00000186   0xE000             B.N      ??StopLineCheck_13
    756              {
    757                  //防止下面的判断溢出
    758                  if (ImgNew[row][BlackLeftLoc[row][0]] >= LimitLeftW || ImgNew[row][BlackRightLoc[row][0]] >= LimitRightW)
    759                  {
    760                      centerErrorCount++;
    761                      if (centerErrorCount > 2)
    762                      {
    763                          return 0;
    764                      }
    765                      continue;
   \                     ??StopLineCheck_14: (+1)
   \                     ??StopLineCheck_15: (+1)
   \   00000188   0x1E49             SUBS     R1,R1,#+1
   \                     ??StopLineCheck_13: (+1)
   \   0000018A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000018C   0x2928             CMP      R1,#+40
   \   0000018E   0xDB2B             BLT.N    ??StopLineCheck_16
   \   00000190   0x.... 0x....      LDR.W    R2,??DataTable6_11
   \   00000194   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000196   0x23FA             MOVS     R3,#+250
   \   00000198   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   0000019C   0x.... 0x....      LDR.W    R3,??DataTable6_12
   \   000001A0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001A2   0x2703             MOVS     R7,#+3
   \   000001A4   0xFB07 0x3301      MLA      R3,R7,R1,R3
   \   000001A8   0x781B             LDRB     R3,[R3, #+0]
   \   000001AA   0x5C9A             LDRB     R2,[R3, R2]
   \   000001AC   0x.... 0x....      LDR.W    R3,??DataTable7_7
   \   000001B0   0x781B             LDRB     R3,[R3, #+0]
   \   000001B2   0x429A             CMP      R2,R3
   \   000001B4   0xD212             BCS.N    ??StopLineCheck_17
   \   000001B6   0x.... 0x....      LDR.W    R2,??DataTable6_11
   \   000001BA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001BC   0x23FA             MOVS     R3,#+250
   \   000001BE   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   000001C2   0x.... 0x....      LDR.W    R3,??DataTable7
   \   000001C6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001C8   0x2703             MOVS     R7,#+3
   \   000001CA   0xFB07 0x3301      MLA      R3,R7,R1,R3
   \   000001CE   0x781B             LDRB     R3,[R3, #+0]
   \   000001D0   0x5C9A             LDRB     R2,[R3, R2]
   \   000001D2   0x.... 0x....      LDR.W    R3,??DataTable7_8
   \   000001D6   0x781B             LDRB     R3,[R3, #+0]
   \   000001D8   0x429A             CMP      R2,R3
   \   000001DA   0xD3D5             BCC.N    ??StopLineCheck_15
   \                     ??StopLineCheck_17: (+1)
   \   000001DC   0x1C40             ADDS     R0,R0,#+1
   \   000001DE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001E0   0x2803             CMP      R0,#+3
   \   000001E2   0xDBD1             BLT.N    ??StopLineCheck_14
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0xE08B             B.N      ??StopLineCheck_4
    766                  }
    767              }
    768          
    769              centerErrorCount = 0;
   \                     ??StopLineCheck_16: (+1)
   \   000001E8   0x2000             MOVS     R0,#+0
    770              //检测20-35行之间有没有可疑的停车线
    771              for (row = 59; row >= 20; row--)
   \   000001EA   0x213B             MOVS     R1,#+59
   \   000001EC   0xE026             B.N      ??StopLineCheck_18
    772              {
    773                  //防止下面的判断溢出
    774                  if (BlackLeftLoc[row][0] == MaxValUint8 || BlackRightLoc[row][0] == MaxValUint8)
    775                  {
    776                      centerErrorCount++;
    777                      if (centerErrorCount > 5)
    778                      {
    779                          return 0;
    780                      }
    781                      continue;
    782                  }
    783                  //从中间线的位置开始找线，一直找到中间线-40
    784                  for (col = BlackLeftLoc[row][0] + 3; col <= (BlackLeftLoc[row][0] + BlackRightLoc[row][0]) / 2; col++)
    785                  {
    786                      if (ImgNew[row][col] < limitStopLineBlack+ limitStopLineBlackXiu)
    787                      {
    788                          leftCount++;
    789                      }
    790                  }
    791          
    792                  //从中间线的位置开始找线，一直找到中间线+40
    793                  for (col = BlackRightLoc[row][0] - 3; col >= (BlackLeftLoc[row][0] + BlackRightLoc[row][0]) / 2; col--)
    794                  {
    795                      if (ImgNew[row][col] < limitStopLineBlack + limitStopLineBlackXiu)
   \                     ??StopLineCheck_19: (+1)
   \   000001EE   0x.... 0x....      LDR.W    R3,??DataTable6_11
   \   000001F2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001F4   0x27FA             MOVS     R7,#+250
   \   000001F6   0xFB07 0x3301      MLA      R3,R7,R1,R3
   \   000001FA   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001FC   0x5CD3             LDRB     R3,[R2, R3]
   \   000001FE   0x.... 0x....      LDR.W    R7,??DataTable7_9
   \   00000202   0x783F             LDRB     R7,[R7, #+0]
   \   00000204   0x19F7             ADDS     R7,R6,R7
   \   00000206   0x42BB             CMP      R3,R7
   \   00000208   0xD200             BCS.N    ??StopLineCheck_20
    796                      {
    797                          rightCount++;
   \   0000020A   0x1C6D             ADDS     R5,R5,#+1
    798                      }
    799                  }
   \                     ??StopLineCheck_20: (+1)
   \   0000020C   0x1E52             SUBS     R2,R2,#+1
   \                     ??StopLineCheck_21: (+1)
   \   0000020E   0x.... 0x....      LDR.W    R3,??DataTable6_12
   \   00000212   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000214   0x2703             MOVS     R7,#+3
   \   00000216   0xFB07 0x3301      MLA      R3,R7,R1,R3
   \   0000021A   0x781B             LDRB     R3,[R3, #+0]
   \   0000021C   0x.... 0x....      LDR.W    R7,??DataTable7
   \   00000220   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000222   0xF05F 0x0C03      MOVS     R12,#+3
   \   00000226   0xFB0C 0x7701      MLA      R7,R12,R1,R7
   \   0000022A   0x783F             LDRB     R7,[R7, #+0]
   \   0000022C   0x18FB             ADDS     R3,R7,R3
   \   0000022E   0x2702             MOVS     R7,#+2
   \   00000230   0xFB93 0xF3F7      SDIV     R3,R3,R7
   \   00000234   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000236   0x429A             CMP      R2,R3
   \   00000238   0xDAD9             BGE.N    ??StopLineCheck_19
   \                     ??StopLineCheck_22: (+1)
   \   0000023A   0x1E49             SUBS     R1,R1,#+1
   \                     ??StopLineCheck_18: (+1)
   \   0000023C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000023E   0x2914             CMP      R1,#+20
   \   00000240   0xDB50             BLT.N    ??StopLineCheck_23
   \   00000242   0x.... 0x....      LDR.W    R2,??DataTable6_12
   \   00000246   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000248   0x2303             MOVS     R3,#+3
   \   0000024A   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   0000024E   0x7812             LDRB     R2,[R2, #+0]
   \   00000250   0x2AFF             CMP      R2,#+255
   \   00000252   0xD008             BEQ.N    ??StopLineCheck_24
   \   00000254   0x.... 0x....      LDR.W    R2,??DataTable7
   \   00000258   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000025A   0x2303             MOVS     R3,#+3
   \   0000025C   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000260   0x7812             LDRB     R2,[R2, #+0]
   \   00000262   0x2AFF             CMP      R2,#+255
   \   00000264   0xD106             BNE.N    ??StopLineCheck_25
   \                     ??StopLineCheck_24: (+1)
   \   00000266   0x1C40             ADDS     R0,R0,#+1
   \   00000268   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000026A   0x2806             CMP      R0,#+6
   \   0000026C   0xDB01             BLT.N    ??StopLineCheck_26
   \   0000026E   0x2000             MOVS     R0,#+0
   \   00000270   0xE046             B.N      ??StopLineCheck_4
   \                     ??StopLineCheck_26: (+1)
   \   00000272   0xE7E2             B.N      ??StopLineCheck_22
   \                     ??StopLineCheck_25: (+1)
   \   00000274   0x.... 0x....      LDR.W    R2,??DataTable6_12
   \   00000278   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000027A   0x2303             MOVS     R3,#+3
   \   0000027C   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000280   0x7812             LDRB     R2,[R2, #+0]
   \   00000282   0x1CD2             ADDS     R2,R2,#+3
   \   00000284   0xE00F             B.N      ??StopLineCheck_27
   \                     ??StopLineCheck_28: (+1)
   \   00000286   0x.... 0x....      LDR.W    R3,??DataTable6_11
   \   0000028A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000028C   0x27FA             MOVS     R7,#+250
   \   0000028E   0xFB07 0x3301      MLA      R3,R7,R1,R3
   \   00000292   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000294   0x5CD3             LDRB     R3,[R2, R3]
   \   00000296   0x.... 0x....      LDR.W    R7,??DataTable7_9
   \   0000029A   0x783F             LDRB     R7,[R7, #+0]
   \   0000029C   0x19F7             ADDS     R7,R6,R7
   \   0000029E   0x42BB             CMP      R3,R7
   \   000002A0   0xD200             BCS.N    ??StopLineCheck_29
   \   000002A2   0x1C64             ADDS     R4,R4,#+1
   \                     ??StopLineCheck_29: (+1)
   \   000002A4   0x1C52             ADDS     R2,R2,#+1
   \                     ??StopLineCheck_27: (+1)
   \   000002A6   0x.... 0x....      LDR.W    R3,??DataTable6_12
   \   000002AA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002AC   0x2703             MOVS     R7,#+3
   \   000002AE   0xFB07 0x3301      MLA      R3,R7,R1,R3
   \   000002B2   0x781B             LDRB     R3,[R3, #+0]
   \   000002B4   0x.... 0x....      LDR.W    R7,??DataTable7
   \   000002B8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002BA   0xF05F 0x0C03      MOVS     R12,#+3
   \   000002BE   0xFB0C 0x7701      MLA      R7,R12,R1,R7
   \   000002C2   0x783F             LDRB     R7,[R7, #+0]
   \   000002C4   0x18FB             ADDS     R3,R7,R3
   \   000002C6   0x2702             MOVS     R7,#+2
   \   000002C8   0xFB93 0xF3F7      SDIV     R3,R3,R7
   \   000002CC   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000002CE   0x4293             CMP      R3,R2
   \   000002D0   0xDAD9             BGE.N    ??StopLineCheck_28
   \   000002D2   0x.... 0x....      LDR.W    R2,??DataTable7
   \   000002D6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002D8   0x2303             MOVS     R3,#+3
   \   000002DA   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   000002DE   0x7812             LDRB     R2,[R2, #+0]
   \   000002E0   0x1ED2             SUBS     R2,R2,#+3
   \   000002E2   0xE794             B.N      ??StopLineCheck_21
    800              }
    801          
    802          
    803              //最后看左右停止线的线头是不是满足水平距离要求
    804              if (leftCount + rightCount > 10 && leftCount >= 5 && rightCount >= 5)//(stopLineLeft!=MaxValUint8)&&(stopLineRight!=MaxValUint8)&&(stopLineRight-stopLineLeft<=40)&&(stopLineRight-stopLineLeft>=20)
   \                     ??StopLineCheck_23: (+1)
   \   000002E4   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000002E6   0xFA15 0xF084      UXTAH    R0,R5,R4
   \   000002EA   0x280B             CMP      R0,#+11
   \   000002EC   0xDB07             BLT.N    ??StopLineCheck_30
   \   000002EE   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000002F0   0x2C05             CMP      R4,#+5
   \   000002F2   0xDB04             BLT.N    ??StopLineCheck_30
   \   000002F4   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000002F6   0x2D05             CMP      R5,#+5
   \   000002F8   0xDB01             BLT.N    ??StopLineCheck_30
    805              {
    806                  return 1;
   \   000002FA   0x2001             MOVS     R0,#+1
   \   000002FC   0xE000             B.N      ??StopLineCheck_4
    807              }
    808              else
    809              {
    810                  return 0;
   \                     ??StopLineCheck_30: (+1)
   \   000002FE   0x2000             MOVS     R0,#+0
   \                     ??StopLineCheck_4: (+1)
   \   00000300   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    811              }
    812          }
    813          
    814          
    815          
    816          
    817          
    818          
    819          //======================================================================
    820          //函数名：LeastSquareInt16a1
    821          //功  能：针对y是int16型数据的最小二乘法的a1值的求取
    822          //参  数：x数组，y数组，num基于的有效数据个数
    823          //返  回：a1
    824          //影  响：无
    825          //说  明：1. y = a0 + a1 * x;
    826          //        2. a1 = (N * Σxy - Σx * Σy) / (N * Σx^2 - Σx * Σx);
    827          //        3. a1乘以了LeastSquareMulti倍。
    828          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    829          int32 LeastSquareInt16a1(uint8 x[], int16 y[], uint8 num)
    830          {
   \                     LeastSquareInt16a1: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    831            int32 andxy = 0, andx = 0, andy = 0, andx2 = 0;
   \   00000002   0x2600             MOVS     R6,#+0
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x2500             MOVS     R5,#+0
    832            int32 a1;
    833            uint8 i;
    834           
    835            for(i = 0; i < num; i++)
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xE01A             B.N      ??LeastSquareInt16a1_0
    836            {
    837              andxy += x[i] * y[i];
   \                     ??LeastSquareInt16a1_1: (+1)
   \   0000000E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000010   0xF817 0xC000      LDRB     R12,[R7, R0]
   \   00000014   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000016   0xF931 0xE017      LDRSH    LR,[R1, R7, LSL #+1]
   \   0000001A   0xFB0E 0x660C      MLA      R6,LR,R12,R6
    838              andx += x[i];
   \   0000001E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000020   0xF817 0xC000      LDRB     R12,[R7, R0]
   \   00000024   0xEB13 0x030C      ADDS     R3,R3,R12
    839              andy += y[i];
   \   00000028   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002A   0xF931 0xC017      LDRSH    R12,[R1, R7, LSL #+1]
   \   0000002E   0xEB14 0x040C      ADDS     R4,R4,R12
    840              andx2 += x[i] * x[i];
   \   00000032   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000034   0xF817 0xC000      LDRB     R12,[R7, R0]
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0xF817 0xE000      LDRB     LR,[R7, R0]
   \   0000003E   0xFB0E 0x550C      MLA      R5,LR,R12,R5
    841            }
   \   00000042   0x1C7F             ADDS     R7,R7,#+1
   \                     ??LeastSquareInt16a1_0: (+1)
   \   00000044   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000046   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000048   0x4297             CMP      R7,R2
   \   0000004A   0xD3E0             BCC.N    ??LeastSquareInt16a1_1
    842            
    843            //运算时为整型，最后变为int32型，且放大了LeastSquareMulti倍。
    844            a1 = (int32)(LeastSquareMulti * (num * andxy - andx * andy) / (num * andx2 - andx * andx));    
   \   0000004C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004E   0xFB06 0xF002      MUL      R0,R6,R2
   \   00000052   0xFB04 0x0013      MLS      R0,R4,R3,R0
   \   00000056   0xF44F 0x717A      MOV      R1,#+1000
   \   0000005A   0x4348             MULS     R0,R1,R0
   \   0000005C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000005E   0xFB05 0xF102      MUL      R1,R5,R2
   \   00000062   0xFB03 0x1113      MLS      R1,R3,R3,R1
   \   00000066   0xFB90 0xF0F1      SDIV     R0,R0,R1
    845            
    846            return a1;  
   \   0000006A   0xBDF0             POP      {R4-R7,PC}       ;; return
    847            
    848          }
    849          
    850          //======================================================================
    851          //函数名：LeastSquareInt16a0
    852          //功  能：针对y是int16型数据的最小二乘法的a0值的求取
    853          //参  数：x数组，y数组，a1参数，num基于的有效数据个数
    854          //返  回：a0
    855          //影  响：无
    856          //说  明：1. y = a0 + a1 * x;
    857          //        2. a0 = Σy / N - a1 * Σx / N;
    858          //        3. a0乘以了LeastSquareMulti倍。      
    859          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    860          int32 LeastSquareInt16a0(uint8 x[], int16 y[], int32 a1, uint8 num)
    861          {
   \                     LeastSquareInt16a0: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    862            int32 andx = 0, andy = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x2500             MOVS     R5,#+0
    863            int32 a0;
    864            uint8 i;
    865            for(i = 0; i < num; i++)
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xE007             B.N      ??LeastSquareInt16a0_0
    866            {
    867              andx += x[i];
   \                     ??LeastSquareInt16a0_1: (+1)
   \   0000000A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000000C   0x5C37             LDRB     R7,[R6, R0]
   \   0000000E   0x19E4             ADDS     R4,R4,R7
    868              andy += y[i];
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0xF931 0x7016      LDRSH    R7,[R1, R6, LSL #+1]
   \   00000016   0x19ED             ADDS     R5,R5,R7
    869            }
   \   00000018   0x1C76             ADDS     R6,R6,#+1
   \                     ??LeastSquareInt16a0_0: (+1)
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000001E   0x429E             CMP      R6,R3
   \   00000020   0xD3F3             BCC.N    ??LeastSquareInt16a0_1
    870            
    871            //运算时为整型，最后变为int32型，且放大了LeastSquareMulti倍。
    872            a0 = (int32)(LeastSquareMulti * andy / num - a1 * andx / num);
   \   00000022   0xF44F 0x707A      MOV      R0,#+1000
   \   00000026   0xFB00 0xF005      MUL      R0,R0,R5
   \   0000002A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000002C   0xFB90 0xF0F3      SDIV     R0,R0,R3
   \   00000030   0xFB04 0xF102      MUL      R1,R4,R2
   \   00000034   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000036   0xFB91 0xF1F3      SDIV     R1,R1,R3
   \   0000003A   0x1A40             SUBS     R0,R0,R1
    873            return a0;
   \   0000003C   0xBCF0             POP      {R4-R7}
   \   0000003E   0x4770             BX       LR               ;; return
    874          }
    875          
    876          //======================================================================
    877          //函数名：LeastSquarea1
    878          //功  能：最小二乘法的a1值的求取
    879          //参  数：x数组，y数组，num基于的有效数据个数
    880          //返  回：a1
    881          //影  响：无
    882          //说  明：1. y = a0 + a1 * x;
    883          //        2. a1 = (N * Σxy - Σx * Σy) / (N * Σx^2 - Σx * Σx);
    884          //        3. a1乘以了LeastSquareMulti倍。
    885          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    886          int32 LeastSquarea1(uint8 x[], uint8 y[], uint8 num)
    887          {
   \                     LeastSquarea1: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    888            int32 andxy = 0, andx = 0, andy = 0, andx2 = 0;
   \   00000002   0x2600             MOVS     R6,#+0
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x2500             MOVS     R5,#+0
    889            int32 a1;
    890            uint8 i;
    891           
    892            for(i = 0; i < num; i++)
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xE01A             B.N      ??LeastSquarea1_0
    893            {
    894              andxy += x[i] * y[i];
   \                     ??LeastSquarea1_1: (+1)
   \   0000000E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000010   0xF817 0xC000      LDRB     R12,[R7, R0]
   \   00000014   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000016   0xF817 0xE001      LDRB     LR,[R7, R1]
   \   0000001A   0xFB0E 0x660C      MLA      R6,LR,R12,R6
    895              andx += x[i];
   \   0000001E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000020   0xF817 0xC000      LDRB     R12,[R7, R0]
   \   00000024   0xEB13 0x030C      ADDS     R3,R3,R12
    896              andy += y[i];
   \   00000028   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002A   0xF817 0xC001      LDRB     R12,[R7, R1]
   \   0000002E   0xEB14 0x040C      ADDS     R4,R4,R12
    897              andx2 += x[i] * x[i];
   \   00000032   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000034   0xF817 0xC000      LDRB     R12,[R7, R0]
   \   00000038   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003A   0xF817 0xE000      LDRB     LR,[R7, R0]
   \   0000003E   0xFB0E 0x550C      MLA      R5,LR,R12,R5
    898            }
   \   00000042   0x1C7F             ADDS     R7,R7,#+1
   \                     ??LeastSquarea1_0: (+1)
   \   00000044   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000046   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000048   0x4297             CMP      R7,R2
   \   0000004A   0xD3E0             BCC.N    ??LeastSquarea1_1
    899            
    900            //运算时为整型，最后变为int32型，且放大了LeastSquareMulti倍。
    901            a1 = (int32)(LeastSquareMulti * (num * andxy - andx * andy) / (num * andx2 - andx * andx));    
   \   0000004C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004E   0xFB06 0xF002      MUL      R0,R6,R2
   \   00000052   0xFB04 0x0013      MLS      R0,R4,R3,R0
   \   00000056   0xF44F 0x717A      MOV      R1,#+1000
   \   0000005A   0x4348             MULS     R0,R1,R0
   \   0000005C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000005E   0xFB05 0xF102      MUL      R1,R5,R2
   \   00000062   0xFB03 0x1113      MLS      R1,R3,R3,R1
   \   00000066   0xFB90 0xF0F1      SDIV     R0,R0,R1
    902            return a1;  
   \   0000006A   0xBDF0             POP      {R4-R7,PC}       ;; return
    903          }
    904          
    905          
    906          //======================================================================
    907          //函数名：LeastSquarea0
    908          //功  能：最小二乘法的a0值的求取
    909          //参  数：x数组，y数组，a1参数，num基于的有效数据个数
    910          //返  回：a0
    911          //影  响：无
    912          //说  明：1. y = a0 + a1 * x;
    913          //        2. a0 = Σy / N - a1 * Σx / N;
    914          //        3. a0乘以了LeastSquareMulti倍。      
    915          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    916          int32 LeastSquarea0(uint8 x[], uint8 y[], int32 a1, uint8 num)
    917          {
   \                     LeastSquarea0: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    918            int32 andx = 0, andy = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0x2500             MOVS     R5,#+0
    919            int32 a0;
    920            uint8 i;
    921            for(i = 0; i < num; i++)
   \   00000006   0x2600             MOVS     R6,#+0
   \   00000008   0xE006             B.N      ??LeastSquarea0_0
    922            {
    923              andx += x[i];
   \                     ??LeastSquarea0_1: (+1)
   \   0000000A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000000C   0x5C37             LDRB     R7,[R6, R0]
   \   0000000E   0x19E4             ADDS     R4,R4,R7
    924              andy += y[i];
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x5C77             LDRB     R7,[R6, R1]
   \   00000014   0x19ED             ADDS     R5,R5,R7
    925            }
   \   00000016   0x1C76             ADDS     R6,R6,#+1
   \                     ??LeastSquarea0_0: (+1)
   \   00000018   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000001C   0x429E             CMP      R6,R3
   \   0000001E   0xD3F4             BCC.N    ??LeastSquarea0_1
    926            
    927            //运算时为整型，最后变为int32型，且放大了LeastSquareMulti倍。
    928            a0 = (int32)(LeastSquareMulti * andy / num - a1 * andx / num);
   \   00000020   0xF44F 0x707A      MOV      R0,#+1000
   \   00000024   0xFB00 0xF005      MUL      R0,R0,R5
   \   00000028   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000002A   0xFB90 0xF0F3      SDIV     R0,R0,R3
   \   0000002E   0xFB04 0xF102      MUL      R1,R4,R2
   \   00000032   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000034   0xFB91 0xF1F3      SDIV     R1,R1,R3
   \   00000038   0x1A40             SUBS     R0,R0,R1
    929            return a0;
   \   0000003A   0xBCF0             POP      {R4-R7}
   \   0000003C   0x4770             BX       LR               ;; return
    930          }
    931          
    932          
    933          
    934          
    935          /*
    936          //二值化图像解压函数
    937          //dst             图像解压目的地址
    938          //src             图像解压源地址
    939          //srclen          二值化图像的占用空间大小
    940          void ImageExtract(uint8 *dst, uint8 *src, uint32 srclen)
    941          {
    942              uint8 colour[2] = {255, 0}; //0 和 1 分别对应的颜色
    943              //注：山外的摄像头 0 表示 白色，1表示 黑色
    944              uint8 tmpsrc;
    945              while(srclen --)
    946              {
    947                  tmpsrc = *src++;
    948                  *dst++ = colour[ (tmpsrc >> 7 ) & 0x01 ];
    949                  *dst++ = colour[ (tmpsrc >> 6 ) & 0x01 ];
    950                  *dst++ = colour[ (tmpsrc >> 5 ) & 0x01 ];
    951                  *dst++ = colour[ (tmpsrc >> 4 ) & 0x01 ];
    952                  *dst++ = colour[ (tmpsrc >> 3 ) & 0x01 ];
    953                  *dst++ = colour[ (tmpsrc >> 2 ) & 0x01 ];
    954                  *dst++ = colour[ (tmpsrc >> 1 ) & 0x01 ];
    955                  *dst++ = colour[ (tmpsrc >> 0 ) & 0x01 ];
    956              }
    957          }
    958          
    959          
    960          */
    961          
    962          /*          //OV7725的图像发送函数
    963          //图像发送到上位机
    964          void SendImage(uint8 *imgaddr, uint32 imgsize)
    965          {                                                                                   
    966              uint8 cmd[4] = {0, 255, 1, 0 };    //yy_摄像头串口调试 使用的命令
    967          
    968              //uint8 cmd[1] = {255};       //DEMOK上位机使用的命令   
    969            
    970              uart_sendN(UART0, cmd, sizeof(cmd));    //先发送命令
    971          
    972              uart_sendN(UART0, imgaddr, imgsize); //再发送图像
    973          }
    974          
    975          */
    976          
    977          //======================================================================
    978          //函数名：SendCenterLineLoc
    979          //功  能：中心线数组发送函数
    980          //参  数：img待发送的一维图像数组
    981          //返  回：无
    982          //影  响：无
    983          //说  明：1. 这里的命令头和图像数组发送函数的命令头不一样。
    984          //      
    985          //          
    986          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    987          void SendCenterLineLoc(uint8 img[CameraHight])
    988          {
   \                     SendCenterLineLoc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    989              uint8 i;
    990              uint8 cmd[4] = {0, 255, 1, 255 };   //中心线数组的数据头
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable7_10
   \   0000000A   0x680A             LDR      R2,[R1, #0]
   \   0000000C   0x6002             STR      R2,[R0, #+0]
    991              uart_sendN(UART0, cmd, sizeof(cmd));    //先发送命令
   \   0000000E   0x2204             MOVS     R2,#+4
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable7_11  ;; 0x4006a000
   \   00000016   0x.... 0x....      BL       uart_sendN
    992              for(i = 0; i < CameraHight; i++)
   \   0000001A   0x2500             MOVS     R5,#+0
   \   0000001C   0xE006             B.N      ??SendCenterLineLoc_0
    993              {
    994                uart_send1(UART0, img[i]); //发送中心线数组
   \                     ??SendCenterLineLoc_1: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x5D29             LDRB     R1,[R5, R4]
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable7_11  ;; 0x4006a000
   \   00000026   0x.... 0x....      BL       uart_send1
    995              }
   \   0000002A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??SendCenterLineLoc_0: (+1)
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D3C             CMP      R5,#+60
   \   00000030   0xDBF5             BLT.N    ??SendCenterLineLoc_1
    996              
    997          }
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    998          
    999          
   1000          
   1001          
   1002          //======================================================================
   1003          //函数名：SendImage
   1004          //功  能：OV7620的图像发送函数
   1005          //参  数：待发送的二维图像数组imgaddr
   1006          //返  回：无
   1007          //影  响：无
   1008          //说  明：1. 修改图像数组大小时需要把内部两个for的内容也改掉
   1009          //        2. 这里的命令头与中心线数组发送函数的命令头不一样。
   1010          //          
   1011          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1012          void SendImage(uint8 imgaddr[CameraHight][CameraRealWidth])
   1013          {                            
   \                     SendImage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   1014              uint16 i, j;
   1015              uint8 cmd[4] = {0, 255, 1, 0 };    //图像数组的数据头
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable7_12
   \   0000000C   0x680A             LDR      R2,[R1, #0]
   \   0000000E   0x6002             STR      R2,[R0, #+0]
   1016          
   1017              //uint8 cmd[1] = {255};       //DEMOK上位机使用的命令   
   1018            
   1019              uart_sendN(UART0, cmd, sizeof(cmd));    //先发送命令
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0xA900             ADD      R1,SP,#+0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable7_11  ;; 0x4006a000
   \   00000018   0x.... 0x....      BL       uart_sendN
   1020              
   1021              //这里不能用uart_sendN(UART0, imgaddr, CameraSize)来代替，因为uart_sendN函数里的buff[i].
   1022              for(i = 0; i < CameraHight; i++)
   \   0000001C   0x2500             MOVS     R5,#+0
   \   0000001E   0xE00E             B.N      ??SendImage_0
   1023                  for(j = 0; j < CameraRealWidth; j++)
   1024                      uart_send1(UART0, imgaddr[i][j]); //发送图像
   \                     ??SendImage_1: (+1)
   \   00000020   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000022   0x20FA             MOVS     R0,#+250
   \   00000024   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   00000028   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000002A   0x5C31             LDRB     R1,[R6, R0]
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable7_11  ;; 0x4006a000
   \   00000030   0x.... 0x....      BL       uart_send1
   \   00000034   0x1C76             ADDS     R6,R6,#+1
   \                     ??SendImage_2: (+1)
   \   00000036   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000038   0x2EFA             CMP      R6,#+250
   \   0000003A   0xDBF1             BLT.N    ??SendImage_1
   \   0000003C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??SendImage_0: (+1)
   \   0000003E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000040   0x2D3C             CMP      R5,#+60
   \   00000042   0xDA01             BGE.N    ??SendImage_3
   \   00000044   0x2600             MOVS     R6,#+0
   \   00000046   0xE7F6             B.N      ??SendImage_2
   1025          }
   \                     ??SendImage_3: (+1)
   \   00000048   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   1026          
   1027          
   1028          
   1029          //====================================左左左左左左左左左左左左左左左左左============================
   1030          
   1031          
   1032          
   1033          
   1034          //======================================================================
   1035          //函数名：BlackLeftRealClear
   1036          //功  能：左黑线提取中，对3个关键值的实际值清零
   1037          //参  数：无
   1038          //返  回：无
   1039          //影  响：BlackLeftRealWB[], BlackLeftRealW[], BlackLeftRealB[]
   1040          //说  明：
   1041          //      
   1042          //             
   1043          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1044          void BlackLeftRealClear(void)
   1045          {
   1046              BlackLeftRealWB[0] = 0;
   \                     BlackLeftRealClear: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable7_13
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   1047              BlackLeftRealWB[1] = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable7_13
   \   0000000E   0x7048             STRB     R0,[R1, #+1]
   1048              BlackLeftRealW[0] = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable7_14
   \   00000016   0x7008             STRB     R0,[R1, #+0]
   1049              BlackLeftRealW[1] = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable7_14
   \   0000001E   0x7048             STRB     R0,[R1, #+1]
   1050              BlackLeftRealB[0] = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable7_15
   \   00000026   0x7008             STRB     R0,[R1, #+0]
   1051              BlackLeftRealB[1] = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable7_15
   \   0000002E   0x7048             STRB     R0,[R1, #+1]
   1052          }
   \   00000030   0x4770             BX       LR               ;; return
   1053          
   1054          
   1055          //黑线提取成功，找左黑线的线头线尾。

   \                                 In section .text, align 2, keep-with-next
   1056          uint8 BlackLeftHeadEndSearch(void)
   1057          {
   1058            uint8 i;
   1059            //左线线头和线尾的查找
   1060            if(BlackLeftDone == 1)
   \                     BlackLeftHeadEndSearch: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable6_1
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD138             BNE.N    ??BlackLeftHeadEndSearch_0
   1061            { //左线线头的查找。
   1062              for(i = 0; ; i++)
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE000             B.N      ??BlackLeftHeadEndSearch_1
   \                     ??BlackLeftHeadEndSearch_2: (+1)
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   1063              {
   1064                if(BlackLeftLoc[i][0] != MaxValUint8)
   \                     ??BlackLeftHeadEndSearch_1: (+1)
   \   0000000E   0x....             LDR.N    R1,??DataTable6_12
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x2203             MOVS     R2,#+3
   \   00000014   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   00000018   0x7809             LDRB     R1,[R1, #+0]
   \   0000001A   0x29FF             CMP      R1,#+255
   \   0000001C   0xD002             BEQ.N    ??BlackLeftHeadEndSearch_3
   1065                { //找到了线头
   1066                  BlackLeftHeadLine = i;
   \   0000001E   0x....             LDR.N    R1,??DataTable6_10
   \   00000020   0x7008             STRB     R0,[R1, #+0]
   1067                  break;
   \   00000022   0xE005             B.N      ??BlackLeftHeadEndSearch_4
   1068                }
   1069                if(i == CameraHight - 1) 
   \                     ??BlackLeftHeadEndSearch_3: (+1)
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x283B             CMP      R0,#+59
   \   00000028   0xD1F0             BNE.N    ??BlackLeftHeadEndSearch_2
   1070                { //直到最近一行还没有找到线头
   1071                  BlackLeftHeadLine = MaxValUint8;
   \   0000002A   0x20FF             MOVS     R0,#+255
   \   0000002C   0x....             LDR.N    R1,??DataTable6_10
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
   1072                  break;
   1073                }
   1074              }
   1075              
   1076              //若线头已经查找失败，就不用查找线尾了。
   1077              if(BlackLeftHeadLine == MaxValUint8)
   \                     ??BlackLeftHeadEndSearch_4: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable6_10
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x28FF             CMP      R0,#+255
   \   00000036   0xD106             BNE.N    ??BlackLeftHeadEndSearch_5
   1078              {
   1079                BlackLeftEndLine = MaxValUint8;
   \   00000038   0x20FF             MOVS     R0,#+255
   \   0000003A   0x....             LDR.N    R1,??DataTable6_8
   \   0000003C   0x7008             STRB     R0,[R1, #+0]
   1080                BlackLeftDone = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x....             LDR.N    R1,??DataTable6_1
   \   00000042   0x7008             STRB     R0,[R1, #+0]
   \   00000044   0xE01F             B.N      ??BlackLeftHeadEndSearch_6
   1081              }
   1082              //若线头查找成功，就开始找线尾。
   1083              else
   1084              {
   1085                //左线线尾的查找。
   1086                for(i = CameraHight - 1; ; i--)
   \                     ??BlackLeftHeadEndSearch_5: (+1)
   \   00000046   0x203B             MOVS     R0,#+59
   \   00000048   0xE000             B.N      ??BlackLeftHeadEndSearch_7
   \                     ??BlackLeftHeadEndSearch_8: (+1)
   \   0000004A   0x1E40             SUBS     R0,R0,#+1
   1087                { //左线线尾查找成功。
   1088                  if(BlackLeftLoc[i][0] != MaxValUint8)
   \                     ??BlackLeftHeadEndSearch_7: (+1)
   \   0000004C   0x....             LDR.N    R1,??DataTable6_12
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x2203             MOVS     R2,#+3
   \   00000052   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   00000056   0x7809             LDRB     R1,[R1, #+0]
   \   00000058   0x29FF             CMP      R1,#+255
   \   0000005A   0xD002             BEQ.N    ??BlackLeftHeadEndSearch_9
   1089                  {
   1090                    BlackLeftEndLine = i;
   \   0000005C   0x....             LDR.N    R1,??DataTable6_8
   \   0000005E   0x7008             STRB     R0,[R1, #+0]
   1091                    break;
   \   00000060   0xE011             B.N      ??BlackLeftHeadEndSearch_6
   1092                  }
   1093                  //左线线尾查找失败。左线不可能有头无尾，所以均置无效值。
   1094                  if(i == BlackLeftHeadLine)
   \                     ??BlackLeftHeadEndSearch_9: (+1)
   \   00000062   0x....             LDR.N    R1,??DataTable6_10
   \   00000064   0x7809             LDRB     R1,[R1, #+0]
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0x4288             CMP      R0,R1
   \   0000006A   0xD1EE             BNE.N    ??BlackLeftHeadEndSearch_8
   1095                  {
   1096                    BlackLeftHeadLine = MaxValUint8;
   \   0000006C   0x20FF             MOVS     R0,#+255
   \   0000006E   0x....             LDR.N    R1,??DataTable6_10
   \   00000070   0x7008             STRB     R0,[R1, #+0]
   1097                    BlackLeftEndLine = MaxValUint8;
   \   00000072   0x20FF             MOVS     R0,#+255
   \   00000074   0x....             LDR.N    R1,??DataTable6_8
   \   00000076   0x7008             STRB     R0,[R1, #+0]
   1098                    break;
   \   00000078   0xE005             B.N      ??BlackLeftHeadEndSearch_6
   1099                  }
   1100                }
   1101              }
   1102            }
   1103            //如果左黑线提取失败，就不用找线头和线尾了。
   1104            else
   1105            {
   1106              BlackLeftHeadLine = MaxValUint8;
   \                     ??BlackLeftHeadEndSearch_0: (+1)
   \   0000007A   0x20FF             MOVS     R0,#+255
   \   0000007C   0x....             LDR.N    R1,??DataTable6_10
   \   0000007E   0x7008             STRB     R0,[R1, #+0]
   1107              BlackLeftEndLine = MaxValUint8;
   \   00000080   0x20FF             MOVS     R0,#+255
   \   00000082   0x....             LDR.N    R1,??DataTable6_8
   \   00000084   0x7008             STRB     R0,[R1, #+0]
   1108            }
   1109            
   1110            //本幅图像有单线时，删掉最远一个点。
   1111            if(SingleBlackAllFlag == 1)
   \                     ??BlackLeftHeadEndSearch_6: (+1)
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable7_16
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0x2801             CMP      R0,#+1
   \   0000008E   0xD10C             BNE.N    ??BlackLeftHeadEndSearch_10
   1112            {
   1113              BlackLeftLoc[BlackLeftHeadLine][0] = MaxValUint8; //Udis数组不用改，因为线头线尾查找之后才轮到矫正函数。
   \   00000090   0x20FF             MOVS     R0,#+255
   \   00000092   0x....             LDR.N    R1,??DataTable6_12
   \   00000094   0x....             LDR.N    R2,??DataTable6_10
   \   00000096   0x7812             LDRB     R2,[R2, #+0]
   \   00000098   0x2303             MOVS     R3,#+3
   \   0000009A   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
   1114              BlackLeftHeadLine += 1;
   \   000000A0   0x....             LDR.N    R0,??DataTable6_10
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0x1C40             ADDS     R0,R0,#+1
   \   000000A6   0x....             LDR.N    R1,??DataTable6_10
   \   000000A8   0x7008             STRB     R0,[R1, #+0]
   1115            }
   1116            else
   1117            {
   1118            }
   1119            
   1120            return 1;
   \                     ??BlackLeftHeadEndSearch_10: (+1)
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0x4770             BX       LR               ;; return
   1121          }
   1122          
   1123          
   1124          
   1125          
   1126          
   1127          
   1128          
   1129          
   1130          //======================================================================
   1131          //函数名：BlackLeftBigChangeCheck
   1132          //功  能：左黑线提取时，大斜率检测。
   1133          //参  数：newrow新加进来的需要判定是否有效的行,use调用时是连续2行的第几行。
   1134          //返  回：1该行黑线成功，0该行黑线失败。
   1135          //影  响：
   1136          //说  明：1. 用来防止大斜率突变的坏点。
   1137          //        2. 共5个行，取1，3，5行进行斜率计算，每进一个新行，移出一个旧行。
   1138          //             
   1139          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1140          uint8 BlackLeftBigChangeCheck(uint8 newrow, uint8 use)
   1141          {
   \                     BlackLeftBigChangeCheck: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1142            uint8 tempstorex, tempstorey;
   1143            uint8 i;
   1144            int32 tempslope1, tempslope2;
   1145            
   1146            //tempstorex用来储存将要移出的一行，用来检测失败时复原5行数组。
   1147            tempstorex = BlackLeftBigChangeNumx[0];
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable8
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   1148            BlackLeftBigChangeNumx[0] = BlackLeftBigChangeNumx[1];
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable8
   \   0000000C   0x7852             LDRB     R2,[R2, #+1]
   \   0000000E   0x.... 0x....      LDR.W    R3,??DataTable8
   \   00000012   0x701A             STRB     R2,[R3, #+0]
   1149            BlackLeftBigChangeNumx[1] = BlackLeftBigChangeNumx[2];
   \   00000014   0x.... 0x....      LDR.W    R2,??DataTable8
   \   00000018   0x7892             LDRB     R2,[R2, #+2]
   \   0000001A   0x.... 0x....      LDR.W    R3,??DataTable8
   \   0000001E   0x705A             STRB     R2,[R3, #+1]
   1150            BlackLeftBigChangeNumx[2] = BlackLeftBigChangeNumx[3];
   \   00000020   0x.... 0x....      LDR.W    R2,??DataTable8
   \   00000024   0x78D2             LDRB     R2,[R2, #+3]
   \   00000026   0x.... 0x....      LDR.W    R3,??DataTable8
   \   0000002A   0x709A             STRB     R2,[R3, #+2]
   1151            BlackLeftBigChangeNumx[3] = BlackLeftBigChangeNumx[4];
   \   0000002C   0x.... 0x....      LDR.W    R2,??DataTable8
   \   00000030   0x7912             LDRB     R2,[R2, #+4]
   \   00000032   0x.... 0x....      LDR.W    R3,??DataTable8
   \   00000036   0x70DA             STRB     R2,[R3, #+3]
   1152            BlackLeftBigChangeNumx[4] = newrow;
   \   00000038   0x.... 0x....      LDR.W    R2,??DataTable8
   \   0000003C   0x7110             STRB     R0,[R2, #+4]
   1153          
   1154            tempstorey = BlackLeftBigChangeNumy[0];
   \   0000003E   0x.... 0x....      LDR.W    R2,??DataTable7_17
   \   00000042   0x7812             LDRB     R2,[R2, #+0]
   1155            BlackLeftBigChangeNumy[0] = BlackLeftBigChangeNumy[1];
   \   00000044   0x.... 0x....      LDR.W    R3,??DataTable7_17
   \   00000048   0x785B             LDRB     R3,[R3, #+1]
   \   0000004A   0x.... 0x....      LDR.W    R4,??DataTable7_17
   \   0000004E   0x7023             STRB     R3,[R4, #+0]
   1156            BlackLeftBigChangeNumy[1] = BlackLeftBigChangeNumy[2];
   \   00000050   0x.... 0x....      LDR.W    R3,??DataTable7_17
   \   00000054   0x789B             LDRB     R3,[R3, #+2]
   \   00000056   0x.... 0x....      LDR.W    R4,??DataTable7_17
   \   0000005A   0x7063             STRB     R3,[R4, #+1]
   1157            BlackLeftBigChangeNumy[2] = BlackLeftBigChangeNumy[3];
   \   0000005C   0x.... 0x....      LDR.W    R3,??DataTable7_17
   \   00000060   0x78DB             LDRB     R3,[R3, #+3]
   \   00000062   0x.... 0x....      LDR.W    R4,??DataTable7_17
   \   00000066   0x70A3             STRB     R3,[R4, #+2]
   1158            BlackLeftBigChangeNumy[3] = BlackLeftBigChangeNumy[4];
   \   00000068   0x.... 0x....      LDR.W    R3,??DataTable7_17
   \   0000006C   0x791B             LDRB     R3,[R3, #+4]
   \   0000006E   0x.... 0x....      LDR.W    R4,??DataTable7_17
   \   00000072   0x70E3             STRB     R3,[R4, #+3]
   1159            BlackLeftBigChangeNumy[4] = BlackLeftLoc[newrow][0];
   \   00000074   0x....             LDR.N    R3,??DataTable6_12
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0x2403             MOVS     R4,#+3
   \   0000007A   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   0000007E   0x781B             LDRB     R3,[R3, #+0]
   \   00000080   0x.... 0x....      LDR.W    R4,??DataTable7_17
   \   00000084   0x7123             STRB     R3,[R4, #+4]
   1160            
   1161            //每幅图最多只进一次这个for循环，可以省时间。
   1162            if(BlackLeftBigChangeJumpFlag == 0)
   \   00000086   0x.... 0x....      LDR.W    R3,??DataTable7_18
   \   0000008A   0x781B             LDRB     R3,[R3, #+0]
   \   0000008C   0x2B00             CMP      R3,#+0
   \   0000008E   0xD111             BNE.N    ??BlackLeftBigChangeCheck_0
   1163            {
   1164              //储存数组的有效性判断，若不足5个数，则无法进行大斜率检测，直接返回成功。
   1165              for(i = 0; i <= 4; i++)
   \   00000090   0x2300             MOVS     R3,#+0
   \   00000092   0xE000             B.N      ??BlackLeftBigChangeCheck_1
   \                     ??BlackLeftBigChangeCheck_2: (+1)
   \   00000094   0x1C5B             ADDS     R3,R3,#+1
   \                     ??BlackLeftBigChangeCheck_1: (+1)
   \   00000096   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000098   0x2B05             CMP      R3,#+5
   \   0000009A   0xDA07             BGE.N    ??BlackLeftBigChangeCheck_3
   1166              {
   1167                if(BlackLeftBigChangeNumx[i] == MaxValUint8)
   \   0000009C   0x.... 0x....      LDR.W    R4,??DataTable8
   \   000000A0   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000A2   0x5D1C             LDRB     R4,[R3, R4]
   \   000000A4   0x2CFF             CMP      R4,#+255
   \   000000A6   0xD1F5             BNE.N    ??BlackLeftBigChangeCheck_2
   1168                {
   1169                  return 1;
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xE0EE             B.N      ??BlackLeftBigChangeCheck_4
   1170                }
   1171              }
   1172              //改变标志位，下次就不进来了。
   1173              BlackLeftBigChangeJumpFlag = 1;
   \                     ??BlackLeftBigChangeCheck_3: (+1)
   \   000000AC   0x2301             MOVS     R3,#+1
   \   000000AE   0x.... 0x....      LDR.W    R4,??DataTable7_18
   \   000000B2   0x7023             STRB     R3,[R4, #+0]
   1174            }
   1175            //走到这里说明通过了数组有效性判断。
   1176            
   1177            
   1178            //取1，3点进行斜率计算。
   1179            //因为只有两个点，所以斜率的计算采取斜率的初始定义的方式，不采取最小二乘法，可以省很多时间。
   1180            tempslope1 = (BlackLeftBigChangeNumy[2] - BlackLeftBigChangeNumy[0]) 
   1181                       * LeastSquareMulti   //乘以了这么多倍。跟最小二乘法一样。
   1182                       / (BlackLeftBigChangeNumx[2] - BlackLeftBigChangeNumx[0]);
   \                     ??BlackLeftBigChangeCheck_0: (+1)
   \   000000B4   0x.... 0x....      LDR.W    R3,??DataTable7_17
   \   000000B8   0x789B             LDRB     R3,[R3, #+2]
   \   000000BA   0x.... 0x....      LDR.W    R4,??DataTable7_17
   \   000000BE   0x7824             LDRB     R4,[R4, #+0]
   \   000000C0   0x1B1B             SUBS     R3,R3,R4
   \   000000C2   0xF44F 0x747A      MOV      R4,#+1000
   \   000000C6   0x4363             MULS     R3,R4,R3
   \   000000C8   0x.... 0x....      LDR.W    R4,??DataTable8
   \   000000CC   0x78A4             LDRB     R4,[R4, #+2]
   \   000000CE   0x.... 0x....      LDR.W    R5,??DataTable8
   \   000000D2   0x782D             LDRB     R5,[R5, #+0]
   \   000000D4   0x1B64             SUBS     R4,R4,R5
   \   000000D6   0xFB93 0xF3F4      SDIV     R3,R3,R4
   1183            tempslope2 = (BlackLeftBigChangeNumy[4] - BlackLeftBigChangeNumy[2]) 
   1184                       * LeastSquareMulti   //乘以了这么多倍。跟最小二乘法一样。
   1185                       / (BlackLeftBigChangeNumx[4] - BlackLeftBigChangeNumx[2]);
   \   000000DA   0x.... 0x....      LDR.W    R4,??DataTable7_17
   \   000000DE   0x7924             LDRB     R4,[R4, #+4]
   \   000000E0   0x.... 0x....      LDR.W    R5,??DataTable7_17
   \   000000E4   0x78AD             LDRB     R5,[R5, #+2]
   \   000000E6   0x1B64             SUBS     R4,R4,R5
   \   000000E8   0xF44F 0x757A      MOV      R5,#+1000
   \   000000EC   0x436C             MULS     R4,R5,R4
   \   000000EE   0x.... 0x....      LDR.W    R5,??DataTable8
   \   000000F2   0x792D             LDRB     R5,[R5, #+4]
   \   000000F4   0x.... 0x....      LDR.W    R6,??DataTable8
   \   000000F8   0x78B6             LDRB     R6,[R6, #+2]
   \   000000FA   0x1BAD             SUBS     R5,R5,R6
   \   000000FC   0xFB94 0xF4F5      SDIV     R4,R4,R5
   1186            BlackLeftBigChangeSlopeStore = tempslope1;
   \   00000100   0x.... 0x....      LDR.W    R5,??DataTable8_1
   \   00000104   0x602B             STR      R3,[R5, #+0]
   1187            //小5点斜率储存在数组中，由于储存的是tempslope1，所以大跳变点不会记录，会出现多行相同值。
   1188            BlackLeft5Slope[BlackLeft5SlopeIndex] = BlackLeftBigChangeSlopeStore;
   \   00000106   0x.... 0x....      LDR.W    R5,??DataTable8_1
   \   0000010A   0x682D             LDR      R5,[R5, #+0]
   \   0000010C   0x.... 0x....      LDR.W    R6,??DataTable8_2
   \   00000110   0x.... 0x....      LDR.W    R7,??DataTable8_3
   \   00000114   0x783F             LDRB     R7,[R7, #+0]
   \   00000116   0xF846 0x5027      STR      R5,[R6, R7, LSL #+2]
   1189            BlackLeft5SlopeRow[BlackLeft5SlopeIndex] = newrow;  //记录计算5点斜率的最远点所在行
   \   0000011A   0x.... 0x....      LDR.W    R5,??DataTable8_4
   \   0000011E   0x.... 0x....      LDR.W    R6,??DataTable8_3
   \   00000122   0x7836             LDRB     R6,[R6, #+0]
   \   00000124   0x5570             STRB     R0,[R6, R5]
   1190            BlackLeft5SlopeIndex++;
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable8_3
   \   0000012A   0x7800             LDRB     R0,[R0, #+0]
   \   0000012C   0x1C40             ADDS     R0,R0,#+1
   \   0000012E   0x.... 0x....      LDR.W    R5,??DataTable8_3
   \   00000132   0x7028             STRB     R0,[R5, #+0]
   1191            
   1192            //1. 前后两次的斜率是相反的。
   1193            if(tempslope1 >= 0 && tempslope2 < 0)
   \   00000134   0x2B00             CMP      R3,#+0
   \   00000136   0xD455             BMI.N    ??BlackLeftBigChangeCheck_5
   \   00000138   0x2C00             CMP      R4,#+0
   \   0000013A   0xD553             BPL.N    ??BlackLeftBigChangeCheck_5
   1194            {
   1195              //2. 两者差值很大很大。
   1196              if(tempslope1 >= tempslope2 + BlackLeftBigChangeSlopeLimit)
   \   0000013C   0xF514 0x607A      ADDS     R0,R4,#+4000
   \   00000140   0x4283             CMP      R3,R0
   \   00000142   0xDB4D             BLT.N    ??BlackLeftBigChangeCheck_6
   1197              {
   1198                //两者差值的确很大。不会刷新储存值。
   1199                //if(use == 2)                    //另一种方案是在连续2行的第2行调用时才置成功标志位。
   1200                //{
   1201                  //置成功标志位。
   1202                  BlackLeftBigChangeFlag = 1;
   \   00000144   0x2001             MOVS     R0,#+1
   \   00000146   0x.... 0x....      LDR.W    R3,??DataTable8_5
   \   0000014A   0x7018             STRB     R0,[R3, #+0]
   1203                //}
   1204                //else
   1205                //{
   1206                //}
   1207                //此次行不进入队列。
   1208                BlackLeftBigChangeNumx[4] = BlackLeftBigChangeNumx[3];
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000150   0x78C0             LDRB     R0,[R0, #+3]
   \   00000152   0x.... 0x....      LDR.W    R3,??DataTable8
   \   00000156   0x7118             STRB     R0,[R3, #+4]
   1209                BlackLeftBigChangeNumx[3] = BlackLeftBigChangeNumx[2];
   \   00000158   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000015C   0x7880             LDRB     R0,[R0, #+2]
   \   0000015E   0x.... 0x....      LDR.W    R3,??DataTable8
   \   00000162   0x70D8             STRB     R0,[R3, #+3]
   1210                BlackLeftBigChangeNumx[2] = BlackLeftBigChangeNumx[1];
   \   00000164   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000168   0x7840             LDRB     R0,[R0, #+1]
   \   0000016A   0x.... 0x....      LDR.W    R3,??DataTable8
   \   0000016E   0x7098             STRB     R0,[R3, #+2]
   1211                BlackLeftBigChangeNumx[1] = BlackLeftBigChangeNumx[0];
   \   00000170   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000174   0x7800             LDRB     R0,[R0, #+0]
   \   00000176   0x.... 0x....      LDR.W    R3,??DataTable8
   \   0000017A   0x7058             STRB     R0,[R3, #+1]
   1212                BlackLeftBigChangeNumx[0] = tempstorex;
   \   0000017C   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000180   0x7001             STRB     R1,[R0, #+0]
   1213                BlackLeftBigChangeNumy[4] = BlackLeftBigChangeNumy[3];
   \   00000182   0x.... 0x....      LDR.W    R0,??DataTable7_17
   \   00000186   0x78C0             LDRB     R0,[R0, #+3]
   \   00000188   0x.... 0x....      LDR.W    R1,??DataTable7_17
   \   0000018C   0x7108             STRB     R0,[R1, #+4]
   1214                BlackLeftBigChangeNumy[3] = BlackLeftBigChangeNumy[2];
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable7_17
   \   00000192   0x7880             LDRB     R0,[R0, #+2]
   \   00000194   0x.... 0x....      LDR.W    R1,??DataTable7_17
   \   00000198   0x70C8             STRB     R0,[R1, #+3]
   1215                BlackLeftBigChangeNumy[2] = BlackLeftBigChangeNumy[1];
   \   0000019A   0x.... 0x....      LDR.W    R0,??DataTable7_17
   \   0000019E   0x7840             LDRB     R0,[R0, #+1]
   \   000001A0   0x.... 0x....      LDR.W    R1,??DataTable7_17
   \   000001A4   0x7088             STRB     R0,[R1, #+2]
   1216                BlackLeftBigChangeNumy[1] = BlackLeftBigChangeNumy[0];
   \   000001A6   0x.... 0x....      LDR.W    R0,??DataTable7_17
   \   000001AA   0x7800             LDRB     R0,[R0, #+0]
   \   000001AC   0x.... 0x....      LDR.W    R1,??DataTable7_17
   \   000001B0   0x7048             STRB     R0,[R1, #+1]
   1217                BlackLeftBigChangeNumy[0] = tempstorey;
   \   000001B2   0x.... 0x....      LDR.W    R0,??DataTable7_17
   \   000001B6   0x7002             STRB     R2,[R0, #+0]
   1218                
   1219                //将前面3个左黑线(共4个)的值置无效值。图像上更连续。
   1220                BlackLeftLoc[BlackLeftBigChangeNumx[4]][0] = MaxValUint8;
   \   000001B8   0x20FF             MOVS     R0,#+255
   \   000001BA   0x....             LDR.N    R1,??DataTable6_12
   \   000001BC   0x.... 0x....      LDR.W    R2,??DataTable8
   \   000001C0   0x7912             LDRB     R2,[R2, #+4]
   \   000001C2   0x2303             MOVS     R3,#+3
   \   000001C4   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000001C8   0x7008             STRB     R0,[R1, #+0]
   1221                BlackLeftLoc[BlackLeftBigChangeNumx[3]][0] = MaxValUint8;
   \   000001CA   0x20FF             MOVS     R0,#+255
   \   000001CC   0x....             LDR.N    R1,??DataTable6_12
   \   000001CE   0x.... 0x....      LDR.W    R2,??DataTable8
   \   000001D2   0x78D2             LDRB     R2,[R2, #+3]
   \   000001D4   0x2303             MOVS     R3,#+3
   \   000001D6   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000001DA   0x7008             STRB     R0,[R1, #+0]
   1222                //BlackLeftLoc[BlackLeftBigChangeNumx[2]][0] = MaxValUint8;    
   1223                
   1224                return 0;
   \   000001DC   0x2000             MOVS     R0,#+0
   \   000001DE   0xE054             B.N      ??BlackLeftBigChangeCheck_4
   1225              }
   1226              else
   1227              {
   1228                //刷新斜率储存值。
   1229                //BlackLeftBigChangeSlopeStore = tempslope;
   1230                return 1;
   \                     ??BlackLeftBigChangeCheck_6: (+1)
   \   000001E0   0x2001             MOVS     R0,#+1
   \   000001E2   0xE052             B.N      ??BlackLeftBigChangeCheck_4
   1231              }
   1232            }
   1233            //1. 前后两次的斜率是相反的。
   1234            else if(tempslope1 < 0 && tempslope2 >= 0)
   \                     ??BlackLeftBigChangeCheck_5: (+1)
   \   000001E4   0x2B00             CMP      R3,#+0
   \   000001E6   0xD54F             BPL.N    ??BlackLeftBigChangeCheck_7
   \   000001E8   0x2C00             CMP      R4,#+0
   \   000001EA   0xD44D             BMI.N    ??BlackLeftBigChangeCheck_7
   1235            {
   1236              //2. 两者差值很大很大。
   1237              if(tempslope2 >= tempslope1 + BlackLeftBigChangeSlopeLimit)
   \   000001EC   0xF513 0x607A      ADDS     R0,R3,#+4000
   \   000001F0   0x4284             CMP      R4,R0
   \   000001F2   0xDB47             BLT.N    ??BlackLeftBigChangeCheck_8
   1238              {
   1239                //两者差值的确很大。不会刷新储存值。
   1240                //if(use == 2)                    //另一种方案是在连续2行的第2行调用时才置成功标志位。
   1241                //{
   1242                  //置成功标志位。
   1243                  BlackLeftBigChangeFlag = 1;
   \   000001F4   0x2001             MOVS     R0,#+1
   \   000001F6   0x.... 0x....      LDR.W    R3,??DataTable8_5
   \   000001FA   0x7018             STRB     R0,[R3, #+0]
   1244                //}
   1245                //else
   1246                //{
   1247                //}
   1248                //此次行不进入队列。
   1249                BlackLeftBigChangeNumx[4] = BlackLeftBigChangeNumx[3];
   \   000001FC   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000200   0x78C0             LDRB     R0,[R0, #+3]
   \   00000202   0x.... 0x....      LDR.W    R3,??DataTable8
   \   00000206   0x7118             STRB     R0,[R3, #+4]
   1250                BlackLeftBigChangeNumx[3] = BlackLeftBigChangeNumx[2];
   \   00000208   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000020C   0x7880             LDRB     R0,[R0, #+2]
   \   0000020E   0x.... 0x....      LDR.W    R3,??DataTable8
   \   00000212   0x70D8             STRB     R0,[R3, #+3]
   1251                BlackLeftBigChangeNumx[2] = BlackLeftBigChangeNumx[1];
   \   00000214   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000218   0x7840             LDRB     R0,[R0, #+1]
   \   0000021A   0x.... 0x....      LDR.W    R3,??DataTable8
   \   0000021E   0x7098             STRB     R0,[R3, #+2]
   1252                BlackLeftBigChangeNumx[1] = BlackLeftBigChangeNumx[0];
   \   00000220   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000224   0x7800             LDRB     R0,[R0, #+0]
   \   00000226   0x.... 0x....      LDR.W    R3,??DataTable8
   \   0000022A   0x7058             STRB     R0,[R3, #+1]
   1253                BlackLeftBigChangeNumx[0] = tempstorex;
   \   0000022C   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000230   0x7001             STRB     R1,[R0, #+0]
   1254                BlackLeftBigChangeNumy[4] = BlackLeftBigChangeNumy[3];
   \   00000232   0x.... 0x....      LDR.W    R0,??DataTable7_17
   \   00000236   0x78C0             LDRB     R0,[R0, #+3]
   \   00000238   0x.... 0x....      LDR.W    R1,??DataTable7_17
   \   0000023C   0x7108             STRB     R0,[R1, #+4]
   1255                BlackLeftBigChangeNumy[3] = BlackLeftBigChangeNumy[2];
   \   0000023E   0x.... 0x....      LDR.W    R0,??DataTable7_17
   \   00000242   0x7880             LDRB     R0,[R0, #+2]
   \   00000244   0x....             LDR.N    R1,??DataTable7_17
   \   00000246   0x70C8             STRB     R0,[R1, #+3]
   1256                BlackLeftBigChangeNumy[2] = BlackLeftBigChangeNumy[1];
   \   00000248   0x....             LDR.N    R0,??DataTable7_17
   \   0000024A   0x7840             LDRB     R0,[R0, #+1]
   \   0000024C   0x....             LDR.N    R1,??DataTable7_17
   \   0000024E   0x7088             STRB     R0,[R1, #+2]
   1257                BlackLeftBigChangeNumy[1] = BlackLeftBigChangeNumy[0];
   \   00000250   0x....             LDR.N    R0,??DataTable7_17
   \   00000252   0x7800             LDRB     R0,[R0, #+0]
   \   00000254   0x....             LDR.N    R1,??DataTable7_17
   \   00000256   0x7048             STRB     R0,[R1, #+1]
   1258                BlackLeftBigChangeNumy[0] = tempstorey;
   \   00000258   0x....             LDR.N    R0,??DataTable7_17
   \   0000025A   0x7002             STRB     R2,[R0, #+0]
   1259                
   1260                //将前面3个左黑线(共4个)的值置无效值。图像上更连续。
   1261                BlackLeftLoc[BlackLeftBigChangeNumx[4]][0] = MaxValUint8;
   \   0000025C   0x20FF             MOVS     R0,#+255
   \   0000025E   0x....             LDR.N    R1,??DataTable6_12
   \   00000260   0x.... 0x....      LDR.W    R2,??DataTable8
   \   00000264   0x7912             LDRB     R2,[R2, #+4]
   \   00000266   0x2303             MOVS     R3,#+3
   \   00000268   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   0000026C   0x7008             STRB     R0,[R1, #+0]
   1262                BlackLeftLoc[BlackLeftBigChangeNumx[3]][0] = MaxValUint8;
   \   0000026E   0x20FF             MOVS     R0,#+255
   \   00000270   0x....             LDR.N    R1,??DataTable6_12
   \   00000272   0x.... 0x....      LDR.W    R2,??DataTable8
   \   00000276   0x78D2             LDRB     R2,[R2, #+3]
   \   00000278   0x2303             MOVS     R3,#+3
   \   0000027A   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   0000027E   0x7008             STRB     R0,[R1, #+0]
   1263                //BlackLeftLoc[BlackLeftBigChangeNumx[2]][0] = MaxValUint8; 
   1264                
   1265                return 0;
   \   00000280   0x2000             MOVS     R0,#+0
   \   00000282   0xE002             B.N      ??BlackLeftBigChangeCheck_4
   1266              }
   1267              else
   1268              {
   1269                //刷新斜率储存值。
   1270                //BlackLeftBigChangeSlopeStore = tempslope;
   1271                return 1;
   \                     ??BlackLeftBigChangeCheck_8: (+1)
   \   00000284   0x2001             MOVS     R0,#+1
   \   00000286   0xE000             B.N      ??BlackLeftBigChangeCheck_4
   1272              }
   1273            }
   1274            //若不相反，则判定无大斜率的跳变。返回成功。
   1275            else
   1276            {
   1277              //刷新斜率储存值。
   1278              //BlackLeftBigChangeSlopeStore = tempslope;
   1279              return 1;
   \                     ??BlackLeftBigChangeCheck_7: (+1)
   \   00000288   0x2001             MOVS     R0,#+1
   \                     ??BlackLeftBigChangeCheck_4: (+1)
   \   0000028A   0xBCF0             POP      {R4-R7}
   \   0000028C   0x4770             BX       LR               ;; return
   1280            }
   1281            
   1282          }
   1283          
   1284          
   1285          //单纯的、从右往左的、一定窗口内的、扫描跳变沿的函数.可以精简Step2Win, CrossSpeWin等诸多内容。
   1286          //返回的是跳变沿的白点所在位置。

   \                                 In section .text, align 2, keep-with-next
   1287          uint8 BlackGetLeftJustWin(uint8 row, int32 colleft, int32 colright)
   1288          {
   \                     BlackGetLeftJustWin: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1289            uint8 temp1, abs1;
   1290            uint8 tempadd1, tempadd2, tempadd3, tempadd4;
   1291            
   1292            //左右边界限幅
   1293            colleft = BoundaryLimitRe(colleft, 0, CameraRealWidth - 1);
   \   00000008   0x22F9             MOVS     R2,#+249
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x.... 0x....      BL       BoundaryLimitRe
   \   00000012   0x0005             MOVS     R5,R0
   1294            colright = BoundaryLimitRe(colright, 0, CameraRealWidth - 1);
   \   00000014   0x22F9             MOVS     R2,#+249
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x0030             MOVS     R0,R6
   \   0000001A   0x.... 0x....      BL       BoundaryLimitRe
   \   0000001E   0x0006             MOVS     R6,R0
   \   00000020   0xE000             B.N      ??BlackGetLeftJustWin_0
   1295            
   1296            //判断条件里的">"很关键，没有写">="是考虑temp = 0的情况，这样可以防止产生负数（uint8中为正数），即无限循环。
   1297            for( ; colright > colleft; colright--) 
   \                     ??BlackGetLeftJustWin_1: (+1)
   \   00000022   0x1E76             SUBS     R6,R6,#+1
   \                     ??BlackGetLeftJustWin_0: (+1)
   \   00000024   0x42B5             CMP      R5,R6
   \   00000026   0xF280 0x8138      BGE.W    ??BlackGetLeftJustWin_2
   1298            {
   1299              //右白点与左黑线的差。
   1300              if(ImgNew[row][colright] > ImgNew[row][colright-1-BlackLeftEdgeNum])
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable9
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x21FA             MOVS     R1,#+250
   \   00000032   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000036   0x1830             ADDS     R0,R6,R0
   \   00000038   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable9
   \   00000040   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000042   0x22FA             MOVS     R2,#+250
   \   00000044   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000048   0x5C71             LDRB     R1,[R6, R1]
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD211             BCS.N    ??BlackGetLeftJustWin_3
   1301              {
   1302                abs1 = ImgNew[row][colright] - ImgNew[row][colright-1-BlackLeftEdgeNum];
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x21FA             MOVS     R1,#+250
   \   00000056   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000005A   0x5C30             LDRB     R0,[R6, R0]
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable9
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0x22FA             MOVS     R2,#+250
   \   00000064   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000068   0x1871             ADDS     R1,R6,R1
   \   0000006A   0xF811 0x1C04      LDRB     R1,[R1, #-4]
   \   0000006E   0x1A40             SUBS     R0,R0,R1
   \   00000070   0xE000             B.N      ??BlackGetLeftJustWin_4
   1303              }
   1304              else
   1305              {
   1306                abs1 = 0;
   \                     ??BlackGetLeftJustWin_3: (+1)
   \   00000072   0x2000             MOVS     R0,#+0
   1307              }
   1308             
   1309              if( //跳变沿的第一批条件：
   1310                  //黑够黑，白够白，差够大。
   1311                  //这里的3个阈值是自适应之后调整的值
   1312                    (abs1 > LimitLeftWB - LimitLeftWBAdjust[row]) //两者的差够大
   1313                  &&(ImgNew[row][colright] > LimitLeftW)                     //白点够白
   1314                  &&(ImgNew[row][colright-1-BlackLeftEdgeNum] < LimitLeftB)                   //黑点够黑
   1315                 )
   \                     ??BlackGetLeftJustWin_4: (+1)
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable9_1
   \   00000078   0x7809             LDRB     R1,[R1, #+0]
   \   0000007A   0x.... 0x....      LDR.W    R2,??DataTable9_2
   \   0000007E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000080   0x5CA2             LDRB     R2,[R4, R2]
   \   00000082   0x1A89             SUBS     R1,R1,R2
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0x4281             CMP      R1,R0
   \   00000088   0xDACB             BGE.N    ??BlackGetLeftJustWin_1
   \   0000008A   0x....             LDR.N    R0,??DataTable7_7
   \   0000008C   0x7800             LDRB     R0,[R0, #+0]
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable9
   \   00000092   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000094   0x22FA             MOVS     R2,#+250
   \   00000096   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000009A   0x5C71             LDRB     R1,[R6, R1]
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xD2C0             BCS.N    ??BlackGetLeftJustWin_1
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable9
   \   000000A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A6   0x21FA             MOVS     R1,#+250
   \   000000A8   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000AC   0x1830             ADDS     R0,R6,R0
   \   000000AE   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   000000B2   0x....             LDR.N    R1,??DataTable7_1
   \   000000B4   0x7809             LDRB     R1,[R1, #+0]
   \   000000B6   0x4288             CMP      R0,R1
   \   000000B8   0xD2B3             BCS.N    ??BlackGetLeftJustWin_1
   1316              {
   1317                      //多几个白点的确认。用来防止右黑线右边的白边。
   1318                      if(colright < CameraRealWidth - 1 - 6)
   \   000000BA   0x2EF3             CMP      R6,#+243
   \   000000BC   0xDA3D             BGE.N    ??BlackGetLeftJustWin_5
   1319                      {
   1320                        tempadd1 = (ImgNew[row][colright+3] > LimitLeftW);
   \   000000BE   0x....             LDR.N    R0,??DataTable7_7
   \   000000C0   0x7800             LDRB     R0,[R0, #+0]
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable9
   \   000000C6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C8   0x22FA             MOVS     R2,#+250
   \   000000CA   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000CE   0x1871             ADDS     R1,R6,R1
   \   000000D0   0x78C9             LDRB     R1,[R1, #+3]
   \   000000D2   0x4288             CMP      R0,R1
   \   000000D4   0xD201             BCS.N    ??BlackGetLeftJustWin_6
   \   000000D6   0x2001             MOVS     R0,#+1
   \   000000D8   0xE000             B.N      ??BlackGetLeftJustWin_7
   \                     ??BlackGetLeftJustWin_6: (+1)
   \   000000DA   0x2000             MOVS     R0,#+0
   1321                        tempadd2 = (ImgNew[row][colright+4] > LimitLeftW);
   \                     ??BlackGetLeftJustWin_7: (+1)
   \   000000DC   0x....             LDR.N    R1,??DataTable7_7
   \   000000DE   0x7809             LDRB     R1,[R1, #+0]
   \   000000E0   0x.... 0x....      LDR.W    R2,??DataTable9
   \   000000E4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E6   0x23FA             MOVS     R3,#+250
   \   000000E8   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   000000EC   0x18B2             ADDS     R2,R6,R2
   \   000000EE   0x7912             LDRB     R2,[R2, #+4]
   \   000000F0   0x4291             CMP      R1,R2
   \   000000F2   0xD201             BCS.N    ??BlackGetLeftJustWin_8
   \   000000F4   0x2101             MOVS     R1,#+1
   \   000000F6   0xE000             B.N      ??BlackGetLeftJustWin_9
   \                     ??BlackGetLeftJustWin_8: (+1)
   \   000000F8   0x2100             MOVS     R1,#+0
   1322                        tempadd3 = (ImgNew[row][colright+5] > LimitLeftW);
   \                     ??BlackGetLeftJustWin_9: (+1)
   \   000000FA   0x....             LDR.N    R2,??DataTable7_7
   \   000000FC   0x7812             LDRB     R2,[R2, #+0]
   \   000000FE   0x.... 0x....      LDR.W    R3,??DataTable9
   \   00000102   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000104   0x27FA             MOVS     R7,#+250
   \   00000106   0xFB07 0x3304      MLA      R3,R7,R4,R3
   \   0000010A   0x18F3             ADDS     R3,R6,R3
   \   0000010C   0x795B             LDRB     R3,[R3, #+5]
   \   0000010E   0x429A             CMP      R2,R3
   \   00000110   0xD201             BCS.N    ??BlackGetLeftJustWin_10
   \   00000112   0x2201             MOVS     R2,#+1
   \   00000114   0xE000             B.N      ??BlackGetLeftJustWin_11
   \                     ??BlackGetLeftJustWin_10: (+1)
   \   00000116   0x2200             MOVS     R2,#+0
   1323                        tempadd4 = (ImgNew[row][colright+6] > LimitLeftW);
   \                     ??BlackGetLeftJustWin_11: (+1)
   \   00000118   0x....             LDR.N    R3,??DataTable7_7
   \   0000011A   0x781B             LDRB     R3,[R3, #+0]
   \   0000011C   0x.... 0x....      LDR.W    R7,??DataTable9
   \   00000120   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000122   0xF05F 0x0CFA      MOVS     R12,#+250
   \   00000126   0xFB0C 0x7704      MLA      R7,R12,R4,R7
   \   0000012A   0x19F7             ADDS     R7,R6,R7
   \   0000012C   0x79BF             LDRB     R7,[R7, #+6]
   \   0000012E   0x42BB             CMP      R3,R7
   \   00000130   0xD201             BCS.N    ??BlackGetLeftJustWin_12
   \   00000132   0x2301             MOVS     R3,#+1
   \   00000134   0xE005             B.N      ??BlackGetLeftJustWin_13
   \                     ??BlackGetLeftJustWin_12: (+1)
   \   00000136   0x2300             MOVS     R3,#+0
   \   00000138   0xE003             B.N      ??BlackGetLeftJustWin_13
   1324                      }
   1325                      else
   1326                      {
   1327                        tempadd1 = 1;
   \                     ??BlackGetLeftJustWin_5: (+1)
   \   0000013A   0x2001             MOVS     R0,#+1
   1328                        tempadd2 = 1;
   \   0000013C   0x2101             MOVS     R1,#+1
   1329                        tempadd3 = 1;
   \   0000013E   0x2201             MOVS     R2,#+1
   1330                        tempadd4 = 1;
   \   00000140   0x2301             MOVS     R3,#+1
   1331                      }       
   1332                
   1333                    //近处的行，向左3个点仍为黑点，向右4个点仍为白点。
   1334                    if(row > BlackMiddleLine)
   \                     ??BlackGetLeftJustWin_13: (+1)
   \   00000142   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000144   0x2C33             CMP      R4,#+51
   \   00000146   0xDB4D             BLT.N    ??BlackGetLeftJustWin_14
   1335                    {                        
   1336                      temp1 = (
   1337                                (ImgNew[row][colright-2-BlackLeftEdgeNum] < LimitLeftB)
   1338                              &&(ImgNew[row][colright-3-BlackLeftEdgeNum] < LimitLeftB)
   1339                              //&&(ImgNew[row][colright-4-BlackLeftEdgeNum] < LimitLeftB)
   1340                              &&(ImgNew[row][colright+1] > LimitLeftW)
   1341                              &&(ImgNew[row][colright+2] > LimitLeftW)
   1342                              &&(tempadd1 == 1)
   1343                              &&(tempadd2 == 1)
   1344                              &&(tempadd3 == 1)
   1345                              &&(tempadd4 == 1)
   1346                              );
   \   00000148   0x.... 0x....      LDR.W    R7,??DataTable9
   \   0000014C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000014E   0xF05F 0x0CFA      MOVS     R12,#+250
   \   00000152   0xFB0C 0x7704      MLA      R7,R12,R4,R7
   \   00000156   0x19F7             ADDS     R7,R6,R7
   \   00000158   0xF817 0x7C05      LDRB     R7,[R7, #-5]
   \   0000015C   0x.... 0x....      LDR.W    R12,??DataTable7_1
   \   00000160   0xF89C 0xC000      LDRB     R12,[R12, #+0]
   \   00000164   0x4567             CMP      R7,R12
   \   00000166   0xD23B             BCS.N    ??BlackGetLeftJustWin_15
   \   00000168   0x.... 0x....      LDR.W    R7,??DataTable9
   \   0000016C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000016E   0xF05F 0x0CFA      MOVS     R12,#+250
   \   00000172   0xFB0C 0x7704      MLA      R7,R12,R4,R7
   \   00000176   0x19F7             ADDS     R7,R6,R7
   \   00000178   0xF817 0x7C06      LDRB     R7,[R7, #-6]
   \   0000017C   0x.... 0x....      LDR.W    R12,??DataTable7_1
   \   00000180   0xF89C 0xC000      LDRB     R12,[R12, #+0]
   \   00000184   0x4567             CMP      R7,R12
   \   00000186   0xD22B             BCS.N    ??BlackGetLeftJustWin_15
   \   00000188   0x....             LDR.N    R7,??DataTable7_7
   \   0000018A   0x783F             LDRB     R7,[R7, #+0]
   \   0000018C   0x.... 0x....      LDR.W    R12,??DataTable9
   \   00000190   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000192   0xF05F 0x0EFA      MOVS     LR,#+250
   \   00000196   0xFB0E 0xCC04      MLA      R12,LR,R4,R12
   \   0000019A   0xEB16 0x0C0C      ADDS     R12,R6,R12
   \   0000019E   0xF89C 0xC001      LDRB     R12,[R12, #+1]
   \   000001A2   0x4567             CMP      R7,R12
   \   000001A4   0xD21C             BCS.N    ??BlackGetLeftJustWin_15
   \   000001A6   0x....             LDR.N    R7,??DataTable7_7
   \   000001A8   0x783F             LDRB     R7,[R7, #+0]
   \   000001AA   0x.... 0x....      LDR.W    R12,??DataTable9
   \   000001AE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001B0   0xF05F 0x0EFA      MOVS     LR,#+250
   \   000001B4   0xFB0E 0xCC04      MLA      R12,LR,R4,R12
   \   000001B8   0xEB16 0x0C0C      ADDS     R12,R6,R12
   \   000001BC   0xF89C 0xC002      LDRB     R12,[R12, #+2]
   \   000001C0   0x4567             CMP      R7,R12
   \   000001C2   0xD20D             BCS.N    ??BlackGetLeftJustWin_15
   \   000001C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001C6   0x2801             CMP      R0,#+1
   \   000001C8   0xD10A             BNE.N    ??BlackGetLeftJustWin_15
   \   000001CA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001CC   0x2901             CMP      R1,#+1
   \   000001CE   0xD107             BNE.N    ??BlackGetLeftJustWin_15
   \   000001D0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001D2   0x2A01             CMP      R2,#+1
   \   000001D4   0xD104             BNE.N    ??BlackGetLeftJustWin_15
   \   000001D6   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001D8   0x2B01             CMP      R3,#+1
   \   000001DA   0xD101             BNE.N    ??BlackGetLeftJustWin_15
   \   000001DC   0x2001             MOVS     R0,#+1
   \   000001DE   0xE055             B.N      ??BlackGetLeftJustWin_16
   \                     ??BlackGetLeftJustWin_15: (+1)
   \   000001E0   0x2000             MOVS     R0,#+0
   \   000001E2   0xE053             B.N      ??BlackGetLeftJustWin_16
   1347                    }
   1348                    else
   1349                    {
   1350                      //中间的行 ，向左2个点为仍为黑点，向右4个点仍为白点。
   1351                      if(row > BlackFarLine)
   \                     ??BlackGetLeftJustWin_14: (+1)
   \   000001E4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001E6   0x2C29             CMP      R4,#+41
   \   000001E8   0xDB2E             BLT.N    ??BlackGetLeftJustWin_17
   1352                      {
   1353                        temp1 = (
   1354                                  (ImgNew[row][colright-2-BlackLeftEdgeNum] < LimitLeftB)
   1355                                //&&(ImgNew[row][colright-3-BlackLeftEdgeNum] < LimitLeftB)
   1356                                &&(ImgNew[row][colright+1] > LimitLeftW)
   1357                                &&(tempadd1 == 1)
   1358                                &&(tempadd2 == 1)
   1359                                &&(tempadd3 == 1)
   1360                                &&(tempadd4 == 1)                        
   1361                                );
   \   000001EA   0x.... 0x....      LDR.W    R7,??DataTable9
   \   000001EE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001F0   0xF05F 0x0CFA      MOVS     R12,#+250
   \   000001F4   0xFB0C 0x7704      MLA      R7,R12,R4,R7
   \   000001F8   0x19F7             ADDS     R7,R6,R7
   \   000001FA   0xF817 0x7C05      LDRB     R7,[R7, #-5]
   \   000001FE   0x.... 0x....      LDR.W    R12,??DataTable7_1
   \   00000202   0xF89C 0xC000      LDRB     R12,[R12, #+0]
   \   00000206   0x4567             CMP      R7,R12
   \   00000208   0xD21C             BCS.N    ??BlackGetLeftJustWin_18
   \   0000020A   0x....             LDR.N    R7,??DataTable7_7
   \   0000020C   0x783F             LDRB     R7,[R7, #+0]
   \   0000020E   0x.... 0x....      LDR.W    R12,??DataTable9
   \   00000212   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000214   0xF05F 0x0EFA      MOVS     LR,#+250
   \   00000218   0xFB0E 0xCC04      MLA      R12,LR,R4,R12
   \   0000021C   0xEB16 0x0C0C      ADDS     R12,R6,R12
   \   00000220   0xF89C 0xC001      LDRB     R12,[R12, #+1]
   \   00000224   0x4567             CMP      R7,R12
   \   00000226   0xD20D             BCS.N    ??BlackGetLeftJustWin_18
   \   00000228   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000022A   0x2801             CMP      R0,#+1
   \   0000022C   0xD10A             BNE.N    ??BlackGetLeftJustWin_18
   \   0000022E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000230   0x2901             CMP      R1,#+1
   \   00000232   0xD107             BNE.N    ??BlackGetLeftJustWin_18
   \   00000234   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000236   0x2A01             CMP      R2,#+1
   \   00000238   0xD104             BNE.N    ??BlackGetLeftJustWin_18
   \   0000023A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000023C   0x2B01             CMP      R3,#+1
   \   0000023E   0xD101             BNE.N    ??BlackGetLeftJustWin_18
   \   00000240   0x2001             MOVS     R0,#+1
   \   00000242   0xE023             B.N      ??BlackGetLeftJustWin_16
   \                     ??BlackGetLeftJustWin_18: (+1)
   \   00000244   0x2000             MOVS     R0,#+0
   \   00000246   0xE021             B.N      ??BlackGetLeftJustWin_16
   1362                      }
   1363                      else
   1364                      {
   1365                        if(row > BlackFarfarLine)
   \                     ??BlackGetLeftJustWin_17: (+1)
   \   00000248   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000024A   0x2C15             CMP      R4,#+21
   \   0000024C   0xDB0F             BLT.N    ??BlackGetLeftJustWin_19
   1366                        {
   1367                          //远处的行 ，向左1个点为仍为黑点，向右4个点仍为白点。
   1368                          temp1 = (
   1369                                  //(ImgNew[row][colright-2-BlackLeftEdgeNum] < LimitLeftB)
   1370                                  (tempadd1 == 1)
   1371                                &&(tempadd2 == 1)
   1372                                &&(tempadd3 == 1)
   1373                                &&(tempadd4 == 1)
   1374                                  );                   
   \   0000024E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000250   0x2801             CMP      R0,#+1
   \   00000252   0xD10A             BNE.N    ??BlackGetLeftJustWin_20
   \   00000254   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000256   0x2901             CMP      R1,#+1
   \   00000258   0xD107             BNE.N    ??BlackGetLeftJustWin_20
   \   0000025A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000025C   0x2A01             CMP      R2,#+1
   \   0000025E   0xD104             BNE.N    ??BlackGetLeftJustWin_20
   \   00000260   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000262   0x2B01             CMP      R3,#+1
   \   00000264   0xD101             BNE.N    ??BlackGetLeftJustWin_20
   \   00000266   0x2001             MOVS     R0,#+1
   \   00000268   0xE010             B.N      ??BlackGetLeftJustWin_16
   \                     ??BlackGetLeftJustWin_20: (+1)
   \   0000026A   0x2000             MOVS     R0,#+0
   \   0000026C   0xE00E             B.N      ??BlackGetLeftJustWin_16
   1375                        }
   1376                        else
   1377                        {
   1378                          //很远处的行，只对跳变和周围白点有要求，对周围黑点没有要求。
   1379                          temp1 = (
   1380                                  (tempadd1 == 1)
   1381                                &&(tempadd2 == 1)
   1382                                &&(tempadd3 == 1)
   1383                                &&(tempadd4 == 1)
   1384                                  );    
   \                     ??BlackGetLeftJustWin_19: (+1)
   \   0000026E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000270   0x2801             CMP      R0,#+1
   \   00000272   0xD10A             BNE.N    ??BlackGetLeftJustWin_21
   \   00000274   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000276   0x2901             CMP      R1,#+1
   \   00000278   0xD107             BNE.N    ??BlackGetLeftJustWin_21
   \   0000027A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000027C   0x2A01             CMP      R2,#+1
   \   0000027E   0xD104             BNE.N    ??BlackGetLeftJustWin_21
   \   00000280   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000282   0x2B01             CMP      R3,#+1
   \   00000284   0xD101             BNE.N    ??BlackGetLeftJustWin_21
   \   00000286   0x2001             MOVS     R0,#+1
   \   00000288   0xE000             B.N      ??BlackGetLeftJustWin_16
   \                     ??BlackGetLeftJustWin_21: (+1)
   \   0000028A   0x2000             MOVS     R0,#+0
   1385                        }
   1386                              
   1387                      }
   1388                    }
   1389                    
   1390                    //跳变沿的第二批条件：
   1391                    if(temp1 == 1)
   \                     ??BlackGetLeftJustWin_16: (+1)
   \   0000028C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000028E   0x2801             CMP      R0,#+1
   \   00000290   0xF47F 0xAEC7      BNE.W    ??BlackGetLeftJustWin_1
   1392                    {
   1393                      //两批条件均满足，返回白点位置，不是黑点位置！           
   1394                      return colright;              
   \   00000294   0x0030             MOVS     R0,R6
   \   00000296   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000298   0xE000             B.N      ??BlackGetLeftJustWin_22
   1395                      
   1396                      //break;          
   1397                    }// end of 跳变沿检测的第2批条件
   1398              }// end of 跳变沿检测的第1批条件
   1399            }// end of for循环  
   1400            
   1401            
   1402            
   1403            //如果一直到窗口最左边还没有找到跳变沿，返回无效值。
   1404            return MaxValUint8;  
   \                     ??BlackGetLeftJustWin_2: (+1)
   \   0000029A   0x20FF             MOVS     R0,#+255
   \                     ??BlackGetLeftJustWin_22: (+1)
   \   0000029C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1405            
   1406          }
   1407          
   1408          
   1409          
   1410          
   1411          //======================================================================
   1412          //函数名：BlackGetLeftStep1Edge
   1413          //功  能：左黑线提取中，第1阶段跳变检测函数,处理该行左线的可疑黑点
   1414          //参  数：待检测的行号row, 第几次使用use, 黑线预处理标志preflag(1是预处理)
   1415          //返  回：1成功 0失败
   1416          //影  响：BlackLeftRealWB[], BlackLeftRealW[], BlackLeftRealB[]
   1417          //        BlackLeftLoc[][]
   1418          //说  明：1. 对第row行的跳变向左进行白到黑检测，成功就赋相应的值（有3个备用值），失败则赋255
   1419          //        2. 两批条件均满足时。则检测成功。会有最多3个值进行记录，现阶段只用到了第1个值
   1420          //        3. 里面有涉及3个关键值的实际值的记录，CrossFlag的情况就不用记录（也就不用更改）
   1421          //        4. 若1个黑点也没有，或者超过3个黑点，则检测失败。
   1422          //        5. 若要改成黑到白的检测，或者任意检测，只需更改第一批条件即可，很方便。
   1423          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1424          uint8 BlackGetLeftStep1Edge(uint8 row, uint8 use, uint8 preflag)
   1425          {
   \                     BlackGetLeftStep1Edge: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1426            uint8 index, col, temp1;
   1427            uint8 abs1;
   1428            uint8 tempadd1, tempadd2, tempadd3, tempadd4;
   1429            uint8 avgr1, avgl1;
   1430            uint8 i;
   1431            
   1432            //根据上一幅有效图像的中线来预估这一幅图像的左右黑线扫描起点，左线起点需要在中线往右一个黑线宽度。 
   1433            col = (uint8)MinRe((int32)BlackLeftEdgeStartCol+10, CameraRealWidth - 1);
   \   0000000A   0x21F9             MOVS     R1,#+249
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable10
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x300A             ADDS     R0,R0,#+10
   \   00000014   0x.... 0x....      BL       MinRe
   \   00000018   0x0007             MOVS     R7,R0
   1434          
   1435            //右线开始扫描。
   1436            //如果是预处理，也不用考虑这个情况。直接往下走就好。
   1437            if((BlackGetPreDir == 1)
   1438            &&(BlackRightLoc[row][0] != MaxValUint8)
   1439            &&(preflag == 0)
   1440              )
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD145             BNE.N    ??BlackGetLeftStep1Edge_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2103             MOVS     R1,#+3
   \   0000002C   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x28FF             CMP      R0,#+255
   \   00000034   0xD03C             BEQ.N    ??BlackGetLeftStep1Edge_0
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E00             CMP      R6,#+0
   \   0000003A   0xD139             BNE.N    ??BlackGetLeftStep1Edge_0
   1441            {
   1442              //如果上一幅图是单线，则左线扫描起点必须在右线的右边一个单线宽度。
   1443              if(
   1444                (row > CameraHight - 5)
   1445              &&(SingleBlackLastAllFlag == 1)
   1446                 )
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C38             CMP      R4,#+56
   \   00000040   0xDB1A             BLT.N    ??BlackGetLeftStep1Edge_1
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable10_3
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD115             BNE.N    ??BlackGetLeftStep1Edge_1
   1447              {
   1448                col = MaxRe(col, MinRe(CameraRealWidth - 1, BlackRightLoc[row][0] + SingleBlackWidthMax[row]));
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0x2103             MOVS     R1,#+3
   \   00000054   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable10_4
   \   0000005E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000060   0x5C61             LDRB     R1,[R4, R1]
   \   00000062   0x1809             ADDS     R1,R1,R0
   \   00000064   0x20F9             MOVS     R0,#+249
   \   00000066   0x.... 0x....      BL       MinRe
   \   0000006A   0x0001             MOVS     R1,R0
   \   0000006C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006E   0x0038             MOVS     R0,R7
   \   00000070   0x.... 0x....      BL       MaxRe
   \   00000074   0x0007             MOVS     R7,R0
   \   00000076   0xE01B             B.N      ??BlackGetLeftStep1Edge_0
   1449              }
   1450              //如果上一幅图不是单线，且最近四行没有采集到单线，那就视为不可能出现单线。所以左线扫描起点必须在右线的左边
   1451              else if(
   1452                     (row <= CameraHight - 5)
   1453                   //&&(SingleBlackLastAllFlag == 0)
   1454                      )
   \                     ??BlackGetLeftStep1Edge_1: (+1)
   \   00000078   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007A   0x2C38             CMP      R4,#+56
   \   0000007C   0xDA0C             BGE.N    ??BlackGetLeftStep1Edge_2
   1455              {
   1456                col = MinRe(col, BlackRightLoc[row][0]);
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000082   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000084   0x2103             MOVS     R1,#+3
   \   00000086   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000008A   0x7801             LDRB     R1,[R0, #+0]
   \   0000008C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000008E   0x0038             MOVS     R0,R7
   \   00000090   0x.... 0x....      BL       MinRe
   \   00000094   0x0007             MOVS     R7,R0
   \   00000096   0xE00B             B.N      ??BlackGetLeftStep1Edge_0
   1457              }
   1458              else
   1459              {
   1460                col = MinRe(col, BlackRightLoc[row][0]);
   \                     ??BlackGetLeftStep1Edge_2: (+1)
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000009C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009E   0x2103             MOVS     R1,#+3
   \   000000A0   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000A4   0x7801             LDRB     R1,[R0, #+0]
   \   000000A6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A8   0x0038             MOVS     R0,R7
   \   000000AA   0x.... 0x....      BL       MinRe
   \   000000AE   0x0007             MOVS     R7,R0
   1461              }
   1462            }
   1463            else
   1464            {    
   1465            }
   1466            
   1467            //窗口预测值记录
   1468            BlackLeftPredictL[row] = 4 + BlackLeftEdgeNum;
   \                     ??BlackGetLeftStep1Edge_0: (+1)
   \   000000B0   0x2007             MOVS     R0,#+7
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable11
   \   000000B6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B8   0x5460             STRB     R0,[R4, R1]
   1469            BlackLeftPredictR[row] = col;
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   000000BE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C0   0x5427             STRB     R7,[R4, R0]
   1470            
   1471            index = 0;         //可疑点的序号
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xE000             B.N      ??BlackGetLeftStep1Edge_3
   1472            //从中间到最左边扫描，隔1个点求差
   1473            for(; col >= 4+BlackLeftEdgeNum; col--) 
   \                     ??BlackGetLeftStep1Edge_4: (+1)
   \   000000C6   0x1E7F             SUBS     R7,R7,#+1
   \                     ??BlackGetLeftStep1Edge_3: (+1)
   \   000000C8   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000CA   0x2F07             CMP      R7,#+7
   \   000000CC   0xF2C0 0x81A7      BLT.W    ??BlackGetLeftStep1Edge_5
   1474            {
   1475                //右白点与左黑点的差。
   1476                if(ImgNew[row][col] > ImgNew[row][col-1-BlackLeftEdgeNum])
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable9
   \   000000D4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D6   0x22FA             MOVS     R2,#+250
   \   000000D8   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000DC   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000DE   0x1879             ADDS     R1,R7,R1
   \   000000E0   0xF811 0x1C04      LDRB     R1,[R1, #-4]
   \   000000E4   0x.... 0x....      LDR.W    R2,??DataTable9
   \   000000E8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EA   0x23FA             MOVS     R3,#+250
   \   000000EC   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   000000F0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F2   0x5CBA             LDRB     R2,[R7, R2]
   \   000000F4   0x4291             CMP      R1,R2
   \   000000F6   0xD213             BCS.N    ??BlackGetLeftStep1Edge_6
   1477                {
   1478                  abs1 = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum];
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable9
   \   000000FC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FE   0x22FA             MOVS     R2,#+250
   \   00000100   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000104   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000106   0x5C79             LDRB     R1,[R7, R1]
   \   00000108   0x.... 0x....      LDR.W    R2,??DataTable9
   \   0000010C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000010E   0x23FA             MOVS     R3,#+250
   \   00000110   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   00000114   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000116   0x18BA             ADDS     R2,R7,R2
   \   00000118   0xF812 0x2C04      LDRB     R2,[R2, #-4]
   \   0000011C   0x1A89             SUBS     R1,R1,R2
   \   0000011E   0xE000             B.N      ??BlackGetLeftStep1Edge_7
   1479                }
   1480                else
   1481                {
   1482                  abs1 = 0;
   \                     ??BlackGetLeftStep1Edge_6: (+1)
   \   00000120   0x2100             MOVS     R1,#+0
   1483                }
   1484                
   1485                if( //跳变沿的第一批条件：
   1486                    //黑够黑，白够白，差够大。
   1487                    //这里的3个阈值为初始值，不是自适应之后调整的值。
   1488                    (abs1 > LimitLeftWB - LimitLeftWBAdjust[row]) //两者的差够大
   1489                  //后面两个条件改一下，就可以实现黑到白的跳变检测，或者任意检测。
   1490                  &&(ImgNew[row][col] > LimitLeftW)                     //白点够白
   1491                  &&(ImgNew[row][col-1-BlackLeftEdgeNum] < LimitLeftB)                   //黑点够黑
   1492                   )
   \                     ??BlackGetLeftStep1Edge_7: (+1)
   \   00000122   0x.... 0x....      LDR.W    R2,??DataTable9_1
   \   00000126   0x7812             LDRB     R2,[R2, #+0]
   \   00000128   0x.... 0x....      LDR.W    R3,??DataTable9_2
   \   0000012C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000012E   0x5CE3             LDRB     R3,[R4, R3]
   \   00000130   0x1AD2             SUBS     R2,R2,R3
   \   00000132   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000134   0x428A             CMP      R2,R1
   \   00000136   0xDAC6             BGE.N    ??BlackGetLeftStep1Edge_4
   \   00000138   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   0000013C   0x7809             LDRB     R1,[R1, #+0]
   \   0000013E   0x.... 0x....      LDR.W    R2,??DataTable9
   \   00000142   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000144   0x23FA             MOVS     R3,#+250
   \   00000146   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   0000014A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000014C   0x5CBA             LDRB     R2,[R7, R2]
   \   0000014E   0x4291             CMP      R1,R2
   \   00000150   0xD2B9             BCS.N    ??BlackGetLeftStep1Edge_4
   \   00000152   0x.... 0x....      LDR.W    R1,??DataTable9
   \   00000156   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000158   0x22FA             MOVS     R2,#+250
   \   0000015A   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000015E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000160   0x1879             ADDS     R1,R7,R1
   \   00000162   0xF811 0x1C04      LDRB     R1,[R1, #-4]
   \   00000166   0x.... 0x....      LDR.W    R2,??DataTable11_3
   \   0000016A   0x7812             LDRB     R2,[R2, #+0]
   \   0000016C   0x4291             CMP      R1,R2
   \   0000016E   0xD2AA             BCS.N    ??BlackGetLeftStep1Edge_4
   1493                {
   1494                      //多几个白点的确认。用来防止右黑线右边的白边。
   1495                      if(col < CameraRealWidth - 1 - 6)
   \   00000170   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000172   0x2FF3             CMP      R7,#+243
   \   00000174   0xDA4E             BGE.N    ??BlackGetLeftStep1Edge_8
   1496                      {
   1497                        tempadd1 = (ImgNew[row][col+3] > LimitLeftW);
   \   00000176   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   0000017A   0x7809             LDRB     R1,[R1, #+0]
   \   0000017C   0x.... 0x....      LDR.W    R2,??DataTable9
   \   00000180   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000182   0x23FA             MOVS     R3,#+250
   \   00000184   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   00000188   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000018A   0x18BA             ADDS     R2,R7,R2
   \   0000018C   0x78D2             LDRB     R2,[R2, #+3]
   \   0000018E   0x4291             CMP      R1,R2
   \   00000190   0xD201             BCS.N    ??BlackGetLeftStep1Edge_9
   \   00000192   0x2101             MOVS     R1,#+1
   \   00000194   0xE000             B.N      ??BlackGetLeftStep1Edge_10
   \                     ??BlackGetLeftStep1Edge_9: (+1)
   \   00000196   0x2100             MOVS     R1,#+0
   1498                        tempadd2 = (ImgNew[row][col+4] > LimitLeftW);
   \                     ??BlackGetLeftStep1Edge_10: (+1)
   \   00000198   0x.... 0x....      LDR.W    R2,??DataTable11_2
   \   0000019C   0x7812             LDRB     R2,[R2, #+0]
   \   0000019E   0x.... 0x....      LDR.W    R3,??DataTable9
   \   000001A2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001A4   0xF05F 0x0CFA      MOVS     R12,#+250
   \   000001A8   0xFB0C 0x3304      MLA      R3,R12,R4,R3
   \   000001AC   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001AE   0x18FB             ADDS     R3,R7,R3
   \   000001B0   0x791B             LDRB     R3,[R3, #+4]
   \   000001B2   0x429A             CMP      R2,R3
   \   000001B4   0xD201             BCS.N    ??BlackGetLeftStep1Edge_11
   \   000001B6   0x2201             MOVS     R2,#+1
   \   000001B8   0xE000             B.N      ??BlackGetLeftStep1Edge_12
   \                     ??BlackGetLeftStep1Edge_11: (+1)
   \   000001BA   0x2200             MOVS     R2,#+0
   1499                        tempadd3 = (ImgNew[row][col+5] > LimitLeftW);
   \                     ??BlackGetLeftStep1Edge_12: (+1)
   \   000001BC   0x.... 0x....      LDR.W    R3,??DataTable11_2
   \   000001C0   0x781B             LDRB     R3,[R3, #+0]
   \   000001C2   0x.... 0x....      LDR.W    R12,??DataTable9
   \   000001C6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001C8   0xF05F 0x0EFA      MOVS     LR,#+250
   \   000001CC   0xFB0E 0xCC04      MLA      R12,LR,R4,R12
   \   000001D0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001D2   0xEB17 0x0C0C      ADDS     R12,R7,R12
   \   000001D6   0xF89C 0xC005      LDRB     R12,[R12, #+5]
   \   000001DA   0x4563             CMP      R3,R12
   \   000001DC   0xD201             BCS.N    ??BlackGetLeftStep1Edge_13
   \   000001DE   0x2301             MOVS     R3,#+1
   \   000001E0   0xE000             B.N      ??BlackGetLeftStep1Edge_14
   \                     ??BlackGetLeftStep1Edge_13: (+1)
   \   000001E2   0x2300             MOVS     R3,#+0
   1500                        tempadd4 = (ImgNew[row][col+6] > LimitLeftW);
   \                     ??BlackGetLeftStep1Edge_14: (+1)
   \   000001E4   0x.... 0x....      LDR.W    R12,??DataTable11_2
   \   000001E8   0xF89C 0xC000      LDRB     R12,[R12, #+0]
   \   000001EC   0x.... 0x....      LDR.W    LR,??DataTable9
   \   000001F0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001F2   0xF05F 0x08FA      MOVS     R8,#+250
   \   000001F6   0xFB08 0xEE04      MLA      LR,R8,R4,LR
   \   000001FA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001FC   0xEB17 0x0E0E      ADDS     LR,R7,LR
   \   00000200   0xF89E 0xE006      LDRB     LR,[LR, #+6]
   \   00000204   0x45F4             CMP      R12,LR
   \   00000206   0xD202             BCS.N    ??BlackGetLeftStep1Edge_15
   \   00000208   0xF05F 0x0C01      MOVS     R12,#+1
   \   0000020C   0xE007             B.N      ??BlackGetLeftStep1Edge_16
   \                     ??BlackGetLeftStep1Edge_15: (+1)
   \   0000020E   0xF05F 0x0C00      MOVS     R12,#+0
   \   00000212   0xE004             B.N      ??BlackGetLeftStep1Edge_16
   1501                      }
   1502                      else
   1503                      {
   1504                        tempadd1 = 1;
   \                     ??BlackGetLeftStep1Edge_8: (+1)
   \   00000214   0x2101             MOVS     R1,#+1
   1505                        tempadd2 = 1;
   \   00000216   0x2201             MOVS     R2,#+1
   1506                        tempadd3 = 1;
   \   00000218   0x2301             MOVS     R3,#+1
   1507                        tempadd4 = 1;
   \   0000021A   0xF05F 0x0C01      MOVS     R12,#+1
   1508                      }       
   1509                    //跳变沿的第二批条件：
   1510                    //近处的行，向左3个点仍为黑点，向右4个点仍为白点。
   1511                    if(row > BlackMiddleLine)
   \                     ??BlackGetLeftStep1Edge_16: (+1)
   \   0000021E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000220   0x2C33             CMP      R4,#+51
   \   00000222   0xDB6B             BLT.N    ??BlackGetLeftStep1Edge_17
   1512                    {                                
   1513                      temp1 = (
   1514                                (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB)
   1515                              &&(ImgNew[row][col-3-BlackLeftEdgeNum] < LimitLeftB)
   1516                              &&(ImgNew[row][col-4-BlackLeftEdgeNum] < LimitLeftB)
   1517                              &&(ImgNew[row][col+1] > LimitLeftW)
   1518                              &&(ImgNew[row][col+2] > LimitLeftW)
   1519                              &&(tempadd1 == 1)
   1520                              &&(tempadd2 == 1)
   1521                              &&(tempadd3 == 1)
   1522                              &&(tempadd4 == 1)
   1523                              );
   \   00000224   0x.... 0x....      LDR.W    LR,??DataTable9
   \   00000228   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000022A   0xF05F 0x08FA      MOVS     R8,#+250
   \   0000022E   0xFB08 0xEE04      MLA      LR,R8,R4,LR
   \   00000232   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000234   0xEB17 0x0E0E      ADDS     LR,R7,LR
   \   00000238   0xF81E 0xEC05      LDRB     LR,[LR, #-5]
   \   0000023C   0x.... 0x....      LDR.W    R8,??DataTable11_3
   \   00000240   0xF898 0x8000      LDRB     R8,[R8, #+0]
   \   00000244   0x45C6             CMP      LR,R8
   \   00000246   0xD257             BCS.N    ??BlackGetLeftStep1Edge_18
   \   00000248   0x.... 0x....      LDR.W    LR,??DataTable9
   \   0000024C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000024E   0xF05F 0x08FA      MOVS     R8,#+250
   \   00000252   0xFB08 0xEE04      MLA      LR,R8,R4,LR
   \   00000256   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000258   0xEB17 0x0E0E      ADDS     LR,R7,LR
   \   0000025C   0xF81E 0xEC06      LDRB     LR,[LR, #-6]
   \   00000260   0x.... 0x....      LDR.W    R8,??DataTable11_3
   \   00000264   0xF898 0x8000      LDRB     R8,[R8, #+0]
   \   00000268   0x45C6             CMP      LR,R8
   \   0000026A   0xD245             BCS.N    ??BlackGetLeftStep1Edge_18
   \   0000026C   0x.... 0x....      LDR.W    LR,??DataTable9
   \   00000270   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000272   0xF05F 0x08FA      MOVS     R8,#+250
   \   00000276   0xFB08 0xEE04      MLA      LR,R8,R4,LR
   \   0000027A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000027C   0xEB17 0x0E0E      ADDS     LR,R7,LR
   \   00000280   0xF81E 0xEC07      LDRB     LR,[LR, #-7]
   \   00000284   0x.... 0x....      LDR.W    R8,??DataTable11_3
   \   00000288   0xF898 0x8000      LDRB     R8,[R8, #+0]
   \   0000028C   0x45C6             CMP      LR,R8
   \   0000028E   0xD233             BCS.N    ??BlackGetLeftStep1Edge_18
   \   00000290   0x.... 0x....      LDR.W    LR,??DataTable11_2
   \   00000294   0xF89E 0xE000      LDRB     LR,[LR, #+0]
   \   00000298   0x.... 0x....      LDR.W    R8,??DataTable9
   \   0000029C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000029E   0xF05F 0x09FA      MOVS     R9,#+250
   \   000002A2   0xFB09 0x8804      MLA      R8,R9,R4,R8
   \   000002A6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002A8   0xEB17 0x0808      ADDS     R8,R7,R8
   \   000002AC   0xF898 0x8001      LDRB     R8,[R8, #+1]
   \   000002B0   0x45C6             CMP      LR,R8
   \   000002B2   0xD221             BCS.N    ??BlackGetLeftStep1Edge_18
   \   000002B4   0x.... 0x....      LDR.W    LR,??DataTable11_2
   \   000002B8   0xF89E 0xE000      LDRB     LR,[LR, #+0]
   \   000002BC   0x.... 0x....      LDR.W    R8,??DataTable9
   \   000002C0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002C2   0xF05F 0x09FA      MOVS     R9,#+250
   \   000002C6   0xFB09 0x8804      MLA      R8,R9,R4,R8
   \   000002CA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002CC   0xEB17 0x0808      ADDS     R8,R7,R8
   \   000002D0   0xF898 0x8002      LDRB     R8,[R8, #+2]
   \   000002D4   0x45C6             CMP      LR,R8
   \   000002D6   0xD20F             BCS.N    ??BlackGetLeftStep1Edge_18
   \   000002D8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002DA   0x2901             CMP      R1,#+1
   \   000002DC   0xD10C             BNE.N    ??BlackGetLeftStep1Edge_18
   \   000002DE   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000002E0   0x2A01             CMP      R2,#+1
   \   000002E2   0xD109             BNE.N    ??BlackGetLeftStep1Edge_18
   \   000002E4   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000002E6   0x2B01             CMP      R3,#+1
   \   000002E8   0xD106             BNE.N    ??BlackGetLeftStep1Edge_18
   \   000002EA   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   000002EE   0xF1BC 0x0F01      CMP      R12,#+1
   \   000002F2   0xD101             BNE.N    ??BlackGetLeftStep1Edge_18
   \   000002F4   0x2101             MOVS     R1,#+1
   \   000002F6   0xE084             B.N      ??BlackGetLeftStep1Edge_19
   \                     ??BlackGetLeftStep1Edge_18: (+1)
   \   000002F8   0x2100             MOVS     R1,#+0
   \   000002FA   0xE082             B.N      ??BlackGetLeftStep1Edge_19
   1524                    }          
   1525                    else
   1526                    {
   1527                      //远处的行 ，向左2个点为仍为黑点，向右4个点仍为白点。
   1528                      if(row > BlackFarLine)
   \                     ??BlackGetLeftStep1Edge_17: (+1)
   \   000002FC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002FE   0x2C29             CMP      R4,#+41
   \   00000300   0xDB47             BLT.N    ??BlackGetLeftStep1Edge_20
   1529                      {
   1530                        temp1 = (
   1531                                  (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB)
   1532                                &&(ImgNew[row][col-3-BlackLeftEdgeNum] < LimitLeftB)
   1533                                &&(ImgNew[row][col+1] > LimitLeftW)
   1534                                &&(tempadd1 == 1)
   1535                                &&(tempadd2 == 1)
   1536                                &&(tempadd3 == 1)
   1537                                &&(tempadd4 == 1)
   1538                                );
   \   00000302   0x.... 0x....      LDR.W    LR,??DataTable9
   \   00000306   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000308   0xF05F 0x08FA      MOVS     R8,#+250
   \   0000030C   0xFB08 0xEE04      MLA      LR,R8,R4,LR
   \   00000310   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000312   0xEB17 0x0E0E      ADDS     LR,R7,LR
   \   00000316   0xF81E 0xEC05      LDRB     LR,[LR, #-5]
   \   0000031A   0x.... 0x....      LDR.W    R8,??DataTable11_3
   \   0000031E   0xF898 0x8000      LDRB     R8,[R8, #+0]
   \   00000322   0x45C6             CMP      LR,R8
   \   00000324   0xD233             BCS.N    ??BlackGetLeftStep1Edge_21
   \   00000326   0x.... 0x....      LDR.W    LR,??DataTable9
   \   0000032A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000032C   0xF05F 0x08FA      MOVS     R8,#+250
   \   00000330   0xFB08 0xEE04      MLA      LR,R8,R4,LR
   \   00000334   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000336   0xEB17 0x0E0E      ADDS     LR,R7,LR
   \   0000033A   0xF81E 0xEC06      LDRB     LR,[LR, #-6]
   \   0000033E   0x.... 0x....      LDR.W    R8,??DataTable11_3
   \   00000342   0xF898 0x8000      LDRB     R8,[R8, #+0]
   \   00000346   0x45C6             CMP      LR,R8
   \   00000348   0xD221             BCS.N    ??BlackGetLeftStep1Edge_21
   \   0000034A   0x.... 0x....      LDR.W    LR,??DataTable11_2
   \   0000034E   0xF89E 0xE000      LDRB     LR,[LR, #+0]
   \   00000352   0x.... 0x....      LDR.W    R8,??DataTable9
   \   00000356   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000358   0xF05F 0x09FA      MOVS     R9,#+250
   \   0000035C   0xFB09 0x8804      MLA      R8,R9,R4,R8
   \   00000360   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000362   0xEB17 0x0808      ADDS     R8,R7,R8
   \   00000366   0xF898 0x8001      LDRB     R8,[R8, #+1]
   \   0000036A   0x45C6             CMP      LR,R8
   \   0000036C   0xD20F             BCS.N    ??BlackGetLeftStep1Edge_21
   \   0000036E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000370   0x2901             CMP      R1,#+1
   \   00000372   0xD10C             BNE.N    ??BlackGetLeftStep1Edge_21
   \   00000374   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000376   0x2A01             CMP      R2,#+1
   \   00000378   0xD109             BNE.N    ??BlackGetLeftStep1Edge_21
   \   0000037A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000037C   0x2B01             CMP      R3,#+1
   \   0000037E   0xD106             BNE.N    ??BlackGetLeftStep1Edge_21
   \   00000380   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   00000384   0xF1BC 0x0F01      CMP      R12,#+1
   \   00000388   0xD101             BNE.N    ??BlackGetLeftStep1Edge_21
   \   0000038A   0x2101             MOVS     R1,#+1
   \   0000038C   0xE039             B.N      ??BlackGetLeftStep1Edge_19
   \                     ??BlackGetLeftStep1Edge_21: (+1)
   \   0000038E   0x2100             MOVS     R1,#+0
   \   00000390   0xE037             B.N      ??BlackGetLeftStep1Edge_19
   1539                      }            
   1540                      else
   1541                      {
   1542                        if(row > BlackFarfarLine)
   \                     ??BlackGetLeftStep1Edge_20: (+1)
   \   00000392   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000394   0x2C15             CMP      R4,#+21
   \   00000396   0xDB23             BLT.N    ??BlackGetLeftStep1Edge_22
   1543                        {
   1544                          //远处的行 ，向左1个点为仍为黑点，向右4个点仍为白点。
   1545                          temp1 = (
   1546                                  (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB)
   1547                                &&(tempadd1 == 1)
   1548                                &&(tempadd2 == 1)
   1549                                &&(tempadd3 == 1)
   1550                                &&(tempadd4 == 1)
   1551                                  );
   \   00000398   0x.... 0x....      LDR.W    LR,??DataTable9
   \   0000039C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000039E   0xF05F 0x08FA      MOVS     R8,#+250
   \   000003A2   0xFB08 0xEE04      MLA      LR,R8,R4,LR
   \   000003A6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000003A8   0xEB17 0x0E0E      ADDS     LR,R7,LR
   \   000003AC   0xF81E 0xEC05      LDRB     LR,[LR, #-5]
   \   000003B0   0x.... 0x....      LDR.W    R8,??DataTable11_3
   \   000003B4   0xF898 0x8000      LDRB     R8,[R8, #+0]
   \   000003B8   0x45C6             CMP      LR,R8
   \   000003BA   0xD20F             BCS.N    ??BlackGetLeftStep1Edge_23
   \   000003BC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000003BE   0x2901             CMP      R1,#+1
   \   000003C0   0xD10C             BNE.N    ??BlackGetLeftStep1Edge_23
   \   000003C2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000003C4   0x2A01             CMP      R2,#+1
   \   000003C6   0xD109             BNE.N    ??BlackGetLeftStep1Edge_23
   \   000003C8   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000003CA   0x2B01             CMP      R3,#+1
   \   000003CC   0xD106             BNE.N    ??BlackGetLeftStep1Edge_23
   \   000003CE   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   000003D2   0xF1BC 0x0F01      CMP      R12,#+1
   \   000003D6   0xD101             BNE.N    ??BlackGetLeftStep1Edge_23
   \   000003D8   0x2101             MOVS     R1,#+1
   \   000003DA   0xE012             B.N      ??BlackGetLeftStep1Edge_19
   \                     ??BlackGetLeftStep1Edge_23: (+1)
   \   000003DC   0x2100             MOVS     R1,#+0
   \   000003DE   0xE010             B.N      ??BlackGetLeftStep1Edge_19
   1552                        }
   1553                        else
   1554                        {
   1555                          //很远的行，有跳变，有周围白点确认就行，对周围黑点没有要求。
   1556                          temp1 = (
   1557                                  (tempadd1 == 1)
   1558                                &&(tempadd2 == 1)
   1559                                &&(tempadd3 == 1)
   1560                                &&(tempadd4 == 1)
   1561                                  );
   \                     ??BlackGetLeftStep1Edge_22: (+1)
   \   000003E0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000003E2   0x2901             CMP      R1,#+1
   \   000003E4   0xD10C             BNE.N    ??BlackGetLeftStep1Edge_24
   \   000003E6   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000003E8   0x2A01             CMP      R2,#+1
   \   000003EA   0xD109             BNE.N    ??BlackGetLeftStep1Edge_24
   \   000003EC   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000003EE   0x2B01             CMP      R3,#+1
   \   000003F0   0xD106             BNE.N    ??BlackGetLeftStep1Edge_24
   \   000003F2   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   000003F6   0xF1BC 0x0F01      CMP      R12,#+1
   \   000003FA   0xD101             BNE.N    ??BlackGetLeftStep1Edge_24
   \   000003FC   0x2101             MOVS     R1,#+1
   \   000003FE   0xE000             B.N      ??BlackGetLeftStep1Edge_19
   \                     ??BlackGetLeftStep1Edge_24: (+1)
   \   00000400   0x2100             MOVS     R1,#+0
   1562                        }
   1563                      }
   1564                    }
   1565          
   1566                    if(temp1)
   \                     ??BlackGetLeftStep1Edge_19: (+1)
   \   00000402   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000404   0x2900             CMP      R1,#+0
   \   00000406   0xF43F 0xAE5E      BEQ.W    ??BlackGetLeftStep1Edge_4
   1567                    {            
   1568                        //跳变检测成功，取黑点
   1569                        BlackLeftLoc[row][index] = col - 1 - BlackLeftEdgeNum;          
   \   0000040A   0x.... 0x....      LDR.W    R1,??DataTable13
   \   0000040E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000410   0x2203             MOVS     R2,#+3
   \   00000412   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000416   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000418   0x1F3A             SUBS     R2,R7,#+4
   \   0000041A   0x5442             STRB     R2,[R0, R1]
   1570                        index++;
   \   0000041C   0x1C40             ADDS     R0,R0,#+1
   1571                        break;
   1572                      
   1573                    }    //end of 跳变沿的第二批条件
   1574                }   //end of 跳变沿的第一批条件
   1575            }// end of 从中间到最左边扫描，隔1个点求差
   1576            
   1577            //1个可疑黑点也没有，则报错。
   1578            if(index == 0)
   \                     ??BlackGetLeftStep1Edge_5: (+1)
   \   0000041E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000420   0x2800             CMP      R0,#+0
   \   00000422   0xD10E             BNE.N    ??BlackGetLeftStep1Edge_25
   1579            {
   1580              //如果是黑线预处理的调用，也不用更新这几个值。
   1581              if(preflag == 0)
   \   00000424   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000426   0x2E00             CMP      R6,#+0
   \   00000428   0xD101             BNE.N    ??BlackGetLeftStep1Edge_26
   1582              {
   1583                //对3个关键值的实际值清零
   1584                BlackLeftRealClear();
   \   0000042A   0x.... 0x....      BL       BlackLeftRealClear
   1585              }
   1586              //该行定位黑线失败，赋无效值
   1587              BlackLeftLoc[row][0] = MaxValUint8;
   \                     ??BlackGetLeftStep1Edge_26: (+1)
   \   0000042E   0x20FF             MOVS     R0,#+255
   \   00000430   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000434   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000436   0x2203             MOVS     R2,#+3
   \   00000438   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000043C   0x7008             STRB     R0,[R1, #+0]
   1588              return 0;
   \   0000043E   0x2000             MOVS     R0,#+0
   \   00000440   0xE1DE             B.N      ??BlackGetLeftStep1Edge_27
   1589            }
   1590            
   1591            //不是黑线预处理的调用，则进行大斜率检测。
   1592            if(preflag == 0)
   \                     ??BlackGetLeftStep1Edge_25: (+1)
   \   00000442   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000444   0x2E00             CMP      R6,#+0
   \   00000446   0xF040 0x8142      BNE.W    ??BlackGetLeftStep1Edge_28
   1593            {
   1594              //最后确认前，需要进行大斜率的检测。若不成功，则说明检测到坏点。
   1595              if(BlackLeftBigChangeCheck(row, use) == 1)
   \   0000044A   0x0029             MOVS     R1,R5
   \   0000044C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000044E   0x0020             MOVS     R0,R4
   \   00000450   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000452   0x.... 0x....      BL       BlackLeftBigChangeCheck
   \   00000456   0x2801             CMP      R0,#+1
   \   00000458   0xF040 0x8191      BNE.W    ??BlackGetLeftStep1Edge_29
   1596              {
   1597                //从右线开始的扫描
   1598                //若已经确认为单线了，就不用再次确认了。
   1599                if(
   1600                  (SingleBlackAllFlag == 0) 
   1601                &&(BlackGetPreDir == 1)   
   1602                  )
   \   0000045C   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000460   0x7800             LDRB     R0,[R0, #+0]
   \   00000462   0x2800             CMP      R0,#+0
   \   00000464   0xF040 0x8133      BNE.W    ??BlackGetLeftStep1Edge_28
   \   00000468   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   0000046C   0x7800             LDRB     R0,[R0, #+0]
   \   0000046E   0x2801             CMP      R0,#+1
   \   00000470   0xF040 0x812D      BNE.W    ??BlackGetLeftStep1Edge_28
   1603                {
   1604                  //若该行左右黑线均检测成功，且右线在左线的左边一定范围内，则该行判定为单线。
   1605                  if((BlackLeftLoc[row][0] != MaxValUint8)
   1606                   &&(BlackRightLoc[row][0] != MaxValUint8)
   1607                   &&(BlackRightLoc[row][0] < BlackLeftLoc[row][0])
   1608                   &&(BlackRightLoc[row][0] - BlackLeftLoc[row][0] < SingleBlackWidthMax[row]) //结果是负数也会满足，所以必须小于。
   1609                  )
   \   00000474   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000478   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000047A   0x2103             MOVS     R1,#+3
   \   0000047C   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000480   0x7800             LDRB     R0,[R0, #+0]
   \   00000482   0x28FF             CMP      R0,#+255
   \   00000484   0xF000 0x8175      BEQ.W    ??BlackGetLeftStep1Edge_30
   \   00000488   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   0000048C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000048E   0x2103             MOVS     R1,#+3
   \   00000490   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000494   0x7800             LDRB     R0,[R0, #+0]
   \   00000496   0x28FF             CMP      R0,#+255
   \   00000498   0xF000 0x816B      BEQ.W    ??BlackGetLeftStep1Edge_30
   \   0000049C   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   000004A0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000004A2   0x2103             MOVS     R1,#+3
   \   000004A4   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000004A8   0x7800             LDRB     R0,[R0, #+0]
   \   000004AA   0x.... 0x....      LDR.W    R1,??DataTable13
   \   000004AE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000004B0   0x2203             MOVS     R2,#+3
   \   000004B2   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000004B6   0x7809             LDRB     R1,[R1, #+0]
   \   000004B8   0x4288             CMP      R0,R1
   \   000004BA   0xF080 0x815A      BCS.W    ??BlackGetLeftStep1Edge_30
   \   000004BE   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   000004C2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000004C4   0x2103             MOVS     R1,#+3
   \   000004C6   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000004CA   0x7800             LDRB     R0,[R0, #+0]
   \   000004CC   0x.... 0x....      LDR.W    R1,??DataTable13
   \   000004D0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000004D2   0x2203             MOVS     R2,#+3
   \   000004D4   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000004D8   0x7809             LDRB     R1,[R1, #+0]
   \   000004DA   0x1A40             SUBS     R0,R0,R1
   \   000004DC   0x.... 0x....      LDR.W    R1,??DataTable10_4
   \   000004E0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000004E2   0x5C61             LDRB     R1,[R4, R1]
   \   000004E4   0x4288             CMP      R0,R1
   \   000004E6   0xF280 0x8144      BGE.W    ??BlackGetLeftStep1Edge_30
   1610                  {
   1611                    //检查5个白点的平均值是否相近，若相近，则是单线，若不相近，则置无效值。
   1612                    if(
   1613                      (BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 5 < 0)
   1614                    ||(BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 5 > CameraRealWidth - 1)
   1615                      )
   \   000004EA   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   000004EE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000004F0   0x2103             MOVS     R1,#+3
   \   000004F2   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000004F6   0x7800             LDRB     R0,[R0, #+0]
   \   000004F8   0x3809             SUBS     R0,R0,#+9
   \   000004FA   0x2800             CMP      R0,#+0
   \   000004FC   0xD409             BMI.N    ??BlackGetLeftStep1Edge_31
   \   000004FE   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000502   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000504   0x2103             MOVS     R1,#+3
   \   00000506   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000050A   0x7800             LDRB     R0,[R0, #+0]
   \   0000050C   0x3009             ADDS     R0,R0,#+9
   \   0000050E   0x28FA             CMP      R0,#+250
   \   00000510   0xDB1F             BLT.N    ??BlackGetLeftStep1Edge_32
   1616                    {
   1617                      //不哆5个点。
   1618                      //因为进行过大跳变，所以要清除。只针对最近几行。
   1619                      if(row > CameraHight - 5)
   \                     ??BlackGetLeftStep1Edge_31: (+1)
   \   00000512   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000514   0x2C38             CMP      R4,#+56
   \   00000516   0xDB12             BLT.N    ??BlackGetLeftStep1Edge_33
   1620                      {
   1621                          for(i = 0; i <= 4; i++)
   \   00000518   0x2000             MOVS     R0,#+0
   \   0000051A   0xE009             B.N      ??BlackGetLeftStep1Edge_34
   1622                          {
   1623                              BlackLeftBigChangeNumx[i] = MaxValUint8;
   \                     ??BlackGetLeftStep1Edge_35: (+1)
   \   0000051C   0x21FF             MOVS     R1,#+255
   \   0000051E   0x....             LDR.N    R2,??DataTable8
   \   00000520   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000522   0x5481             STRB     R1,[R0, R2]
   1624                              BlackLeftBigChangeNumy[i] = MaxValUint8;
   \   00000524   0x21FF             MOVS     R1,#+255
   \   00000526   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   0000052A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000052C   0x5481             STRB     R1,[R0, R2]
   1625                          }
   \   0000052E   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackGetLeftStep1Edge_34: (+1)
   \   00000530   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000532   0x2805             CMP      R0,#+5
   \   00000534   0xDBF2             BLT.N    ??BlackGetLeftStep1Edge_35
   1626                          BlackLeftBigChangeJumpFlag = 0;
   \   00000536   0x2000             MOVS     R0,#+0
   \   00000538   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   0000053C   0x7008             STRB     R0,[R1, #+0]
   1627                      }
   1628                      else
   1629                      {
   1630                      }
   1631                      
   1632                      //该行定位黑线失败，赋无效值
   1633                      BlackLeftLoc[row][0] = MaxValUint8;
   \                     ??BlackGetLeftStep1Edge_33: (+1)
   \   0000053E   0x20FF             MOVS     R0,#+255
   \   00000540   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000544   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000546   0x2203             MOVS     R2,#+3
   \   00000548   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000054C   0x7008             STRB     R0,[R1, #+0]
   1634                      return 0;
   \   0000054E   0x2000             MOVS     R0,#+0
   \   00000550   0xE156             B.N      ??BlackGetLeftStep1Edge_27
   1635                    }
   1636                    else
   1637                    {
   1638                      //该行右线的白点平均值
   1639                      avgr1 = (ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 1]
   1640                             + ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 2]
   1641                             + ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 3]
   1642                             + ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 4]
   1643                             + ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 5])
   1644                             / 5;
   \                     ??BlackGetLeftStep1Edge_32: (+1)
   \   00000552   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000556   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000558   0x21FA             MOVS     R1,#+250
   \   0000055A   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000055E   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   00000562   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000564   0x2203             MOVS     R2,#+3
   \   00000566   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000056A   0x7809             LDRB     R1,[R1, #+0]
   \   0000056C   0x1808             ADDS     R0,R1,R0
   \   0000056E   0xF810 0x0C05      LDRB     R0,[R0, #-5]
   \   00000572   0x.... 0x....      LDR.W    R1,??DataTable9
   \   00000576   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000578   0x22FA             MOVS     R2,#+250
   \   0000057A   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000057E   0x.... 0x....      LDR.W    R2,??DataTable10_2
   \   00000582   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000584   0x2303             MOVS     R3,#+3
   \   00000586   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   0000058A   0x7812             LDRB     R2,[R2, #+0]
   \   0000058C   0x1851             ADDS     R1,R2,R1
   \   0000058E   0xF811 0x1C06      LDRB     R1,[R1, #-6]
   \   00000592   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000596   0x.... 0x....      LDR.W    R1,??DataTable9
   \   0000059A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000059C   0x22FA             MOVS     R2,#+250
   \   0000059E   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000005A2   0x.... 0x....      LDR.W    R2,??DataTable10_2
   \   000005A6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000005A8   0x2303             MOVS     R3,#+3
   \   000005AA   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   000005AE   0x7812             LDRB     R2,[R2, #+0]
   \   000005B0   0x1851             ADDS     R1,R2,R1
   \   000005B2   0xF811 0x1C07      LDRB     R1,[R1, #-7]
   \   000005B6   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   000005BA   0x.... 0x....      LDR.W    R1,??DataTable9
   \   000005BE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000005C0   0x22FA             MOVS     R2,#+250
   \   000005C2   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000005C6   0x.... 0x....      LDR.W    R2,??DataTable10_2
   \   000005CA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000005CC   0x2303             MOVS     R3,#+3
   \   000005CE   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   000005D2   0x7812             LDRB     R2,[R2, #+0]
   \   000005D4   0x1851             ADDS     R1,R2,R1
   \   000005D6   0xF811 0x1C08      LDRB     R1,[R1, #-8]
   \   000005DA   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   000005DE   0x.... 0x....      LDR.W    R1,??DataTable9
   \   000005E2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000005E4   0x22FA             MOVS     R2,#+250
   \   000005E6   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000005EA   0x.... 0x....      LDR.W    R2,??DataTable10_2
   \   000005EE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000005F0   0x2303             MOVS     R3,#+3
   \   000005F2   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   000005F6   0x7812             LDRB     R2,[R2, #+0]
   \   000005F8   0x1851             ADDS     R1,R2,R1
   \   000005FA   0xF811 0x1C09      LDRB     R1,[R1, #-9]
   \   000005FE   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   00000602   0x2105             MOVS     R1,#+5
   \   00000604   0xFB90 0xF0F1      SDIV     R0,R0,R1
   1645                      //该行左线的白点平均值
   1646                      avgl1 = (ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 1]
   1647                             + ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 2]
   1648                             + ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 3]
   1649                             + ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 4]
   1650                             + ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 5])
   1651                             / 5;    
   \   00000608   0x.... 0x....      LDR.W    R1,??DataTable9
   \   0000060C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000060E   0x22FA             MOVS     R2,#+250
   \   00000610   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000614   0x.... 0x....      LDR.W    R2,??DataTable13
   \   00000618   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000061A   0x2303             MOVS     R3,#+3
   \   0000061C   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   00000620   0x7812             LDRB     R2,[R2, #+0]
   \   00000622   0x1851             ADDS     R1,R2,R1
   \   00000624   0x7949             LDRB     R1,[R1, #+5]
   \   00000626   0x.... 0x....      LDR.W    R2,??DataTable9
   \   0000062A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000062C   0x23FA             MOVS     R3,#+250
   \   0000062E   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   00000632   0x.... 0x....      LDR.W    R3,??DataTable13
   \   00000636   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000638   0xF05F 0x0C03      MOVS     R12,#+3
   \   0000063C   0xFB0C 0x3304      MLA      R3,R12,R4,R3
   \   00000640   0x781B             LDRB     R3,[R3, #+0]
   \   00000642   0x189A             ADDS     R2,R3,R2
   \   00000644   0x7992             LDRB     R2,[R2, #+6]
   \   00000646   0xFA52 0xF181      UXTAB    R1,R2,R1
   \   0000064A   0x....             LDR.N    R2,??DataTable9
   \   0000064C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000064E   0x23FA             MOVS     R3,#+250
   \   00000650   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   00000654   0x.... 0x....      LDR.W    R3,??DataTable13
   \   00000658   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000065A   0xF05F 0x0C03      MOVS     R12,#+3
   \   0000065E   0xFB0C 0x3304      MLA      R3,R12,R4,R3
   \   00000662   0x781B             LDRB     R3,[R3, #+0]
   \   00000664   0x189A             ADDS     R2,R3,R2
   \   00000666   0x79D2             LDRB     R2,[R2, #+7]
   \   00000668   0xFA51 0xF182      UXTAB    R1,R1,R2
   \   0000066C   0x....             LDR.N    R2,??DataTable9
   \   0000066E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000670   0x23FA             MOVS     R3,#+250
   \   00000672   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   00000676   0x.... 0x....      LDR.W    R3,??DataTable13
   \   0000067A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000067C   0xF05F 0x0C03      MOVS     R12,#+3
   \   00000680   0xFB0C 0x3304      MLA      R3,R12,R4,R3
   \   00000684   0x781B             LDRB     R3,[R3, #+0]
   \   00000686   0x189A             ADDS     R2,R3,R2
   \   00000688   0x7A12             LDRB     R2,[R2, #+8]
   \   0000068A   0xFA51 0xF182      UXTAB    R1,R1,R2
   \   0000068E   0x....             LDR.N    R2,??DataTable9
   \   00000690   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000692   0x23FA             MOVS     R3,#+250
   \   00000694   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   00000698   0x.... 0x....      LDR.W    R3,??DataTable13
   \   0000069C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000069E   0xF05F 0x0C03      MOVS     R12,#+3
   \   000006A2   0xFB0C 0x3304      MLA      R3,R12,R4,R3
   \   000006A6   0x781B             LDRB     R3,[R3, #+0]
   \   000006A8   0x189A             ADDS     R2,R3,R2
   \   000006AA   0x7A52             LDRB     R2,[R2, #+9]
   \   000006AC   0xFA51 0xF182      UXTAB    R1,R1,R2
   \   000006B0   0x2205             MOVS     R2,#+5
   \   000006B2   0xFB91 0xF1F2      SDIV     R1,R1,R2
   1652                      if(AbsInt(avgr1 - avgl1) < 20)
   \   000006B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000006B8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000006BA   0x1A40             SUBS     R0,R0,R1
   \   000006BC   0x.... 0x....      BL       AbsInt
   \   000006C0   0x2814             CMP      R0,#+20
   \   000006C2   0xDA36             BGE.N    ??BlackGetLeftStep1Edge_36
   1653                      {
   1654                        //5个白点之间的差别够小，单线判断成功。
   1655                        SingleBlackFlag[row] = 1;      
   \   000006C4   0x2001             MOVS     R0,#+1
   \   000006C6   0x.... 0x....      LDR.W    R1,??DataTable14
   \   000006CA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000006CC   0x5460             STRB     R0,[R4, R1]
   1656                        //SingleBlackAllFlag = 1;   //总幅图像的单线标志，只要有一行检测单线成功，则置1.
   1657                      }
   1658                      else
   1659                      {
   1660                        //5个白点之间的差别太大，单线判断失败。
   1661                        //因为进行过大跳变，所以要清除。只针对最近几行。
   1662                        if(row > CameraHight - 5)
   1663                        {
   1664                            for(i = 0; i <= 4; i++)
   1665                            {
   1666                                BlackLeftBigChangeNumx[i] = MaxValUint8;
   1667                                BlackLeftBigChangeNumy[i] = MaxValUint8;
   1668                            }
   1669                            BlackLeftBigChangeJumpFlag = 0;
   1670                        }
   1671                        else
   1672                        {
   1673                        }             
   1674                        
   1675                        //该行定位黑线失败，赋无效值
   1676                        BlackLeftLoc[row][0] = MaxValUint8;
   1677                        return 0;              
   1678                      }
   1679                    }          
   1680                  }
   1681                  else
   1682                  {
   1683                    //否则该行单线标志为0.
   1684                    SingleBlackFlag[row] = 0;
   1685                  }
   1686                }
   1687                //从右线开始的扫描，右线不用检测是否有单线，左线去检测即可。
   1688                else
   1689                {
   1690                }
   1691                
   1692                //没有报错，就会走到这里，黑点查找成功，会有1，2，3个黑点
   1693                //return 1;
   1694              }
   1695              else
   1696              {
   1697                //没通过大斜率检测。
   1698                BlackLeftBigChangeCheckRow[row] = 1;
   1699                BlackLeftBigChangeCheckAllRow = 1;
   1700                
   1701                //return 1;    
   1702                
   1703                
   1704                //该行定位黑线失败，赋无效值
   1705                BlackLeftLoc[row][0] = MaxValUint8;
   1706                return 0;    
   1707              }
   1708            }
   1709            //不是黑线预处理的调用，不需进行大斜率检测，直接返回成功。
   1710            else
   1711            {
   1712              //return 1;    
   1713            }
   1714            
   1715            //如果是黑线预处理，也不用更新这几个值
   1716            if(preflag == 0)
   \                     ??BlackGetLeftStep1Edge_28: (+1)
   \   000006CE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000006D0   0x2E00             CMP      R6,#+0
   \   000006D2   0xF040 0x8094      BNE.W    ??BlackGetLeftStep1Edge_37
   1717            {
   1718              //进入这里说明跳变沿的二批条件均满足，进入黑点记录阶段
   1719              //记录3个关键值的实际信息，作为后面的参考。
   1720              if(use == 1)
   \   000006D6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000006D8   0x2D01             CMP      R5,#+1
   \   000006DA   0xD163             BNE.N    ??BlackGetLeftStep1Edge_38
   1721              {
   1722                BlackLeftRealWB[0] = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum]; 
   \   000006DC   0x....             LDR.N    R0,??DataTable9
   \   000006DE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000006E0   0x21FA             MOVS     R1,#+250
   \   000006E2   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000006E6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000006E8   0x5C38             LDRB     R0,[R7, R0]
   \   000006EA   0x....             LDR.N    R1,??DataTable9
   \   000006EC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000006EE   0x22FA             MOVS     R2,#+250
   \   000006F0   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000006F4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000006F6   0x1879             ADDS     R1,R7,R1
   \   000006F8   0xF811 0x1C04      LDRB     R1,[R1, #-4]
   \   000006FC   0x1A40             SUBS     R0,R0,R1
   \   000006FE   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   00000702   0x7008             STRB     R0,[R1, #+0]
   1723                BlackLeftRealW[0] = ImgNew[row][col];
   \   00000704   0x....             LDR.N    R0,??DataTable9
   \   00000706   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000708   0x21FA             MOVS     R1,#+250
   \   0000070A   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000070E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000710   0x5C38             LDRB     R0,[R7, R0]
   \   00000712   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000716   0x7008             STRB     R0,[R1, #+0]
   1724                BlackLeftRealB[0] = ImgNew[row][col-1-BlackLeftEdgeNum];
   \   00000718   0x....             LDR.N    R0,??DataTable9
   \   0000071A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000071C   0x21FA             MOVS     R1,#+250
   \   0000071E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000722   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000724   0x1838             ADDS     R0,R7,R0
   \   00000726   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   0000072A   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   0000072E   0x7008             STRB     R0,[R1, #+0]
   \   00000730   0xE065             B.N      ??BlackGetLeftStep1Edge_37
   1725              }
   \                     ??BlackGetLeftStep1Edge_36: (+1)
   \   00000732   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000734   0x2C38             CMP      R4,#+56
   \   00000736   0xDB12             BLT.N    ??BlackGetLeftStep1Edge_39
   \   00000738   0x2000             MOVS     R0,#+0
   \   0000073A   0xE009             B.N      ??BlackGetLeftStep1Edge_40
   \                     ??BlackGetLeftStep1Edge_41: (+1)
   \   0000073C   0x21FF             MOVS     R1,#+255
   \   0000073E   0x....             LDR.N    R2,??DataTable8
   \   00000740   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000742   0x5481             STRB     R1,[R0, R2]
   \   00000744   0x21FF             MOVS     R1,#+255
   \   00000746   0x.... 0x....      LDR.W    R2,??DataTable13_2
   \   0000074A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000074C   0x5481             STRB     R1,[R0, R2]
   \   0000074E   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackGetLeftStep1Edge_40: (+1)
   \   00000750   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000752   0x2805             CMP      R0,#+5
   \   00000754   0xDBF2             BLT.N    ??BlackGetLeftStep1Edge_41
   \   00000756   0x2000             MOVS     R0,#+0
   \   00000758   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   0000075C   0x7008             STRB     R0,[R1, #+0]
   \                     ??BlackGetLeftStep1Edge_39: (+1)
   \   0000075E   0x20FF             MOVS     R0,#+255
   \   00000760   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000764   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000766   0x2203             MOVS     R2,#+3
   \   00000768   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000076C   0x7008             STRB     R0,[R1, #+0]
   \   0000076E   0x2000             MOVS     R0,#+0
   \   00000770   0xE046             B.N      ??BlackGetLeftStep1Edge_27
   \                     ??BlackGetLeftStep1Edge_30: (+1)
   \   00000772   0x2000             MOVS     R0,#+0
   \   00000774   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000778   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000077A   0x5460             STRB     R0,[R4, R1]
   \   0000077C   0xE7A7             B.N      ??BlackGetLeftStep1Edge_28
   \                     ??BlackGetLeftStep1Edge_29: (+1)
   \   0000077E   0x2001             MOVS     R0,#+1
   \   00000780   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000784   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000786   0x5460             STRB     R0,[R4, R1]
   \   00000788   0x2001             MOVS     R0,#+1
   \   0000078A   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   0000078E   0x7008             STRB     R0,[R1, #+0]
   \   00000790   0x20FF             MOVS     R0,#+255
   \   00000792   0x.... 0x....      LDR.W    R1,??DataTable13
   \   00000796   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000798   0x2203             MOVS     R2,#+3
   \   0000079A   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000079E   0x7008             STRB     R0,[R1, #+0]
   \   000007A0   0x2000             MOVS     R0,#+0
   \   000007A2   0xE02D             B.N      ??BlackGetLeftStep1Edge_27
   1726              else if(use == 2)
   \                     ??BlackGetLeftStep1Edge_38: (+1)
   \   000007A4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000007A6   0x2D02             CMP      R5,#+2
   \   000007A8   0xD129             BNE.N    ??BlackGetLeftStep1Edge_37
   1727              {
   1728                BlackLeftRealWB[1] = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum]; 
   \   000007AA   0x....             LDR.N    R0,??DataTable9
   \   000007AC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000007AE   0x21FA             MOVS     R1,#+250
   \   000007B0   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000007B4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000007B6   0x5C38             LDRB     R0,[R7, R0]
   \   000007B8   0x....             LDR.N    R1,??DataTable9
   \   000007BA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000007BC   0x22FA             MOVS     R2,#+250
   \   000007BE   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000007C2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000007C4   0x1879             ADDS     R1,R7,R1
   \   000007C6   0xF811 0x1C04      LDRB     R1,[R1, #-4]
   \   000007CA   0x1A40             SUBS     R0,R0,R1
   \   000007CC   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   000007D0   0x7048             STRB     R0,[R1, #+1]
   1729                BlackLeftRealW[1] = ImgNew[row][col];
   \   000007D2   0x....             LDR.N    R0,??DataTable9
   \   000007D4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000007D6   0x21FA             MOVS     R1,#+250
   \   000007D8   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000007DC   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000007DE   0x5C38             LDRB     R0,[R7, R0]
   \   000007E0   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   000007E4   0x7048             STRB     R0,[R1, #+1]
   1730                BlackLeftRealB[1] = ImgNew[row][col-1-BlackLeftEdgeNum];
   \   000007E6   0x....             LDR.N    R0,??DataTable9
   \   000007E8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000007EA   0x21FA             MOVS     R1,#+250
   \   000007EC   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000007F0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000007F2   0x1838             ADDS     R0,R7,R0
   \   000007F4   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   000007F8   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   000007FC   0x7048             STRB     R0,[R1, #+1]
   1731              }
   1732              else
   1733              {
   1734              }
   1735            }
   1736            else
   1737            {
   1738            }
   1739            
   1740            return 1;
   \                     ??BlackGetLeftStep1Edge_37: (+1)
   \   000007FE   0x2001             MOVS     R0,#+1
   \                     ??BlackGetLeftStep1Edge_27: (+1)
   \   00000800   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1741            
   1742          }
   1743          
   1744          
   1745          
   1746          //======================================================================
   1747          //函数名：BlackGetLeftStep2Win
   1748          //功  能：左黑线提取中，第2阶段窗口内跳变检测函数
   1749          //参  数：待处理行号row, 窗口大小win, 预测的跳变点的位置predict, 第几次使用use
   1750          //返  回：1成功  0失败
   1751          //影  响：BlackLeftLoc[][0]
   1752          //说  明：1. 满足两批条件，才能检测成功。只有一个点的记录。
   1753          //        2. 窗口内没有检测到，则检测失败。
   1754          //        3. 窗缩小可以减少一定的时间，但如果遇到斜率过大的情况，就有可能检测不到。     
   1755          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1756          uint8 BlackGetLeftStep2Win(uint8 row, uint8 win, uint8 predict, uint8 use)
   1757          {
   \                     BlackGetLeftStep2Win: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x001D             MOVS     R5,R3
   1758            uint8 col, temp;
   1759            
   1760            //在规划好的窗口内，从右往左查找跳变沿
   1761            //防止溢出
   1762            
   1763            //对左边界的限制
   1764            if(predict <= win)
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0x4291             CMP      R1,R2
   \   0000000C   0xD301             BCC.N    ??BlackGetLeftStep2Win_0
   1765            {
   1766              temp = 4 + BlackLeftEdgeNum;
   \   0000000E   0x2607             MOVS     R6,#+7
   \   00000010   0xE004             B.N      ??BlackGetLeftStep2Win_1
   1767            }  
   1768            else
   1769            {
   1770              temp = predict - win;
   \                     ??BlackGetLeftStep2Win_0: (+1)
   \   00000012   0x1A56             SUBS     R6,R2,R1
   1771              if(temp < 4 + BlackLeftEdgeNum)
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0x2E07             CMP      R6,#+7
   \   00000018   0xDA00             BGE.N    ??BlackGetLeftStep2Win_1
   1772              {
   1773                temp = 4 + BlackLeftEdgeNum;
   \   0000001A   0x2607             MOVS     R6,#+7
   1774              }
   1775              else 
   1776              {
   1777              } 
   1778            }
   1779            
   1780            //对右边界的限制
   1781            if(predict + win > CameraRealWidth - 1)
   \                     ??BlackGetLeftStep2Win_1: (+1)
   \   0000001C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001E   0xFA51 0xF082      UXTAB    R0,R1,R2
   \   00000022   0x28FA             CMP      R0,#+250
   \   00000024   0xDB01             BLT.N    ??BlackGetLeftStep2Win_2
   1782            {
   1783              col = CameraRealWidth - 1;  
   \   00000026   0x27F9             MOVS     R7,#+249
   \   00000028   0xE000             B.N      ??BlackGetLeftStep2Win_3
   1784            }
   1785            else
   1786            {
   1787              col = predict + win;  
   \                     ??BlackGetLeftStep2Win_2: (+1)
   \   0000002A   0x188F             ADDS     R7,R1,R2
   1788            }
   1789            
   1790            //右线开始扫描时，左线的扫描右边界必须在该行有效右黑线的左边。
   1791            if((BlackGetPreDir == 1)
   1792            &&(SingleBlackAllFlag == 0)   
   1793            &&(BlackRightLoc[row][0] != MaxValUint8)
   1794              )
   \                     ??BlackGetLeftStep2Win_3: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable10_1
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD119             BNE.N    ??BlackGetLeftStep2Win_4
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD114             BNE.N    ??BlackGetLeftStep2Win_4
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000044   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000046   0x2103             MOVS     R1,#+3
   \   00000048   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x28FF             CMP      R0,#+255
   \   00000050   0xD00B             BEQ.N    ??BlackGetLeftStep2Win_4
   1795            {
   1796              col = MinRe(col, BlackRightLoc[row][0]);
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable10_2
   \   00000056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   0x2103             MOVS     R1,#+3
   \   0000005A   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000005E   0x7801             LDRB     R1,[R0, #+0]
   \   00000060   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000062   0x0038             MOVS     R0,R7
   \   00000064   0x.... 0x....      BL       MinRe
   \   00000068   0x0007             MOVS     R7,R0
   1797            }
   1798            else
   1799            {
   1800            }
   1801            
   1802            //窗口预测值记录
   1803            BlackLeftPredictL[row] = temp;
   \                     ??BlackGetLeftStep2Win_4: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable11
   \   0000006E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000070   0x5426             STRB     R6,[R4, R0]
   1804            BlackLeftPredictR[row] = col;
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   00000076   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000078   0x5427             STRB     R7,[R4, R0]
   1805            
   1806            //右边界小于左边界，返回失败
   1807            if(col <= temp) return 0;
   \   0000007A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000007E   0x42BE             CMP      R6,R7
   \   00000080   0xD301             BCC.N    ??BlackGetLeftStep2Win_5
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xE095             B.N      ??BlackGetLeftStep2Win_6
   1808            
   1809            //开窗扫描跳变沿
   1810            col = BlackGetLeftJustWin(row, temp, col);
   \                     ??BlackGetLeftStep2Win_5: (+1)
   \   00000086   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000088   0x003A             MOVS     R2,R7
   \   0000008A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008C   0x0031             MOVS     R1,R6
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000092   0x.... 0x....      BL       BlackGetLeftJustWin
   \   00000096   0x0007             MOVS     R7,R0
   1811            if(col != MaxValUint8)
   \   00000098   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000009A   0x2FFF             CMP      R7,#+255
   \   0000009C   0xF000 0x8080      BEQ.W    ??BlackGetLeftStep2Win_7
   1812            {
   1813              //两批条件均满足，直接记录该点为黑线，返回即可
   1814              BlackLeftLoc[row][0] = col - 1 - BlackLeftEdgeNum;
   \   000000A0   0x1F38             SUBS     R0,R7,#+4
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable13
   \   000000A6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A8   0x2203             MOVS     R2,#+3
   \   000000AA   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000AE   0x7008             STRB     R0,[R1, #+0]
   1815          
   1816              //最后确认前，需要进行大斜率的检测。若不成功，则说明检测到坏点。
   1817              if(BlackLeftBigChangeCheck(row, use) == 0)
   \   000000B0   0x0029             MOVS     R1,R5
   \   000000B2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B8   0x.... 0x....      BL       BlackLeftBigChangeCheck
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD112             BNE.N    ??BlackGetLeftStep2Win_8
   1818              {              
   1819                //没通过大斜率检测。
   1820                BlackLeftBigChangeCheckRow[row] = 1;
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   000000C6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C8   0x5460             STRB     R0,[R4, R1]
   1821                BlackLeftBigChangeCheckAllRow = 1;
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable14_5
   \   000000D0   0x7008             STRB     R0,[R1, #+0]
   1822             
   1823                
   1824                //该行定位黑线失败，赋无效值
   1825                BlackLeftLoc[row][0] = MaxValUint8;
   \   000000D2   0x20FF             MOVS     R0,#+255
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable13
   \   000000D8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DA   0x2203             MOVS     R2,#+3
   \   000000DC   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000E0   0x7008             STRB     R0,[R1, #+0]
   1826                return 0;
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0xE065             B.N      ??BlackGetLeftStep2Win_6
   1827              }
   1828              else
   1829              {
   1830              }
   1831              
   1832              //通过了大斜率检测。
   1833              //记录3个关键值的实际信息，作为后面的参考。
   1834              if(use == 1)
   \                     ??BlackGetLeftStep2Win_8: (+1)
   \   000000E6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E8   0x2D01             CMP      R5,#+1
   \   000000EA   0xD12A             BNE.N    ??BlackGetLeftStep2Win_9
   1835              {
   1836                BlackLeftRealWB[0] = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum]; 
   \   000000EC   0x....             LDR.N    R0,??DataTable9
   \   000000EE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F0   0x21FA             MOVS     R1,#+250
   \   000000F2   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000F6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F8   0x5C38             LDRB     R0,[R7, R0]
   \   000000FA   0x....             LDR.N    R1,??DataTable9
   \   000000FC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FE   0x22FA             MOVS     R2,#+250
   \   00000100   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000104   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000106   0x1879             ADDS     R1,R7,R1
   \   00000108   0xF811 0x1C04      LDRB     R1,[R1, #-4]
   \   0000010C   0x1A40             SUBS     R0,R0,R1
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   00000112   0x7008             STRB     R0,[R1, #+0]
   1837                BlackLeftRealW[0] = ImgNew[row][col];
   \   00000114   0x....             LDR.N    R0,??DataTable9
   \   00000116   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000118   0x21FA             MOVS     R1,#+250
   \   0000011A   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000011E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000120   0x5C38             LDRB     R0,[R7, R0]
   \   00000122   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000126   0x7008             STRB     R0,[R1, #+0]
   1838                BlackLeftRealB[0] = ImgNew[row][col-1-BlackLeftEdgeNum];
   \   00000128   0x....             LDR.N    R0,??DataTable9
   \   0000012A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000012C   0x21FA             MOVS     R1,#+250
   \   0000012E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000132   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000134   0x1838             ADDS     R0,R7,R0
   \   00000136   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   0000013A   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   0000013E   0x7008             STRB     R0,[R1, #+0]
   \   00000140   0xE02C             B.N      ??BlackGetLeftStep2Win_10
   1839              }
   1840              else if(use == 2)
   \                     ??BlackGetLeftStep2Win_9: (+1)
   \   00000142   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000144   0x2D02             CMP      R5,#+2
   \   00000146   0xD129             BNE.N    ??BlackGetLeftStep2Win_10
   1841              {
   1842                BlackLeftRealWB[1] = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum]; 
   \   00000148   0x....             LDR.N    R0,??DataTable9
   \   0000014A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000014C   0x21FA             MOVS     R1,#+250
   \   0000014E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000152   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000154   0x5C38             LDRB     R0,[R7, R0]
   \   00000156   0x....             LDR.N    R1,??DataTable9
   \   00000158   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000015A   0x22FA             MOVS     R2,#+250
   \   0000015C   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000160   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000162   0x1879             ADDS     R1,R7,R1
   \   00000164   0xF811 0x1C04      LDRB     R1,[R1, #-4]
   \   00000168   0x1A40             SUBS     R0,R0,R1
   \   0000016A   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   0000016E   0x7048             STRB     R0,[R1, #+1]
   1843                BlackLeftRealW[1] = ImgNew[row][col];
   \   00000170   0x....             LDR.N    R0,??DataTable9
   \   00000172   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000174   0x21FA             MOVS     R1,#+250
   \   00000176   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000017A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000017C   0x5C38             LDRB     R0,[R7, R0]
   \   0000017E   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000182   0x7048             STRB     R0,[R1, #+1]
   1844                BlackLeftRealB[1] = ImgNew[row][col-1-BlackLeftEdgeNum];
   \   00000184   0x....             LDR.N    R0,??DataTable9
   \   00000186   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000188   0x21FA             MOVS     R1,#+250
   \   0000018A   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000018E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000190   0x1838             ADDS     R0,R7,R0
   \   00000192   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   00000196   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   0000019A   0x7048             STRB     R0,[R1, #+1]
   1845              }
   1846              else
   1847              {
   1848              }     
   1849              
   1850              return 1;                  
   \                     ??BlackGetLeftStep2Win_10: (+1)
   \   0000019C   0x2001             MOVS     R0,#+1
   \   0000019E   0xE008             B.N      ??BlackGetLeftStep2Win_6
   1851            }
   1852            else
   1853            {
   1854              //窗口内没有扫描到跳变沿，该行的黑线位置记为无效值，返回0失败.
   1855              BlackLeftLoc[row][0] = MaxValUint8;
   \                     ??BlackGetLeftStep2Win_7: (+1)
   \   000001A0   0x20FF             MOVS     R0,#+255
   \   000001A2   0x.... 0x....      LDR.W    R1,??DataTable13
   \   000001A6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001A8   0x2203             MOVS     R2,#+3
   \   000001AA   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000001AE   0x7008             STRB     R0,[R1, #+0]
   1856              return 0;   
   \   000001B0   0x2000             MOVS     R0,#+0
   \                     ??BlackGetLeftStep2Win_6: (+1)
   \   000001B2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1857            }
   1858            
   1859          }
   1860          
   1861          
   1862          //======================================================================
   1863          //函数名：BlackGetLeftStep1Scan
   1864          //功  能：左黑线提取中，第1阶段的行扫描函数
   1865          //参  数：扫描起始行FirstLine, 扫描结束行LastLine
   1866          //返  回：0~CameraHight-1行数 255采集失败
   1867          //影  响：BlackLeftRealWB[], BlackLeftRealW[], BlackLeftRealB[], BlackLeftLoc[][],
   1868          //        LimitLeftWB, LimitLeftW, LimitLeftB
   1869          //说  明：1. 可用于正常地第1阶段行扫描，也可用于十字再检测时的行扫描
   1870          //        2. 正常第1阶段扫描时，会更改3个关键阈值的值。
   1871          //             
   1872          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1873          uint8 BlackGetLeftStep1Scan(uint8 FirstLine, uint8 LastLine, uint8 CrossFlag)
   1874          {
   \                     BlackGetLeftStep1Scan: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1875              uint8 row, temp1, temp2;
   1876              uint8 abs1;
   1877              uint8 tempWB, tempW, tempB;
   1878              uint8 flag, i;
   1879              
   1880              flag = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   1881              //最近的BlackStep1Size行用差值法找黑线
   1882              for(row = FirstLine; row > LastLine; row -= 2)
   \   0000000C   0x46A0             MOV      R8,R4
   \   0000000E   0xE00A             B.N      ??BlackGetLeftStep1Scan_0
   1883              {
   1884                //判断是否连续两行检测到跳变，可疑黑点有3个点，暂取其中一个。非黑线预处理。
   1885                temp1 = BlackGetLeftStep1Edge(row, 1, 0);
   1886                temp2 = BlackGetLeftStep1Edge(row-1, 2, 0);
   1887                if(temp1 == 1 && temp2 == 1)//这里可以这么写，不用嵌套if，因为&&的特点
   1888                {
   1889                  abs1 = AbsRe(BlackLeftLoc[row-1][0], BlackLeftLoc[row][0]);
   1890                  //进一步判断连续两行的黑点的间隔是否够小，且暂取第1个可疑黑点。
   1891                  if(abs1 < BlackLeftStep1ScanMinus)
   1892                  {
   1893                    //检测到了连续的黑线，停止差值法找跳变沿，节省时间，下面进入第2阶段
   1894                    //如果不是十字再检测的情况，就更新一下实际的3个关键值，否则不更新。
   1895                    if(CrossFlag == 1)
   1896                      {
   1897                        //差值的处理，留有裕度，且有上下界。
   1898                        tempWB = (BlackLeftRealWB[0] + BlackLeftRealWB[1]) / 2 - LimitLeftWBMargin; 
   1899                        if(tempWB < LimitLeftWBMin) tempWB = LimitLeftWBMin;
   1900                        else if(tempWB > LimitLeftWBMax) tempWB = LimitLeftWBMax;
   1901                        else ;
   1902                        LimitLeftWB = tempWB;
   1903                        
   1904                        //白点的处理，留有裕度，且有上下界。
   1905                        tempW = (BlackLeftRealW[0] + BlackLeftRealW[1]) / 2 - LimitLeftWMargin;
   1906                        if(tempW < LimitLeftWMin) tempW = LimitLeftWMin;
   1907                        else if(tempW > LimitLeftWMax) tempW = LimitLeftWMax;
   1908                        else ;
   1909                        LimitLeftW = tempW;
   1910                        
   1911                        //黑点的处理，留有裕度，且有上下界。
   1912                        tempB = (BlackLeftRealB[0] + BlackLeftRealB[1]) / 2 + LimitLeftBMargin;
   1913                        if(tempB < LimitLeftBMin) tempB = LimitLeftBMin;
   1914                        else if(tempB > LimitLeftBMax) tempB = LimitLeftBMax;
   1915                        else ;
   1916                        //黑色阈值不能超过白色
   1917                        if(tempB >= LimitLeftW)
   1918                        {
   1919                          tempB = LimitLeftW - 1;
   1920                        }
   1921                        else
   1922                        {
   1923                        }
   1924                        
   1925                        LimitLeftB = tempB;
   1926                      }
   1927                    break;
   1928                  }
   1929                  else
   1930                  {
   1931                    //连续两行黑点差别太大，视为错误的点。
   1932                    BlackLeftLoc[row][0] = MaxValUint8;
   1933                    BlackLeftLoc[row-1][0] = MaxValUint8;
   1934                    //大跳变检测数组的复位。
   1935                    BlackLeftBigChangeNumx[3] = MaxValUint8;
   1936                    BlackLeftBigChangeNumx[4] = MaxValUint8;
   1937                    BlackLeftBigChangeNumy[3] = MaxValUint8;
   1938                    BlackLeftBigChangeNumy[4] = MaxValUint8;
   1939                    BlackLeftBigChangeJumpFlag = 0;
   1940                  }
   1941                }
   1942                else if(temp1 == 0 && temp2 == 1)
   1943                {
   1944                  //走到这里，说明双黑线检测成功之前有双线之一采集成功。
   1945                  flag = 1;
   1946                }
   1947                else if(temp1 == 1 && temp2 == 0)
   \                     ??BlackGetLeftStep1Scan_1: (+1)
   \   00000010   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000014   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000018   0xD103             BNE.N    ??BlackGetLeftStep1Scan_2
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD100             BNE.N    ??BlackGetLeftStep1Scan_2
   1948                {
   1949                  //走到这里，说明双黑线检测成功之前有双线之一采集成功。
   1950                  flag = 1;
   \   00000020   0x2701             MOVS     R7,#+1
   1951                }
   \                     ??BlackGetLeftStep1Scan_2: (+1)
   \   00000022   0xF1B8 0x0802      SUBS     R8,R8,#+2
   \                     ??BlackGetLeftStep1Scan_0: (+1)
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000002C   0x4545             CMP      R5,R8
   \   0000002E   0xF080 0x809A      BCS.W    ??BlackGetLeftStep1Scan_3
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x.... 0x....      BL       BlackGetLeftStep1Edge
   \   0000003E   0x4681             MOV      R9,R0
   \   00000040   0x2200             MOVS     R2,#+0
   \   00000042   0x2102             MOVS     R1,#+2
   \   00000044   0xF1B8 0x0001      SUBS     R0,R8,#+1
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x.... 0x....      BL       BlackGetLeftStep1Edge
   \   0000004E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000052   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000056   0xF040 0x80B5      BNE.W    ??BlackGetLeftStep1Scan_4
   \   0000005A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xF040 0x80B1      BNE.W    ??BlackGetLeftStep1Scan_4
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000066   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000006A   0x2103             MOVS     R1,#+3
   \   0000006C   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00000070   0x7801             LDRB     R1,[R0, #+0]
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000076   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000007A   0x2203             MOVS     R2,#+3
   \   0000007C   0xFB02 0x0008      MLA      R0,R2,R8,R0
   \   00000080   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000084   0x.... 0x....      BL       AbsRe
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0x2808             CMP      R0,#+8
   \   0000008C   0xDA72             BGE.N    ??BlackGetLeftStep1Scan_5
   \   0000008E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000090   0x2E01             CMP      R6,#+1
   \   00000092   0xD168             BNE.N    ??BlackGetLeftStep1Scan_6
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   0000009E   0x7849             LDRB     R1,[R1, #+1]
   \   000000A0   0x1808             ADDS     R0,R1,R0
   \   000000A2   0x2102             MOVS     R1,#+2
   \   000000A4   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000A8   0x3814             SUBS     R0,R0,#+20
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable15
   \   000000AE   0x7809             LDRB     R1,[R1, #+0]
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0x4288             CMP      R0,R1
   \   000000B4   0xD203             BCS.N    ??BlackGetLeftStep1Scan_7
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0xE008             B.N      ??BlackGetLeftStep1Scan_8
   \                     ??BlackGetLeftStep1Scan_7: (+1)
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable15_1
   \   000000C2   0x7809             LDRB     R1,[R1, #+0]
   \   000000C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C6   0x4281             CMP      R1,R0
   \   000000C8   0xD202             BCS.N    ??BlackGetLeftStep1Scan_8
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   000000CE   0x7800             LDRB     R0,[R0, #+0]
   \                     ??BlackGetLeftStep1Scan_8: (+1)
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \   000000D4   0x7008             STRB     R0,[R1, #+0]
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   000000DA   0x7800             LDRB     R0,[R0, #+0]
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   000000E0   0x7849             LDRB     R1,[R1, #+1]
   \   000000E2   0x1808             ADDS     R0,R1,R0
   \   000000E4   0x2102             MOVS     R1,#+2
   \   000000E6   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000EA   0x3828             SUBS     R0,R0,#+40
   \   000000EC   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   000000F0   0x7809             LDRB     R1,[R1, #+0]
   \   000000F2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F4   0x4288             CMP      R0,R1
   \   000000F6   0xD203             BCS.N    ??BlackGetLeftStep1Scan_9
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   000000FC   0x7800             LDRB     R0,[R0, #+0]
   \   000000FE   0xE008             B.N      ??BlackGetLeftStep1Scan_10
   \                     ??BlackGetLeftStep1Scan_9: (+1)
   \   00000100   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000104   0x7809             LDRB     R1,[R1, #+0]
   \   00000106   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000108   0x4281             CMP      R1,R0
   \   0000010A   0xD202             BCS.N    ??BlackGetLeftStep1Scan_10
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \   00000110   0x7800             LDRB     R0,[R0, #+0]
   \                     ??BlackGetLeftStep1Scan_10: (+1)
   \   00000112   0x....             LDR.N    R1,??DataTable11_2
   \   00000114   0x7008             STRB     R0,[R1, #+0]
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   0000011A   0x7800             LDRB     R0,[R0, #+0]
   \   0000011C   0x.... 0x....      LDR.W    R1,??DataTable14_3
   \   00000120   0x7849             LDRB     R1,[R1, #+1]
   \   00000122   0x1808             ADDS     R0,R1,R0
   \   00000124   0x2102             MOVS     R1,#+2
   \   00000126   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000012A   0x3023             ADDS     R0,R0,#+35
   \   0000012C   0x.... 0x....      LDR.W    R1,??DataTable15_5
   \   00000130   0x7809             LDRB     R1,[R1, #+0]
   \   00000132   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000134   0x4288             CMP      R0,R1
   \   00000136   0xD203             BCS.N    ??BlackGetLeftStep1Scan_11
   \   00000138   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \   0000013C   0x7800             LDRB     R0,[R0, #+0]
   \   0000013E   0xE008             B.N      ??BlackGetLeftStep1Scan_12
   \                     ??BlackGetLeftStep1Scan_11: (+1)
   \   00000140   0x.... 0x....      LDR.W    R1,??DataTable15_6
   \   00000144   0x7809             LDRB     R1,[R1, #+0]
   \   00000146   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000148   0x4281             CMP      R1,R0
   \   0000014A   0xD202             BCS.N    ??BlackGetLeftStep1Scan_12
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable15_6
   \   00000150   0x7800             LDRB     R0,[R0, #+0]
   \                     ??BlackGetLeftStep1Scan_12: (+1)
   \   00000152   0x....             LDR.N    R1,??DataTable11_2
   \   00000154   0x7809             LDRB     R1,[R1, #+0]
   \   00000156   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000158   0x4288             CMP      R0,R1
   \   0000015A   0xD302             BCC.N    ??BlackGetLeftStep1Scan_13
   \   0000015C   0x....             LDR.N    R0,??DataTable11_2
   \   0000015E   0x7800             LDRB     R0,[R0, #+0]
   \   00000160   0x1E40             SUBS     R0,R0,#+1
   \                     ??BlackGetLeftStep1Scan_13: (+1)
   \   00000162   0x....             LDR.N    R1,??DataTable11_3
   \   00000164   0x7008             STRB     R0,[R1, #+0]
   1952                else
   1953                {
   1954                }
   1955              }   
   1956              
   1957              //检测了BlackStep1Size行也没有检测到连续的黑线，说明黑线检测失败
   1958              if(row <= LastLine)
   \                     ??BlackGetLeftStep1Scan_6: (+1)
   \                     ??BlackGetLeftStep1Scan_3: (+1)
   \   00000166   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000168   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000016C   0x4545             CMP      R5,R8
   \   0000016E   0xD335             BCC.N    ??BlackGetLeftStep1Scan_14
   1959              {
   1960                return MaxValUint8;
   \   00000170   0x20FF             MOVS     R0,#+255
   \   00000172   0xE05E             B.N      ??BlackGetLeftStep1Scan_15
   1961              }               
   \                     ??BlackGetLeftStep1Scan_5: (+1)
   \   00000174   0x20FF             MOVS     R0,#+255
   \   00000176   0x.... 0x....      LDR.W    R1,??DataTable13
   \   0000017A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000017E   0x2203             MOVS     R2,#+3
   \   00000180   0xFB02 0x1108      MLA      R1,R2,R8,R1
   \   00000184   0x7008             STRB     R0,[R1, #+0]
   \   00000186   0x20FF             MOVS     R0,#+255
   \   00000188   0x.... 0x....      LDR.W    R1,??DataTable13
   \   0000018C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000190   0x2203             MOVS     R2,#+3
   \   00000192   0xFB02 0x1108      MLA      R1,R2,R8,R1
   \   00000196   0xF801 0x0C03      STRB     R0,[R1, #-3]
   \   0000019A   0x20FF             MOVS     R0,#+255
   \   0000019C   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   000001A0   0x70C8             STRB     R0,[R1, #+3]
   \   000001A2   0x20FF             MOVS     R0,#+255
   \   000001A4   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   000001A8   0x7108             STRB     R0,[R1, #+4]
   \   000001AA   0x20FF             MOVS     R0,#+255
   \   000001AC   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000001B0   0x70C8             STRB     R0,[R1, #+3]
   \   000001B2   0x20FF             MOVS     R0,#+255
   \   000001B4   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   000001B8   0x7108             STRB     R0,[R1, #+4]
   \   000001BA   0x2000             MOVS     R0,#+0
   \   000001BC   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   000001C0   0x7008             STRB     R0,[R1, #+0]
   \   000001C2   0xE72E             B.N      ??BlackGetLeftStep1Scan_2
   \                     ??BlackGetLeftStep1Scan_4: (+1)
   \   000001C4   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001C8   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001CC   0xF47F 0xAF20      BNE.W    ??BlackGetLeftStep1Scan_1
   \   000001D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001D2   0x2801             CMP      R0,#+1
   \   000001D4   0xF47F 0xAF1C      BNE.W    ??BlackGetLeftStep1Scan_1
   \   000001D8   0x2701             MOVS     R7,#+1
   \   000001DA   0xE722             B.N      ??BlackGetLeftStep1Scan_2
   1962              else
   1963              {
   1964                  //双黑线检测成功 且 双黑线检测成功之前有双线之一采集成功。
   1965                  if(flag == 1)
   \                     ??BlackGetLeftStep1Scan_14: (+1)
   \   000001DC   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001DE   0x2F01             CMP      R7,#+1
   \   000001E0   0xD125             BNE.N    ??BlackGetLeftStep1Scan_16
   1966                  {
   1967                      //把前面的双线之一都去掉。
   1968                      for(i = FirstLine; ; i--)
   \   000001E2   0xE008             B.N      ??BlackGetLeftStep1Scan_17
   1969                      {
   1970                          if(i == row) break;
   1971                          BlackLeftLoc[i][0] = MaxValUint8;                
   \                     ??BlackGetLeftStep1Scan_18: (+1)
   \   000001E4   0x20FF             MOVS     R0,#+255
   \   000001E6   0x.... 0x....      LDR.W    R1,??DataTable13
   \   000001EA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001EC   0x2203             MOVS     R2,#+3
   \   000001EE   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000001F2   0x7008             STRB     R0,[R1, #+0]
   \   000001F4   0x1E64             SUBS     R4,R4,#+1
   \                     ??BlackGetLeftStep1Scan_17: (+1)
   \   000001F6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001F8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001FC   0x4544             CMP      R4,R8
   \   000001FE   0xD1F1             BNE.N    ??BlackGetLeftStep1Scan_18
   1972                      }
   1973                      
   1974                      //第一次scan
   1975                      if(CrossFlag == 1)
   \   00000200   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000202   0x2E01             CMP      R6,#+1
   \   00000204   0xD113             BNE.N    ??BlackGetLeftStep1Scan_16
   1976                      {
   1977                        //把前3个大斜率检测储存值都去掉，后面2个不用，因为是对的。
   1978                        for(i = 0; i <= 2; i++)
   \   00000206   0x2400             MOVS     R4,#+0
   \   00000208   0xE00E             B.N      ??BlackGetLeftStep1Scan_19
   1979                        {
   1980                            BlackLeftBigChangeNumx[i] = MaxValUint8;
   \                     ??BlackGetLeftStep1Scan_20: (+1)
   \   0000020A   0x20FF             MOVS     R0,#+255
   \   0000020C   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   00000210   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000212   0x5460             STRB     R0,[R4, R1]
   1981                            BlackLeftBigChangeNumy[i] = MaxValUint8;
   \   00000214   0x20FF             MOVS     R0,#+255
   \   00000216   0x.... 0x....      LDR.W    R1,??DataTable13_2
   \   0000021A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000021C   0x5460             STRB     R0,[R4, R1]
   1982                            BlackLeftBigChangeJumpFlag = 0;   //小细节
   \   0000021E   0x2000             MOVS     R0,#+0
   \   00000220   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \   00000224   0x7008             STRB     R0,[R1, #+0]
   1983                        }
   \   00000226   0x1C64             ADDS     R4,R4,#+1
   \                     ??BlackGetLeftStep1Scan_19: (+1)
   \   00000228   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000022A   0x2C03             CMP      R4,#+3
   \   0000022C   0xDBED             BLT.N    ??BlackGetLeftStep1Scan_20
   1984                      }
   1985                      else
   1986                      {
   1987                      }
   1988                  }
   1989                  else
   1990                  {
   1991          
   1992                  }
   1993                  
   1994                  return row;
   \                     ??BlackGetLeftStep1Scan_16: (+1)
   \   0000022E   0x4640             MOV      R0,R8
   \   00000230   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??BlackGetLeftStep1Scan_15: (+1)
   \   00000232   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1995              }
   1996            
   1997          }
   1998          
   1999          //======================================================================
   2000          //函数名：BlackLeftCrossStep3
   2001          //功  能：左线提取中，十字检测第3阶段，脑补线函数
   2002          //参  数：第1段有效黑线的最后一行FirstLine， 第2段有效黑线的第一行LastLine
   2003          //返  回：1成功 0失败
   2004          //影  响：BlackLeftLoc[][0]
   2005          //说  明：1. 这里有一些浮点运算，会占时间，在调用本函数时要慎重，尽量不要用。
   2006          //        2. 这里的两点间连线的思路很不错，float强转和uint8强转用得很好。
   2007          //             
   2008          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   2009          uint8 BlackLeftCrossStep3(uint8 FirstLine, uint8 LastLine)
   2010          {
   \                     BlackLeftCrossStep3: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   2011            int32 delta_x, delta_y, delta, index;
   2012            uint8 row, temp1, temp2;
   2013            uint8 i;
   2014            //uint8 temp3, temp4, flag1, flag2;
   2015            
   2016            //超始行比结束行还高，报错！
   2017            if(LastLine >= FirstLine)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xD301             BCC.N    ??BlackLeftCrossStep3_0
   2018            {
   2019              //uart_sendN(UART0, (uint8 *)"\nError In BlackLeftCrossStep3!", 30);
   2020              return 0;  
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE08C             B.N      ??BlackLeftCrossStep3_1
   2021            }
   2022            
   2023            //有可能出现被大斜率检测删掉的情况，这种情况下该行黑线判断为错误，就不进行十字补线了。
   2024            if(BlackLeftLoc[LastLine][0] == MaxValUint8)
   \                     ??BlackLeftCrossStep3_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R2,??DataTable13
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x2303             MOVS     R3,#+3
   \   00000016   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   0000001A   0x7812             LDRB     R2,[R2, #+0]
   \   0000001C   0x2AFF             CMP      R2,#+255
   \   0000001E   0xD10F             BNE.N    ??BlackLeftCrossStep3_2
   2025            {
   2026              //返回失败前扫屁股
   2027              for(i = FirstLine - 1; ; i--)
   \   00000020   0x1E40             SUBS     R0,R0,#+1
   \   00000022   0xE000             B.N      ??BlackLeftCrossStep3_3
   \                     ??BlackLeftCrossStep3_4: (+1)
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   2028              {
   2029                BlackLeftLoc[i][0] = MaxValUint8;
   \                     ??BlackLeftCrossStep3_3: (+1)
   \   00000026   0x21FF             MOVS     R1,#+255
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable13
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x2303             MOVS     R3,#+3
   \   00000030   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000034   0x7011             STRB     R1,[R2, #+0]
   2030                if(i == 0) break;
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD1F3             BNE.N    ??BlackLeftCrossStep3_4
   2031              }
   2032              
   2033              return 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE073             B.N      ??BlackLeftCrossStep3_1
   2034            }
   2035            else
   2036            {
   2037            }
   2038            
   2039            temp1 = BlackLeftLoc[FirstLine][0];
   \                     ??BlackLeftCrossStep3_2: (+1)
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable13
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x2303             MOVS     R3,#+3
   \   00000048   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000004C   0x7814             LDRB     R4,[R2, #+0]
   2040            temp2 = BlackLeftLoc[LastLine][0];
   \   0000004E   0x.... 0x....      LDR.W    R2,??DataTable13
   \   00000052   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000054   0x2303             MOVS     R3,#+3
   \   00000056   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   0000005A   0x7812             LDRB     R2,[R2, #+0]
   2041            
   2042            /*
   2043            flag = 1;
   2044            flag = 2;
   2045            //确认这两个点是直角处的点，也就是往左6个点仍为黑点
   2046            if(temp1 <= (CameraRealWidth - 9))
   2047            {
   2048              temp3 = (
   2049                      (ImgNew[FirstLine+1][temp1+6] < LimitLeftB)
   2050                    &&(ImgNew[FirstLine+1][temp1+7] < LimitLeftB)
   2051                    &&(ImgNew[FirstLine+1][temp1+8] < LimitLeftB)
   2052                    );
   2053              if(temp3)
   2054              {
   2055                flag1 = 0;  
   2056              }
   2057            }
   2058            
   2059            if(temp2 <= (CameraRealWidth - 9))
   2060            {
   2061              temp4 = (
   2062                      (ImgNew[LastLine-1][temp2+6] < LimitLeftB)
   2063                    &&(ImgNew[LastLine-1][temp2+7] < LimitLeftB)
   2064                    &&(ImgNew[LastLine-1][temp2+8] < LimitLeftB)
   2065                    );
   2066              if(temp4)
   2067              {
   2068                flag2 = 0;  
   2069              }
   2070            }
   2071            
   2072            if((flag1 == 0) || (flag2 == 0))
   2073            {
   2074              return 0;  
   2075            }
   2076            
   2077            */
   2078            
   2079            delta_y = FirstLine - LastLine;
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000060   0x1A43             SUBS     R3,R0,R1
   2080            
   2081            
   2082            //斜率向右
   2083            if(temp1 < temp2)
   \   00000062   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000064   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000066   0x4294             CMP      R4,R2
   \   00000068   0xD226             BCS.N    ??BlackLeftCrossStep3_5
   2084            {
   2085              //放大BlackLeftCrossStep3Multi倍。
   2086              delta_x = temp2 - temp1;  
   \   0000006A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0x1B12             SUBS     R2,R2,R4
   2087              delta = delta_x * BlackLeftCrossStep3Multi / delta_y; 
   \   00000070   0xF44F 0x747A      MOV      R4,#+1000
   \   00000074   0x4362             MULS     R2,R4,R2
   \   00000076   0xFB92 0xF3F3      SDIV     R3,R2,R3
   2088              
   2089              index = 1;
   \   0000007A   0x2401             MOVS     R4,#+1
   2090              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \   0000007C   0x1E42             SUBS     R2,R0,#+1
   \                     ??BlackLeftCrossStep3_6: (+1)
   \   0000007E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000080   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000082   0x1C4D             ADDS     R5,R1,#+1
   \   00000084   0x42AA             CMP      R2,R5
   \   00000086   0xDB4E             BLT.N    ??BlackLeftCrossStep3_7
   2091              {
   2092                //每次右移一点点
   2093                BlackLeftLoc[row][0] = (uint8)(BlackLeftLoc[FirstLine][0] + delta * index / BlackLeftCrossStep3Multi);
   \   00000088   0x.... 0x....      LDR.W    R5,??DataTable13
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0x2603             MOVS     R6,#+3
   \   00000090   0xFB06 0x5500      MLA      R5,R6,R0,R5
   \   00000094   0x782D             LDRB     R5,[R5, #+0]
   \   00000096   0xFB04 0xF603      MUL      R6,R4,R3
   \   0000009A   0xF44F 0x777A      MOV      R7,#+1000
   \   0000009E   0xFB96 0xF6F7      SDIV     R6,R6,R7
   \   000000A2   0x1975             ADDS     R5,R6,R5
   \   000000A4   0x.... 0x....      LDR.W    R6,??DataTable13
   \   000000A8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000AA   0x2703             MOVS     R7,#+3
   \   000000AC   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   000000B0   0x7035             STRB     R5,[R6, #+0]
   2094                index += 1;
   \   000000B2   0x1C64             ADDS     R4,R4,#+1
   2095              }
   \   000000B4   0x1E52             SUBS     R2,R2,#+1
   \   000000B6   0xE7E2             B.N      ??BlackLeftCrossStep3_6
   2096            }
   2097            //斜率向左
   2098            else if(temp1 > temp2)
   \                     ??BlackLeftCrossStep3_5: (+1)
   \   000000B8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000BA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BC   0x42A2             CMP      R2,R4
   \   000000BE   0xD224             BCS.N    ??BlackLeftCrossStep3_8
   2099            {
   2100              //放大BlackLeftCrossStep3Multi倍。
   2101              delta_x = temp1 - temp2;
   \   000000C0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000C4   0x1AA2             SUBS     R2,R4,R2
   2102              delta = delta_x * BlackLeftCrossStep3Multi / delta_y;
   \   000000C6   0xF44F 0x747A      MOV      R4,#+1000
   \   000000CA   0x4362             MULS     R2,R4,R2
   \   000000CC   0xFB92 0xF3F3      SDIV     R3,R2,R3
   2103              
   2104              index = 1;
   \   000000D0   0x2401             MOVS     R4,#+1
   2105              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \   000000D2   0x1E42             SUBS     R2,R0,#+1
   \                     ??BlackLeftCrossStep3_9: (+1)
   \   000000D4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000D6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D8   0x1C4D             ADDS     R5,R1,#+1
   \   000000DA   0x42AA             CMP      R2,R5
   \   000000DC   0xDB23             BLT.N    ??BlackLeftCrossStep3_7
   2106              {
   2107                //每次右移一点点
   2108                BlackLeftLoc[row][0] = (uint8)(BlackLeftLoc[FirstLine][0] - delta * index / BlackLeftCrossStep3Multi);
   \   000000DE   0x....             LDR.N    R5,??DataTable13
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0x2603             MOVS     R6,#+3
   \   000000E4   0xFB06 0x5500      MLA      R5,R6,R0,R5
   \   000000E8   0x782D             LDRB     R5,[R5, #+0]
   \   000000EA   0xFB04 0xF603      MUL      R6,R4,R3
   \   000000EE   0xF44F 0x777A      MOV      R7,#+1000
   \   000000F2   0xFB96 0xF6F7      SDIV     R6,R6,R7
   \   000000F6   0x1BAD             SUBS     R5,R5,R6
   \   000000F8   0x....             LDR.N    R6,??DataTable13
   \   000000FA   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000FC   0x2703             MOVS     R7,#+3
   \   000000FE   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   00000102   0x7035             STRB     R5,[R6, #+0]
   2109                index += 1;
   \   00000104   0x1C64             ADDS     R4,R4,#+1
   2110              }
   \   00000106   0x1E52             SUBS     R2,R2,#+1
   \   00000108   0xE7E4             B.N      ??BlackLeftCrossStep3_9
   2111            }
   2112            //斜率直走，这个不太可能出现
   2113            else
   2114            {
   2115              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \                     ??BlackLeftCrossStep3_8: (+1)
   \   0000010A   0x1E42             SUBS     R2,R0,#+1
   \   0000010C   0xE006             B.N      ??BlackLeftCrossStep3_10
   2116              {
   2117                //赋相同的值
   2118                BlackLeftLoc[row][0] = temp1;
   \                     ??BlackLeftCrossStep3_11: (+1)
   \   0000010E   0x....             LDR.N    R0,??DataTable13
   \   00000110   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000112   0x2303             MOVS     R3,#+3
   \   00000114   0xFB03 0x0002      MLA      R0,R3,R2,R0
   \   00000118   0x7004             STRB     R4,[R0, #+0]
   2119              }
   \   0000011A   0x1E52             SUBS     R2,R2,#+1
   \                     ??BlackLeftCrossStep3_10: (+1)
   \   0000011C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000011E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000120   0x1C48             ADDS     R0,R1,#+1
   \   00000122   0x4282             CMP      R2,R0
   \   00000124   0xDAF3             BGE.N    ??BlackLeftCrossStep3_11
   2120            }
   2121            
   2122            return 1;
   \                     ??BlackLeftCrossStep3_7: (+1)
   \   00000126   0x2001             MOVS     R0,#+1
   \                     ??BlackLeftCrossStep3_1: (+1)
   \   00000128   0xBCF0             POP      {R4-R7}
   \   0000012A   0x4770             BX       LR               ;; return
   2123              
   2124          }
   2125          
   2126          //======================================================================
   2127          //函数名：BlackLeftCrossConfirm
   2128          //功  能：十字再检测时 ，线头有效性的确认。
   2129          //参  数：第1段黑线的真实结束行Row1RealLastLine，第2段黑线的真实起始行Row2RealFirstLine
   2130          //返  回：1成功 0失败
   2131          //影  响：无
   2132          //说  明：1. 为了应对270度弯道十字误检测而诞生，编写过程中没有过多考虑其它情况。
   2133          //      
   2134          //             
   2135          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   2136          uint8 BlackLeftCrossConfirm(uint8 Row1RealLastLine, uint8 Row2RealFirstLine)
   2137          {
   \                     BlackLeftCrossConfirm: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x000C             MOVS     R4,R1
   2138            uint8 row, index;
   2139            uint8 x[BlackCrossConfirmNum];
   2140            uint8 y[BlackCrossConfirmNum];
   2141            
   2142            int32 a0, a1, temp;
   2143          
   2144            //1. 先进行第二段黑线起始点方向判定，若不满足左十字该有方向，则判定为错误点。直接返回0.
   2145            if(BlackLeftLoc[Row2RealFirstLine][0] > BlackLeftLoc[Row2RealFirstLine-1][0]) 
   \   00000006   0x....             LDR.N    R1,??DataTable13
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2203             MOVS     R2,#+3
   \   0000000C   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000010   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000014   0x....             LDR.N    R2,??DataTable13
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x2303             MOVS     R3,#+3
   \   0000001A   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   0000001E   0x7812             LDRB     R2,[R2, #+0]
   \   00000020   0x4291             CMP      R1,R2
   \   00000022   0xD201             BCS.N    ??BlackLeftCrossConfirm_0
   2146            {
   2147              return 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE099             B.N      ??BlackLeftCrossConfirm_1
   2148            }
   2149            //2. 再进行第二段黑线起始两点的斜率判定，也就是对两点的列差作限定，太大则有可能是大弯回弯。针对回弯十字误补。
   2150            else if((BlackLeftLoc[Row2RealFirstLine][0] < BlackLeftLoc[Row2RealFirstLine-1][0])
   2151             &&(BlackLeftLoc[Row2RealFirstLine-1][0] - BlackLeftLoc[Row2RealFirstLine][0] >= 3)
   2152               )
   \                     ??BlackLeftCrossConfirm_0: (+1)
   \   00000028   0x....             LDR.N    R1,??DataTable13
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2203             MOVS     R2,#+3
   \   0000002E   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000032   0x7809             LDRB     R1,[R1, #+0]
   \   00000034   0x....             LDR.N    R2,??DataTable13
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x2303             MOVS     R3,#+3
   \   0000003A   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   0000003E   0xF812 0x2C03      LDRB     R2,[R2, #-3]
   \   00000042   0x4291             CMP      R1,R2
   \   00000044   0xD211             BCS.N    ??BlackLeftCrossConfirm_2
   \   00000046   0x....             LDR.N    R1,??DataTable13
   \   00000048   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   0x2203             MOVS     R2,#+3
   \   0000004C   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000050   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000054   0x....             LDR.N    R2,??DataTable13
   \   00000056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   0x2303             MOVS     R3,#+3
   \   0000005A   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   0000005E   0x7812             LDRB     R2,[R2, #+0]
   \   00000060   0x1A89             SUBS     R1,R1,R2
   \   00000062   0x2903             CMP      R1,#+3
   \   00000064   0xDB01             BLT.N    ??BlackLeftCrossConfirm_2
   2153            {
   2154              return 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xE078             B.N      ??BlackLeftCrossConfirm_1
   2155            }
   2156            //3. 再对上一幅图的右线斜率和右线头进行检查。这里的右线斜率与右线头因为还没更新，所以是上一幅图的。针对回弯十字误补。
   2157            else if((SlopeR > BlackCrossConfirmSlopeLimit) //上一幅图的右线斜率很大。
   2158             &&(BlackRightHeadLine < BlackCrossConfirmHeadLineLimit) //上一幅图的右线线头比较高。（防止因为线特别短而造成的斜率不准确）
   2159               )
   \                     ??BlackLeftCrossConfirm_2: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000006E   0x6809             LDR      R1,[R1, #+0]
   \   00000070   0xF640 0x32B9      MOVW     R2,#+3001
   \   00000074   0x4291             CMP      R1,R2
   \   00000076   0xDB06             BLT.N    ??BlackLeftCrossConfirm_3
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   0000007C   0x7809             LDRB     R1,[R1, #+0]
   \   0000007E   0x2928             CMP      R1,#+40
   \   00000080   0xDA01             BGE.N    ??BlackLeftCrossConfirm_3
   2160            {
   2161              return 0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xE06A             B.N      ??BlackLeftCrossConfirm_1
   2162            }
   2163            else
   2164            {
   2165            }
   2166            
   2167            //第一段黑线太短，无法检测正确性时，检查要补的行是不是够长，如果够长，就视为正确。
   2168            //if(Row1RealLastLine >= CameraHight - 5 && Row2RealFirstLine > Row1RealLastLine + BlackLeftCrossConfirmGapLine) return 1;
   2169            //if(Row1RealLastLine >= CameraHight - 5) return 0;
   2170            
   2171            //以左上角为原点，向下为x轴正方向（0~49），向右为y轴正方向(0~249)
   2172            index = 0;
   \                     ??BlackLeftCrossConfirm_3: (+1)
   \   00000086   0x2100             MOVS     R1,#+0
   2173            for(row = Row1RealLastLine; ; row++)
   \   00000088   0xE000             B.N      ??BlackLeftCrossConfirm_4
   \                     ??BlackLeftCrossConfirm_5: (+1)
   \   0000008A   0x1C40             ADDS     R0,R0,#+1
   2174            {
   2175              //有效行的记录
   2176              if(BlackLeftLoc[row][0] != MaxValUint8)
   \                     ??BlackLeftCrossConfirm_4: (+1)
   \   0000008C   0x....             LDR.N    R2,??DataTable13
   \   0000008E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000090   0x2303             MOVS     R3,#+3
   \   00000092   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000096   0x7812             LDRB     R2,[R2, #+0]
   \   00000098   0x2AFF             CMP      R2,#+255
   \   0000009A   0xD00C             BEQ.N    ??BlackLeftCrossConfirm_6
   2177              {
   2178                y[index] = BlackLeftLoc[row][0];
   \   0000009C   0x....             LDR.N    R2,??DataTable13
   \   0000009E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A0   0x2303             MOVS     R3,#+3
   \   000000A2   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000A6   0x7812             LDRB     R2,[R2, #+0]
   \   000000A8   0xAB00             ADD      R3,SP,#+0
   \   000000AA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000AC   0x54CA             STRB     R2,[R1, R3]
   2179                x[index] = row;
   \   000000AE   0xAA01             ADD      R2,SP,#+4
   \   000000B0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B2   0x5488             STRB     R0,[R1, R2]
   2180                index++;
   \   000000B4   0x1C49             ADDS     R1,R1,#+1
   2181              }
   2182              //点数够多，则跳出。
   2183              if(index == BlackCrossConfirmNum) break;
   \                     ??BlackLeftCrossConfirm_6: (+1)
   \   000000B6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B8   0x2904             CMP      R1,#+4
   \   000000BA   0xD10B             BNE.N    ??BlackLeftCrossConfirm_7
   2184              //直到最低行仍没有凑够足够的点数，说明第一段有效黑线太短，无法检测正确性，直接返回1.
   2185              if(row == CameraHight - 1) 
   2186              {
   2187                if(index == 0) return 0;
   2188                //判断第二段黑点起点是不是在第一段黑点末尾的右边一定范围内
   2189                if(BlackLeftLoc[Row2RealFirstLine][0] > y[0] && BlackLeftLoc[Row2RealFirstLine][0] - y[0] < 50)
   2190                {
   2191                  return 1;
   2192                }
   2193                else
   2194                {
   2195                  return 0;
   2196                }      
   2197              }
   2198              else
   2199              {
   2200              }
   2201            }
   2202            
   2203            //最小二乘法
   2204            //y = a0 + a1 * x
   2205            a1 = LeastSquarea1(x, y, BlackCrossConfirmNum);
   \   000000BC   0x2204             MOVS     R2,#+4
   \   000000BE   0xA900             ADD      R1,SP,#+0
   \   000000C0   0xA801             ADD      R0,SP,#+4
   \   000000C2   0x.... 0x....      BL       LeastSquarea1
   \   000000C6   0x0005             MOVS     R5,R0
   2206            
   2207            //判断斜率是不是从右下到左上，如果是，则返回失败。
   2208            if(a1 > BlackLeftCrossConfirmSlopeLimit) return 0;
   \   000000C8   0xF240 0x404D      MOVW     R0,#+1101
   \   000000CC   0x4285             CMP      R5,R0
   \   000000CE   0xDB22             BLT.N    ??BlackLeftCrossConfirm_8
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0xE043             B.N      ??BlackLeftCrossConfirm_1
   \                     ??BlackLeftCrossConfirm_7: (+1)
   \   000000D4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D6   0x283B             CMP      R0,#+59
   \   000000D8   0xD1D7             BNE.N    ??BlackLeftCrossConfirm_5
   \   000000DA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000DC   0x2900             CMP      R1,#+0
   \   000000DE   0xD101             BNE.N    ??BlackLeftCrossConfirm_9
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0xE03B             B.N      ??BlackLeftCrossConfirm_1
   \                     ??BlackLeftCrossConfirm_9: (+1)
   \   000000E4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000000E8   0x....             LDR.N    R1,??DataTable13
   \   000000EA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EC   0x2203             MOVS     R2,#+3
   \   000000EE   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000F2   0x7809             LDRB     R1,[R1, #+0]
   \   000000F4   0x4288             CMP      R0,R1
   \   000000F6   0xD20C             BCS.N    ??BlackLeftCrossConfirm_10
   \   000000F8   0x....             LDR.N    R0,??DataTable13
   \   000000FA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FC   0x2103             MOVS     R1,#+3
   \   000000FE   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000102   0x7800             LDRB     R0,[R0, #+0]
   \   00000104   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000108   0x1A40             SUBS     R0,R0,R1
   \   0000010A   0x2832             CMP      R0,#+50
   \   0000010C   0xDA01             BGE.N    ??BlackLeftCrossConfirm_10
   \   0000010E   0x2001             MOVS     R0,#+1
   \   00000110   0xE024             B.N      ??BlackLeftCrossConfirm_1
   \                     ??BlackLeftCrossConfirm_10: (+1)
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xE022             B.N      ??BlackLeftCrossConfirm_1
   2209            
   2210            a0 = LeastSquarea0(x, y, a1, BlackCrossConfirmNum);
   \                     ??BlackLeftCrossConfirm_8: (+1)
   \   00000116   0x2304             MOVS     R3,#+4
   \   00000118   0x002A             MOVS     R2,R5
   \   0000011A   0xA900             ADD      R1,SP,#+0
   \   0000011C   0xA801             ADD      R0,SP,#+4
   \   0000011E   0x.... 0x....      BL       LeastSquarea0
   2211            
   2212            //temp为第2段黑线起始行本应该在的位置。
   2213            temp = (a0 + a1 * Row2RealFirstLine) / LeastSquareMulti;
   \   00000122   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000124   0xFB04 0x0005      MLA      R0,R4,R5,R0
   \   00000128   0xF44F 0x717A      MOV      R1,#+1000
   \   0000012C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   2214          
   2215            //把这个点限定在窗内
   2216            if(
   2217              (BlackLeftLoc[Row2RealFirstLine][0] > temp - BlackCrossConfirmWin) 
   2218            &&(BlackLeftLoc[Row2RealFirstLine][0] < temp + BlackCrossConfirmWin)  //向右的值太大的话，会在“下双上单”的时候出现十字误补线。
   2219              )
   \   00000130   0xF1B0 0x0128      SUBS     R1,R0,#+40
   \   00000134   0x....             LDR.N    R2,??DataTable13
   \   00000136   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000138   0x2303             MOVS     R3,#+3
   \   0000013A   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   0000013E   0x7812             LDRB     R2,[R2, #+0]
   \   00000140   0x4291             CMP      R1,R2
   \   00000142   0xDA0A             BGE.N    ??BlackLeftCrossConfirm_11
   \   00000144   0x....             LDR.N    R1,??DataTable13
   \   00000146   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000148   0x2203             MOVS     R2,#+3
   \   0000014A   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000014E   0x7809             LDRB     R1,[R1, #+0]
   \   00000150   0x3028             ADDS     R0,R0,#+40
   \   00000152   0x4281             CMP      R1,R0
   \   00000154   0xDA01             BGE.N    ??BlackLeftCrossConfirm_11
   2220            {
   2221              return 1;
   \   00000156   0x2001             MOVS     R0,#+1
   \   00000158   0xE000             B.N      ??BlackLeftCrossConfirm_1
   2222            }
   2223            else
   2224            {
   2225              return 0;
   \                     ??BlackLeftCrossConfirm_11: (+1)
   \   0000015A   0x2000             MOVS     R0,#+0
   \                     ??BlackLeftCrossConfirm_1: (+1)
   \   0000015C   0xBD3E             POP      {R1-R5,PC}       ;; return
   2226            }
   2227              
   2228             
   2229          }
   2230          
   2231          
   2232          
   2233          
   2234          //======================================================================
   2235          //函数名：BlackGetLeftCrossSpeWin
   2236          //功  能：左黑线十字再检测时，窗口的特殊扫描
   2237          //参  数：待处理行号row, 窗口左边界colleft, 窗口右边界colright, 第几次使用use.
   2238          //返  回：1成功  0失败
   2239          //影  响：BlackLeftLoc[][0]
   2240          //说  明：1. 满足两批条件，才能检测成功。只有一个点的记录。
   2241          //        2. 窗口内没有检测到，则检测失败。  
   2242          //        3. 跟普通窗口扫描不一样，前者输入变量是预测值和窗口大小，后者是左右边界。
   2243          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   2244          uint8 BlackGetLeftCrossSpeWin(uint8 row, uint8 colleft, uint8 colright, uint8 use)
   2245          {
   \                     BlackGetLeftCrossSpeWin: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0010             MOVS     R0,R2
   \   00000008   0x001D             MOVS     R5,R3
   2246            uint8 col;
   2247            
   2248            //在规划好的窗口内，从右往左查找跳变沿
   2249            //防止溢出
   2250            
   2251            //对左边界的限制
   2252            if(colleft < 4 + BlackLeftEdgeNum)
   \   0000000A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000000C   0x2E07             CMP      R6,#+7
   \   0000000E   0xDA00             BGE.N    ??BlackGetLeftCrossSpeWin_0
   2253            {
   2254              colleft = 4 + BlackLeftEdgeNum;
   \   00000010   0x2607             MOVS     R6,#+7
   2255            }
   2256            else 
   2257            {
   2258            } 
   2259          
   2260            //对右边界的限制
   2261            if(colright > CameraRealWidth - 1)
   \                     ??BlackGetLeftCrossSpeWin_0: (+1)
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x28FA             CMP      R0,#+250
   \   00000016   0xDB00             BLT.N    ??BlackGetLeftCrossSpeWin_1
   2262            {
   2263              colright = CameraRealWidth - 1;  
   \   00000018   0x20F9             MOVS     R0,#+249
   2264            }
   2265            else
   2266            {
   2267            }
   2268            
   2269            //右线开始扫描时，左线扫描的右边界必须在该行有效右黑线的左边。
   2270            if((BlackGetPreDir == 1)
   2271             &&(BlackRightLoc[row][0] != MaxValUint8)
   2272               )
   \                     ??BlackGetLeftCrossSpeWin_1: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable16_2
   \   0000001E   0x7809             LDRB     R1,[R1, #+0]
   \   00000020   0x2901             CMP      R1,#+1
   \   00000022   0xD112             BNE.N    ??BlackGetLeftCrossSpeWin_2
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2203             MOVS     R2,#+3
   \   0000002C   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000030   0x7809             LDRB     R1,[R1, #+0]
   \   00000032   0x29FF             CMP      R1,#+255
   \   00000034   0xD009             BEQ.N    ??BlackGetLeftCrossSpeWin_2
   2273            {
   2274              colright = MinRe(colright, BlackRightLoc[row][0]);
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   0000003A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003C   0x2203             MOVS     R2,#+3
   \   0000003E   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000042   0x7809             LDRB     R1,[R1, #+0]
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x.... 0x....      BL       MinRe
   2275            }
   2276            else
   2277            {
   2278            }
   2279            
   2280            //窗口预测值记录
   2281            BlackLeftPredictL[row] = colleft;
   \                     ??BlackGetLeftCrossSpeWin_2: (+1)
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable16_4
   \   0000004E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000050   0x5466             STRB     R6,[R4, R1]
   2282            BlackLeftPredictR[row] = colright;
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   00000056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   0x5460             STRB     R0,[R4, R1]
   2283            
   2284            //左边界在右边界右边，直接返回失败。
   2285            if(colleft >= colright) return 0;
   \   0000005A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0x4286             CMP      R6,R0
   \   00000060   0xD301             BCC.N    ??BlackGetLeftCrossSpeWin_3
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xE095             B.N      ??BlackGetLeftCrossSpeWin_4
   2286            
   2287            //开窗扫描跳变沿
   2288            col = BlackGetLeftJustWin(row, colleft, colright);
   \                     ??BlackGetLeftCrossSpeWin_3: (+1)
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0x0002             MOVS     R2,R0
   \   0000006A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006C   0x0031             MOVS     R1,R6
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0x.... 0x....      BL       BlackGetLeftJustWin
   \   00000076   0x0006             MOVS     R6,R0
   2289            if(col != MaxValUint8)
   \   00000078   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007A   0x2EFF             CMP      R6,#+255
   \   0000007C   0xF000 0x8080      BEQ.W    ??BlackGetLeftCrossSpeWin_5
   2290            {
   2291              //两批条件均满足，直接记录该点为黑线，返回即可
   2292              BlackLeftLoc[row][0] = col - 1 - BlackLeftEdgeNum;
   \   00000080   0x1F30             SUBS     R0,R6,#+4
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000086   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000088   0x2203             MOVS     R2,#+3
   \   0000008A   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000008E   0x7008             STRB     R0,[R1, #+0]
   2293          
   2294              //最后确认前，需要进行大斜率的检测。若不成功，则说明检测到坏点。
   2295              if(BlackLeftBigChangeCheck(row, use) == 0)
   \   00000090   0x0029             MOVS     R1,R5
   \   00000092   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000094   0x0020             MOVS     R0,R4
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0x.... 0x....      BL       BlackLeftBigChangeCheck
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD110             BNE.N    ??BlackGetLeftCrossSpeWin_6
   2296              {              
   2297                //没通过大斜率检测。
   2298                BlackLeftBigChangeCheckRow[row] = 1;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0x....             LDR.N    R1,??DataTable14_4
   \   000000A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A6   0x5460             STRB     R0,[R4, R1]
   2299                BlackLeftBigChangeCheckAllRow = 1;
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0x....             LDR.N    R1,??DataTable14_5
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
   2300             
   2301                
   2302                //该行定位黑线失败，赋无效值
   2303                BlackLeftLoc[row][0] = MaxValUint8;
   \   000000AE   0x20FF             MOVS     R0,#+255
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable17
   \   000000B4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B6   0x2203             MOVS     R2,#+3
   \   000000B8   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000BC   0x7008             STRB     R0,[R1, #+0]
   2304                return 0;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xE067             B.N      ??BlackGetLeftCrossSpeWin_4
   2305              }
   2306              else
   2307              {
   2308              }
   2309              
   2310              //通过了大斜率检测。
   2311              //记录3个关键值的实际信息，作为后面的参考。
   2312              if(use == 1)
   \                     ??BlackGetLeftCrossSpeWin_6: (+1)
   \   000000C2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C4   0x2D01             CMP      R5,#+1
   \   000000C6   0xD12B             BNE.N    ??BlackGetLeftCrossSpeWin_7
   2313              {
   2314                BlackLeftRealWB[0] = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum]; 
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   000000CC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CE   0x21FA             MOVS     R1,#+250
   \   000000D0   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000D4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D6   0x5C30             LDRB     R0,[R6, R0]
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   000000DC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DE   0x22FA             MOVS     R2,#+250
   \   000000E0   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000E4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000E6   0x1871             ADDS     R1,R6,R1
   \   000000E8   0xF811 0x1C04      LDRB     R1,[R1, #-4]
   \   000000EC   0x1A40             SUBS     R0,R0,R1
   \   000000EE   0x....             LDR.N    R1,??DataTable14_1
   \   000000F0   0x7008             STRB     R0,[R1, #+0]
   2315                BlackLeftRealW[0] = ImgNew[row][col];
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   000000F6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F8   0x21FA             MOVS     R1,#+250
   \   000000FA   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000FE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000100   0x5C30             LDRB     R0,[R6, R0]
   \   00000102   0x....             LDR.N    R1,??DataTable14_2
   \   00000104   0x7008             STRB     R0,[R1, #+0]
   2316                BlackLeftRealB[0] = ImgNew[row][col-1-BlackLeftEdgeNum];
   \   00000106   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000010A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000010C   0x21FA             MOVS     R1,#+250
   \   0000010E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000112   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000114   0x1830             ADDS     R0,R6,R0
   \   00000116   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   0000011A   0x....             LDR.N    R1,??DataTable14_3
   \   0000011C   0x7008             STRB     R0,[R1, #+0]
   \   0000011E   0xE02D             B.N      ??BlackGetLeftCrossSpeWin_8
   2317              }
   2318              else if(use == 2)
   \                     ??BlackGetLeftCrossSpeWin_7: (+1)
   \   00000120   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000122   0x2D02             CMP      R5,#+2
   \   00000124   0xD12A             BNE.N    ??BlackGetLeftCrossSpeWin_8
   2319              {
   2320                BlackLeftRealWB[1] = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum]; 
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000012A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000012C   0x21FA             MOVS     R1,#+250
   \   0000012E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000132   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000134   0x5C30             LDRB     R0,[R6, R0]
   \   00000136   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   0000013A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000013C   0x22FA             MOVS     R2,#+250
   \   0000013E   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000142   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000144   0x1871             ADDS     R1,R6,R1
   \   00000146   0xF811 0x1C04      LDRB     R1,[R1, #-4]
   \   0000014A   0x1A40             SUBS     R0,R0,R1
   \   0000014C   0x....             LDR.N    R1,??DataTable14_1
   \   0000014E   0x7048             STRB     R0,[R1, #+1]
   2321                BlackLeftRealW[1] = ImgNew[row][col];
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000154   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000156   0x21FA             MOVS     R1,#+250
   \   00000158   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000015C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000015E   0x5C30             LDRB     R0,[R6, R0]
   \   00000160   0x....             LDR.N    R1,??DataTable14_2
   \   00000162   0x7048             STRB     R0,[R1, #+1]
   2322                BlackLeftRealB[1] = ImgNew[row][col-1-BlackLeftEdgeNum];
   \   00000164   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000168   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000016A   0x21FA             MOVS     R1,#+250
   \   0000016C   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000170   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000172   0x1830             ADDS     R0,R6,R0
   \   00000174   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   00000178   0x....             LDR.N    R1,??DataTable14_3
   \   0000017A   0x7048             STRB     R0,[R1, #+1]
   2323              }
   2324              else
   2325              {
   2326              }     
   2327              
   2328              return 1;   
   \                     ??BlackGetLeftCrossSpeWin_8: (+1)
   \   0000017C   0x2001             MOVS     R0,#+1
   \   0000017E   0xE008             B.N      ??BlackGetLeftCrossSpeWin_4
   2329            }
   2330            else
   2331            {
   2332              //窗口内没有扫描到跳变沿，该行的黑线位置记为无效值，返回0失败.
   2333              BlackLeftLoc[row][0] = MaxValUint8;
   \                     ??BlackGetLeftCrossSpeWin_5: (+1)
   \   00000180   0x20FF             MOVS     R0,#+255
   \   00000182   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000186   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000188   0x2203             MOVS     R2,#+3
   \   0000018A   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000018E   0x7008             STRB     R0,[R1, #+0]
   2334              return 0; 
   \   00000190   0x2000             MOVS     R0,#+0
   \                     ??BlackGetLeftCrossSpeWin_4: (+1)
   \   00000192   0xBD70             POP      {R4-R6,PC}       ;; return
   2335            }
   2336          }
   2337          
   2338          
   2339          
   2340          //======================================================================
   2341          //函数名：BlackGetLeftCrossSpeScan
   2342          //功  能：十字再检测时，线头的特殊扫描
   2343          //参  数：第2段黑线的预测起始行Row2FirstLine， 第2段黑线的预测结束行Row2LastLine，
   2344          //        最近一次的窗口预测值LastWinPredict
   2345          //返  回：MaxValUint8失败，否则成功。
   2346          //影  响：
   2347          //说  明：
   2348          //      
   2349          //             
   2350          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   2351          uint8 BlackGetLeftCrossSpeScan(uint8 Row2FirstLine, uint8 Row2LastLine, uint8 LastWinPredict)
   2352          {
   \                     BlackGetLeftCrossSpeScan: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0010             MOVS     R0,R2
   2353            uint8 row;
   2354            uint8 temp1, temp2, temppredict, tempminus;
   2355            uint8 colleft, colright;
   2356            uint8 i;
   2357            
   2358            //最近一次的窗口预测值。
   2359            temppredict = LastWinPredict;
   2360            
   2361            //colleft的确定
   2362            //对于左黑线扫描，colleft表示之前所有有效黑线的最左点。
   2363            //找第1个有效左黑线。
   2364            for(i = Row2FirstLine+1; ; i++)
   \   0000000A   0x1C61             ADDS     R1,R4,#+1
   \   0000000C   0xE000             B.N      ??BlackGetLeftCrossSpeScan_0
   \                     ??BlackGetLeftCrossSpeScan_1: (+1)
   \   0000000E   0x1C49             ADDS     R1,R1,#+1
   2365            {
   2366              if(BlackLeftLoc[i][0] != MaxValUint8)
   \                     ??BlackGetLeftCrossSpeScan_0: (+1)
   \   00000010   0x.... 0x....      LDR.W    R2,??DataTable17
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x2303             MOVS     R3,#+3
   \   00000018   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   0000001C   0x7812             LDRB     R2,[R2, #+0]
   \   0000001E   0x2AFF             CMP      R2,#+255
   \   00000020   0xD007             BEQ.N    ??BlackGetLeftCrossSpeScan_2
   2367              {
   2368                colleft = BlackLeftLoc[i][0];
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable17
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0x2303             MOVS     R3,#+3
   \   0000002A   0xFB03 0x2101      MLA      R1,R3,R1,R2
   \   0000002E   0x780E             LDRB     R6,[R1, #+0]
   2369                break;
   2370              }
   2371              else
   2372              {
   2373              }
   2374              //若一直到最近一行仍没有有效左黑线，则返回失败。理论上不可能走到这里。
   2375              if(i == CameraHight - 1) return MaxValUint8;
   2376            }
   2377            //暂时不用最左边的左黑线，也就相当于用最右边的左黑线。
   2378          //  //找最左的有效左黑线。
   2379          //  for( ; ; i++)
   2380          //  {
   2381          //    if(BlackLeftLoc[i][0] != MaxValUint8)
   2382          //    {
   2383          //      if(BlackLeftLoc[i][0] < colleft)
   2384          //      {
   2385          //        colleft = BlackLeftLoc[i][0];
   2386          //      }
   2387          //      else
   2388          //      {
   2389          //      }
   2390          //    }
   2391          //    else
   2392          //    { 
   2393          //    }
   2394          //    
   2395          //    if(i == CameraHight - 1) break;
   2396          //  }
   2397          
   2398            //逐行开窗扫描左黑线。
   2399            for(row = Row2FirstLine; ; row -= 2)
   \   00000030   0xE005             B.N      ??BlackGetLeftCrossSpeScan_3
   \                     ??BlackGetLeftCrossSpeScan_2: (+1)
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0x293B             CMP      R1,#+59
   \   00000036   0xD1EA             BNE.N    ??BlackGetLeftCrossSpeScan_1
   \   00000038   0x20FF             MOVS     R0,#+255
   \   0000003A   0xE089             B.N      ??BlackGetLeftCrossSpeScan_4
   \                     ??BlackGetLeftCrossSpeScan_5: (+1)
   \   0000003C   0x1EA4             SUBS     R4,R4,#+2
   2400            {
   2401              //colright的确定
   2402              colright = BoundaryLimitRe(temppredict + BlackLeftWinVal * 2,
   2403                                         0,
   2404                                         CameraRealWidth - 1);        
   \                     ??BlackGetLeftCrossSpeScan_3: (+1)
   \   0000003E   0x22F9             MOVS     R2,#+249
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x301E             ADDS     R0,R0,#+30
   \   00000046   0x.... 0x....      BL       BoundaryLimitRe
   \   0000004A   0x4680             MOV      R8,R0
   2405              
   2406              //为了防止窗口有错，所以最左边不得小于BlackLeftEdgeStartColOffset。
   2407              colright = MaxRe(colright, CameraRealWidth / 2 - 1 + BlackLeftEdgeStartColOffset[row]);
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0x5C20             LDRB     R0,[R4, R0]
   \   00000054   0xF110 0x017C      ADDS     R1,R0,#+124
   \   00000058   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000005C   0x4640             MOV      R0,R8
   \   0000005E   0x.... 0x....      BL       MaxRe
   \   00000062   0x4680             MOV      R8,R0
   2408              
   2409              //连续2行检测黑点,特殊开窗扫描。
   2410              temp1 = BlackGetLeftCrossSpeWin(row, colleft, colright, 1);
   \   00000064   0x2301             MOVS     R3,#+1
   \   00000066   0x4642             MOV      R2,R8
   \   00000068   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006A   0x0031             MOVS     R1,R6
   \   0000006C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0x.... 0x....      BL       BlackGetLeftCrossSpeWin
   \   00000076   0x0007             MOVS     R7,R0
   2411              temp2 = BlackGetLeftCrossSpeWin(row-1, colleft, colright, 2);
   \   00000078   0x2302             MOVS     R3,#+2
   \   0000007A   0x4642             MOV      R2,R8
   \   0000007C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000007E   0x0031             MOVS     R1,R6
   \   00000080   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000082   0x1E60             SUBS     R0,R4,#+1
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0x.... 0x....      BL       BlackGetLeftCrossSpeWin
   2412              //连续2行开窗检测黑点成功，则线头检测成功。跳出。
   2413              if(temp1 == 1 && temp2 == 1)
   \   0000008A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000008C   0x2F01             CMP      R7,#+1
   \   0000008E   0xD105             BNE.N    ??BlackGetLeftCrossSpeScan_6
   \   00000090   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000092   0x2801             CMP      R0,#+1
   \   00000094   0xD102             BNE.N    ??BlackGetLeftCrossSpeScan_6
   2414              {
   2415                return row;
   \   00000096   0x0020             MOVS     R0,R4
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009A   0xE059             B.N      ??BlackGetLeftCrossSpeScan_4
   2416              }
   2417              //连续2行开窗检测黑线失败，则窗口预测点继续变化，继续开窗检测。
   2418              else if(temp1 == 0 && temp2 == 0)
   \                     ??BlackGetLeftCrossSpeScan_6: (+1)
   \   0000009C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000009E   0x2F00             CMP      R7,#+0
   \   000000A0   0xD121             BNE.N    ??BlackGetLeftCrossSpeScan_7
   \   000000A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD11E             BNE.N    ??BlackGetLeftCrossSpeScan_7
   2419              {
   2420                //预测点按趋势走也要限幅。
   2421                tempminus = BoundaryLimitRe(BlackLeftWinPredictStore2 + BlackLeftWinPredictStore2 - BlackLeftWinPredictStore1,
   2422                                            0,
   2423                                            CameraRealWidth - 1);
   \   000000A8   0x22F9             MOVS     R2,#+249
   \   000000AA   0x2100             MOVS     R1,#+0
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000000B0   0x7800             LDRB     R0,[R0, #+0]
   \   000000B2   0x.... 0x....      LDR.W    R3,??DataTable20
   \   000000B6   0x781B             LDRB     R3,[R3, #+0]
   \   000000B8   0x1818             ADDS     R0,R3,R0
   \   000000BA   0x.... 0x....      LDR.W    R3,??DataTable19
   \   000000BE   0x781B             LDRB     R3,[R3, #+0]
   \   000000C0   0x1AC0             SUBS     R0,R0,R3
   \   000000C2   0x.... 0x....      BL       BoundaryLimitRe
   2424                //temp在这里表示窗口预测点位置。
   2425                temppredict = tempminus;
   2426                BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000000CA   0x7809             LDRB     R1,[R1, #+0]
   \   000000CC   0x.... 0x....      LDR.W    R2,??DataTable19_1
   \   000000D0   0x7011             STRB     R1,[R2, #+0]
   2427                BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable20
   \   000000D6   0x7809             LDRB     R1,[R1, #+0]
   \   000000D8   0x.... 0x....      LDR.W    R2,??DataTable19
   \   000000DC   0x7011             STRB     R1,[R2, #+0]
   2428                BlackLeftWinPredictStore2 = temppredict;      
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable20
   \   000000E2   0x7008             STRB     R0,[R1, #+0]
   \   000000E4   0xE02E             B.N      ??BlackGetLeftCrossSpeScan_8
   2429              }
   2430              //其中一行开窗检测成功，则当作干扰点，窗口预测点继续变化，继续开窗检测。
   2431              else
   2432              {
   2433                //当作干扰点滤掉。
   2434                BlackLeftLoc[row][0] = MaxValUint8;
   \                     ??BlackGetLeftCrossSpeScan_7: (+1)
   \   000000E6   0x20FF             MOVS     R0,#+255
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable17
   \   000000EC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EE   0x2203             MOVS     R2,#+3
   \   000000F0   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000F4   0x7008             STRB     R0,[R1, #+0]
   2435                BlackLeftLoc[row-1][0] = MaxValUint8;
   \   000000F6   0x20FF             MOVS     R0,#+255
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable17
   \   000000FC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FE   0x2203             MOVS     R2,#+3
   \   00000100   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000104   0xF801 0x0C03      STRB     R0,[R1, #-3]
   2436                
   2437                //预测点按趋势走也要限幅。
   2438                tempminus = BoundaryLimitRe(BlackLeftWinPredictStore2 + BlackLeftWinPredictStore2 - BlackLeftWinPredictStore1,
   2439                                            0,
   2440                                            CameraRealWidth - 1);
   \   00000108   0x22F9             MOVS     R2,#+249
   \   0000010A   0x2100             MOVS     R1,#+0
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000110   0x7800             LDRB     R0,[R0, #+0]
   \   00000112   0x.... 0x....      LDR.W    R3,??DataTable20
   \   00000116   0x781B             LDRB     R3,[R3, #+0]
   \   00000118   0x1818             ADDS     R0,R3,R0
   \   0000011A   0x.... 0x....      LDR.W    R3,??DataTable19
   \   0000011E   0x781B             LDRB     R3,[R3, #+0]
   \   00000120   0x1AC0             SUBS     R0,R0,R3
   \   00000122   0x.... 0x....      BL       BoundaryLimitRe
   2441                //temp在这里表示窗口预测点位置。
   2442                temppredict = tempminus;
   2443                BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
   \   00000126   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000012A   0x7809             LDRB     R1,[R1, #+0]
   \   0000012C   0x.... 0x....      LDR.W    R2,??DataTable19_1
   \   00000130   0x7011             STRB     R1,[R2, #+0]
   2444                BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable20
   \   00000136   0x7809             LDRB     R1,[R1, #+0]
   \   00000138   0x.... 0x....      LDR.W    R2,??DataTable19
   \   0000013C   0x7011             STRB     R1,[R2, #+0]
   2445                BlackLeftWinPredictStore2 = temppredict;        
   \   0000013E   0x.... 0x....      LDR.W    R1,??DataTable20
   \   00000142   0x7008             STRB     R0,[R1, #+0]
   2446              }
   2447                
   2448                
   2449                
   2450              //一直到第Row2LastLine行也没有连续2行检测成功，则返回失败。
   2451              if(row == Row2LastLine) 
   \                     ??BlackGetLeftCrossSpeScan_8: (+1)
   \   00000144   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000146   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000148   0x42AC             CMP      R4,R5
   \   0000014A   0xF47F 0xAF77      BNE.W    ??BlackGetLeftCrossSpeScan_5
   2452              {
   2453                return MaxValUint8;
   \   0000014E   0x20FF             MOVS     R0,#+255
   \                     ??BlackGetLeftCrossSpeScan_4: (+1)
   \   00000150   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2454              }
   2455              else
   2456              {
   2457              }
   2458            }
   2459           
   2460          
   2461          
   2462          
   2463          }
   2464          
   2465          //======================================================================
   2466          //函数名：BlackLeftAgainForCross
   2467          //功  能：左黑线提取中，针对十字的再检测程序
   2468          //参  数：第2段黑线的预测起始行Row2FirstLine， 第2段黑线的预测结束行Row2LastLine，
   2469          //        第1段黑线的实际结束行Row1RealLastLine， 最近一次的窗口预测值LastWinPredict
   2470          //返  回：1成功 0失败
   2471          //影  响：BlackLeftLoc[][]。 （不会影响那几个阈值。）
   2472          //说  明：1. 本函数会调用浮点运算的函数，预计花费较多时间，调用入口需谨慎。
   2473          //        2. 本函数仅影响了BlackLeftLoc[][]，以后也应该保持。
   2474          //             
   2475          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   2476          uint8 BlackLeftAgainForCross(uint8 Row2FirstLine, uint8 Row2LastLine, uint8 Row1RealLastLine, uint8 LastWinPredict)
   2477          {
   \                     BlackLeftAgainForCross: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
   2478              uint8 row, temp, temp1, temp2;
   2479              uint8 Row2RealFirstLine; //第2段黑线的真实起始行
   2480              uint8 i;
   2481              
   2482              uint8 tempWB, tempW, tempB;
   2483              uint8 tempminus;
   2484              
   2485              //第1段黑线的真实结束行有可能因为大跳变被删掉，所以需要重新查找并更新。
   2486              for(i = Row1RealLastLine; i <= CameraHight - 1; i++)
   \   0000000A   0x0028             MOVS     R0,R5
   \   0000000C   0xE000             B.N      ??BlackLeftAgainForCross_0
   \                     ??BlackLeftAgainForCross_1: (+1)
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackLeftAgainForCross_0: (+1)
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x283C             CMP      R0,#+60
   \   00000014   0xDA09             BGE.N    ??BlackLeftAgainForCross_2
   2487              {
   2488                if(BlackLeftLoc[i][0] != MaxValUint8)
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable17
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x2203             MOVS     R2,#+3
   \   0000001E   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   00000022   0x7809             LDRB     R1,[R1, #+0]
   \   00000024   0x29FF             CMP      R1,#+255
   \   00000026   0xD0F2             BEQ.N    ??BlackLeftAgainForCross_1
   2489                {
   2490                  Row1RealLastLine = i;
   \   00000028   0x0005             MOVS     R5,R0
   2491                  break;
   2492                }
   2493                else
   2494                {
   2495                }
   2496              }
   2497              //由于直角黑块不允许检测十字再补线，所以当第1段黑线真实结束行的斜上方有黑块时，不允许补线。
   2498              //取5列。
   2499              for(i = 0; i <= 5; i++)
   \                     ??BlackLeftAgainForCross_2: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE000             B.N      ??BlackLeftAgainForCross_3
   \                     ??BlackLeftAgainForCross_4: (+1)
   \   0000002E   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackLeftAgainForCross_3: (+1)
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x2806             CMP      R0,#+6
   \   00000034   0xDA33             BGE.N    ??BlackLeftAgainForCross_5
   2500              {
   2501                if(ImgNew[Row1RealLastLine - 4][BlackLeftLoc[Row1RealLastLine][0] + 5 + i] < LimitLeftB) //往远4行。斜右上方。
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x22FA             MOVS     R2,#+250
   \   0000003E   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000042   0x.... 0x....      LDR.W    R2,??DataTable17
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2703             MOVS     R7,#+3
   \   0000004A   0xFB07 0x2205      MLA      R2,R7,R5,R2
   \   0000004E   0x7812             LDRB     R2,[R2, #+0]
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0x1882             ADDS     R2,R0,R2
   \   00000054   0x1851             ADDS     R1,R2,R1
   \   00000056   0xF2A1 0x31E3      SUBW     R1,R1,#+995
   \   0000005A   0x7809             LDRB     R1,[R1, #+0]
   \   0000005C   0x.... 0x....      LDR.W    R2,??DataTable19_2
   \   00000060   0x7812             LDRB     R2,[R2, #+0]
   \   00000062   0x4291             CMP      R1,R2
   \   00000064   0xD201             BCS.N    ??BlackLeftAgainForCross_6
   2502                {
   2503                  return 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xE19C             B.N      ??BlackLeftAgainForCross_7
   2504                }
   2505                else if(ImgNew[Row1RealLastLine - 5][BlackLeftLoc[Row1RealLastLine][0] + 5 + i] < LimitLeftB) //往远5行。斜右上方。
   \                     ??BlackLeftAgainForCross_6: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   0000006E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000070   0x22FA             MOVS     R2,#+250
   \   00000072   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000076   0x.... 0x....      LDR.W    R2,??DataTable17
   \   0000007A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007C   0x2703             MOVS     R7,#+3
   \   0000007E   0xFB07 0x2205      MLA      R2,R7,R5,R2
   \   00000082   0x7812             LDRB     R2,[R2, #+0]
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0x1882             ADDS     R2,R0,R2
   \   00000088   0x1851             ADDS     R1,R2,R1
   \   0000008A   0xF2A1 0x41DD      SUBW     R1,R1,#+1245
   \   0000008E   0x7809             LDRB     R1,[R1, #+0]
   \   00000090   0x.... 0x....      LDR.W    R2,??DataTable19_2
   \   00000094   0x7812             LDRB     R2,[R2, #+0]
   \   00000096   0x4291             CMP      R1,R2
   \   00000098   0xD2C9             BCS.N    ??BlackLeftAgainForCross_4
   2506                {
   2507                  return 0;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xE182             B.N      ??BlackLeftAgainForCross_7
   2508                }
   2509                else
   2510                {
   2511                }      
   2512              }
   2513              
   2514              //十字再检测第1阶段，找线头。
   2515              //temp = BlackGetLeftStep1Scan(Row2FirstLine, Row2LastLine, 0); //第3个参数0表示是十字再检测，不用更新3个关键值
   2516              
   2517              //十字再检测第1阶段，找线头，不采用Scan的方式，采用Win的方式。
   2518              temp = BlackGetLeftCrossSpeScan(Row2FirstLine, Row2LastLine, LastWinPredict);
   \                     ??BlackLeftAgainForCross_5: (+1)
   \   0000009E   0x001A             MOVS     R2,R3
   \   000000A0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000A2   0x0021             MOVS     R1,R4
   \   000000A4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A6   0x0030             MOVS     R0,R6
   \   000000A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AA   0x.... 0x....      BL       BlackGetLeftCrossSpeScan
   \   000000AE   0x4680             MOV      R8,R0
   2519              
   2520              //线头查找失败，或找到最远两行（继续执行后面会数组超出界限），就直接判定为失败。
   2521              if(
   2522                (temp == MaxValUint8)
   2523              ||(temp <= 1)
   2524              ||(BlackAgainForCrossFar10CutSwitch == 1 && temp <= 9)  //当远10行删除开关开启时，且十字再检测时的第2段黑线线头在最远的10行，则十字再检测失败。
   2525                )
   \   000000B0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000B4   0xF1B8 0x0FFF      CMP      R8,#+255
   \   000000B8   0xD009             BEQ.N    ??BlackLeftAgainForCross_8
   \   000000BA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000BE   0xF1B8 0x0F02      CMP      R8,#+2
   \   000000C2   0xDB04             BLT.N    ??BlackLeftAgainForCross_8
   \   000000C4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000C8   0xF1B8 0x0F0A      CMP      R8,#+10
   \   000000CC   0xDA0F             BGE.N    ??BlackLeftAgainForCross_9
   2526              {
   2527                //扫屁股工作。       //i >= Row2LastLine
   2528                for(i = Row2FirstLine; ; i--)
   \                     ??BlackLeftAgainForCross_8: (+1)
   \   000000CE   0x0030             MOVS     R0,R6
   \   000000D0   0xE000             B.N      ??BlackLeftAgainForCross_10
   \                     ??BlackLeftAgainForCross_11: (+1)
   \   000000D2   0x1E40             SUBS     R0,R0,#+1
   2529                {
   2530                  BlackLeftLoc[i][0] = MaxValUint8;
   \                     ??BlackLeftAgainForCross_10: (+1)
   \   000000D4   0x21FF             MOVS     R1,#+255
   \   000000D6   0x.... 0x....      LDR.W    R2,??DataTable17
   \   000000DA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DC   0x2303             MOVS     R3,#+3
   \   000000DE   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000E2   0x7011             STRB     R1,[R2, #+0]
   2531                  if(i == 0) break;
   \   000000E4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD1F3             BNE.N    ??BlackLeftAgainForCross_11
   2532                }
   2533                return 0;  
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0xE15A             B.N      ??BlackLeftAgainForCross_7
   2534              }
   2535              else 
   2536              {
   2537                ////////////////如果要注释，就从这里开始注释
   2538                
   2539                //十字再检测的线头不在限定的范围内，认为是干扰点，不用顺着线头找线了，直接退出。
   2540                if(BlackLeftCrossConfirm(Row1RealLastLine+1, temp) == 0)
   \                     ??BlackLeftAgainForCross_9: (+1)
   \   000000EE   0x4641             MOV      R1,R8
   \   000000F0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000F2   0x1C68             ADDS     R0,R5,#+1
   \   000000F4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F6   0x.... 0x....      BL       BlackLeftCrossConfirm
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD113             BNE.N    ??BlackLeftAgainForCross_12
   2541                { //扫屁股工作。       //i >= (temp-1)
   2542                  BlackLeftCrossConfirmFlag = 1;  //左十字线头标志确认失败，超出预想范围。
   \   000000FE   0x2001             MOVS     R0,#+1
   \   00000100   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   00000104   0x7008             STRB     R0,[R1, #+0]
   2543                  for(i = Row2FirstLine; ; i--)
   \   00000106   0x0030             MOVS     R0,R6
   \   00000108   0xE000             B.N      ??BlackLeftAgainForCross_13
   \                     ??BlackLeftAgainForCross_14: (+1)
   \   0000010A   0x1E40             SUBS     R0,R0,#+1
   2544                  {
   2545                    BlackLeftLoc[i][0] = MaxValUint8;
   \                     ??BlackLeftAgainForCross_13: (+1)
   \   0000010C   0x21FF             MOVS     R1,#+255
   \   0000010E   0x.... 0x....      LDR.W    R2,??DataTable17
   \   00000112   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000114   0x2303             MOVS     R3,#+3
   \   00000116   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000011A   0x7011             STRB     R1,[R2, #+0]
   2546                    if(i == 0) break;
   \   0000011C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD1F3             BNE.N    ??BlackLeftAgainForCross_14
   2547                  }
   2548                  return 0;
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0xE13E             B.N      ??BlackLeftAgainForCross_7
   2549                }
   2550                //十字再检测的线头的确在限定的范围内，可以继续。
   2551                else
   2552                {
   2553                  BlackLeftCrossConfirmFlag = 2;  //左十字线头标志确认成功。
   \                     ??BlackLeftAgainForCross_12: (+1)
   \   00000126   0x2002             MOVS     R0,#+2
   \   00000128   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   0000012C   0x7008             STRB     R0,[R1, #+0]
   2554                  row = temp;
   \   0000012E   0x4647             MOV      R7,R8
   2555                }
   2556                
   2557                ////////////////如果要注释，就从这里结束注释
   2558                
   2559                //暂时不用confirm函数，如果要用的话 ，就把后面这句话去掉，前面注释去掉。
   2560                //row = temp;
   2561              }
   2562              
   2563              Row2RealFirstLine = row; //记录第2段黑线的真实起始行
   \   00000130   0x003E             MOVS     R6,R7
   2564              
   2565              //十字再检测第2阶段，顺着线头找线。
   2566              //temp为预测的黑点位置
   2567              temp = BoundaryLimitRe(BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0],
   2568                                     0,
   2569                                     CameraRealWidth - 1);
   \   00000132   0x22F9             MOVS     R2,#+249
   \   00000134   0x2100             MOVS     R1,#+0
   \   00000136   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000013A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000013C   0x2303             MOVS     R3,#+3
   \   0000013E   0xFB03 0x0007      MLA      R0,R3,R7,R0
   \   00000142   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000146   0x.... 0x....      LDR.W    R3,??DataTable17
   \   0000014A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000014C   0xF05F 0x0C03      MOVS     R12,#+3
   \   00000150   0xFB0C 0x3307      MLA      R3,R12,R7,R3
   \   00000154   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   00000158   0xFA53 0xF080      UXTAB    R0,R3,R0
   \   0000015C   0x.... 0x....      LDR.W    R3,??DataTable17
   \   00000160   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000162   0xF05F 0x0C03      MOVS     R12,#+3
   \   00000166   0xFB0C 0x3307      MLA      R3,R12,R7,R3
   \   0000016A   0x781B             LDRB     R3,[R3, #+0]
   \   0000016C   0x1AC0             SUBS     R0,R0,R3
   \   0000016E   0x.... 0x....      BL       BoundaryLimitRe
   \   00000172   0x4680             MOV      R8,R0
   2570              //预测值更新后就刷新一次堆栈，堆栈顶部丢失。
   2571              BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
   \   00000174   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000178   0x7800             LDRB     R0,[R0, #+0]
   \   0000017A   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \   0000017E   0x7008             STRB     R0,[R1, #+0]
   2572              BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
   \   00000180   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000184   0x7800             LDRB     R0,[R0, #+0]
   \   00000186   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000018A   0x7008             STRB     R0,[R1, #+0]
   2573              BlackLeftWinPredictStore2 = temp;    
   \   0000018C   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000190   0xF880 0x8000      STRB     R8,[R0, #+0]
   2574              
   2575              //从最近的认证行到取最远的行
   2576              for(row -= 2; ; row -= 2)
   \   00000194   0x1EBF             SUBS     R7,R7,#+2
   \   00000196   0xE000             B.N      ??BlackLeftAgainForCross_15
   \                     ??BlackLeftAgainForCross_16: (+1)
   \   00000198   0x1EBF             SUBS     R7,R7,#+2
   2577              {
   2578                //连续2行检测黑点。
   2579                temp1 = BlackGetLeftStep2Win(row, BlackLeftWinVal, temp, 1);
   \                     ??BlackLeftAgainForCross_15: (+1)
   \   0000019A   0x2301             MOVS     R3,#+1
   \   0000019C   0x4642             MOV      R2,R8
   \   0000019E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001A0   0x210F             MOVS     R1,#+15
   \   000001A2   0x0038             MOVS     R0,R7
   \   000001A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001A6   0x.... 0x....      BL       BlackGetLeftStep2Win
   \   000001AA   0x4681             MOV      R9,R0
   2580                temp2 = BlackGetLeftStep2Win(row-1, BlackLeftWinVal, temp, 2);
   \   000001AC   0x2302             MOVS     R3,#+2
   \   000001AE   0x4642             MOV      R2,R8
   \   000001B0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001B2   0x210F             MOVS     R1,#+15
   \   000001B4   0x1E78             SUBS     R0,R7,#+1
   \   000001B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B8   0x.... 0x....      BL       BlackGetLeftStep2Win
   2581                
   2582                //若连续2行黑点检测成功，则对3个阈值进行更新，且更新预测点位置。
   2583                if(temp1 && temp2) 
   \   000001BC   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001C0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001C4   0xF000 0x8094      BEQ.W    ??BlackLeftAgainForCross_17
   \   000001C8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001CA   0x2800             CMP      R0,#+0
   \   000001CC   0xF000 0x8090      BEQ.W    ??BlackLeftAgainForCross_17
   2584                {
   2585                  //差值的处理，留有裕度，且有上下界。
   2586                  tempWB = (BlackLeftRealWB[0] + BlackLeftRealWB[1]) / 2 - LimitLeftWBMargin; 
   \   000001D0   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   000001D4   0x7800             LDRB     R0,[R0, #+0]
   \   000001D6   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   000001DA   0x7849             LDRB     R1,[R1, #+1]
   \   000001DC   0x1808             ADDS     R0,R1,R0
   \   000001DE   0x2102             MOVS     R1,#+2
   \   000001E0   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000001E4   0x3814             SUBS     R0,R0,#+20
   2587                  if(tempWB < LimitLeftWBMin) tempWB = LimitLeftWBMin;
   \   000001E6   0x....             LDR.N    R1,??DataTable15
   \   000001E8   0x7809             LDRB     R1,[R1, #+0]
   \   000001EA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001EC   0x4288             CMP      R0,R1
   \   000001EE   0xD202             BCS.N    ??BlackLeftAgainForCross_18
   \   000001F0   0x....             LDR.N    R0,??DataTable15
   \   000001F2   0x7800             LDRB     R0,[R0, #+0]
   \   000001F4   0xE006             B.N      ??BlackLeftAgainForCross_19
   2588                  else if(tempWB > LimitLeftWBMax) tempWB = LimitLeftWBMax;
   \                     ??BlackLeftAgainForCross_18: (+1)
   \   000001F6   0x....             LDR.N    R1,??DataTable15_1
   \   000001F8   0x7809             LDRB     R1,[R1, #+0]
   \   000001FA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001FC   0x4281             CMP      R1,R0
   \   000001FE   0xD201             BCS.N    ??BlackLeftAgainForCross_19
   \   00000200   0x....             LDR.N    R0,??DataTable15_1
   \   00000202   0x7800             LDRB     R0,[R0, #+0]
   2589                  else ;
   2590                  LimitLeftWB = tempWB;
   \                     ??BlackLeftAgainForCross_19: (+1)
   \   00000204   0x....             LDR.N    R1,??DataTable15_2
   \   00000206   0x7008             STRB     R0,[R1, #+0]
   2591                  
   2592                  //白点的处理，留有裕度，且有上下界。
   2593                  tempW = (BlackLeftRealW[0] + BlackLeftRealW[1]) / 2 - LimitLeftWMargin;
   \   00000208   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   0000020C   0x7800             LDRB     R0,[R0, #+0]
   \   0000020E   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000212   0x7849             LDRB     R1,[R1, #+1]
   \   00000214   0x1808             ADDS     R0,R1,R0
   \   00000216   0x2102             MOVS     R1,#+2
   \   00000218   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000021C   0x3828             SUBS     R0,R0,#+40
   2594                  if(tempW < LimitLeftWMin) tempW = LimitLeftWMin;
   \   0000021E   0x....             LDR.N    R1,??DataTable15_3
   \   00000220   0x7809             LDRB     R1,[R1, #+0]
   \   00000222   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000224   0x4288             CMP      R0,R1
   \   00000226   0xD202             BCS.N    ??BlackLeftAgainForCross_20
   \   00000228   0x....             LDR.N    R0,??DataTable15_3
   \   0000022A   0x7800             LDRB     R0,[R0, #+0]
   \   0000022C   0xE006             B.N      ??BlackLeftAgainForCross_21
   2595                  else if(tempW > LimitLeftWMax) tempW = LimitLeftWMax;
   \                     ??BlackLeftAgainForCross_20: (+1)
   \   0000022E   0x....             LDR.N    R1,??DataTable15_4
   \   00000230   0x7809             LDRB     R1,[R1, #+0]
   \   00000232   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000234   0x4281             CMP      R1,R0
   \   00000236   0xD201             BCS.N    ??BlackLeftAgainForCross_21
   \   00000238   0x....             LDR.N    R0,??DataTable15_4
   \   0000023A   0x7800             LDRB     R0,[R0, #+0]
   2596                  else ;
   2597                  LimitLeftW = tempW;
   \                     ??BlackLeftAgainForCross_21: (+1)
   \   0000023C   0x.... 0x....      LDR.W    R1,??DataTable20_4
   \   00000240   0x7008             STRB     R0,[R1, #+0]
   2598                  
   2599                  //黑点的处理，留有裕度，且有上下界。
   2600                  tempB = (BlackLeftRealB[0] + BlackLeftRealB[1]) / 2 + LimitLeftBMargin;
   \   00000242   0x....             LDR.N    R0,??DataTable15_7
   \   00000244   0x7800             LDRB     R0,[R0, #+0]
   \   00000246   0x....             LDR.N    R1,??DataTable15_7
   \   00000248   0x7849             LDRB     R1,[R1, #+1]
   \   0000024A   0x1808             ADDS     R0,R1,R0
   \   0000024C   0x2102             MOVS     R1,#+2
   \   0000024E   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000252   0x3023             ADDS     R0,R0,#+35
   2601                  if(tempB < LimitLeftBMin) tempB = LimitLeftBMin;
   \   00000254   0x....             LDR.N    R1,??DataTable15_5
   \   00000256   0x7809             LDRB     R1,[R1, #+0]
   \   00000258   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000025A   0x4288             CMP      R0,R1
   \   0000025C   0xD202             BCS.N    ??BlackLeftAgainForCross_22
   \   0000025E   0x....             LDR.N    R0,??DataTable15_5
   \   00000260   0x7800             LDRB     R0,[R0, #+0]
   \   00000262   0xE006             B.N      ??BlackLeftAgainForCross_23
   2602                  else if(tempB > LimitLeftBMax) tempB = LimitLeftBMax;
   \                     ??BlackLeftAgainForCross_22: (+1)
   \   00000264   0x....             LDR.N    R1,??DataTable15_6
   \   00000266   0x7809             LDRB     R1,[R1, #+0]
   \   00000268   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000026A   0x4281             CMP      R1,R0
   \   0000026C   0xD201             BCS.N    ??BlackLeftAgainForCross_23
   \   0000026E   0x....             LDR.N    R0,??DataTable15_6
   \   00000270   0x7800             LDRB     R0,[R0, #+0]
   2603                  else ;
   2604                  //黑色阈值不能超过白色
   2605                  if(tempB >= LimitLeftW)
   \                     ??BlackLeftAgainForCross_23: (+1)
   \   00000272   0x.... 0x....      LDR.W    R1,??DataTable20_4
   \   00000276   0x7809             LDRB     R1,[R1, #+0]
   \   00000278   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000027A   0x4288             CMP      R0,R1
   \   0000027C   0xD303             BCC.N    ??BlackLeftAgainForCross_24
   2606                  {
   2607                    tempB = LimitLeftW - 1;
   \   0000027E   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   00000282   0x7800             LDRB     R0,[R0, #+0]
   \   00000284   0x1E40             SUBS     R0,R0,#+1
   2608                  }
   2609                  else
   2610                  {
   2611                  }
   2612                  LimitLeftB = tempB;
   \                     ??BlackLeftAgainForCross_24: (+1)
   \   00000286   0x.... 0x....      LDR.W    R1,??DataTable19_2
   \   0000028A   0x7008             STRB     R0,[R1, #+0]
   2613                  
   2614                  //预测点更新，并限幅
   2615                  temp = BoundaryLimitRe(BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0],
   2616                                         0,
   2617                                         CameraRealWidth - 1);
   \   0000028C   0x22F9             MOVS     R2,#+249
   \   0000028E   0x2100             MOVS     R1,#+0
   \   00000290   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000294   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000296   0x2303             MOVS     R3,#+3
   \   00000298   0xFB03 0x0007      MLA      R0,R3,R7,R0
   \   0000029C   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000002A0   0x.... 0x....      LDR.W    R3,??DataTable17
   \   000002A4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002A6   0xF05F 0x0C03      MOVS     R12,#+3
   \   000002AA   0xFB0C 0x3307      MLA      R3,R12,R7,R3
   \   000002AE   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   000002B2   0xFA53 0xF080      UXTAB    R0,R3,R0
   \   000002B6   0x.... 0x....      LDR.W    R3,??DataTable17
   \   000002BA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002BC   0xF05F 0x0C03      MOVS     R12,#+3
   \   000002C0   0xFB0C 0x3307      MLA      R3,R12,R7,R3
   \   000002C4   0x781B             LDRB     R3,[R3, #+0]
   \   000002C6   0x1AC0             SUBS     R0,R0,R3
   \   000002C8   0x.... 0x....      BL       BoundaryLimitRe
   \   000002CC   0x4680             MOV      R8,R0
   2618                  //预测值更新后就刷新一次堆栈，堆栈顶部丢失。
   2619                  BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
   \   000002CE   0x.... 0x....      LDR.W    R0,??DataTable19
   \   000002D2   0x7800             LDRB     R0,[R0, #+0]
   \   000002D4   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \   000002D8   0x7008             STRB     R0,[R1, #+0]
   2620                  BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
   \   000002DA   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000002DE   0x7800             LDRB     R0,[R0, #+0]
   \   000002E0   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000002E4   0x7008             STRB     R0,[R1, #+0]
   2621                  BlackLeftWinPredictStore2 = temp;
   \   000002E6   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000002EA   0xF880 0x8000      STRB     R8,[R0, #+0]
   \   000002EE   0xE01F             B.N      ??BlackLeftAgainForCross_25
   2622                }
   2623                //如果没能连续两行检测黑点成功，原本打算用原位置的预测点，后来发现效果不好，所以决定按预测点的趋势走。
   2624                else
   2625                {
   2626                  //预测点按趋势走也要限幅。
   2627                  tempminus = BoundaryLimitRe(BlackLeftWinPredictStore2 + BlackLeftWinPredictStore2 - BlackLeftWinPredictStore1,
   2628                                              0,
   2629                                              CameraRealWidth - 1);
   \                     ??BlackLeftAgainForCross_17: (+1)
   \   000002F0   0x22F9             MOVS     R2,#+249
   \   000002F2   0x2100             MOVS     R1,#+0
   \   000002F4   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000002F8   0x7800             LDRB     R0,[R0, #+0]
   \   000002FA   0x.... 0x....      LDR.W    R3,??DataTable20
   \   000002FE   0x781B             LDRB     R3,[R3, #+0]
   \   00000300   0x1818             ADDS     R0,R3,R0
   \   00000302   0x.... 0x....      LDR.W    R3,??DataTable19
   \   00000306   0x781B             LDRB     R3,[R3, #+0]
   \   00000308   0x1AC0             SUBS     R0,R0,R3
   \   0000030A   0x.... 0x....      BL       BoundaryLimitRe
   \   0000030E   0x4680             MOV      R8,R0
   2630                  //temp在这里表示窗口预测点位置。
   2631                  temp = tempminus;
   2632                  BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
   \   00000310   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000314   0x7800             LDRB     R0,[R0, #+0]
   \   00000316   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \   0000031A   0x7008             STRB     R0,[R1, #+0]
   2633                  BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
   \   0000031C   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000320   0x7800             LDRB     R0,[R0, #+0]
   \   00000322   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000326   0x7008             STRB     R0,[R1, #+0]
   2634                  BlackLeftWinPredictStore2 = temp;
   \   00000328   0x.... 0x....      LDR.W    R0,??DataTable20
   \   0000032C   0xF880 0x8000      STRB     R8,[R0, #+0]
   2635                }       
   2636                
   2637                if((row == Row2LastLine) || (row == Row2LastLine+1)) break;      
   \                     ??BlackLeftAgainForCross_25: (+1)
   \   00000330   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000332   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000334   0x42A7             CMP      R7,R4
   \   00000336   0xD005             BEQ.N    ??BlackLeftAgainForCross_26
   \   00000338   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000033A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000033C   0x1C60             ADDS     R0,R4,#+1
   \   0000033E   0x4287             CMP      R7,R0
   \   00000340   0xF47F 0xAF2A      BNE.W    ??BlackLeftAgainForCross_16
   2638              }
   2639              
   2640              //检查是否因大斜率而被削头。如果有，则更新头的位置，如果没有，则正常补线。
   2641              if (BlackLeftLoc[Row1RealLastLine][0] == MaxValUint8)
   \                     ??BlackLeftAgainForCross_26: (+1)
   \   00000344   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000348   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000034A   0x2103             MOVS     R1,#+3
   \   0000034C   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000350   0x7800             LDRB     R0,[R0, #+0]
   \   00000352   0x28FF             CMP      R0,#+255
   \   00000354   0xD11B             BNE.N    ??BlackLeftAgainForCross_27
   2642              {
   2643          
   2644                  //头足够高，找回头。
   2645                  for (i = Row1RealLastLine; ; i++)
   \   00000356   0x0028             MOVS     R0,R5
   \   00000358   0xE000             B.N      ??BlackLeftAgainForCross_28
   \                     ??BlackLeftAgainForCross_29: (+1)
   \   0000035A   0x1C40             ADDS     R0,R0,#+1
   2646                  {
   2647                      if (BlackLeftLoc[i][0] != MaxValUint8)
   \                     ??BlackLeftAgainForCross_28: (+1)
   \   0000035C   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000360   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000362   0x2203             MOVS     R2,#+3
   \   00000364   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   00000368   0x7809             LDRB     R1,[R1, #+0]
   \   0000036A   0x29FF             CMP      R1,#+255
   \   0000036C   0xD00A             BEQ.N    ??BlackLeftAgainForCross_30
   2648                      {
   2649                          Row1RealLastLine = i;
   \   0000036E   0x0005             MOVS     R5,R0
   2650                          break;
   2651                      }
   2652                      else
   2653                      {
   2654                      }
   2655                      //直到最后一行也没有找到有效行，不用补线，直接返回1.
   2656                      if (i == CameraHight - 1) return 1;
   2657                  }
   2658          
   2659                  //十字再检测第3阶段，脑补两段线的接线。
   2660                  if (BlackLeftCrossStep3(Row1RealLastLine, Row2RealFirstLine) == 0)
   \   00000370   0x0031             MOVS     R1,R6
   \   00000372   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000374   0x0028             MOVS     R0,R5
   \   00000376   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000378   0x.... 0x....      BL       BlackLeftCrossStep3
   \   0000037C   0x2800             CMP      R0,#+0
   \   0000037E   0xD110             BNE.N    ??BlackLeftAgainForCross_31
   2661                  {
   2662                      return 0;
   \   00000380   0x2000             MOVS     R0,#+0
   \   00000382   0xE00F             B.N      ??BlackLeftAgainForCross_7
   2663                  }
   \                     ??BlackLeftAgainForCross_30: (+1)
   \   00000384   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000386   0x283B             CMP      R0,#+59
   \   00000388   0xD1E7             BNE.N    ??BlackLeftAgainForCross_29
   \   0000038A   0x2001             MOVS     R0,#+1
   \   0000038C   0xE00A             B.N      ??BlackLeftAgainForCross_7
   2664          
   2665              }
   2666              else
   2667              {
   2668                  //没有被大斜率削头。
   2669                  //十字再检测第3阶段，脑补两段线的接线。
   2670                  if (BlackLeftCrossStep3(Row1RealLastLine, Row2RealFirstLine) == 0)
   \                     ??BlackLeftAgainForCross_27: (+1)
   \   0000038E   0x0031             MOVS     R1,R6
   \   00000390   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000392   0x0028             MOVS     R0,R5
   \   00000394   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000396   0x.... 0x....      BL       BlackLeftCrossStep3
   \   0000039A   0x2800             CMP      R0,#+0
   \   0000039C   0xD101             BNE.N    ??BlackLeftAgainForCross_31
   2671                  {
   2672                      return 0;
   \   0000039E   0x2000             MOVS     R0,#+0
   \   000003A0   0xE000             B.N      ??BlackLeftAgainForCross_7
   2673                  }
   2674              }
   2675          
   2676              
   2677              return 1;
   \                     ??BlackLeftAgainForCross_31: (+1)
   \   000003A2   0x2001             MOVS     R0,#+1
   \                     ??BlackLeftAgainForCross_7: (+1)
   \   000003A4   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   2678                  
   2679          }
   2680          
   2681          //======================================================================
   2682          //函数名：BlackLeftStep4BackLine
   2683          //功  能：左黑线提取中，第4阶段十字向后补线函数。
   2684          //参  数：Step4StartLine开始行，flag标志0表示正常调用，1表示单线错误的调用
   2685          //返  回：1成功 0失败
   2686          //影  响：BlackLeftLoc[][0]
   2687          //说  明：1. 这里引用了float型的函数，有可能占用较长的时间。
   2688          //        2. 想要减少时间，可以把宏定义BlackBackLineNum减至3或者2.
   2689          //        3. 单线错误的调用时，不用检测十字外尾     
   2690          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   2691          uint8 BlackLeftStep4BackLine(uint8 Step4StartLine, uint8 flag)
   2692          {
   \                     BlackLeftStep4BackLine: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   2693            uint8 row;
   2694            uint8 i, index;
   2695            uint8 x[BlackBackLineNum];   //取多少个点在一开始有定义。
   2696            uint8 y[BlackBackLineNum];
   2697            uint8 j;
   2698            uint8 temp1;
   2699            uint8 tempend;
   2700            
   2701            int32 temp;
   2702            int32 a0;
   2703            int32 a1;
   2704            
   2705            //正常调用时，需要检测十字外尾
   2706            if(flag == 0)
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xF040 0x80CF      BNE.W    ??BlackLeftStep4BackLine_0
   2707            {
   2708              //十字外尾处理
   2709              //第1阶段的线头比较高的话，就开始十字外尾检测。否则不用管。
   2710              if(BlackLeftStep1ScanRow < BlackLeftCrossTailRowLimit)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2832             CMP      R0,#+50
   \   00000016   0xF280 0x80C5      BGE.W    ??BlackLeftStep4BackLine_1
   2711              {
   2712                //检查线头处的斜率是不是很大，若很大，则怀疑有十字外尾。否则不用管。
   2713                //这里用的斜率是十字外尾专用斜率。
   2714                if(BlackLeft5Slope[0] + BlackLeftCrossTailSlopeLimit < 0 || AbsInt(BlackLeft5Slope[0])>BlackLeftCrossTailSlopeLimit)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable20_6
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF600 0x5048      ADDW     R0,R0,#+3400
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD409             BMI.N    ??BlackLeftStep4BackLine_2
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable20_6
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x.... 0x....      BL       AbsInt
   \   00000032   0xF640 0x5149      MOVW     R1,#+3401
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xF2C0 0x80AF      BLT.W    ??BlackLeftStep4BackLine_3
   2715                {
   2716                  //十字外尾标志置位。
   2717                  BlackLeftCrossTailFlag = 1;
   \                     ??BlackLeftStep4BackLine_2: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   00000042   0x7008             STRB     R0,[R1, #+0]
   2718                  BlackLeftHeadEndSearch();
   \   00000044   0x.... 0x....      BL       BlackLeftHeadEndSearch
   2719                  if (BlackLeftEndLine - BlackLeftHeadLine<=8 && BlackLeftHeadLine!=MaxValUint8 && BlackLeftEndLine!=MaxValUint8)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable20_8
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable20_9
   \   00000052   0x7809             LDRB     R1,[R1, #+0]
   \   00000054   0x1A40             SUBS     R0,R0,R1
   \   00000056   0x2809             CMP      R0,#+9
   \   00000058   0xDA1E             BGE.N    ??BlackLeftStep4BackLine_4
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable20_9
   \   0000005E   0x7800             LDRB     R0,[R0, #+0]
   \   00000060   0x28FF             CMP      R0,#+255
   \   00000062   0xD019             BEQ.N    ??BlackLeftStep4BackLine_4
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable20_8
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0x28FF             CMP      R0,#+255
   \   0000006C   0xD014             BEQ.N    ??BlackLeftStep4BackLine_4
   2720                  {
   2721                      //这种情况有可能是回弯导致的，过滤掉
   2722                      for (i = BlackLeftHeadLine; i <= BlackLeftEndLine; i++)
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable20_9
   \   00000072   0x7800             LDRB     R0,[R0, #+0]
   \   00000074   0xE008             B.N      ??BlackLeftStep4BackLine_5
   2723                      {
   2724                          BlackLeftLoc[i][0] = MaxValUint8;
   \                     ??BlackLeftStep4BackLine_6: (+1)
   \   00000076   0x21FF             MOVS     R1,#+255
   \   00000078   0x.... 0x....      LDR.W    R2,??DataTable17
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x2303             MOVS     R3,#+3
   \   00000080   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000084   0x7011             STRB     R1,[R2, #+0]
   2725                      }
   \   00000086   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackLeftStep4BackLine_5: (+1)
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable20_8
   \   0000008C   0x7809             LDRB     R1,[R1, #+0]
   \   0000008E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000090   0x4281             CMP      R1,R0
   \   00000092   0xD2F0             BCS.N    ??BlackLeftStep4BackLine_6
   2726                      return 0;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xE0F6             B.N      ??BlackLeftStep4BackLine_7
   2727                  }
   2728                  else if (BlackLeft5Slope[0] == MaxValInt16)
   \                     ??BlackLeftStep4BackLine_4: (+1)
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable20_6
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0xF647 0x71FF      MOVW     R1,#+32767
   \   000000A2   0x4288             CMP      R0,R1
   \   000000A4   0xD10F             BNE.N    ??BlackLeftStep4BackLine_8
   2729                  {
   2730                      //这种情况有可能是回弯导致的，过滤掉
   2731                      for (i = 0; i <= 59; i++)
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xE008             B.N      ??BlackLeftStep4BackLine_9
   2732                      {
   2733                          BlackLeftLoc[i][0] = MaxValUint8;
   \                     ??BlackLeftStep4BackLine_10: (+1)
   \   000000AA   0x21FF             MOVS     R1,#+255
   \   000000AC   0x.... 0x....      LDR.W    R2,??DataTable17
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0x2303             MOVS     R3,#+3
   \   000000B4   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000B8   0x7011             STRB     R1,[R2, #+0]
   2734                      }
   \   000000BA   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackLeftStep4BackLine_9: (+1)
   \   000000BC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BE   0x283C             CMP      R0,#+60
   \   000000C0   0xDBF3             BLT.N    ??BlackLeftStep4BackLine_10
   2735                      return 0;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xE0DF             B.N      ??BlackLeftStep4BackLine_7
   2736                  }
   2737                  //5Slope数组有可能已经删掉了一些黑点，所以也要参考实际的有效黑点数。
   2738                  if(BlackLeftEndLine - BlackLeftHeadLine - 4 < 0 || BlackLeft5SlopeIndex - 1 < 0)
   \                     ??BlackLeftStep4BackLine_8: (+1)
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable20_8
   \   000000CA   0x7800             LDRB     R0,[R0, #+0]
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable20_9
   \   000000D0   0x7809             LDRB     R1,[R1, #+0]
   \   000000D2   0x1A40             SUBS     R0,R0,R1
   \   000000D4   0x1F00             SUBS     R0,R0,#+4
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD405             BMI.N    ??BlackLeftStep4BackLine_11
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable20_10
   \   000000DE   0x7800             LDRB     R0,[R0, #+0]
   \   000000E0   0x1E40             SUBS     R0,R0,#+1
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD501             BPL.N    ??BlackLeftStep4BackLine_12
   2739                  {
   2740                    return 0;
   \                     ??BlackLeftStep4BackLine_11: (+1)
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0xE0CD             B.N      ??BlackLeftStep4BackLine_7
   2741                  }
   2742                  else
   2743                  {
   2744                  }        
   2745                  tempend = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 4, BlackLeft5SlopeIndex - 1);
   \                     ??BlackLeftStep4BackLine_12: (+1)
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable20_10
   \   000000EE   0x7800             LDRB     R0,[R0, #+0]
   \   000000F0   0x1E41             SUBS     R1,R0,#+1
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable20_8
   \   000000F6   0x7800             LDRB     R0,[R0, #+0]
   \   000000F8   0x.... 0x....      LDR.W    R2,??DataTable20_9
   \   000000FC   0x7812             LDRB     R2,[R2, #+0]
   \   000000FE   0x1A80             SUBS     R0,R0,R2
   \   00000100   0x1F00             SUBS     R0,R0,#+4
   \   00000102   0x.... 0x....      BL       MinRe
   \   00000106   0x0001             MOVS     R1,R0
   2746                  //开始消除十字外尾，找十字外尾的处理最远行。              
   2747                  for(i = 0; ; i++)
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0xE000             B.N      ??BlackLeftStep4BackLine_13
   \                     ??BlackLeftStep4BackLine_14: (+1)
   \   0000010C   0x1C40             ADDS     R0,R0,#+1
   2748                  {
   2749                    //找斜率在直道范围内的。这里用的斜率是判断为直道的斜率。
   2750                    if(BlackLeft5Slope[i] + PathJudgeStraightSlopeLimit > 0)
   \                     ??BlackLeftStep4BackLine_13: (+1)
   \   0000010E   0x.... 0x....      LDR.W    R2,??DataTable20_6
   \   00000112   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000114   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000118   0xF602 0x0234      ADDW     R2,R2,#+2100
   \   0000011C   0x2A01             CMP      R2,#+1
   \   0000011E   0xDB22             BLT.N    ??BlackLeftStep4BackLine_15
   2751                    {
   2752                      BlackLeftCrossTailEndLine = BlackLeft5SlopeRow[i];
   \   00000120   0x.... 0x....      LDR.W    R1,??DataTable20_11
   \   00000124   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000126   0x5C40             LDRB     R0,[R0, R1]
   \   00000128   0x.... 0x....      LDR.W    R1,??DataTable20_12
   \   0000012C   0x7008             STRB     R0,[R1, #+0]
   2753                      break;
   2754                    }
   2755                    
   2756                    if(i == tempend) return 0;  //一直都很斜，则有可能是回弯，直接返回失败。
   2757                    //按理说不会走到这里，因为回弯会导致向后补线出错，向后补线出错后进来本函数时会先检查出错的原因BlackLeftStep4ErrorCheck()，会检测斜率是不是都是直线，若不是则不会进来。
   2758                  }
   2759                  //向近处4个点，也就是“5”点斜率的计算末尾。
   2760                  BlackLeftCrossTailEndLine += 4;
   \   0000012E   0x.... 0x....      LDR.W    R0,??DataTable20_12
   \   00000132   0x7800             LDRB     R0,[R0, #+0]
   \   00000134   0x1D00             ADDS     R0,R0,#+4
   \   00000136   0x.... 0x....      LDR.W    R1,??DataTable20_12
   \   0000013A   0x7008             STRB     R0,[R1, #+0]
   2761                  //取最先采集到的行。
   2762                  i = MinRe(BlackLeft5SlopeRow[0] + 4, CameraHight - 1);
   \   0000013C   0x213B             MOVS     R1,#+59
   \   0000013E   0x.... 0x....      LDR.W    R0,??DataTable20_11
   \   00000142   0x7800             LDRB     R0,[R0, #+0]
   \   00000144   0x1D00             ADDS     R0,R0,#+4
   \   00000146   0x.... 0x....      BL       MinRe
   2763                  i = MaxRe(BlackLeftStep1ScanRow, i);
   \   0000014A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014C   0x0001             MOVS     R1,R0
   \   0000014E   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   00000152   0x7800             LDRB     R0,[R0, #+0]
   \   00000154   0x.... 0x....      BL       MaxRe
   2764                  if(i >= BlackLeftCrossTailEndLine)
   \   00000158   0x.... 0x....      LDR.W    R1,??DataTable20_12
   \   0000015C   0x7809             LDRB     R1,[R1, #+0]
   \   0000015E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000160   0x4288             CMP      R0,R1
   \   00000162   0xD323             BCC.N    ??BlackLeftStep4BackLine_0
   \   00000164   0xE006             B.N      ??BlackLeftStep4BackLine_16
   \                     ??BlackLeftStep4BackLine_15: (+1)
   \   00000166   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000168   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000016A   0x4288             CMP      R0,R1
   \   0000016C   0xD1CE             BNE.N    ??BlackLeftStep4BackLine_14
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0xE089             B.N      ??BlackLeftStep4BackLine_7
   2765                  {
   2766                    //开始删除十字外尾。
   2767                    for(; ; i--)
   \                     ??BlackLeftStep4BackLine_17: (+1)
   \   00000172   0x1E40             SUBS     R0,R0,#+1
   2768                    {
   2769                      BlackLeftLoc[i][0] = MaxValUint8;
   \                     ??BlackLeftStep4BackLine_16: (+1)
   \   00000174   0x21FF             MOVS     R1,#+255
   \   00000176   0x.... 0x....      LDR.W    R2,??DataTable17
   \   0000017A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000017C   0x2303             MOVS     R3,#+3
   \   0000017E   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000182   0x7011             STRB     R1,[R2, #+0]
   2770                      if(i == BlackLeftCrossTailEndLine) break;
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable20_12
   \   00000188   0x7809             LDRB     R1,[R1, #+0]
   \   0000018A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000018C   0x4288             CMP      R0,R1
   \   0000018E   0xD1F0             BNE.N    ??BlackLeftStep4BackLine_17
   2771                    }
   2772                    //修改向后补线的起点。
   2773                    Step4StartLine = BlackLeftCrossTailEndLine - 1;
   \   00000190   0x.... 0x....      LDR.W    R0,??DataTable20_12
   \   00000194   0x7800             LDRB     R0,[R0, #+0]
   \   00000196   0x1E44             SUBS     R4,R0,#+1
   \   00000198   0xE008             B.N      ??BlackLeftStep4BackLine_0
   2774                  }
   2775                  else
   2776                  {
   2777                  }
   2778                }
   2779                else
   2780                {
   2781                  //没有十字外尾。
   2782                  BlackLeftCrossTailFlag = 0;      
   \                     ??BlackLeftStep4BackLine_3: (+1)
   \   0000019A   0x2000             MOVS     R0,#+0
   \   0000019C   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   000001A0   0x7008             STRB     R0,[R1, #+0]
   \   000001A2   0xE003             B.N      ??BlackLeftStep4BackLine_0
   2783                }
   2784              }
   2785              else
   2786              {    
   2787                //没有十字外尾。
   2788                BlackLeftCrossTailFlag = 0;
   \                     ??BlackLeftStep4BackLine_1: (+1)
   \   000001A4   0x2000             MOVS     R0,#+0
   \   000001A6   0x.... 0x....      LDR.W    R1,??DataTable20_7
   \   000001AA   0x7008             STRB     R0,[R1, #+0]
   2789              }
   2790            }
   2791            //单线错误调用时，就不用检测十字外尾了。
   2792            else
   2793            {
   2794            }
   2795           
   2796            //正常的十字向后补线。
   2797            if(Step4StartLine - BlackBackLineNum - BlackBackLineNum < 0)
   \                     ??BlackLeftStep4BackLine_0: (+1)
   \   000001AC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001AE   0xF1B4 0x0008      SUBS     R0,R4,#+8
   \   000001B2   0x2800             CMP      R0,#+0
   \   000001B4   0xD501             BPL.N    ??BlackLeftStep4BackLine_18
   2798            {
   2799              temp1 = 0;    
   \   000001B6   0x2200             MOVS     R2,#+0
   \   000001B8   0xE001             B.N      ??BlackLeftStep4BackLine_19
   2800            }
   2801            else
   2802            {
   2803              temp1 = Step4StartLine - BlackBackLineNum - BlackBackLineNum;
   \                     ??BlackLeftStep4BackLine_18: (+1)
   \   000001BA   0xF1B4 0x0208      SUBS     R2,R4,#+8
   2804            }
   2805            
   2806            //取BlackBackLineNum个点作为最小二乘法的基准点。
   2807            //以左上角为原点，向下为x轴正方向，向右为y轴正方向
   2808            index = 0;
   \                     ??BlackLeftStep4BackLine_19: (+1)
   \   000001BE   0x2100             MOVS     R1,#+0
   2809            for(i = Step4StartLine; ; i--)
   \   000001C0   0x0020             MOVS     R0,R4
   \   000001C2   0xE000             B.N      ??BlackLeftStep4BackLine_20
   \                     ??BlackLeftStep4BackLine_21: (+1)
   \   000001C4   0x1E40             SUBS     R0,R0,#+1
   2810            {
   2811              if(BlackLeftLoc[i][0] != MaxValUint8)
   \                     ??BlackLeftStep4BackLine_20: (+1)
   \   000001C6   0x.... 0x....      LDR.W    R3,??DataTable17
   \   000001CA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001CC   0x2503             MOVS     R5,#+3
   \   000001CE   0xFB05 0x3300      MLA      R3,R5,R0,R3
   \   000001D2   0x781B             LDRB     R3,[R3, #+0]
   \   000001D4   0x2BFF             CMP      R3,#+255
   \   000001D6   0xD00D             BEQ.N    ??BlackLeftStep4BackLine_22
   2812              {
   2813                y[index] = BlackLeftLoc[i][0];
   \   000001D8   0x.... 0x....      LDR.W    R3,??DataTable17
   \   000001DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001DE   0x2503             MOVS     R5,#+3
   \   000001E0   0xFB05 0x3300      MLA      R3,R5,R0,R3
   \   000001E4   0x781B             LDRB     R3,[R3, #+0]
   \   000001E6   0xAD00             ADD      R5,SP,#+0
   \   000001E8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001EA   0x554B             STRB     R3,[R1, R5]
   2814                x[index] = i;
   \   000001EC   0xAB01             ADD      R3,SP,#+4
   \   000001EE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001F0   0x54C8             STRB     R0,[R1, R3]
   2815                index++;
   \   000001F2   0x1C49             ADDS     R1,R1,#+1
   2816              }
   2817              if(index == BlackBackLineNum)
   \                     ??BlackLeftStep4BackLine_22: (+1)
   \   000001F4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001F6   0x2904             CMP      R1,#+4
   \   000001F8   0xD10D             BNE.N    ??BlackLeftStep4BackLine_23
   2818              {
   2819                break;  
   2820              }
   2821              if(i == temp1)
   2822              {
   2823                return 0;
   2824              }
   2825            }
   2826            
   2827            //最小二乘法
   2828            //y = a0 + a1 * x
   2829            a1 = LeastSquarea1(x, y, BlackBackLineNum);
   \   000001FA   0x2204             MOVS     R2,#+4
   \   000001FC   0xA900             ADD      R1,SP,#+0
   \   000001FE   0xA801             ADD      R0,SP,#+4
   \   00000200   0x.... 0x....      BL       LeastSquarea1
   \   00000204   0x0005             MOVS     R5,R0
   2830            /*
   2831            //如果直线是从左上到右下，则说明是取到了错误的线，不必再补线，全数组清零。
   2832            if(a1 > BlackLeftBackLineSlope)
   2833            {
   2834              for(row = Step4StartLine; ; row--)
   2835              {
   2836                BlackLeftLoc[row][0] = MaxValUint8;
   2837                if(row == 0) break;
   2838              }
   2839              return 0;
   2840            }
   2841            //否则继续。
   2842            else
   2843            {
   2844            }
   2845            */
   2846            
   2847            
   2848            //直着补，不是顺着补。
   2849            /*
   2850            for (row = Step4StartLine + 1; row <= CameraHight - 1; row++)
   2851            {
   2852              BlackLeftLoc[row][0] = BlackLeftLoc[Step4StartLine][0];
   2853            }
   2854            */
   2855            
   2856            //顺着补，不是直着补。
   2857            a0 = LeastSquarea0(x, y, a1, BlackBackLineNum);
   \   00000206   0x2304             MOVS     R3,#+4
   \   00000208   0x002A             MOVS     R2,R5
   \   0000020A   0xA900             ADD      R1,SP,#+0
   \   0000020C   0xA801             ADD      R0,SP,#+4
   \   0000020E   0x.... 0x....      BL       LeastSquarea0
   2858            
   2859            for(row = Step4StartLine + 1; row <= CameraHight - 1; row++)
   \   00000212   0x1C61             ADDS     R1,R4,#+1
   \   00000214   0xE00D             B.N      ??BlackLeftStep4BackLine_24
   \                     ??BlackLeftStep4BackLine_23: (+1)
   \   00000216   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000218   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000021A   0x4290             CMP      R0,R2
   \   0000021C   0xD1D2             BNE.N    ??BlackLeftStep4BackLine_21
   \   0000021E   0x2000             MOVS     R0,#+0
   \   00000220   0xE031             B.N      ??BlackLeftStep4BackLine_7
   2860            {
   2861              //补线也有个度，向左向右都不能补出范围。
   2862              temp = (a0 + a1 * row) / LeastSquareMulti;
   2863              if(temp >= CameraRealWidth-1)
   2864              {
   2865                //BlackLeftLoc[row][0] = CameraRealWidth - 1;
   2866                //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。
   2867                for(j = row; ; j++)
   2868                {
   2869                  BlackLeftLoc[j][0] = CameraRealWidth-1;
   2870                  if(j == CameraHight - 1) break;
   2871                }
   2872                break;
   2873              }
   2874              else if(temp <= 0)
   2875              {
   2876                //BlackLeftLoc[row][0] = 0;
   2877                //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。
   2878                for(j = row; ; j++)
   2879                {
   2880                  BlackLeftLoc[j][0] = 0;
   2881                  if(j == CameraHight - 1) break;
   2882                }
   2883                break;
   2884              }
   2885              else
   2886              {
   2887                BlackLeftLoc[row][0] = (uint8)(temp); 
   \                     ??BlackLeftStep4BackLine_25: (+1)
   \   00000222   0x.... 0x....      LDR.W    R3,??DataTable17
   \   00000226   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000228   0x2403             MOVS     R4,#+3
   \   0000022A   0xFB04 0x3301      MLA      R3,R4,R1,R3
   \   0000022E   0x701A             STRB     R2,[R3, #+0]
   2888              }
   \   00000230   0x1C49             ADDS     R1,R1,#+1
   \                     ??BlackLeftStep4BackLine_24: (+1)
   \   00000232   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000234   0x293C             CMP      R1,#+60
   \   00000236   0xDA25             BGE.N    ??BlackLeftStep4BackLine_26
   \   00000238   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000023A   0xFB01 0x0205      MLA      R2,R1,R5,R0
   \   0000023E   0xF44F 0x737A      MOV      R3,#+1000
   \   00000242   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \   00000246   0x2AF9             CMP      R2,#+249
   \   00000248   0xDB0D             BLT.N    ??BlackLeftStep4BackLine_27
   \   0000024A   0xE000             B.N      ??BlackLeftStep4BackLine_28
   \                     ??BlackLeftStep4BackLine_29: (+1)
   \   0000024C   0x1C49             ADDS     R1,R1,#+1
   \                     ??BlackLeftStep4BackLine_28: (+1)
   \   0000024E   0x20F9             MOVS     R0,#+249
   \   00000250   0x.... 0x....      LDR.W    R2,??DataTable17
   \   00000254   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000256   0x2303             MOVS     R3,#+3
   \   00000258   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   0000025C   0x7010             STRB     R0,[R2, #+0]
   \   0000025E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000260   0x293B             CMP      R1,#+59
   \   00000262   0xD1F3             BNE.N    ??BlackLeftStep4BackLine_29
   \   00000264   0xE00E             B.N      ??BlackLeftStep4BackLine_26
   \                     ??BlackLeftStep4BackLine_27: (+1)
   \   00000266   0x2A01             CMP      R2,#+1
   \   00000268   0xDADB             BGE.N    ??BlackLeftStep4BackLine_25
   \   0000026A   0xE000             B.N      ??BlackLeftStep4BackLine_30
   \                     ??BlackLeftStep4BackLine_31: (+1)
   \   0000026C   0x1C49             ADDS     R1,R1,#+1
   \                     ??BlackLeftStep4BackLine_30: (+1)
   \   0000026E   0x2000             MOVS     R0,#+0
   \   00000270   0x.... 0x....      LDR.W    R2,??DataTable17
   \   00000274   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000276   0x2303             MOVS     R3,#+3
   \   00000278   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   0000027C   0x7010             STRB     R0,[R2, #+0]
   \   0000027E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000280   0x293B             CMP      R1,#+59
   \   00000282   0xD1F3             BNE.N    ??BlackLeftStep4BackLine_31
   2889            }
   2890            
   2891            
   2892            
   2893            return 1;
   \                     ??BlackLeftStep4BackLine_26: (+1)
   \   00000284   0x2001             MOVS     R0,#+1
   \                     ??BlackLeftStep4BackLine_7: (+1)
   \   00000286   0xBD3E             POP      {R1-R5,PC}       ;; return
   2894            
   2895          }
   2896          
   2897          
   2898          
   2899          
   2900          //左黑线连续性补线

   \                                 In section .text, align 2, keep-with-next
   2901          uint8 BlackLeftContinueAdd(void)
   2902          {
   \                     BlackLeftContinueAdd: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   2903              uint8 row, i, j;
   2904              uint8 tempfirst, templast;
   2905              uint8 fangHuiWanFlag =0;
   \   00000002   0x2400             MOVS     R4,#+0
   2906              uint8 fangDuanLieFlag = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   2907              
   2908              //左黑线连续性补线
   2909              //只有左黑线采集成功才补线
   2910              if(BlackLeftDone == 1)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable20_13
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xF040 0x81DD      BNE.W    ??BlackLeftContinueAdd_0
   2911              {        
   2912                  //找线尾
   2913                  for(row = CameraHight - 1; ; row--)
   \   00000012   0x203B             MOVS     R0,#+59
   \   00000014   0xE000             B.N      ??BlackLeftContinueAdd_1
   \                     ??BlackLeftContinueAdd_2: (+1)
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   2914                  {
   2915                    if(BlackLeftLoc[row][0] != MaxValUint8)
   \                     ??BlackLeftContinueAdd_1: (+1)
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable17
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x2203             MOVS     R2,#+3
   \   00000020   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   00000024   0x7809             LDRB     R1,[R1, #+0]
   \   00000026   0x29FF             CMP      R1,#+255
   \   00000028   0xD002             BEQ.N    ??BlackLeftContinueAdd_3
   2916                    {
   2917                      break;
   2918                    }
   2919                    else
   2920                    {
   2921                    }
   2922                    
   2923                    if(row == 0)
   2924                    {
   2925                      BlackLeftDone = 0;
   2926                      return 0;
   2927                    }
   2928                  }
   2929                  
   2930                  //给线头线尾初始化为无效值。
   2931                  tempfirst = MaxValUint8;
   \   0000002A   0x21FF             MOVS     R1,#+255
   2932                  templast = MaxValUint8;
   \   0000002C   0x22FF             MOVS     R2,#+255
   \   0000002E   0xE009             B.N      ??BlackLeftContinueAdd_4
   \                     ??BlackLeftContinueAdd_3: (+1)
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD1EF             BNE.N    ??BlackLeftContinueAdd_2
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable20_13
   \   0000003C   0x7008             STRB     R0,[R1, #+0]
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE1C5             B.N      ??BlackLeftContinueAdd_5
   2933                          
   2934                  //开始补线
   2935                  for (; ; row--)
   \                     ??BlackLeftContinueAdd_6: (+1)
   \   00000042   0x1E40             SUBS     R0,R0,#+1
   2936                  {
   2937                      if (BlackLeftLoc[row][0] == MaxValUint8)
   \                     ??BlackLeftContinueAdd_4: (+1)
   \   00000044   0x.... 0x....      LDR.W    R2,??DataTable17
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x2303             MOVS     R3,#+3
   \   0000004C   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000050   0x7812             LDRB     R2,[R2, #+0]
   \   00000052   0x2AFF             CMP      R2,#+255
   \   00000054   0xD105             BNE.N    ??BlackLeftContinueAdd_7
   2938                      {
   2939                          if (tempfirst == MaxValUint8)
   \   00000056   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000058   0x29FF             CMP      R1,#+255
   \   0000005A   0xF040 0x81B3      BNE.W    ??BlackLeftContinueAdd_8
   2940                          {
   2941                              //若线头为无效值，就记录为线头。
   2942                              tempfirst = row + 1;
   \   0000005E   0x1C41             ADDS     R1,R0,#+1
   \   00000060   0xE1B0             B.N      ??BlackLeftContinueAdd_8
   2943                          }
   2944                          else
   2945                          {
   2946                          }
   2947                      }
   2948                      else
   2949                      {
   2950                          if (tempfirst != MaxValUint8)
   \                     ??BlackLeftContinueAdd_7: (+1)
   \   00000062   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000064   0x29FF             CMP      R1,#+255
   \   00000066   0xF000 0x81AD      BEQ.W    ??BlackLeftContinueAdd_8
   2951                          {
   2952                              //若线头已经有赋值，则开始记录线尾。
   2953                              templast = row;
   \   0000006A   0x0002             MOVS     R2,R0
   2954                              if(templast > 5)
   \   0000006C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006E   0x2A06             CMP      R2,#+6
   \   00000070   0xDB2A             BLT.N    ??BlackLeftContinueAdd_9
   2955                              {
   2956                                  if (BlackLeftLoc[templast - 1][0] != MaxValUint8 && BlackLeftLoc[templast - 2][0] != MaxValUint8 && BlackLeftLoc[templast - 3][0] != MaxValUint8
   2957                                      && BlackLeftLoc[templast - 4][0] != MaxValUint8)
   \   00000072   0x.... 0x....      LDR.W    R3,??DataTable17
   \   00000076   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000078   0x2403             MOVS     R4,#+3
   \   0000007A   0xFB04 0x3302      MLA      R3,R4,R2,R3
   \   0000007E   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   00000082   0x2BFF             CMP      R3,#+255
   \   00000084   0xD01E             BEQ.N    ??BlackLeftContinueAdd_10
   \   00000086   0x.... 0x....      LDR.W    R3,??DataTable17
   \   0000008A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000008C   0x2403             MOVS     R4,#+3
   \   0000008E   0xFB04 0x3302      MLA      R3,R4,R2,R3
   \   00000092   0xF813 0x3C06      LDRB     R3,[R3, #-6]
   \   00000096   0x2BFF             CMP      R3,#+255
   \   00000098   0xD014             BEQ.N    ??BlackLeftContinueAdd_10
   \   0000009A   0x.... 0x....      LDR.W    R3,??DataTable17
   \   0000009E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000A0   0x2403             MOVS     R4,#+3
   \   000000A2   0xFB04 0x3302      MLA      R3,R4,R2,R3
   \   000000A6   0xF813 0x3C09      LDRB     R3,[R3, #-9]
   \   000000AA   0x2BFF             CMP      R3,#+255
   \   000000AC   0xD00A             BEQ.N    ??BlackLeftContinueAdd_10
   \   000000AE   0x....             LDR.N    R3,??DataTable17
   \   000000B0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000B2   0x2403             MOVS     R4,#+3
   \   000000B4   0xFB04 0x3302      MLA      R3,R4,R2,R3
   \   000000B8   0xF813 0x3C0C      LDRB     R3,[R3, #-12]
   \   000000BC   0x2BFF             CMP      R3,#+255
   \   000000BE   0xD001             BEQ.N    ??BlackLeftContinueAdd_10
   2958                                  {
   2959                                      fangDuanLieFlag = 0;
   \   000000C0   0x2300             MOVS     R3,#+0
   \   000000C2   0xE002             B.N      ??BlackLeftContinueAdd_11
   2960                                  }
   2961                                  else
   2962                                  {
   2963                                      fangDuanLieFlag = 1;
   \                     ??BlackLeftContinueAdd_10: (+1)
   \   000000C4   0x2301             MOVS     R3,#+1
   \   000000C6   0xE000             B.N      ??BlackLeftContinueAdd_11
   2964                                  }
   2965                              }
   2966                              else
   2967                              {
   2968                                  fangDuanLieFlag = 1;
   \                     ??BlackLeftContinueAdd_9: (+1)
   \   000000C8   0x2301             MOVS     R3,#+1
   2969                              }
   2970                              
   2971                              if (templast >= 8)
   \                     ??BlackLeftContinueAdd_11: (+1)
   \   000000CA   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000CC   0x2A08             CMP      R2,#+8
   \   000000CE   0xDB4B             BLT.N    ??BlackLeftContinueAdd_12
   2972                              {
   2973                                  if (BlackLeftLoc[templast - 1][0] != MaxValUint8 && BlackLeftLoc[templast - 2][0] != MaxValUint8 && BlackLeftLoc[templast - 3][0] != MaxValUint8
   2974                                      && BlackLeftLoc[templast - 4][0] != MaxValUint8 && BlackLeftLoc[templast - 5][0] != MaxValUint8
   2975                                          && BlackLeftLoc[templast - 6][0] != MaxValUint8 && BlackLeftLoc[templast - 7][0] != MaxValUint8 && BlackLeftLoc[templast - 8][0] != MaxValUint8)
   \   000000D0   0x....             LDR.N    R4,??DataTable17
   \   000000D2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000D4   0x2503             MOVS     R5,#+3
   \   000000D6   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   000000DA   0xF814 0x4C03      LDRB     R4,[R4, #-3]
   \   000000DE   0x2CFF             CMP      R4,#+255
   \   000000E0   0xD040             BEQ.N    ??BlackLeftContinueAdd_13
   \   000000E2   0x....             LDR.N    R4,??DataTable17
   \   000000E4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000E6   0x2503             MOVS     R5,#+3
   \   000000E8   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   000000EC   0xF814 0x4C06      LDRB     R4,[R4, #-6]
   \   000000F0   0x2CFF             CMP      R4,#+255
   \   000000F2   0xD037             BEQ.N    ??BlackLeftContinueAdd_13
   \   000000F4   0x....             LDR.N    R4,??DataTable17
   \   000000F6   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000F8   0x2503             MOVS     R5,#+3
   \   000000FA   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   000000FE   0xF814 0x4C09      LDRB     R4,[R4, #-9]
   \   00000102   0x2CFF             CMP      R4,#+255
   \   00000104   0xD02E             BEQ.N    ??BlackLeftContinueAdd_13
   \   00000106   0x....             LDR.N    R4,??DataTable17
   \   00000108   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000010A   0x2503             MOVS     R5,#+3
   \   0000010C   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   00000110   0xF814 0x4C0C      LDRB     R4,[R4, #-12]
   \   00000114   0x2CFF             CMP      R4,#+255
   \   00000116   0xD025             BEQ.N    ??BlackLeftContinueAdd_13
   \   00000118   0x....             LDR.N    R4,??DataTable17
   \   0000011A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000011C   0x2503             MOVS     R5,#+3
   \   0000011E   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   00000122   0xF814 0x4C0F      LDRB     R4,[R4, #-15]
   \   00000126   0x2CFF             CMP      R4,#+255
   \   00000128   0xD01C             BEQ.N    ??BlackLeftContinueAdd_13
   \   0000012A   0x....             LDR.N    R4,??DataTable17
   \   0000012C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000012E   0x2503             MOVS     R5,#+3
   \   00000130   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   00000134   0xF814 0x4C12      LDRB     R4,[R4, #-18]
   \   00000138   0x2CFF             CMP      R4,#+255
   \   0000013A   0xD013             BEQ.N    ??BlackLeftContinueAdd_13
   \   0000013C   0x....             LDR.N    R4,??DataTable17
   \   0000013E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000140   0x2503             MOVS     R5,#+3
   \   00000142   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   00000146   0xF814 0x4C15      LDRB     R4,[R4, #-21]
   \   0000014A   0x2CFF             CMP      R4,#+255
   \   0000014C   0xD00A             BEQ.N    ??BlackLeftContinueAdd_13
   \   0000014E   0x....             LDR.N    R4,??DataTable17
   \   00000150   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000152   0x2503             MOVS     R5,#+3
   \   00000154   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   00000158   0xF814 0x4C18      LDRB     R4,[R4, #-24]
   \   0000015C   0x2CFF             CMP      R4,#+255
   \   0000015E   0xD001             BEQ.N    ??BlackLeftContinueAdd_13
   2976                                  {
   2977                                      fangHuiWanFlag = 0;
   \   00000160   0x2400             MOVS     R4,#+0
   \   00000162   0xE002             B.N      ??BlackLeftContinueAdd_14
   2978                                  }
   2979                                  else
   2980                                  {
   2981                                      fangHuiWanFlag = 1;
   \                     ??BlackLeftContinueAdd_13: (+1)
   \   00000164   0x2401             MOVS     R4,#+1
   \   00000166   0xE000             B.N      ??BlackLeftContinueAdd_14
   2982                                  }
   2983                              }
   2984                              else
   2985                              {
   2986                                  fangHuiWanFlag = 1;
   \                     ??BlackLeftContinueAdd_12: (+1)
   \   00000168   0x2401             MOVS     R4,#+1
   2987                              }
   2988                              
   2989                              if ((BlackLeftLoc[tempfirst][0]<=15 && BlackLeftLoc[templast][0]<=15) && (tempfirst - templast) <= 12)
   \                     ??BlackLeftContinueAdd_14: (+1)
   \   0000016A   0x....             LDR.N    R5,??DataTable17
   \   0000016C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000016E   0x2603             MOVS     R6,#+3
   \   00000170   0xFB06 0x5501      MLA      R5,R6,R1,R5
   \   00000174   0x782D             LDRB     R5,[R5, #+0]
   \   00000176   0x2D10             CMP      R5,#+16
   \   00000178   0xDA2B             BGE.N    ??BlackLeftContinueAdd_15
   \   0000017A   0x....             LDR.N    R5,??DataTable17
   \   0000017C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000017E   0x2603             MOVS     R6,#+3
   \   00000180   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   00000184   0x782D             LDRB     R5,[R5, #+0]
   \   00000186   0x2D10             CMP      R5,#+16
   \   00000188   0xDA23             BGE.N    ??BlackLeftContinueAdd_15
   \   0000018A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000018C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000018E   0x1A8D             SUBS     R5,R1,R2
   \   00000190   0x2D0D             CMP      R5,#+13
   \   00000192   0xDA1E             BGE.N    ??BlackLeftContinueAdd_15
   2990                              {
   2991                                  //这种情况是防止黑线太靠镜头边界导致黑线不成功的
   2992                                  for (j = tempfirst - 1; ; j--)
   \   00000194   0x1E4B             SUBS     R3,R1,#+1
   \   00000196   0xE000             B.N      ??BlackLeftContinueAdd_16
   \                     ??BlackLeftContinueAdd_17: (+1)
   \   00000198   0x1E5B             SUBS     R3,R3,#+1
   2993                                  {
   2994                                      BlackLeftLoc[j][0] = (BlackLeftLoc[tempfirst][0] + BlackLeftLoc[templast][0]) / 2;
   \                     ??BlackLeftContinueAdd_16: (+1)
   \   0000019A   0x....             LDR.N    R4,??DataTable17
   \   0000019C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000019E   0x2503             MOVS     R5,#+3
   \   000001A0   0xFB05 0x4401      MLA      R4,R5,R1,R4
   \   000001A4   0x7824             LDRB     R4,[R4, #+0]
   \   000001A6   0x....             LDR.N    R5,??DataTable17
   \   000001A8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001AA   0x2603             MOVS     R6,#+3
   \   000001AC   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   000001B0   0x782D             LDRB     R5,[R5, #+0]
   \   000001B2   0x192C             ADDS     R4,R5,R4
   \   000001B4   0x2502             MOVS     R5,#+2
   \   000001B6   0xFB94 0xF4F5      SDIV     R4,R4,R5
   \   000001BA   0x....             LDR.N    R5,??DataTable17
   \   000001BC   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001BE   0x2603             MOVS     R6,#+3
   \   000001C0   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   000001C4   0x702C             STRB     R4,[R5, #+0]
   2995                                      if (j == templast + 1) break;
   \   000001C6   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001C8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001CA   0x1C54             ADDS     R4,R2,#+1
   \   000001CC   0x42A3             CMP      R3,R4
   \   000001CE   0xD1E3             BNE.N    ??BlackLeftContinueAdd_17
   \   000001D0   0xE0F2             B.N      ??BlackLeftContinueAdd_18
   2996                                  }
   2997                              }
   2998                              else if ((BlackLeftLoc[tempfirst][0] <= 15 && BlackLeftLoc[templast][0] <= 15) && (tempfirst - templast) <20
   2999                                          && (BlackLeftLoc[10][0] != MaxValUint8 || BlackLeftLoc[9][0] != MaxValUint8 || BlackLeftLoc[8][0] != MaxValUint8 || BlackLeftLoc[7][0] != MaxValUint8 || BlackLeftLoc[6][0] != MaxValUint8)
   3000                                          && fangHuiWanFlag == 0)
   \                     ??BlackLeftContinueAdd_15: (+1)
   \   000001D2   0x....             LDR.N    R5,??DataTable17
   \   000001D4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001D6   0x2603             MOVS     R6,#+3
   \   000001D8   0xFB06 0x5501      MLA      R5,R6,R1,R5
   \   000001DC   0x782D             LDRB     R5,[R5, #+0]
   \   000001DE   0x2D10             CMP      R5,#+16
   \   000001E0   0xDA42             BGE.N    ??BlackLeftContinueAdd_19
   \   000001E2   0x....             LDR.N    R5,??DataTable17
   \   000001E4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001E6   0x2603             MOVS     R6,#+3
   \   000001E8   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   000001EC   0x782D             LDRB     R5,[R5, #+0]
   \   000001EE   0x2D10             CMP      R5,#+16
   \   000001F0   0xDA3A             BGE.N    ??BlackLeftContinueAdd_19
   \   000001F2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001F4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001F6   0x1A8D             SUBS     R5,R1,R2
   \   000001F8   0x2D14             CMP      R5,#+20
   \   000001FA   0xDA35             BGE.N    ??BlackLeftContinueAdd_19
   \   000001FC   0x....             LDR.N    R5,??DataTable17
   \   000001FE   0x7FAD             LDRB     R5,[R5, #+30]
   \   00000200   0x2DFF             CMP      R5,#+255
   \   00000202   0xD10F             BNE.N    ??BlackLeftContinueAdd_20
   \   00000204   0x....             LDR.N    R5,??DataTable17
   \   00000206   0x7EED             LDRB     R5,[R5, #+27]
   \   00000208   0x2DFF             CMP      R5,#+255
   \   0000020A   0xD10B             BNE.N    ??BlackLeftContinueAdd_20
   \   0000020C   0x....             LDR.N    R5,??DataTable17
   \   0000020E   0x7E2D             LDRB     R5,[R5, #+24]
   \   00000210   0x2DFF             CMP      R5,#+255
   \   00000212   0xD107             BNE.N    ??BlackLeftContinueAdd_20
   \   00000214   0x....             LDR.N    R5,??DataTable17
   \   00000216   0x7D6D             LDRB     R5,[R5, #+21]
   \   00000218   0x2DFF             CMP      R5,#+255
   \   0000021A   0xD103             BNE.N    ??BlackLeftContinueAdd_20
   \   0000021C   0x....             LDR.N    R5,??DataTable17
   \   0000021E   0x7CAD             LDRB     R5,[R5, #+18]
   \   00000220   0x2DFF             CMP      R5,#+255
   \   00000222   0xD021             BEQ.N    ??BlackLeftContinueAdd_19
   \                     ??BlackLeftContinueAdd_20: (+1)
   \   00000224   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000226   0x2C00             CMP      R4,#+0
   \   00000228   0xD11E             BNE.N    ??BlackLeftContinueAdd_19
   3001                              {
   3002                                  //这种情况是防止黑线太靠镜头边界导致黑线不成功的
   3003                                  for (j = tempfirst - 1; ; j--)
   \   0000022A   0x1E4B             SUBS     R3,R1,#+1
   \   0000022C   0xE000             B.N      ??BlackLeftContinueAdd_21
   \                     ??BlackLeftContinueAdd_22: (+1)
   \   0000022E   0x1E5B             SUBS     R3,R3,#+1
   3004                                  {
   3005                                      BlackLeftLoc[j][0] = (BlackLeftLoc[tempfirst][0] + BlackLeftLoc[templast][0]) / 2;
   \                     ??BlackLeftContinueAdd_21: (+1)
   \   00000230   0x....             LDR.N    R4,??DataTable17
   \   00000232   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000234   0x2503             MOVS     R5,#+3
   \   00000236   0xFB05 0x4401      MLA      R4,R5,R1,R4
   \   0000023A   0x7824             LDRB     R4,[R4, #+0]
   \   0000023C   0x....             LDR.N    R5,??DataTable17
   \   0000023E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000240   0x2603             MOVS     R6,#+3
   \   00000242   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   00000246   0x782D             LDRB     R5,[R5, #+0]
   \   00000248   0x192C             ADDS     R4,R5,R4
   \   0000024A   0x2502             MOVS     R5,#+2
   \   0000024C   0xFB94 0xF4F5      SDIV     R4,R4,R5
   \   00000250   0x....             LDR.N    R5,??DataTable17
   \   00000252   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000254   0x2603             MOVS     R6,#+3
   \   00000256   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   0000025A   0x702C             STRB     R4,[R5, #+0]
   3006                                      if (j == templast + 1) break;
   \   0000025C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000025E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000260   0x1C54             ADDS     R4,R2,#+1
   \   00000262   0x42A3             CMP      R3,R4
   \   00000264   0xD1E3             BNE.N    ??BlackLeftContinueAdd_22
   \   00000266   0xE0A7             B.N      ??BlackLeftContinueAdd_18
   3007                                  }
   3008                              }
   3009                              else if ((BlackLeftLoc[tempfirst][0] <= 15 && BlackLeftLoc[templast][0] <= 15) && (tempfirst - templast) <= 35
   3010                                          && (BlackLeftLoc[6][0] != MaxValUint8 || BlackLeftLoc[7][0] != MaxValUint8 || BlackLeftLoc[8][0] != MaxValUint8 || BlackLeftLoc[10][0] != MaxValUint8 || BlackLeftLoc[9][0] != MaxValUint8)
   3011                                          && fangHuiWanFlag == 0)
   \                     ??BlackLeftContinueAdd_19: (+1)
   \   00000268   0x....             LDR.N    R5,??DataTable17
   \   0000026A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000026C   0x2603             MOVS     R6,#+3
   \   0000026E   0xFB06 0x5501      MLA      R5,R6,R1,R5
   \   00000272   0x782D             LDRB     R5,[R5, #+0]
   \   00000274   0x2D10             CMP      R5,#+16
   \   00000276   0xDA42             BGE.N    ??BlackLeftContinueAdd_23
   \   00000278   0x....             LDR.N    R5,??DataTable17
   \   0000027A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000027C   0x2603             MOVS     R6,#+3
   \   0000027E   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   00000282   0x782D             LDRB     R5,[R5, #+0]
   \   00000284   0x2D10             CMP      R5,#+16
   \   00000286   0xDA3A             BGE.N    ??BlackLeftContinueAdd_23
   \   00000288   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000028A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000028C   0x1A8D             SUBS     R5,R1,R2
   \   0000028E   0x2D24             CMP      R5,#+36
   \   00000290   0xDA35             BGE.N    ??BlackLeftContinueAdd_23
   \   00000292   0x....             LDR.N    R5,??DataTable17
   \   00000294   0x7CAD             LDRB     R5,[R5, #+18]
   \   00000296   0x2DFF             CMP      R5,#+255
   \   00000298   0xD10F             BNE.N    ??BlackLeftContinueAdd_24
   \   0000029A   0x....             LDR.N    R5,??DataTable17
   \   0000029C   0x7D6D             LDRB     R5,[R5, #+21]
   \   0000029E   0x2DFF             CMP      R5,#+255
   \   000002A0   0xD10B             BNE.N    ??BlackLeftContinueAdd_24
   \   000002A2   0x....             LDR.N    R5,??DataTable17
   \   000002A4   0x7E2D             LDRB     R5,[R5, #+24]
   \   000002A6   0x2DFF             CMP      R5,#+255
   \   000002A8   0xD107             BNE.N    ??BlackLeftContinueAdd_24
   \   000002AA   0x....             LDR.N    R5,??DataTable17
   \   000002AC   0x7FAD             LDRB     R5,[R5, #+30]
   \   000002AE   0x2DFF             CMP      R5,#+255
   \   000002B0   0xD103             BNE.N    ??BlackLeftContinueAdd_24
   \   000002B2   0x....             LDR.N    R5,??DataTable17
   \   000002B4   0x7EED             LDRB     R5,[R5, #+27]
   \   000002B6   0x2DFF             CMP      R5,#+255
   \   000002B8   0xD021             BEQ.N    ??BlackLeftContinueAdd_23
   \                     ??BlackLeftContinueAdd_24: (+1)
   \   000002BA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002BC   0x2C00             CMP      R4,#+0
   \   000002BE   0xD11E             BNE.N    ??BlackLeftContinueAdd_23
   3012                              {
   3013                                  //这种情况是防止黑线太靠镜头边界导致黑线不成功的
   3014                                  for (j = tempfirst - 1; ; j--)
   \   000002C0   0x1E4B             SUBS     R3,R1,#+1
   \   000002C2   0xE000             B.N      ??BlackLeftContinueAdd_25
   \                     ??BlackLeftContinueAdd_26: (+1)
   \   000002C4   0x1E5B             SUBS     R3,R3,#+1
   3015                                  {
   3016                                      BlackLeftLoc[j][0] = (BlackLeftLoc[tempfirst][0] + BlackLeftLoc[templast][0]) / 2;
   \                     ??BlackLeftContinueAdd_25: (+1)
   \   000002C6   0x....             LDR.N    R4,??DataTable17
   \   000002C8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002CA   0x2503             MOVS     R5,#+3
   \   000002CC   0xFB05 0x4401      MLA      R4,R5,R1,R4
   \   000002D0   0x7824             LDRB     R4,[R4, #+0]
   \   000002D2   0x....             LDR.N    R5,??DataTable17
   \   000002D4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000002D6   0x2603             MOVS     R6,#+3
   \   000002D8   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   000002DC   0x782D             LDRB     R5,[R5, #+0]
   \   000002DE   0x192C             ADDS     R4,R5,R4
   \   000002E0   0x2502             MOVS     R5,#+2
   \   000002E2   0xFB94 0xF4F5      SDIV     R4,R4,R5
   \   000002E6   0x....             LDR.N    R5,??DataTable17
   \   000002E8   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000002EA   0x2603             MOVS     R6,#+3
   \   000002EC   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   000002F0   0x702C             STRB     R4,[R5, #+0]
   3017                                      if (j == templast + 1) break;
   \   000002F2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000002F4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000002F6   0x1C54             ADDS     R4,R2,#+1
   \   000002F8   0x42A3             CMP      R3,R4
   \   000002FA   0xD1E3             BNE.N    ??BlackLeftContinueAdd_26
   \   000002FC   0xE05C             B.N      ??BlackLeftContinueAdd_18
   3018                                  }
   3019                              }
   3020                              //防边线断裂的
   3021                              else if (tempfirst - templast <= 5 && fangDuanLieFlag == 0)
   \                     ??BlackLeftContinueAdd_23: (+1)
   \   000002FE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000300   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000302   0x1A8C             SUBS     R4,R1,R2
   \   00000304   0x2C06             CMP      R4,#+6
   \   00000306   0xDA21             BGE.N    ??BlackLeftContinueAdd_27
   \   00000308   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000030A   0x2B00             CMP      R3,#+0
   \   0000030C   0xD11E             BNE.N    ??BlackLeftContinueAdd_27
   3022                              {
   3023                                  for (j = tempfirst - 1; ; j--)
   \   0000030E   0x1E4B             SUBS     R3,R1,#+1
   \   00000310   0xE000             B.N      ??BlackLeftContinueAdd_28
   \                     ??BlackLeftContinueAdd_29: (+1)
   \   00000312   0x1E5B             SUBS     R3,R3,#+1
   3024                                  {
   3025                                      BlackLeftLoc[j][0] = (BlackLeftLoc[tempfirst][0] + BlackLeftLoc[templast][0]) / 2;
   \                     ??BlackLeftContinueAdd_28: (+1)
   \   00000314   0x....             LDR.N    R4,??DataTable17
   \   00000316   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000318   0x2503             MOVS     R5,#+3
   \   0000031A   0xFB05 0x4401      MLA      R4,R5,R1,R4
   \   0000031E   0x7824             LDRB     R4,[R4, #+0]
   \   00000320   0x....             LDR.N    R5,??DataTable17
   \   00000322   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000324   0x2603             MOVS     R6,#+3
   \   00000326   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   0000032A   0x782D             LDRB     R5,[R5, #+0]
   \   0000032C   0x192C             ADDS     R4,R5,R4
   \   0000032E   0x2502             MOVS     R5,#+2
   \   00000330   0xFB94 0xF4F5      SDIV     R4,R4,R5
   \   00000334   0x....             LDR.N    R5,??DataTable17
   \   00000336   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000338   0x2603             MOVS     R6,#+3
   \   0000033A   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   0000033E   0x702C             STRB     R4,[R5, #+0]
   3026                                      if (j == templast + 1) break;
   \   00000340   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000342   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000344   0x1C54             ADDS     R4,R2,#+1
   \   00000346   0x42A3             CMP      R3,R4
   \   00000348   0xD1E3             BNE.N    ??BlackLeftContinueAdd_29
   \   0000034A   0xE035             B.N      ??BlackLeftContinueAdd_18
   3027                                  }
   3028                              }
   3029                              else if(tempfirst - templast >= 3) 
   \                     ??BlackLeftContinueAdd_27: (+1)
   \   0000034C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000034E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000350   0x1A8B             SUBS     R3,R1,R2
   \   00000352   0x2B03             CMP      R3,#+3
   \   00000354   0xDB12             BLT.N    ??BlackLeftContinueAdd_30
   3030                              {
   3031                                //两者相差太多，则后面的行全部视为错误。
   3032                                for(i = tempfirst - 1; ; i--)
   \   00000356   0x1E48             SUBS     R0,R1,#+1
   \   00000358   0xE000             B.N      ??BlackLeftContinueAdd_31
   \                     ??BlackLeftContinueAdd_32: (+1)
   \   0000035A   0x1E40             SUBS     R0,R0,#+1
   3033                                {
   3034                                  BlackLeftLoc[i][0] = MaxValUint8;
   \                     ??BlackLeftContinueAdd_31: (+1)
   \   0000035C   0x21FF             MOVS     R1,#+255
   \   0000035E   0x....             LDR.N    R2,??DataTable17
   \   00000360   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000362   0x2303             MOVS     R3,#+3
   \   00000364   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000368   0x7011             STRB     R1,[R2, #+0]
   3035                                  if(i == 0) break;
   \   0000036A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000036C   0x2800             CMP      R0,#+0
   \   0000036E   0xD1F4             BNE.N    ??BlackLeftContinueAdd_32
   3036                                }
   3037                                //左黑线连续性标志出错。
   3038                                BlackLeftContinueFlag = 2;
   \   00000370   0x2002             MOVS     R0,#+2
   \   00000372   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000376   0x7008             STRB     R0,[R1, #+0]
   3039                                return 0;
   \   00000378   0x2000             MOVS     R0,#+0
   \   0000037A   0xE028             B.N      ??BlackLeftContinueAdd_5
   3040                              }
   3041                              else
   3042                              {
   3043                                //一共才1或2个点，直接插值就行。
   3044                                for(j = tempfirst - 1; ; j--)
   \                     ??BlackLeftContinueAdd_30: (+1)
   \   0000037C   0x1E4B             SUBS     R3,R1,#+1
   \   0000037E   0xE000             B.N      ??BlackLeftContinueAdd_33
   \                     ??BlackLeftContinueAdd_34: (+1)
   \   00000380   0x1E5B             SUBS     R3,R3,#+1
   3045                                {
   3046                                  BlackLeftLoc[j][0] = (BlackLeftLoc[tempfirst][0] + BlackLeftLoc[templast][0]) / 2;
   \                     ??BlackLeftContinueAdd_33: (+1)
   \   00000382   0x....             LDR.N    R4,??DataTable17
   \   00000384   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000386   0x2503             MOVS     R5,#+3
   \   00000388   0xFB05 0x4401      MLA      R4,R5,R1,R4
   \   0000038C   0x7824             LDRB     R4,[R4, #+0]
   \   0000038E   0x....             LDR.N    R5,??DataTable17
   \   00000390   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000392   0x2603             MOVS     R6,#+3
   \   00000394   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   00000398   0x782D             LDRB     R5,[R5, #+0]
   \   0000039A   0x192C             ADDS     R4,R5,R4
   \   0000039C   0x2502             MOVS     R5,#+2
   \   0000039E   0xFB94 0xF4F5      SDIV     R4,R4,R5
   \   000003A2   0x....             LDR.N    R5,??DataTable17
   \   000003A4   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000003A6   0x2603             MOVS     R6,#+3
   \   000003A8   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   000003AC   0x702C             STRB     R4,[R5, #+0]
   3047                                  if(j == templast + 1) break;
   \   000003AE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000003B0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000003B2   0x1C54             ADDS     R4,R2,#+1
   \   000003B4   0x42A3             CMP      R3,R4
   \   000003B6   0xD1E3             BNE.N    ??BlackLeftContinueAdd_34
   3048                                }
   3049                              }
   3050                              tempfirst = MaxValUint8;
   \                     ??BlackLeftContinueAdd_18: (+1)
   \   000003B8   0x21FF             MOVS     R1,#+255
   3051                              templast = MaxValUint8;
   \   000003BA   0x22FF             MOVS     R2,#+255
   3052                              //左黑线连续性标志置0，不连续。
   3053                              BlackLeftContinueFlag = 0;
   \   000003BC   0x2200             MOVS     R2,#+0
   \   000003BE   0x.... 0x....      LDR.W    R3,??DataTable24
   \   000003C2   0x701A             STRB     R2,[R3, #+0]
   3054                          }
   3055                          else
   3056                          {
   3057                          }
   3058                      }
   3059          
   3060                      if (row == 0) break;
   \                     ??BlackLeftContinueAdd_8: (+1)
   \   000003C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003C6   0x2800             CMP      R0,#+0
   \   000003C8   0xF47F 0xAE3B      BNE.W    ??BlackLeftContinueAdd_6
   3061                  }
   3062              }
   3063              else
   3064              {
   3065              }    
   3066              
   3067              return 1;
   \                     ??BlackLeftContinueAdd_0: (+1)
   \   000003CC   0x2001             MOVS     R0,#+1
   \                     ??BlackLeftContinueAdd_5: (+1)
   \   000003CE   0xBC70             POP      {R4-R6}
   \   000003D0   0x4770             BX       LR               ;; return
   3068          }
   3069          
   3070          
   3071          
   3072          
   3073          
   3074          
   3075          //左黑线的回弯特殊检测。进来前BlackLeftDone已经置为1了。
   3076          //进来前已经进行左、右黑线的斜曲率检测。

   \                                 In section .text, align 2, keep-with-next
   3077          uint8 BlackLeftRollCheck(void)
   3078          {
   3079            uint8 temp1, temp2, temp3;
   3080            
   3081            //当前为单线，不进行回弯特殊检测。
   3082            if(SingleBlackAllFlag == 1) return 1;
   \                     BlackLeftRollCheck: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable23
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??BlackLeftRollCheck_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE047             B.N      ??BlackLeftRollCheck_1
   3083            
   3084            //斜率确认。
   3085            //若无效，直接确认。
   3086            if(SlopeL == MaxValInt16)
   \                     ??BlackLeftRollCheck_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF647 0x71FF      MOVW     R1,#+32767
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD101             BNE.N    ??BlackLeftRollCheck_2
   3087            {
   3088              temp1 = 1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE009             B.N      ??BlackLeftRollCheck_3
   3089            }
   3090            else
   3091            {
   3092              //斜率的确太大。
   3093              if(SlopeL + BlackLeftRollSlopeLimit < 0)
   \                     ??BlackLeftRollCheck_2: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable23_1
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF510 0x60FA      ADDS     R0,R0,#+2000
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD501             BPL.N    ??BlackLeftRollCheck_4
   3094              {
   3095                temp1 = 1;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE000             B.N      ??BlackLeftRollCheck_3
   3096              }
   3097              //斜率不大。
   3098              else
   3099              {
   3100                temp1 = 0;
   \                     ??BlackLeftRollCheck_4: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   3101              }
   3102            }
   3103            
   3104            //线长度确认。
   3105            //若无效，直接确认。
   3106            if(BlackLeftHeadLine == MaxValUint8 || BlackLeftEndLine == MaxValUint8)
   \                     ??BlackLeftRollCheck_3: (+1)
   \   00000034   0x....             LDR.N    R1,??DataTable20_9
   \   00000036   0x7809             LDRB     R1,[R1, #+0]
   \   00000038   0x29FF             CMP      R1,#+255
   \   0000003A   0xD003             BEQ.N    ??BlackLeftRollCheck_5
   \   0000003C   0x....             LDR.N    R1,??DataTable20_8
   \   0000003E   0x7809             LDRB     R1,[R1, #+0]
   \   00000040   0x29FF             CMP      R1,#+255
   \   00000042   0xD101             BNE.N    ??BlackLeftRollCheck_6
   3107            {
   3108              temp2 = 1;
   \                     ??BlackLeftRollCheck_5: (+1)
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0xE009             B.N      ??BlackLeftRollCheck_7
   3109            }
   3110            else
   3111            {
   3112              //线确实很短。
   3113              if(BlackLeftEndLine - BlackLeftHeadLine < BlackLeftRollLengthLimit)
   \                     ??BlackLeftRollCheck_6: (+1)
   \   00000048   0x....             LDR.N    R1,??DataTable20_8
   \   0000004A   0x7809             LDRB     R1,[R1, #+0]
   \   0000004C   0x....             LDR.N    R2,??DataTable20_9
   \   0000004E   0x7812             LDRB     R2,[R2, #+0]
   \   00000050   0x1A89             SUBS     R1,R1,R2
   \   00000052   0x290C             CMP      R1,#+12
   \   00000054   0xDA01             BGE.N    ??BlackLeftRollCheck_8
   3114              {
   3115                temp2 = 1;
   \   00000056   0x2101             MOVS     R1,#+1
   \   00000058   0xE000             B.N      ??BlackLeftRollCheck_7
   3116              }
   3117              //线很长。
   3118              else
   3119              {
   3120                temp2 = 0;
   \                     ??BlackLeftRollCheck_8: (+1)
   \   0000005A   0x2100             MOVS     R1,#+0
   3121              }
   3122            }
   3123            
   3124            /*
   3125            //右线斜率确认。
   3126            //右线必须是左上到右下的，也就是正的斜率。而且斜率要求比较大。才能说明是270等大弯。
   3127            if(SlopeR == MaxValInt16)
   3128            {
   3129              temp3 = 1;    
   3130            }
   3131            else
   3132            {
   3133              if(SlopeR > BlackLeftRollSlopeRLimit)
   3134              {
   3135                temp3 = 1;
   3136              }
   3137              else
   3138              {
   3139                temp3 = 0;
   3140              }
   3141            }
   3142            */
   3143            temp3 = 1;
   \                     ??BlackLeftRollCheck_7: (+1)
   \   0000005C   0x2201             MOVS     R2,#+1
   3144          
   3145            if(
   3146              (BlackLeftStep4Flag == 3 || SingleBlackLastAllFlag == 1)   //左向后补线标志，出错。或者因为上幅图像是单线，无法开启十字，无法置向后补线出错。
   3147            &&(BlackLeftCrossDone == 1 || BlackLeftCrossDone == 0)   //左十字标志，失败。或者未进入（线尾过高不会进行十字再检测）。
   3148            &&(temp1 == 1)                //斜率很大。
   3149            &&(temp2 == 1)                //线很短。
   3150            &&(temp3 == 1)                //右线斜率很大。
   3151              )
   \   0000005E   0x.... 0x....      LDR.W    R3,??DataTable23_2
   \   00000062   0x781B             LDRB     R3,[R3, #+0]
   \   00000064   0x2B03             CMP      R3,#+3
   \   00000066   0xD004             BEQ.N    ??BlackLeftRollCheck_9
   \   00000068   0x.... 0x....      LDR.W    R3,??DataTable23_3
   \   0000006C   0x781B             LDRB     R3,[R3, #+0]
   \   0000006E   0x2B01             CMP      R3,#+1
   \   00000070   0xD114             BNE.N    ??BlackLeftRollCheck_10
   \                     ??BlackLeftRollCheck_9: (+1)
   \   00000072   0x.... 0x....      LDR.W    R3,??DataTable24_1
   \   00000076   0x781B             LDRB     R3,[R3, #+0]
   \   00000078   0x2B01             CMP      R3,#+1
   \   0000007A   0xD004             BEQ.N    ??BlackLeftRollCheck_11
   \   0000007C   0x.... 0x....      LDR.W    R3,??DataTable24_1
   \   00000080   0x781B             LDRB     R3,[R3, #+0]
   \   00000082   0x2B00             CMP      R3,#+0
   \   00000084   0xD10A             BNE.N    ??BlackLeftRollCheck_10
   \                     ??BlackLeftRollCheck_11: (+1)
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0x2801             CMP      R0,#+1
   \   0000008A   0xD107             BNE.N    ??BlackLeftRollCheck_10
   \   0000008C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008E   0x2901             CMP      R1,#+1
   \   00000090   0xD104             BNE.N    ??BlackLeftRollCheck_10
   \   00000092   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000094   0x2A01             CMP      R2,#+1
   \   00000096   0xD101             BNE.N    ??BlackLeftRollCheck_10
   3152            {
   3153              //检测到回弯，返回0.
   3154              return 0;   
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xE000             B.N      ??BlackLeftRollCheck_1
   3155            }
   3156            else
   3157            {
   3158              //没检测到回弯，返回1.
   3159              return 1;
   \                     ??BlackLeftRollCheck_10: (+1)
   \   0000009C   0x2001             MOVS     R0,#+1
   \                     ??BlackLeftRollCheck_1: (+1)
   \   0000009E   0x4770             BX       LR               ;; return
   3160            }
   3161          
   3162          }
   3163          
   3164          //向后补线标志出错时的检查，这个函数是防止回弯的很重要的函数。

   \                                 In section .text, align 2, keep-with-next
   3165          uint8 BlackLeftStep4ErrorCheck(void)
   3166          {
   \                     BlackLeftStep4ErrorCheck: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   3167            uint8 i;
   3168            
   3169            //检查斜率是不是都满足直线
   3170            for(i = 0; ; i++)
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE000             B.N      ??BlackLeftStep4ErrorCheck_0
   \                     ??BlackLeftStep4ErrorCheck_1: (+1)
   \   00000006   0x1C64             ADDS     R4,R4,#+1
   3171            {
   3172              if(BlackLeft5Slope[i] == MaxValInt16) return 0;
   \                     ??BlackLeftStep4ErrorCheck_0: (+1)
   \   00000008   0x....             LDR.N    R0,??DataTable20_6
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000010   0xF647 0x71FF      MOVW     R1,#+32767
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD101             BNE.N    ??BlackLeftStep4ErrorCheck_2
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE00F             B.N      ??BlackLeftStep4ErrorCheck_3
   3173              
   3174              if(AbsInt(BlackLeft5Slope[i]) > PathJudgeStraightSlopeLimit)
   \                     ??BlackLeftStep4ErrorCheck_2: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable20_6
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000024   0x.... 0x....      BL       AbsInt
   \   00000028   0xF640 0x0135      MOVW     R1,#+2101
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xDB01             BLT.N    ??BlackLeftStep4ErrorCheck_4
   3175              {
   3176                return 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE003             B.N      ??BlackLeftStep4ErrorCheck_3
   3177              }
   3178              else
   3179              {      
   3180              }
   3181              
   3182              if(i == 5) break;
   \                     ??BlackLeftStep4ErrorCheck_4: (+1)
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x2C05             CMP      R4,#+5
   \   00000038   0xD1E5             BNE.N    ??BlackLeftStep4ErrorCheck_1
   3183            }
   3184            
   3185            return 1;
   \   0000003A   0x2001             MOVS     R0,#+1
   \                     ??BlackLeftStep4ErrorCheck_3: (+1)
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   3186            
   3187          }
   3188          
   3189          
   3190          //左黑线提取前的参数初始化赋值

   \                                 In section .text, align 2, keep-with-next
   3191          uint8 BlackGetLeftParaInit(void)
   3192          {
   3193            uint8 i;
   3194            
   3195            //左线连续性标志。默认为1连续。
   3196            BlackLeftContinueFlag = 1;  
   \                     BlackGetLeftParaInit: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   3197            
   3198            //采集成功标志位
   3199            BlackLeftDone = 1;  
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x....             LDR.N    R1,??DataTable20_13
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
   3200           
   3201            //左十字线头标志。0未进入，1超范围，2成功。
   3202            BlackLeftCrossConfirmFlag = 0;  //默认为未进入。  
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             LDR.N    R1,??DataTable20_1
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   3203            
   3204            //小5点斜率储存数组置初始值。
   3205            BlackLeft5SlopeIndex = 0;  
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR.N    R1,??DataTable20_10
   \   00000018   0x7008             STRB     R0,[R1, #+0]
   3206            for(i = 0; ; i++)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE000             B.N      ??BlackGetLeftParaInit_0
   \                     ??BlackGetLeftParaInit_1: (+1)
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   3207            {
   3208                BlackLeft5Slope[i] = MaxValInt16;
   \                     ??BlackGetLeftParaInit_0: (+1)
   \   00000020   0xF647 0x71FF      MOVW     R1,#+32767
   \   00000024   0x....             LDR.N    R2,??DataTable20_6
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   3209                BlackLeft5SlopeRow[i] = MaxValUint8;
   \   0000002C   0x21FF             MOVS     R1,#+255
   \   0000002E   0x....             LDR.N    R2,??DataTable20_11
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x5481             STRB     R1,[R0, R2]
   3210                if(i == CameraHight - 1) break;
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x283B             CMP      R0,#+59
   \   00000038   0xD1F1             BNE.N    ??BlackGetLeftParaInit_1
   3211            }  
   3212            
   3213            //回弯检测
   3214            BlackLeftRollCheckFlag = 0;        //检测到回弯。
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable24_2
   \   00000040   0x7008             STRB     R0,[R1, #+0]
   3215            BlackLeftBigChangeJumpFlag = 0;    //回弯跳过标志。
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable24_3
   \   00000048   0x7008             STRB     R0,[R1, #+0]
   3216          
   3217            //大斜率检测时，每幅图像的初始值初始化为无效值。
   3218            for(i = 0; i <= 4; i++)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xE00A             B.N      ??BlackGetLeftParaInit_2
   3219            {
   3220              BlackLeftBigChangeNumx[i] = MaxValUint8;
   \                     ??BlackGetLeftParaInit_3: (+1)
   \   0000004E   0x21FF             MOVS     R1,#+255
   \   00000050   0x.... 0x....      LDR.W    R2,??DataTable24_4
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x5481             STRB     R1,[R0, R2]
   3221              BlackLeftBigChangeNumy[i] = MaxValUint8; 
   \   00000058   0x21FF             MOVS     R1,#+255
   \   0000005A   0x.... 0x....      LDR.W    R2,??DataTable24_5
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x5481             STRB     R1,[R0, R2]
   3222            }
   \   00000062   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackGetLeftParaInit_2: (+1)
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0x2805             CMP      R0,#+5
   \   00000068   0xDBF1             BLT.N    ??BlackGetLeftParaInit_3
   3223            BlackLeftBigChangeFlag = 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable24_6
   \   00000070   0x7008             STRB     R0,[R1, #+0]
   3224            BlackLeftBigChangeSlopeStore = MaxValInt16;
   \   00000072   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable24_7
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   3225          
   3226            //大斜率检测时，每行的大跳变标志置0.
   3227            for(i = 0; ; i++)
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xE000             B.N      ??BlackGetLeftParaInit_4
   \                     ??BlackGetLeftParaInit_5: (+1)
   \   00000080   0x1C40             ADDS     R0,R0,#+1
   3228            {
   3229              BlackLeftBigChangeCheckRow[i] = 0;
   \                     ??BlackGetLeftParaInit_4: (+1)
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x.... 0x....      LDR.W    R2,??DataTable24_8
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0x5481             STRB     R1,[R0, R2]
   3230              if(i == CameraHight - 1) break;
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0x283B             CMP      R0,#+59
   \   00000090   0xD1F6             BNE.N    ??BlackGetLeftParaInit_5
   3231            }
   3232            BlackLeftBigChangeCheckAllRow = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable24_9
   \   00000098   0x7008             STRB     R0,[R1, #+0]
   3233          
   3234            //左黑线储存数组初始化为无效值。
   3235            for(i = 0; ; i++)
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xE000             B.N      ??BlackGetLeftParaInit_6
   \                     ??BlackGetLeftParaInit_7: (+1)
   \   0000009E   0x1C40             ADDS     R0,R0,#+1
   3236            {
   3237              BlackLeftLoc[i][0] = MaxValUint8;
   \                     ??BlackGetLeftParaInit_6: (+1)
   \   000000A0   0x21FF             MOVS     R1,#+255
   \   000000A2   0x.... 0x....      LDR.W    R2,??DataTable24_10
   \   000000A6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A8   0x2303             MOVS     R3,#+3
   \   000000AA   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000AE   0x7011             STRB     R1,[R2, #+0]
   3238              if(i == CameraHight - 1) break;
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0x283B             CMP      R0,#+59
   \   000000B4   0xD1F3             BNE.N    ??BlackGetLeftParaInit_7
   3239            }
   3240          
   3241            //十字外尾
   3242            BlackLeftCrossTailFlag = 2;       //十字外尾标志，0失败，1确认，2未进入。
   \   000000B6   0x2002             MOVS     R0,#+2
   \   000000B8   0x....             LDR.N    R1,??DataTable20_7
   \   000000BA   0x7008             STRB     R0,[R1, #+0]
   3243          
   3244            //窗口预测值管理
   3245            for(i = 0; ; i++)
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xE000             B.N      ??BlackGetLeftParaInit_8
   \                     ??BlackGetLeftParaInit_9: (+1)
   \   000000C0   0x1C40             ADDS     R0,R0,#+1
   3246            {
   3247              BlackLeftPredictL[i] = MaxValUint8;
   \                     ??BlackGetLeftParaInit_8: (+1)
   \   000000C2   0x21FF             MOVS     R1,#+255
   \   000000C4   0x.... 0x....      LDR.W    R2,??DataTable24_11
   \   000000C8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CA   0x5481             STRB     R1,[R0, R2]
   3248              BlackLeftPredictR[i] = MaxValUint8; 
   \   000000CC   0x21FF             MOVS     R1,#+255
   \   000000CE   0x.... 0x....      LDR.W    R2,??DataTable24_12
   \   000000D2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D4   0x5481             STRB     R1,[R0, R2]
   3249              if(i == CameraHight - 1) break;
   \   000000D6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D8   0x283B             CMP      R0,#+59
   \   000000DA   0xD1F1             BNE.N    ??BlackGetLeftParaInit_9
   3250            }
   3251            
   3252            //窗口预测储存值
   3253            BlackLeftWinPredictStore0 = MaxValUint8;
   \   000000DC   0x20FF             MOVS     R0,#+255
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable24_13
   \   000000E2   0x7008             STRB     R0,[R1, #+0]
   3254            BlackLeftWinPredictStore1 = MaxValUint8;
   \   000000E4   0x20FF             MOVS     R0,#+255
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable24_14
   \   000000EA   0x7008             STRB     R0,[R1, #+0]
   3255            BlackLeftWinPredictStore2 = MaxValUint8;
   \   000000EC   0x20FF             MOVS     R0,#+255
   \   000000EE   0x....             LDR.N    R1,??DataTable20
   \   000000F0   0x7008             STRB     R0,[R1, #+0]
   3256          
   3257            //第4阶段进入标志置为未进入
   3258            BlackLeftStep4Flag = 0;
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0x.... 0x....      LDR.W    R1,??DataTable23_2
   \   000000F8   0x7008             STRB     R0,[R1, #+0]
   3259            BlackLeftStep4StartLine = MaxValUint8;
   \   000000FA   0x20FF             MOVS     R0,#+255
   \   000000FC   0x.... 0x....      LDR.W    R1,??DataTable25
   \   00000100   0x7008             STRB     R0,[R1, #+0]
   3260            //默认十字检测标志置为未进入。
   3261            BlackLeftCrossDone = 0;
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   00000108   0x7008             STRB     R0,[R1, #+0]
   3262            
   3263            return 1;
   \   0000010A   0x2001             MOVS     R0,#+1
   \   0000010C   0x4770             BX       LR               ;; return
   3264          }
   3265          
   3266          
   3267          
   3268          
   3269          
   3270          
   3271          //======================================================================
   3272          //函数名：BlackGetLeft
   3273          //功  能：左黑线提取算法
   3274          //参  数：无
   3275          //返  回：1成功 0失败
   3276          //影  响：BlackLeftCrossDone，BlackLeftLoc[][],
   3277          //        BlackLeftRealWB[], BlackLeftRealW[], BlackLeftRealB[],
   3278          //        LimitLeftWB, LimitLeftW, LimitLeftB
   3279          //说  明：1. 暂时可以处理直道，弯道，十字路口3种情况。2014.11.10
   3280          //      
   3281          //             
   3282          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   3283          uint8 BlackGetLeft(void)
   3284          {
   \                     BlackGetLeft: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   3285              uint8 row, temp, temp1, temp2, temp3, i;
   3286              uint8 GapCount, Row1RealLastLine, index, index1;
   3287              uint8 tempWB, tempW, tempB;
   3288              uint8 tempminus;
   3289              uint8 successRow = MaxValUint8;
   \   00000004   0xF04F 0x0AFF      MOV      R10,#+255
   3290              
   3291              int temp001;
   3292              
   3293              //左黑线提取前的参数初始化赋值
   3294              BlackGetLeftParaInit();
   \   00000008   0x.... 0x....      BL       BlackGetLeftParaInit
   3295              
   3296              //第1阶段。这1阶段有可能会返回黑线提取失败
   3297              
   3298              //每幅有效图像的线头的3个阈值单独储存。Step1Scan前调用前一幅有效图像保存的3个阈值。
   3299              LimitLeftWB = LimitLeftHeadWB;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable25_3
   \   00000016   0x7008             STRB     R0,[R1, #+0]
   3300              LimitLeftW = LimitLeftHeadW;
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable25_5
   \   00000022   0x7008             STRB     R0,[R1, #+0]
   3301              LimitLeftB = LimitLeftHeadB;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable25_6
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable25_7
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
   3302              
   3303              temp = BlackGetLeftStep1Scan(CameraHight - 1, CameraHight - BlackStep1Size - 1, 1);
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x210B             MOVS     R1,#+11
   \   00000034   0x203B             MOVS     R0,#+59
   \   00000036   0x.... 0x....      BL       BlackGetLeftStep1Scan
   \   0000003A   0x0004             MOVS     R4,R0
   3304              BlackLeftStep1ScanRow = temp;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable25_8
   \   00000040   0x7004             STRB     R4,[R0, #+0]
   3305              
   3306              //右线开始扫描的情况下，左线尾比右线头高，直接返回失败。增加后面这个条件是为了防止十字误判。
   3307              if(
   3308                 (BlackGetPreDir == 1)
   3309               &&(temp <= BlackRightHeadLine)
   3310               &&(BlackRightHeadLine < CameraHight - 7)
   3311                )
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable25_9
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD11D             BNE.N    ??BlackGetLeft_0
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable25_10
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x42A0             CMP      R0,R4
   \   00000056   0xD317             BCC.N    ??BlackGetLeft_0
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable25_10
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x2835             CMP      R0,#+53
   \   00000060   0xDA12             BGE.N    ??BlackGetLeft_0
   3312              {
   3313                  BlackLeftLoc[temp][0] = MaxValUint8;
   \   00000062   0x20FF             MOVS     R0,#+255
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable24_10
   \   00000068   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006A   0x2203             MOVS     R2,#+3
   \   0000006C   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000070   0x7008             STRB     R0,[R1, #+0]
   3314                  BlackLeftLoc[temp - 1][0] = MaxValUint8;
   \   00000072   0x20FF             MOVS     R0,#+255
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable24_10
   \   00000078   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007A   0x2203             MOVS     R2,#+3
   \   0000007C   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000080   0xF801 0x0C03      STRB     R0,[R1, #-3]
   3315                  return 0;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xE30F             B.N      ??BlackGetLeft_1
   3316              }
   3317              else
   3318              {
   3319              }
   3320              
   3321              if(temp == MaxValUint8)
   \                     ??BlackGetLeft_0: (+1)
   \   00000088   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008A   0x2CFF             CMP      R4,#+255
   \   0000008C   0xD101             BNE.N    ??BlackGetLeft_2
   3322              {
   3323                return 0;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xE30A             B.N      ??BlackGetLeft_1
   3324              }    
   3325              else 
   3326              {     
   3327                        
   3328                //每幅有效图像的线头的3个阈值单独储存。若线头提取成功，则该幅图像有效，线头3个阈值更新。
   3329                LimitLeftHeadWB = LimitLeftWB;
   \                     ??BlackGetLeft_2: (+1)
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable25_3
   \   00000096   0x7800             LDRB     R0,[R0, #+0]
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   0000009C   0x7008             STRB     R0,[R1, #+0]
   3330                LimitLeftHeadW = LimitLeftW;
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable25_5
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \   000000A8   0x7008             STRB     R0,[R1, #+0]
   3331                LimitLeftHeadB = LimitLeftB;
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable25_7
   \   000000AE   0x7800             LDRB     R0,[R0, #+0]
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable25_6
   \   000000B4   0x7008             STRB     R0,[R1, #+0]
   3332                
   3333                row = temp;
   \   000000B6   0x0025             MOVS     R5,R4
   3334                //如果起始线头的位置非常高，就认为是十字的前两个角，需要进入第4阶段向后补线。    
   3335                if(row < CameraHight - BlackLeftBackLineStart)
   \   000000B8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BA   0x2D0C             CMP      R5,#+12
   \   000000BC   0xDA06             BGE.N    ??BlackGetLeft_3
   3336                {
   3337                  BlackLeftStep4Flag = 1;               //默认为失败
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable23_2
   \   000000C4   0x7008             STRB     R0,[R1, #+0]
   3338                  BlackLeftStep4StartLine = row;
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable25
   \   000000CA   0x7005             STRB     R5,[R0, #+0]
   3339                }
   3340              }
   3341              
   3342              //第2阶段。到了这一阶段，已经不会返回黑线提取失败 
   3343              //temp为预测的黑点位置   
   3344          
   3345              //对预测值的大小限定
   3346              temp = BoundaryLimitRe(BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0], 
   3347                                     0, 
   3348                                     CameraRealWidth - 1);
   \                     ??BlackGetLeft_3: (+1)
   \   000000CC   0x22F9             MOVS     R2,#+249
   \   000000CE   0x2100             MOVS     R1,#+0
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable24_10
   \   000000D4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D6   0x2303             MOVS     R3,#+3
   \   000000D8   0xFB03 0x0005      MLA      R0,R3,R5,R0
   \   000000DC   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000000E0   0x.... 0x....      LDR.W    R3,??DataTable24_10
   \   000000E4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E6   0x2403             MOVS     R4,#+3
   \   000000E8   0xFB04 0x3305      MLA      R3,R4,R5,R3
   \   000000EC   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   000000F0   0xFA53 0xF080      UXTAB    R0,R3,R0
   \   000000F4   0x.... 0x....      LDR.W    R3,??DataTable24_10
   \   000000F8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FA   0x2403             MOVS     R4,#+3
   \   000000FC   0xFB04 0x3305      MLA      R3,R4,R5,R3
   \   00000100   0x781B             LDRB     R3,[R3, #+0]
   \   00000102   0x1AC0             SUBS     R0,R0,R3
   \   00000104   0x.... 0x....      BL       BoundaryLimitRe
   \   00000108   0x0004             MOVS     R4,R0
   3349              //预测值更新后就刷新一次堆栈，堆栈顶部丢失。
   3350              BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable24_14
   \   0000010E   0x7800             LDRB     R0,[R0, #+0]
   \   00000110   0x.... 0x....      LDR.W    R1,??DataTable24_13
   \   00000114   0x7008             STRB     R0,[R1, #+0]
   3351              BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable25_11
   \   0000011A   0x7800             LDRB     R0,[R0, #+0]
   \   0000011C   0x.... 0x....      LDR.W    R1,??DataTable24_14
   \   00000120   0x7008             STRB     R0,[R1, #+0]
   3352              BlackLeftWinPredictStore2 = temp;
   \   00000122   0x.... 0x....      LDR.W    R0,??DataTable25_11
   \   00000126   0x7004             STRB     R4,[R0, #+0]
   3353          
   3354              index = 0;
   \   00000128   0xF05F 0x0800      MOVS     R8,#+0
   3355              index1 = 0;
   \   0000012C   0xF05F 0x0900      MOVS     R9,#+0
   3356              
   3357              GapCount = 0;  //连续多少行没有采集到黑线
   \   00000130   0x2600             MOVS     R6,#+0
   3358              successRow = MaxValUint8; //记录最后一次成功的行
   \   00000132   0xF04F 0x0AFF      MOV      R10,#+255
   3359              //从最近的认证行到取最远的行
   3360              for(row -= 2; ; row -= 2)
   \   00000136   0x1EAD             SUBS     R5,R5,#+2
   \   00000138   0xE000             B.N      ??BlackGetLeft_4
   \                     ??BlackGetLeft_5: (+1)
   \   0000013A   0x1EAD             SUBS     R5,R5,#+2
   3361              {      
   3362                //连续2行检测黑点。
   3363                temp1 = BlackGetLeftStep2Win(row, BlackLeftWinVal, temp, 1);
   \                     ??BlackGetLeft_4: (+1)
   \   0000013C   0x2301             MOVS     R3,#+1
   \   0000013E   0x0022             MOVS     R2,R4
   \   00000140   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000142   0x210F             MOVS     R1,#+15
   \   00000144   0x0028             MOVS     R0,R5
   \   00000146   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000148   0x.... 0x....      BL       BlackGetLeftStep2Win
   \   0000014C   0x4683             MOV      R11,R0
   3364                temp2 = BlackGetLeftStep2Win(row-1, BlackLeftWinVal, temp, 2);
   \   0000014E   0x2302             MOVS     R3,#+2
   \   00000150   0x0022             MOVS     R2,R4
   \   00000152   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000154   0x210F             MOVS     R1,#+15
   \   00000156   0x1E68             SUBS     R0,R5,#+1
   \   00000158   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015A   0x.... 0x....      BL       BlackGetLeftStep2Win
   3365                
   3366                temp3 = (
   3367                        (temp1 == 0)
   3368                      &&(temp2 == 0)
   3369                      //&&(BlackLeftStep4Flag == 0)
   3370                        );
   \   0000015E   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000162   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000166   0xD104             BNE.N    ??BlackGetLeft_6
   \   00000168   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000016A   0x2800             CMP      R0,#+0
   \   0000016C   0xD101             BNE.N    ??BlackGetLeft_6
   \   0000016E   0x2101             MOVS     R1,#+1
   \   00000170   0xE000             B.N      ??BlackGetLeft_7
   \                     ??BlackGetLeft_6: (+1)
   \   00000172   0x2100             MOVS     R1,#+0
   3371                
   3372                //若连续2行黑点检测成功，则对3个阈值进行更新，且更新预测点位置。
   3373                if(temp1 == 1 && temp2 == 1) 
   \                     ??BlackGetLeft_7: (+1)
   \   00000174   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000178   0xF1BB 0x0F01      CMP      R11,#+1
   \   0000017C   0xF040 0x80A5      BNE.W    ??BlackGetLeft_8
   \   00000180   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000182   0x2801             CMP      R0,#+1
   \   00000184   0xF040 0x80A1      BNE.W    ??BlackGetLeft_8
   3374                {
   3375                  //只要连续采集到双黑线，则两个标志位重置为0.
   3376                  index = 0;
   \   00000188   0xF05F 0x0800      MOVS     R8,#+0
   3377                  index1 = 0;
   \   0000018C   0xF05F 0x0900      MOVS     R9,#+0
   3378                  successRow = row;
   \   00000190   0x46AA             MOV      R10,R5
   3379                  
   3380                  //差值的处理，留有裕度，且有上下界。
   3381                  tempWB = (BlackLeftRealWB[0] + BlackLeftRealWB[1]) / 2 - LimitLeftWBMargin; 
   \   00000192   0x.... 0x....      LDR.W    R0,??DataTable25_12
   \   00000196   0x7800             LDRB     R0,[R0, #+0]
   \   00000198   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   0000019C   0x7849             LDRB     R1,[R1, #+1]
   \   0000019E   0x1808             ADDS     R0,R1,R0
   \   000001A0   0x2102             MOVS     R1,#+2
   \   000001A2   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000001A6   0x3814             SUBS     R0,R0,#+20
   3382                  if(tempWB < LimitLeftWBMin) tempWB = LimitLeftWBMin;
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable25_13
   \   000001AC   0x7809             LDRB     R1,[R1, #+0]
   \   000001AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B0   0x4288             CMP      R0,R1
   \   000001B2   0xD203             BCS.N    ??BlackGetLeft_9
   \   000001B4   0x.... 0x....      LDR.W    R0,??DataTable25_13
   \   000001B8   0x7800             LDRB     R0,[R0, #+0]
   \   000001BA   0xE008             B.N      ??BlackGetLeft_10
   3383                  else if(tempWB > LimitLeftWBMax) tempWB = LimitLeftWBMax;
   \                     ??BlackGetLeft_9: (+1)
   \   000001BC   0x.... 0x....      LDR.W    R1,??DataTable25_14
   \   000001C0   0x7809             LDRB     R1,[R1, #+0]
   \   000001C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001C4   0x4281             CMP      R1,R0
   \   000001C6   0xD202             BCS.N    ??BlackGetLeft_10
   \   000001C8   0x.... 0x....      LDR.W    R0,??DataTable25_14
   \   000001CC   0x7800             LDRB     R0,[R0, #+0]
   3384                  else ;
   3385                  LimitLeftWB = tempWB;
   \                     ??BlackGetLeft_10: (+1)
   \   000001CE   0x.... 0x....      LDR.W    R1,??DataTable25_3
   \   000001D2   0x7008             STRB     R0,[R1, #+0]
   3386                  
   3387                  //白点的处理，留有裕度，且有上下界。
   3388                  tempW = (BlackLeftRealW[0] + BlackLeftRealW[1]) / 2 - LimitLeftWMargin;
   \   000001D4   0x.... 0x....      LDR.W    R0,??DataTable25_15
   \   000001D8   0x7800             LDRB     R0,[R0, #+0]
   \   000001DA   0x.... 0x....      LDR.W    R1,??DataTable25_15
   \   000001DE   0x7849             LDRB     R1,[R1, #+1]
   \   000001E0   0x1808             ADDS     R0,R1,R0
   \   000001E2   0x2102             MOVS     R1,#+2
   \   000001E4   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000001E8   0x3828             SUBS     R0,R0,#+40
   3389                  if(tempW < LimitLeftWMin) tempW = LimitLeftWMin;
   \   000001EA   0x.... 0x....      LDR.W    R1,??DataTable25_16
   \   000001EE   0x7809             LDRB     R1,[R1, #+0]
   \   000001F0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001F2   0x4288             CMP      R0,R1
   \   000001F4   0xD203             BCS.N    ??BlackGetLeft_11
   \   000001F6   0x.... 0x....      LDR.W    R0,??DataTable25_16
   \   000001FA   0x7800             LDRB     R0,[R0, #+0]
   \   000001FC   0xE008             B.N      ??BlackGetLeft_12
   3390                  else if(tempW > LimitLeftWMax) tempW = LimitLeftWMax;
   \                     ??BlackGetLeft_11: (+1)
   \   000001FE   0x.... 0x....      LDR.W    R1,??DataTable25_17
   \   00000202   0x7809             LDRB     R1,[R1, #+0]
   \   00000204   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000206   0x4281             CMP      R1,R0
   \   00000208   0xD202             BCS.N    ??BlackGetLeft_12
   \   0000020A   0x.... 0x....      LDR.W    R0,??DataTable25_17
   \   0000020E   0x7800             LDRB     R0,[R0, #+0]
   3391                  else ;
   3392                  LimitLeftW = tempW;
   \                     ??BlackGetLeft_12: (+1)
   \   00000210   0x.... 0x....      LDR.W    R1,??DataTable25_5
   \   00000214   0x7008             STRB     R0,[R1, #+0]
   3393                  
   3394                  //黑点的处理，留有裕度，且有上下界。
   3395                  tempB = (BlackLeftRealB[0] + BlackLeftRealB[1]) / 2 + LimitLeftBMargin;
   \   00000216   0x.... 0x....      LDR.W    R0,??DataTable25_18
   \   0000021A   0x7800             LDRB     R0,[R0, #+0]
   \   0000021C   0x.... 0x....      LDR.W    R1,??DataTable25_18
   \   00000220   0x7849             LDRB     R1,[R1, #+1]
   \   00000222   0x1808             ADDS     R0,R1,R0
   \   00000224   0x2102             MOVS     R1,#+2
   \   00000226   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000022A   0x3023             ADDS     R0,R0,#+35
   3396                  if(tempB < LimitLeftBMin) tempB = LimitLeftBMin;
   \   0000022C   0x.... 0x....      LDR.W    R1,??DataTable25_19
   \   00000230   0x7809             LDRB     R1,[R1, #+0]
   \   00000232   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000234   0x4288             CMP      R0,R1
   \   00000236   0xD203             BCS.N    ??BlackGetLeft_13
   \   00000238   0x.... 0x....      LDR.W    R0,??DataTable25_19
   \   0000023C   0x7800             LDRB     R0,[R0, #+0]
   \   0000023E   0xE008             B.N      ??BlackGetLeft_14
   3397                  else if(tempB > LimitLeftBMax) tempB = LimitLeftBMax;
   \                     ??BlackGetLeft_13: (+1)
   \   00000240   0x.... 0x....      LDR.W    R1,??DataTable25_20
   \   00000244   0x7809             LDRB     R1,[R1, #+0]
   \   00000246   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000248   0x4281             CMP      R1,R0
   \   0000024A   0xD202             BCS.N    ??BlackGetLeft_14
   \   0000024C   0x.... 0x....      LDR.W    R0,??DataTable25_20
   \   00000250   0x7800             LDRB     R0,[R0, #+0]
   3398                  else ;
   3399                  //黑色阈值不能超过白色
   3400                  if(tempB >= LimitLeftW)
   \                     ??BlackGetLeft_14: (+1)
   \   00000252   0x.... 0x....      LDR.W    R1,??DataTable25_5
   \   00000256   0x7809             LDRB     R1,[R1, #+0]
   \   00000258   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000025A   0x4288             CMP      R0,R1
   \   0000025C   0xD303             BCC.N    ??BlackGetLeft_15
   3401                  {
   3402                    tempB = LimitLeftW - 1;
   \   0000025E   0x.... 0x....      LDR.W    R0,??DataTable25_5
   \   00000262   0x7800             LDRB     R0,[R0, #+0]
   \   00000264   0x1E40             SUBS     R0,R0,#+1
   3403                  }
   3404                  else
   3405                  {
   3406                  }
   3407                  LimitLeftB = tempB; 
   \                     ??BlackGetLeft_15: (+1)
   \   00000266   0x.... 0x....      LDR.W    R1,??DataTable25_7
   \   0000026A   0x7008             STRB     R0,[R1, #+0]
   3408                   
   3409                  //对预测值的大小限定
   3410                  temp = BoundaryLimitRe(BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0], 
   3411                                         0, 
   3412                                         CameraRealWidth - 1);
   \   0000026C   0x22F9             MOVS     R2,#+249
   \   0000026E   0x2100             MOVS     R1,#+0
   \   00000270   0x.... 0x....      LDR.W    R0,??DataTable24_10
   \   00000274   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000276   0x2303             MOVS     R3,#+3
   \   00000278   0xFB03 0x0005      MLA      R0,R3,R5,R0
   \   0000027C   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000280   0x.... 0x....      LDR.W    R3,??DataTable24_10
   \   00000284   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000286   0x2403             MOVS     R4,#+3
   \   00000288   0xFB04 0x3305      MLA      R3,R4,R5,R3
   \   0000028C   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   00000290   0xFA53 0xF080      UXTAB    R0,R3,R0
   \   00000294   0x.... 0x....      LDR.W    R3,??DataTable24_10
   \   00000298   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000029A   0x2403             MOVS     R4,#+3
   \   0000029C   0xFB04 0x3305      MLA      R3,R4,R5,R3
   \   000002A0   0x781B             LDRB     R3,[R3, #+0]
   \   000002A2   0x1AC0             SUBS     R0,R0,R3
   \   000002A4   0x.... 0x....      BL       BoundaryLimitRe
   \   000002A8   0x0004             MOVS     R4,R0
   3413                  
   3414                  //预测值更新后就刷新一次堆栈，堆栈顶部丢失。
   3415                  BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
   \   000002AA   0x.... 0x....      LDR.W    R0,??DataTable24_14
   \   000002AE   0x7800             LDRB     R0,[R0, #+0]
   \   000002B0   0x.... 0x....      LDR.W    R1,??DataTable24_13
   \   000002B4   0x7008             STRB     R0,[R1, #+0]
   3416                  BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
   \   000002B6   0x.... 0x....      LDR.W    R0,??DataTable25_11
   \   000002BA   0x7800             LDRB     R0,[R0, #+0]
   \   000002BC   0x.... 0x....      LDR.W    R1,??DataTable24_14
   \   000002C0   0x7008             STRB     R0,[R1, #+0]
   3417                  BlackLeftWinPredictStore2 = temp;
   \   000002C2   0x.... 0x....      LDR.W    R0,??DataTable25_11
   \   000002C6   0x7004             STRB     R4,[R0, #+0]
   \   000002C8   0xE1BF             B.N      ??BlackGetLeft_16
   3418                }
   3419                //如果没能连续两行检测黑点成功，原本打算用原位置的预测点，后来发现效果不好，所以决定按预测点的趋势走。
   3420                //如果连续两行均采集黑线失败，则记数，记到一定值就再来一次Step1
   3421                //如果第4阶段检测标志置位，就不用进入十字检测了。
   3422                else if(temp3 == 1)
   \                     ??BlackGetLeft_8: (+1)
   \   000002CA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002CC   0x2901             CMP      R1,#+1
   \   000002CE   0xF040 0x8119      BNE.W    ??BlackGetLeft_17
   3423                {        
   3424                  //若上一幅图是单线，则不允许开启十字。
   3425                  if(SingleBlackLastAllFlag == 1) break;        
   \   000002D2   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   000002D6   0x7800             LDRB     R0,[R0, #+0]
   \   000002D8   0x2801             CMP      R0,#+1
   \   000002DA   0xF000 0x81BD      BEQ.W    ??BlackGetLeft_18
   3426                  //直角黑块锁存期间，为了防止一边十字成功另一边不成功造成的中心线倾斜，所以不允许开启十字。
   3427                  if(AngleZoneConfirmLockFlag == 1) break;
   \                     ??BlackGetLeft_19: (+1)
   \   000002DE   0x.... 0x....      LDR.W    R0,??DataTable25_21
   \   000002E2   0x7800             LDRB     R0,[R0, #+0]
   \   000002E4   0x2801             CMP      R0,#+1
   \   000002E6   0xF000 0x81B7      BEQ.W    ??BlackGetLeft_18
   3428                  
   3429                  //第一次检测到双线失败时，最后的几条线可能已经不太正确。
   3430                  if(index1 == 0)
   \                     ??BlackGetLeft_20: (+1)
   \   000002EA   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000002EE   0xF1B9 0x0F00      CMP      R9,#+0
   \   000002F2   0xD16C             BNE.N    ??BlackGetLeft_21
   3431                  {
   3432                    //如果储存的3个值趋势相同，也就是变化量同号，那么就按正常的来。否则就认为最后一个值已经错误。
   3433                    if(row <= CameraHight - 3)
   \   000002F4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002F6   0x2D3A             CMP      R5,#+58
   \   000002F8   0xDA67             BGE.N    ??BlackGetLeft_22
   3434                    {
   3435                        //若前面两行没有被大跳变删除掉。
   3436                        if (BlackLeftLoc[row + 1][0] != MaxValUint8 && BlackLeftLoc[row + 2][0] != MaxValUint8)
   \   000002FA   0x.... 0x....      LDR.W    R0,??DataTable24_10
   \   000002FE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000300   0x2103             MOVS     R1,#+3
   \   00000302   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000306   0x78C0             LDRB     R0,[R0, #+3]
   \   00000308   0x28FF             CMP      R0,#+255
   \   0000030A   0xD029             BEQ.N    ??BlackGetLeft_23
   \   0000030C   0x.... 0x....      LDR.W    R0,??DataTable24_10
   \   00000310   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000312   0x2103             MOVS     R1,#+3
   \   00000314   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000318   0x7980             LDRB     R0,[R0, #+6]
   \   0000031A   0x28FF             CMP      R0,#+255
   \   0000031C   0xD020             BEQ.N    ??BlackGetLeft_23
   3437                        {
   3438          
   3439          
   3440                            //如果黑线点够，最好还是根据实际的黑点来更新窗口值。
   3441                            tempminus = BoundaryLimitRe(BlackLeftLoc[row + 1][0] * 3 - BlackLeftLoc[row + 2][0] * 2,
   3442                                                        0,
   3443                                                        CameraRealWidth - 1);
   \   0000031E   0x22F9             MOVS     R2,#+249
   \   00000320   0x2100             MOVS     R1,#+0
   \   00000322   0x.... 0x....      LDR.W    R0,??DataTable24_10
   \   00000326   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000328   0x2303             MOVS     R3,#+3
   \   0000032A   0xFB03 0x0005      MLA      R0,R3,R5,R0
   \   0000032E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000330   0x2303             MOVS     R3,#+3
   \   00000332   0x4358             MULS     R0,R3,R0
   \   00000334   0x.... 0x....      LDR.W    R3,??DataTable24_10
   \   00000338   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000033A   0x2403             MOVS     R4,#+3
   \   0000033C   0xFB04 0x3305      MLA      R3,R4,R5,R3
   \   00000340   0x799B             LDRB     R3,[R3, #+6]
   \   00000342   0xEBB0 0x0043      SUBS     R0,R0,R3, LSL #+1
   \   00000346   0x.... 0x....      BL       BoundaryLimitRe
   3444                            //斜入十字不管怎么摆，左十字的上段线一定在下段线的右边。
   3445                            tempminus = MaxRe(tempminus, BlackLeftLoc[row + 1][0]);
   \   0000034A   0x.... 0x....      LDR.W    R1,??DataTable24_10
   \   0000034E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000350   0x2203             MOVS     R2,#+3
   \   00000352   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000356   0x78C9             LDRB     R1,[R1, #+3]
   \   00000358   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000035A   0x.... 0x....      BL       MaxRe
   \   0000035E   0xE031             B.N      ??BlackGetLeft_24
   3446                        }
   3447                        else
   3448                        {
   3449                            temp001 = BlackLeftWinPredictStore1 - BlackLeftWinPredictStore0;
   \                     ??BlackGetLeft_23: (+1)
   \   00000360   0x.... 0x....      LDR.W    R0,??DataTable24_14
   \   00000364   0x7800             LDRB     R0,[R0, #+0]
   \   00000366   0x.... 0x....      LDR.W    R1,??DataTable24_13
   \   0000036A   0x7809             LDRB     R1,[R1, #+0]
   \   0000036C   0x1A40             SUBS     R0,R0,R1
   3450                            BlackLeftWinPredictStore0 += temp001;
   \   0000036E   0x.... 0x....      LDR.W    R1,??DataTable24_13
   \   00000372   0x7809             LDRB     R1,[R1, #+0]
   \   00000374   0x1841             ADDS     R1,R0,R1
   \   00000376   0x.... 0x....      LDR.W    R2,??DataTable24_13
   \   0000037A   0x7011             STRB     R1,[R2, #+0]
   3451                            BlackLeftWinPredictStore1 += temp001;
   \   0000037C   0x.... 0x....      LDR.W    R1,??DataTable24_14
   \   00000380   0x7809             LDRB     R1,[R1, #+0]
   \   00000382   0x1840             ADDS     R0,R0,R1
   \   00000384   0x.... 0x....      LDR.W    R1,??DataTable24_14
   \   00000388   0x7008             STRB     R0,[R1, #+0]
   3452                            BlackLeftWinPredictStore2 = BlackLeftWinPredictStore1 + BlackLeftWinPredictStore1 - BlackLeftWinPredictStore0;
   \   0000038A   0x.... 0x....      LDR.W    R0,??DataTable24_14
   \   0000038E   0x7800             LDRB     R0,[R0, #+0]
   \   00000390   0x.... 0x....      LDR.W    R1,??DataTable24_14
   \   00000394   0x7809             LDRB     R1,[R1, #+0]
   \   00000396   0x1808             ADDS     R0,R1,R0
   \   00000398   0x.... 0x....      LDR.W    R1,??DataTable24_13
   \   0000039C   0x7809             LDRB     R1,[R1, #+0]
   \   0000039E   0x1A40             SUBS     R0,R0,R1
   \   000003A0   0x.... 0x....      LDR.W    R1,??DataTable25_11
   \   000003A4   0x7008             STRB     R0,[R1, #+0]
   3453                            tempminus = BoundaryLimitRe(BlackLeftWinPredictStore2 + BlackLeftWinPredictStore2 - BlackLeftWinPredictStore1,
   3454                                                        0,
   3455                                                        CameraRealWidth - 1);       
   \   000003A6   0x22F9             MOVS     R2,#+249
   \   000003A8   0x2100             MOVS     R1,#+0
   \   000003AA   0x.... 0x....      LDR.W    R0,??DataTable25_11
   \   000003AE   0x7800             LDRB     R0,[R0, #+0]
   \   000003B0   0x.... 0x....      LDR.W    R3,??DataTable25_11
   \   000003B4   0x781B             LDRB     R3,[R3, #+0]
   \   000003B6   0x1818             ADDS     R0,R3,R0
   \   000003B8   0x.... 0x....      LDR.W    R3,??DataTable24_14
   \   000003BC   0x781B             LDRB     R3,[R3, #+0]
   \   000003BE   0x1AC0             SUBS     R0,R0,R3
   \   000003C0   0x.... 0x....      BL       BoundaryLimitRe
   3456                        }
   3457                    }
   3458                    else
   3459                    {
   3460                        //理论上不会走到这里。
   3461                        return 0;
   3462                    }
   3463                    
   3464                    //进来一次后就再也不进来了。
   3465                    index1++;          
   \                     ??BlackGetLeft_24: (+1)
   \   000003C4   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000003C8   0xE010             B.N      ??BlackGetLeft_25
   \                     ??BlackGetLeft_22: (+1)
   \   000003CA   0x2000             MOVS     R0,#+0
   \   000003CC   0xE16C             B.N      ??BlackGetLeft_1
   3466                  }
   3467                  else
   3468                  {
   3469                    //预测点按趋势走也要限幅。
   3470                    tempminus = BoundaryLimitRe(BlackLeftWinPredictStore2 + BlackLeftWinPredictStore2 - BlackLeftWinPredictStore1,
   3471                                                0,
   3472                                                CameraRealWidth - 1);          
   \                     ??BlackGetLeft_21: (+1)
   \   000003CE   0x22F9             MOVS     R2,#+249
   \   000003D0   0x2100             MOVS     R1,#+0
   \   000003D2   0x.... 0x....      LDR.W    R0,??DataTable25_11
   \   000003D6   0x7800             LDRB     R0,[R0, #+0]
   \   000003D8   0x.... 0x....      LDR.W    R3,??DataTable25_11
   \   000003DC   0x781B             LDRB     R3,[R3, #+0]
   \   000003DE   0x1818             ADDS     R0,R3,R0
   \   000003E0   0x.... 0x....      LDR.W    R3,??DataTable24_14
   \   000003E4   0x781B             LDRB     R3,[R3, #+0]
   \   000003E6   0x1AC0             SUBS     R0,R0,R3
   \   000003E8   0x.... 0x....      BL       BoundaryLimitRe
   3473                  }
   3474                  //temp在这里表示窗口预测点位置。
   3475                  temp = tempminus;
   \                     ??BlackGetLeft_25: (+1)
   \   000003EC   0x0004             MOVS     R4,R0
   3476                  BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
   \   000003EE   0x.... 0x....      LDR.W    R0,??DataTable24_14
   \   000003F2   0x7800             LDRB     R0,[R0, #+0]
   \   000003F4   0x.... 0x....      LDR.W    R1,??DataTable24_13
   \   000003F8   0x7008             STRB     R0,[R1, #+0]
   3477                  BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
   \   000003FA   0x.... 0x....      LDR.W    R0,??DataTable25_11
   \   000003FE   0x7800             LDRB     R0,[R0, #+0]
   \   00000400   0x.... 0x....      LDR.W    R1,??DataTable24_14
   \   00000404   0x7008             STRB     R0,[R1, #+0]
   3478                  BlackLeftWinPredictStore2 = temp;
   \   00000406   0x.... 0x....      LDR.W    R0,??DataTable25_11
   \   0000040A   0x7004             STRB     R4,[R0, #+0]
   3479                        
   3480                  //Row1RealLastLine记录第1段黑线的最后一行。
   3481                  if(index == 0)
   \   0000040C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000410   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000414   0xD118             BNE.N    ??BlackGetLeft_26
   3482                  {
   3483                    //进来一次后，就再也不会进来了。
   3484                    index++;
   \   00000416   0xF118 0x0801      ADDS     R8,R8,#+1
   3485                    for(i = row; i <= CameraHight - 1; i++)
   \   0000041A   0x0028             MOVS     R0,R5
   \   0000041C   0xE000             B.N      ??BlackGetLeft_27
   \                     ??BlackGetLeft_28: (+1)
   \   0000041E   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackGetLeft_27: (+1)
   \   00000420   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000422   0x283C             CMP      R0,#+60
   \   00000424   0xDA09             BGE.N    ??BlackGetLeft_29
   3486                    {
   3487                      if(BlackLeftLoc[i][0] != MaxValUint8)
   \   00000426   0x.... 0x....      LDR.W    R1,??DataTable24_10
   \   0000042A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000042C   0x2203             MOVS     R2,#+3
   \   0000042E   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   00000432   0x7809             LDRB     R1,[R1, #+0]
   \   00000434   0x29FF             CMP      R1,#+255
   \   00000436   0xD0F2             BEQ.N    ??BlackGetLeft_28
   3488                      {
   3489                        Row1RealLastLine = i;
   \   00000438   0x0007             MOVS     R7,R0
   3490                        break;
   3491                      }
   3492                    }
   3493                    if(Row1RealLastLine >= CameraHight - 1)
   \                     ??BlackGetLeft_29: (+1)
   \   0000043A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000043C   0x2F3B             CMP      R7,#+59
   \   0000043E   0xDB00             BLT.N    ??BlackGetLeft_30
   3494                    {
   3495                      Row1RealLastLine = CameraHight - 1;
   \   00000440   0x273B             MOVS     R7,#+59
   3496                    }
   3497                    else
   3498                    {
   3499                    }
   3500                    //记录为全局变量
   3501                    BlackLeftRow1RealLastLine = Row1RealLastLine;
   \                     ??BlackGetLeft_30: (+1)
   \   00000442   0x.... 0x....      LDR.W    R0,??DataTable25_22
   \   00000446   0x7007             STRB     R7,[R0, #+0]
   3502                  }
   3503                  
   3504                  GapCount += 2;
   \                     ??BlackGetLeft_26: (+1)
   \   00000448   0x1CB6             ADDS     R6,R6,#+2
   3505                  if (successRow != MaxValUint8 && BlackLeftLoc[successRow][0]<10 && BlackLeftLoc[successRow - 1][0]<10) { }
   \   0000044A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000044E   0xF1BA 0x0FFF      CMP      R10,#+255
   \   00000452   0xD015             BEQ.N    ??BlackGetLeft_31
   \   00000454   0x.... 0x....      LDR.W    R0,??DataTable24_10
   \   00000458   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000045C   0x2103             MOVS     R1,#+3
   \   0000045E   0xFB01 0x000A      MLA      R0,R1,R10,R0
   \   00000462   0x7800             LDRB     R0,[R0, #+0]
   \   00000464   0x280A             CMP      R0,#+10
   \   00000466   0xDA0B             BGE.N    ??BlackGetLeft_31
   \   00000468   0x.... 0x....      LDR.W    R0,??DataTable24_10
   \   0000046C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000470   0x2103             MOVS     R1,#+3
   \   00000472   0xFB01 0x000A      MLA      R0,R1,R10,R0
   \   00000476   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000047A   0x280A             CMP      R0,#+10
   \   0000047C   0xF2C0 0x80E5      BLT.W    ??BlackGetLeft_16
   3506                  ///////////////////////////////进入十字重新检测的条件还要再严格一些，减少没必要的时间，比如说前面最多只允许检测到多少行。
   3507                  else if(GapCount > BlackCrossGapLine)
   \                     ??BlackGetLeft_31: (+1)
   \   00000480   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000482   0x2E0D             CMP      R6,#+13
   \   00000484   0xDB39             BLT.N    ??BlackGetLeft_32
   3508                  {
   3509                    //再检测时的行太远了，就没必要检测了。
   3510                    if(row < BlackLeftCrossTooLowLine)
   \   00000486   0x.... 0x....      LDR.W    R0,??DataTable25_23
   \   0000048A   0x7800             LDRB     R0,[R0, #+0]
   \   0000048C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000048E   0x4285             CMP      R5,R0
   \   00000490   0xD20E             BCS.N    ??BlackGetLeft_33
   3511                    {
   3512                      //扫屁股。
   3513                      for(i = row; ; i--)
   \   00000492   0x0028             MOVS     R0,R5
   \   00000494   0xE000             B.N      ??BlackGetLeft_34
   \                     ??BlackGetLeft_35: (+1)
   \   00000496   0x1E40             SUBS     R0,R0,#+1
   3514                      {
   3515                        BlackLeftLoc[i][0] = MaxValUint8;
   \                     ??BlackGetLeft_34: (+1)
   \   00000498   0x21FF             MOVS     R1,#+255
   \   0000049A   0x.... 0x....      LDR.W    R2,??DataTable24_10
   \   0000049E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004A0   0x2303             MOVS     R3,#+3
   \   000004A2   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000004A6   0x7011             STRB     R1,[R2, #+0]
   3516                        if(i == 0) break;
   \   000004A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004AA   0x2800             CMP      R0,#+0
   \   000004AC   0xD1F3             BNE.N    ??BlackGetLeft_35
   3517                      }
   3518                      //跳出来。
   3519                      break;
   \   000004AE   0xE0D3             B.N      ??BlackGetLeft_18
   3520                    }
   3521                    else
   3522                    {
   3523                    }
   3524                    
   3525                    //进入十字重新检测后，就不允许出现第4阶段向后补线的情况。
   3526                    if(BlackLeftStep4Flag == 1)
   \                     ??BlackGetLeft_33: (+1)
   \   000004B0   0x....             LDR.N    R0,??DataTable23_2
   \   000004B2   0x7800             LDRB     R0,[R0, #+0]
   \   000004B4   0x2801             CMP      R0,#+1
   \   000004B6   0xD102             BNE.N    ??BlackGetLeft_36
   3527                    {
   3528                      BlackLeftStep4Flag = 3;   //向后补线出错。
   \   000004B8   0x2003             MOVS     R0,#+3
   \   000004BA   0x....             LDR.N    R1,??DataTable23_2
   \   000004BC   0x7008             STRB     R0,[R1, #+0]
   3529                    }
   3530                    else
   3531                    {
   3532                    }
   3533                    
   3534                    //十字再检测的话，Step1Scan的线头必须够近。
   3535                    //最后只剩第0，1行没有检测的话，就不用开启十字再检测了。
   3536                    if(BlackLeftStep1ScanRow >= CameraHight - 3 && row > 3)
   \                     ??BlackGetLeft_36: (+1)
   \   000004BE   0x.... 0x....      LDR.W    R0,??DataTable25_8
   \   000004C2   0x7800             LDRB     R0,[R0, #+0]
   \   000004C4   0x2839             CMP      R0,#+57
   \   000004C6   0xDB17             BLT.N    ??BlackGetLeft_37
   \   000004C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004CA   0x2D04             CMP      R5,#+4
   \   000004CC   0xDB14             BLT.N    ??BlackGetLeft_37
   3537                    {            
   3538                      //正常的十字再检测。
   3539                      if(BlackLeftAgainForCross(row - 2, 1, Row1RealLastLine, temp) == 0)
   \   000004CE   0x0023             MOVS     R3,R4
   \   000004D0   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000004D2   0x003A             MOVS     R2,R7
   \   000004D4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000004D6   0x2101             MOVS     R1,#+1
   \   000004D8   0x1EA8             SUBS     R0,R5,#+2
   \   000004DA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004DC   0x.... 0x....      BL       BlackLeftAgainForCross
   \   000004E0   0x2800             CMP      R0,#+0
   \   000004E2   0xD104             BNE.N    ??BlackGetLeft_38
   3540                      {
   3541                        BlackLeftCrossDone = 1;  //十字检测失败           
   \   000004E4   0x2001             MOVS     R0,#+1
   \   000004E6   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   000004EA   0x7008             STRB     R0,[R1, #+0]
   \   000004EC   0xE003             B.N      ??BlackGetLeft_39
   3542                      }
   3543                      else
   3544                      {
   3545                        BlackLeftCrossDone = 2;  //十字检测成功
   \                     ??BlackGetLeft_38: (+1)
   \   000004EE   0x2002             MOVS     R0,#+2
   \   000004F0   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   000004F4   0x7008             STRB     R0,[R1, #+0]
   3546                      }
   3547                      break;  //十字再检测里会开窗检测到指定的最后一行，所以不用再循环了，直接跳出
   \                     ??BlackGetLeft_39: (+1)
   \   000004F6   0xE0AF             B.N      ??BlackGetLeft_18
   3548                    }
   3549                    //线头太远，或者只剩第0，1行的时候，直接break就好，远处的行在初始化时已经置为无效值。
   3550                    else
   3551                    {
   3552                      break;
   \                     ??BlackGetLeft_37: (+1)
   \   000004F8   0xE0AE             B.N      ??BlackGetLeft_18
   3553                    }
   3554                    
   3555                  }
   3556                  else
   3557                  {
   3558                    BlackLeftCrossDone = 0;   //十字检测未进入
   \                     ??BlackGetLeft_32: (+1)
   \   000004FA   0x2000             MOVS     R0,#+0
   \   000004FC   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   00000500   0x7008             STRB     R0,[R1, #+0]
   \   00000502   0xE0A2             B.N      ??BlackGetLeft_16
   3559                  }
   3560                }
   3561                //连续两线只有一线检测成功的情况，仍然要按趋势更新窗口预测值。
   3562                else if((temp1 == 1 && temp2 == 0) || (temp1 == 0 && temp2 == 1)) 
   \                     ??BlackGetLeft_17: (+1)
   \   00000504   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000508   0xF1BB 0x0F01      CMP      R11,#+1
   \   0000050C   0xD102             BNE.N    ??BlackGetLeft_40
   \   0000050E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000510   0x2800             CMP      R0,#+0
   \   00000512   0xD009             BEQ.N    ??BlackGetLeft_41
   \                     ??BlackGetLeft_40: (+1)
   \   00000514   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000518   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000051C   0xF040 0x8095      BNE.W    ??BlackGetLeft_16
   \   00000520   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000522   0x2801             CMP      R0,#+1
   \   00000524   0xF040 0x8091      BNE.W    ??BlackGetLeft_16
   3563                {        
   3564                  
   3565                  //第一次检测到有单条线失败时，最后的几条线可能已经不太正确。
   3566                  if(index1 == 0)
   \                     ??BlackGetLeft_41: (+1)
   \   00000528   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000052C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000530   0xD16C             BNE.N    ??BlackGetLeft_42
   3567                  {
   3568                    //如果储存的3个值趋势相同，也就是变化量同号，那么就按正常的来。否则就认为最后一个值已经错误。
   3569                    if(row <= CameraHight - 3)
   \   00000532   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000534   0x2D3A             CMP      R5,#+58
   \   00000536   0xDA67             BGE.N    ??BlackGetLeft_43
   3570                    {
   3571                        //若前面两行没有被大跳变删除掉。
   3572                        if (BlackLeftLoc[row + 1][0] != MaxValUint8 && BlackLeftLoc[row + 2][0] != MaxValUint8)
   \   00000538   0x.... 0x....      LDR.W    R0,??DataTable24_10
   \   0000053C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000053E   0x2103             MOVS     R1,#+3
   \   00000540   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000544   0x78C0             LDRB     R0,[R0, #+3]
   \   00000546   0x28FF             CMP      R0,#+255
   \   00000548   0xD029             BEQ.N    ??BlackGetLeft_44
   \   0000054A   0x.... 0x....      LDR.W    R0,??DataTable24_10
   \   0000054E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000550   0x2103             MOVS     R1,#+3
   \   00000552   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000556   0x7980             LDRB     R0,[R0, #+6]
   \   00000558   0x28FF             CMP      R0,#+255
   \   0000055A   0xD020             BEQ.N    ??BlackGetLeft_44
   3573                        {
   3574          
   3575          
   3576                            //如果黑线点够，最好还是根据实际的黑点来更新窗口值。
   3577                            tempminus = BoundaryLimitRe(BlackLeftLoc[row + 1][0] * 3 - BlackLeftLoc[row + 2][0] * 2,
   3578                                                        0,
   3579                                                        CameraRealWidth - 1);
   \   0000055C   0x22F9             MOVS     R2,#+249
   \   0000055E   0x2100             MOVS     R1,#+0
   \   00000560   0x.... 0x....      LDR.W    R0,??DataTable24_10
   \   00000564   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000566   0x2303             MOVS     R3,#+3
   \   00000568   0xFB03 0x0005      MLA      R0,R3,R5,R0
   \   0000056C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000056E   0x2303             MOVS     R3,#+3
   \   00000570   0x4358             MULS     R0,R3,R0
   \   00000572   0x.... 0x....      LDR.W    R3,??DataTable24_10
   \   00000576   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000578   0x2403             MOVS     R4,#+3
   \   0000057A   0xFB04 0x3305      MLA      R3,R4,R5,R3
   \   0000057E   0x799B             LDRB     R3,[R3, #+6]
   \   00000580   0xEBB0 0x0043      SUBS     R0,R0,R3, LSL #+1
   \   00000584   0x.... 0x....      BL       BoundaryLimitRe
   3580                            //斜入十字不管怎么摆，左十字的上段线一定在下段线的右边。
   3581                            tempminus = MaxRe(tempminus, BlackLeftLoc[row + 1][0]);
   \   00000588   0x.... 0x....      LDR.W    R1,??DataTable24_10
   \   0000058C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000058E   0x2203             MOVS     R2,#+3
   \   00000590   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000594   0x78C9             LDRB     R1,[R1, #+3]
   \   00000596   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000598   0x.... 0x....      BL       MaxRe
   \   0000059C   0xE031             B.N      ??BlackGetLeft_45
   3582                        }
   3583                        else
   3584                        {
   3585                            temp001 = BlackLeftWinPredictStore1 - BlackLeftWinPredictStore0;
   \                     ??BlackGetLeft_44: (+1)
   \   0000059E   0x.... 0x....      LDR.W    R0,??DataTable24_14
   \   000005A2   0x7800             LDRB     R0,[R0, #+0]
   \   000005A4   0x.... 0x....      LDR.W    R1,??DataTable24_13
   \   000005A8   0x7809             LDRB     R1,[R1, #+0]
   \   000005AA   0x1A40             SUBS     R0,R0,R1
   3586                            BlackLeftWinPredictStore0 += temp001;
   \   000005AC   0x.... 0x....      LDR.W    R1,??DataTable24_13
   \   000005B0   0x7809             LDRB     R1,[R1, #+0]
   \   000005B2   0x1841             ADDS     R1,R0,R1
   \   000005B4   0x.... 0x....      LDR.W    R2,??DataTable24_13
   \   000005B8   0x7011             STRB     R1,[R2, #+0]
   3587                            BlackLeftWinPredictStore1 += temp001;
   \   000005BA   0x.... 0x....      LDR.W    R1,??DataTable24_14
   \   000005BE   0x7809             LDRB     R1,[R1, #+0]
   \   000005C0   0x1840             ADDS     R0,R0,R1
   \   000005C2   0x.... 0x....      LDR.W    R1,??DataTable24_14
   \   000005C6   0x7008             STRB     R0,[R1, #+0]
   3588                            BlackLeftWinPredictStore2 = BlackLeftWinPredictStore1 + BlackLeftWinPredictStore1 - BlackLeftWinPredictStore0;
   \   000005C8   0x.... 0x....      LDR.W    R0,??DataTable24_14
   \   000005CC   0x7800             LDRB     R0,[R0, #+0]
   \   000005CE   0x.... 0x....      LDR.W    R1,??DataTable24_14
   \   000005D2   0x7809             LDRB     R1,[R1, #+0]
   \   000005D4   0x1808             ADDS     R0,R1,R0
   \   000005D6   0x.... 0x....      LDR.W    R1,??DataTable24_13
   \   000005DA   0x7809             LDRB     R1,[R1, #+0]
   \   000005DC   0x1A40             SUBS     R0,R0,R1
   \   000005DE   0x.... 0x....      LDR.W    R1,??DataTable25_11
   \   000005E2   0x7008             STRB     R0,[R1, #+0]
   3589                            tempminus = BoundaryLimitRe(BlackLeftWinPredictStore2 + BlackLeftWinPredictStore2 - BlackLeftWinPredictStore1,
   3590                                                        0,
   3591                                                        CameraRealWidth - 1);       
   \   000005E4   0x22F9             MOVS     R2,#+249
   \   000005E6   0x2100             MOVS     R1,#+0
   \   000005E8   0x.... 0x....      LDR.W    R0,??DataTable25_11
   \   000005EC   0x7800             LDRB     R0,[R0, #+0]
   \   000005EE   0x.... 0x....      LDR.W    R3,??DataTable25_11
   \   000005F2   0x781B             LDRB     R3,[R3, #+0]
   \   000005F4   0x1818             ADDS     R0,R3,R0
   \   000005F6   0x.... 0x....      LDR.W    R3,??DataTable24_14
   \   000005FA   0x781B             LDRB     R3,[R3, #+0]
   \   000005FC   0x1AC0             SUBS     R0,R0,R3
   \   000005FE   0x.... 0x....      BL       BoundaryLimitRe
   3592                        }
   3593                    }
   3594                    else
   3595                    {
   3596                        //理论上不会走到这里。
   3597                        return 0;
   3598                    }
   3599                    
   3600                    //进来一次后就再也不进来了。
   3601                    index1++;          
   \                     ??BlackGetLeft_45: (+1)
   \   00000602   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000606   0xE010             B.N      ??BlackGetLeft_46
   \                     ??BlackGetLeft_43: (+1)
   \   00000608   0x2000             MOVS     R0,#+0
   \   0000060A   0xE04D             B.N      ??BlackGetLeft_1
   3602                  }
   3603                  else
   3604                  {
   3605                    //预测点按趋势走也要限幅。
   3606                    tempminus = BoundaryLimitRe(BlackLeftWinPredictStore2 + BlackLeftWinPredictStore2 - BlackLeftWinPredictStore1,
   3607                                                0,
   3608                                                CameraRealWidth - 1);          
   \                     ??BlackGetLeft_42: (+1)
   \   0000060C   0x22F9             MOVS     R2,#+249
   \   0000060E   0x2100             MOVS     R1,#+0
   \   00000610   0x.... 0x....      LDR.W    R0,??DataTable25_11
   \   00000614   0x7800             LDRB     R0,[R0, #+0]
   \   00000616   0x.... 0x....      LDR.W    R3,??DataTable25_11
   \   0000061A   0x781B             LDRB     R3,[R3, #+0]
   \   0000061C   0x1818             ADDS     R0,R3,R0
   \   0000061E   0x.... 0x....      LDR.W    R3,??DataTable24_14
   \   00000622   0x781B             LDRB     R3,[R3, #+0]
   \   00000624   0x1AC0             SUBS     R0,R0,R3
   \   00000626   0x.... 0x....      BL       BoundaryLimitRe
   3609                  }
   3610                  //temp在这里表示窗口预测点位置。
   3611                  temp = tempminus;
   \                     ??BlackGetLeft_46: (+1)
   \   0000062A   0x0004             MOVS     R4,R0
   3612                  BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
   \   0000062C   0x.... 0x....      LDR.W    R0,??DataTable24_14
   \   00000630   0x7800             LDRB     R0,[R0, #+0]
   \   00000632   0x.... 0x....      LDR.W    R1,??DataTable24_13
   \   00000636   0x7008             STRB     R0,[R1, #+0]
   3613                  BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
   \   00000638   0x.... 0x....      LDR.W    R0,??DataTable25_11
   \   0000063C   0x7800             LDRB     R0,[R0, #+0]
   \   0000063E   0x.... 0x....      LDR.W    R1,??DataTable24_14
   \   00000642   0x7008             STRB     R0,[R1, #+0]
   3614                  BlackLeftWinPredictStore2 = temp;
   \   00000644   0x.... 0x....      LDR.W    R0,??DataTable25_11
   \   00000648   0x7004             STRB     R4,[R0, #+0]
   3615                }
   3616                //理论上不会走到这里。
   3617                else
   3618                {
   3619                }
   3620                
   3621                if((row == 0) || (row == 1)) break;
   \                     ??BlackGetLeft_16: (+1)
   \   0000064A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000064C   0x2D00             CMP      R5,#+0
   \   0000064E   0xD003             BEQ.N    ??BlackGetLeft_47
   \   00000650   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000652   0x2D01             CMP      R5,#+1
   \   00000654   0xF47F 0xAD71      BNE.W    ??BlackGetLeft_5
   3622                
   3623              }
   3624              
   3625              //第4阶段，采集到十字的前两个角，向后补线。这里有浮点运算，要严格控制调用。
   3626              //向后补线时，必须考虑的就是十字外尾的问题。
   3627              if(BlackLeftStep4Flag == 1)
   \                     ??BlackGetLeft_47: (+1)
   \                     ??BlackGetLeft_18: (+1)
   \   00000658   0x....             LDR.N    R0,??DataTable23_2
   \   0000065A   0x7800             LDRB     R0,[R0, #+0]
   \   0000065C   0x2801             CMP      R0,#+1
   \   0000065E   0xD10F             BNE.N    ??BlackGetLeft_48
   3628              {
   3629                if(BlackLeftStep4BackLine(BlackLeftStep4StartLine, 0) == 0)
   \   00000660   0x2100             MOVS     R1,#+0
   \   00000662   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000666   0x7800             LDRB     R0,[R0, #+0]
   \   00000668   0x.... 0x....      BL       BlackLeftStep4BackLine
   \   0000066C   0x2800             CMP      R0,#+0
   \   0000066E   0xD103             BNE.N    ??BlackGetLeft_49
   3630                {
   3631                  BlackLeftStep4Flag = 1;    //向后补线失败，有可能是点取不够，有可能是斜率不对。
   \   00000670   0x2001             MOVS     R0,#+1
   \   00000672   0x....             LDR.N    R1,??DataTable23_2
   \   00000674   0x7008             STRB     R0,[R1, #+0]
   \   00000676   0xE016             B.N      ??BlackGetLeft_50
   3632                  //return 0;  
   3633                }
   3634                else
   3635                {
   3636                  BlackLeftStep4Flag = 2;    // 向后补线成功。
   \                     ??BlackGetLeft_49: (+1)
   \   00000678   0x2002             MOVS     R0,#+2
   \   0000067A   0x....             LDR.N    R1,??DataTable23_2
   \   0000067C   0x7008             STRB     R0,[R1, #+0]
   \   0000067E   0xE012             B.N      ??BlackGetLeft_50
   3637                }
   3638              }
   3639              //BlackLeftStep4Flag出错的情况。
   3640              else if(BlackLeftStep4Flag == 3)
   \                     ??BlackGetLeft_48: (+1)
   \   00000680   0x....             LDR.N    R0,??DataTable23_2
   \   00000682   0x7800             LDRB     R0,[R0, #+0]
   \   00000684   0x2803             CMP      R0,#+3
   \   00000686   0xD10E             BNE.N    ??BlackGetLeft_50
   3641              {
   3642                //检查出错到底是为什么
   3643                if(BlackLeftStep4ErrorCheck() == 1)
   \   00000688   0x.... 0x....      BL       BlackLeftStep4ErrorCheck
   \   0000068C   0x2801             CMP      R0,#+1
   \   0000068E   0xD10A             BNE.N    ??BlackGetLeft_50
   3644                {        
   3645                  if(BlackLeftStep4BackLine(BlackLeftStep4StartLine, 0) == 0)
   \   00000690   0x2100             MOVS     R1,#+0
   \   00000692   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000696   0x7800             LDRB     R0,[R0, #+0]
   \   00000698   0x.... 0x....      BL       BlackLeftStep4BackLine
   \   0000069C   0x2800             CMP      R0,#+0
   \   0000069E   0xD002             BEQ.N    ??BlackGetLeft_50
   3646                  {
   3647                    //BlackLeftStep4Flag = 1;    //向后补线失败，有可能是点取不够，有可能是斜率不对。
   3648                    //return 0;  
   3649                  }
   3650                  else
   3651                  {
   3652                    BlackLeftStep4Flag = 2;    // 向后补线成功。
   \   000006A0   0x2002             MOVS     R0,#+2
   \   000006A2   0x....             LDR.N    R1,??DataTable23_2
   \   000006A4   0x7008             STRB     R0,[R1, #+0]
   3653                  }
   3654                }
   3655                else
   3656                {
   3657                }
   3658                
   3659              }
   3660              //BlackLeftStep4Flag未进入的情况。
   3661              else
   3662              {       
   3663              }
   3664          
   3665              return 1;
   \                     ??BlackGetLeft_50: (+1)
   \   000006A6   0x2001             MOVS     R0,#+1
   \                     ??BlackGetLeft_1: (+1)
   \   000006A8   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   3666          }
   3667          
   3668          
   3669          
   3670          //====================================右右右右右右右右右右右右右右右右右============================
   3671          
   3672          //======================================================================
   3673          //函数名：BlackRightRealClear
   3674          //功  能：右黑线提取中，对3个关键值的实际值清零
   3675          //参  数：无
   3676          //返  回：无
   3677          //影  响：BlackRightRealWB[], BlackRightRealW[], BlackRightRealB[]
   3678          //说  明：
   3679          //      
   3680          //             
   3681          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   3682          void BlackRightRealClear(void)
   3683          {
   3684              BlackRightRealWB[0] = 0;
   \                     BlackRightRealClear: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable26
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   3685              BlackRightRealWB[1] = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable26
   \   0000000E   0x7048             STRB     R0,[R1, #+1]
   3686              BlackRightRealW[0] = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable26_1
   \   00000016   0x7008             STRB     R0,[R1, #+0]
   3687              BlackRightRealW[1] = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable26_1
   \   0000001E   0x7048             STRB     R0,[R1, #+1]
   3688              BlackRightRealB[0] = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable26_2
   \   00000026   0x7008             STRB     R0,[R1, #+0]
   3689              BlackRightRealB[1] = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable26_2
   \   0000002E   0x7048             STRB     R0,[R1, #+1]
   3690          }
   \   00000030   0x4770             BX       LR               ;; return
   3691          
   3692          
   3693          
   3694          
   3695          //黑线提取成功，找右黑线的线头线尾。

   \                                 In section .text, align 2, keep-with-next
   3696          uint8 BlackRightHeadEndSearch(void)
   3697          {
   3698            uint8 i;
   3699            //右线线头和线尾的查找
   3700            if(BlackRightDone == 1)
   \                     BlackRightHeadEndSearch: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD143             BNE.N    ??BlackRightHeadEndSearch_0
   3701            { //右线线头的查找。
   3702              for(i = 0; ; i++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE000             B.N      ??BlackRightHeadEndSearch_1
   \                     ??BlackRightHeadEndSearch_2: (+1)
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   3703              { //找到了右线线头。
   3704                if(BlackRightLoc[i][0] != MaxValUint8)
   \                     ??BlackRightHeadEndSearch_1: (+1)
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable26_4
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x2203             MOVS     R2,#+3
   \   00000018   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x29FF             CMP      R1,#+255
   \   00000020   0xD003             BEQ.N    ??BlackRightHeadEndSearch_3
   3705                {
   3706                  BlackRightHeadLine = i;
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable25_10
   \   00000026   0x7008             STRB     R0,[R1, #+0]
   3707                  break;
   \   00000028   0xE006             B.N      ??BlackRightHeadEndSearch_4
   3708                }
   3709                //直到最近一行仍没有找到线头，则查找失败。
   3710                if(i == CameraHight - 1) 
   \                     ??BlackRightHeadEndSearch_3: (+1)
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x283B             CMP      R0,#+59
   \   0000002E   0xD1EE             BNE.N    ??BlackRightHeadEndSearch_2
   3711                {
   3712                  BlackRightHeadLine = MaxValUint8;
   \   00000030   0x20FF             MOVS     R0,#+255
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable25_10
   \   00000036   0x7008             STRB     R0,[R1, #+0]
   3713                  break;
   3714                }
   3715              }
   3716              //若右线线头查找失败，就不用找右线线尾了。
   3717              if(BlackRightHeadLine == MaxValUint8)
   \                     ??BlackRightHeadEndSearch_4: (+1)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable25_10
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x28FF             CMP      R0,#+255
   \   00000040   0xD108             BNE.N    ??BlackRightHeadEndSearch_5
   3718              {
   3719                BlackRightEndLine = MaxValUint8;
   \   00000042   0x20FF             MOVS     R0,#+255
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   00000048   0x7008             STRB     R0,[R1, #+0]
   3720                BlackRightDone = 0;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable26_3
   \   00000050   0x7008             STRB     R0,[R1, #+0]
   \   00000052   0xE026             B.N      ??BlackRightHeadEndSearch_6
   3721              }
   3722              //若右线线头查找成功，则开始找右线线尾。
   3723              else
   3724              {
   3725                for(i = CameraHight - 1; ; i--)
   \                     ??BlackRightHeadEndSearch_5: (+1)
   \   00000054   0x203B             MOVS     R0,#+59
   \   00000056   0xE000             B.N      ??BlackRightHeadEndSearch_7
   \                     ??BlackRightHeadEndSearch_8: (+1)
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   3726                { //找到了右线的线尾。
   3727                  if(BlackRightLoc[i][0] != MaxValUint8)
   \                     ??BlackRightHeadEndSearch_7: (+1)
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable26_4
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x2203             MOVS     R2,#+3
   \   00000062   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   00000066   0x7809             LDRB     R1,[R1, #+0]
   \   00000068   0x29FF             CMP      R1,#+255
   \   0000006A   0xD003             BEQ.N    ??BlackRightHeadEndSearch_9
   3728                  {
   3729                    BlackRightEndLine = i;
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   00000070   0x7008             STRB     R0,[R1, #+0]
   3730                    break;
   \   00000072   0xE016             B.N      ??BlackRightHeadEndSearch_6
   3731                  }
   3732                  //没找到右线的线尾。右线不可能有头无尾，所以均置无效值。
   3733                  if(i == BlackRightHeadLine) 
   \                     ??BlackRightHeadEndSearch_9: (+1)
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable25_10
   \   00000078   0x7809             LDRB     R1,[R1, #+0]
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xD1EB             BNE.N    ??BlackRightHeadEndSearch_8
   3734                  {
   3735                    BlackRightHeadLine = MaxValUint8;
   \   00000080   0x20FF             MOVS     R0,#+255
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable25_10
   \   00000086   0x7008             STRB     R0,[R1, #+0]
   3736                    BlackRightEndLine = MaxValUint8;
   \   00000088   0x20FF             MOVS     R0,#+255
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   0000008E   0x7008             STRB     R0,[R1, #+0]
   3737                    break;
   \   00000090   0xE007             B.N      ??BlackRightHeadEndSearch_6
   3738                  }
   3739                }
   3740              }
   3741            }
   3742            //若右线黑线提取失败，就不用找线头和线尾了。
   3743            else
   3744            {
   3745              BlackRightHeadLine = MaxValUint8;
   \                     ??BlackRightHeadEndSearch_0: (+1)
   \   00000092   0x20FF             MOVS     R0,#+255
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable25_10
   \   00000098   0x7008             STRB     R0,[R1, #+0]
   3746              BlackRightEndLine = MaxValUint8;
   \   0000009A   0x20FF             MOVS     R0,#+255
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable26_5
   \   000000A0   0x7008             STRB     R0,[R1, #+0]
   3747            }
   3748            
   3749            //本幅图像有单线时，删掉最远一个点。
   3750            if(SingleBlackAllFlag == 1)
   \                     ??BlackRightHeadEndSearch_6: (+1)
   \   000000A2   0x....             LDR.N    R0,??DataTable23
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0x2801             CMP      R0,#+1
   \   000000A8   0xD110             BNE.N    ??BlackRightHeadEndSearch_10
   3751            {
   3752              BlackRightLoc[BlackRightHeadLine][0] = MaxValUint8; //Udis数组不用改，因为线头线尾查找之后才轮到矫正函数。
   \   000000AA   0x20FF             MOVS     R0,#+255
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable26_4
   \   000000B0   0x.... 0x....      LDR.W    R2,??DataTable25_10
   \   000000B4   0x7812             LDRB     R2,[R2, #+0]
   \   000000B6   0x2303             MOVS     R3,#+3
   \   000000B8   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000000BC   0x7008             STRB     R0,[R1, #+0]
   3753              BlackRightHeadLine += 1;
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable25_10
   \   000000C2   0x7800             LDRB     R0,[R0, #+0]
   \   000000C4   0x1C40             ADDS     R0,R0,#+1
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable25_10
   \   000000CA   0x7008             STRB     R0,[R1, #+0]
   3754            }
   3755            else
   3756            {
   3757            }
   3758            
   3759            return 1;
   \                     ??BlackRightHeadEndSearch_10: (+1)
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x4770             BX       LR               ;; return
   3760          }
   3761          
   3762          
   3763          //======================================================================
   3764          //函数名：BlackRightBigChangeCheck
   3765          //功  能：右黑线提取时，大斜率检测。
   3766          //参  数：newrow新加进来的需要判定是否有效的行, use调用时是连续2行的第几行。
   3767          //返  回：1该行黑线成功，0该行黑线失败。
   3768          //影  响：
   3769          //说  明：1. 用来防止大斜率突变的坏点。
   3770          //        2. 共5个行，取1，3，5行进行斜率计算，每进一个新行，移出一个旧行。
   3771          //             
   3772          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   3773          uint8 BlackRightBigChangeCheck(uint8 newrow, uint8 use)
   3774          {
   \                     BlackRightBigChangeCheck: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   3775            uint8 tempstorex, tempstorey;
   3776            uint8 i;
   3777            int32 tempslope1, tempslope2;
   3778            
   3779            //tempstorex用来储存将要移出的一行，用来检测失败时复原5行数组。
   3780            tempstorex = BlackRightBigChangeNumx[0];
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable27
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   3781            BlackRightBigChangeNumx[0] = BlackRightBigChangeNumx[1];
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable27
   \   0000000C   0x7852             LDRB     R2,[R2, #+1]
   \   0000000E   0x.... 0x....      LDR.W    R3,??DataTable27
   \   00000012   0x701A             STRB     R2,[R3, #+0]
   3782            BlackRightBigChangeNumx[1] = BlackRightBigChangeNumx[2];
   \   00000014   0x.... 0x....      LDR.W    R2,??DataTable27
   \   00000018   0x7892             LDRB     R2,[R2, #+2]
   \   0000001A   0x.... 0x....      LDR.W    R3,??DataTable27
   \   0000001E   0x705A             STRB     R2,[R3, #+1]
   3783            BlackRightBigChangeNumx[2] = BlackRightBigChangeNumx[3];
   \   00000020   0x.... 0x....      LDR.W    R2,??DataTable27
   \   00000024   0x78D2             LDRB     R2,[R2, #+3]
   \   00000026   0x.... 0x....      LDR.W    R3,??DataTable27
   \   0000002A   0x709A             STRB     R2,[R3, #+2]
   3784            BlackRightBigChangeNumx[3] = BlackRightBigChangeNumx[4];
   \   0000002C   0x.... 0x....      LDR.W    R2,??DataTable27
   \   00000030   0x7912             LDRB     R2,[R2, #+4]
   \   00000032   0x.... 0x....      LDR.W    R3,??DataTable27
   \   00000036   0x70DA             STRB     R2,[R3, #+3]
   3785            BlackRightBigChangeNumx[4] = newrow;
   \   00000038   0x.... 0x....      LDR.W    R2,??DataTable27
   \   0000003C   0x7110             STRB     R0,[R2, #+4]
   3786          
   3787            tempstorey = BlackRightBigChangeNumy[0];
   \   0000003E   0x.... 0x....      LDR.W    R2,??DataTable26_6
   \   00000042   0x7812             LDRB     R2,[R2, #+0]
   3788            BlackRightBigChangeNumy[0] = BlackRightBigChangeNumy[1];
   \   00000044   0x.... 0x....      LDR.W    R3,??DataTable26_6
   \   00000048   0x785B             LDRB     R3,[R3, #+1]
   \   0000004A   0x.... 0x....      LDR.W    R4,??DataTable26_6
   \   0000004E   0x7023             STRB     R3,[R4, #+0]
   3789            BlackRightBigChangeNumy[1] = BlackRightBigChangeNumy[2];
   \   00000050   0x.... 0x....      LDR.W    R3,??DataTable26_6
   \   00000054   0x789B             LDRB     R3,[R3, #+2]
   \   00000056   0x.... 0x....      LDR.W    R4,??DataTable26_6
   \   0000005A   0x7063             STRB     R3,[R4, #+1]
   3790            BlackRightBigChangeNumy[2] = BlackRightBigChangeNumy[3];
   \   0000005C   0x.... 0x....      LDR.W    R3,??DataTable26_6
   \   00000060   0x78DB             LDRB     R3,[R3, #+3]
   \   00000062   0x.... 0x....      LDR.W    R4,??DataTable26_6
   \   00000066   0x70A3             STRB     R3,[R4, #+2]
   3791            BlackRightBigChangeNumy[3] = BlackRightBigChangeNumy[4];
   \   00000068   0x.... 0x....      LDR.W    R3,??DataTable26_6
   \   0000006C   0x791B             LDRB     R3,[R3, #+4]
   \   0000006E   0x.... 0x....      LDR.W    R4,??DataTable26_6
   \   00000072   0x70E3             STRB     R3,[R4, #+3]
   3792            BlackRightBigChangeNumy[4] = BlackRightLoc[newrow][0];
   \   00000074   0x.... 0x....      LDR.W    R3,??DataTable26_4
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0x2403             MOVS     R4,#+3
   \   0000007C   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   00000080   0x781B             LDRB     R3,[R3, #+0]
   \   00000082   0x.... 0x....      LDR.W    R4,??DataTable26_6
   \   00000086   0x7123             STRB     R3,[R4, #+4]
   3793          
   3794            //每幅图最多只进一次这个for循环，可以省时间。
   3795            if(BlackRightBigChangeJumpFlag == 0)
   \   00000088   0x.... 0x....      LDR.W    R3,??DataTable27_1
   \   0000008C   0x781B             LDRB     R3,[R3, #+0]
   \   0000008E   0x2B00             CMP      R3,#+0
   \   00000090   0xD111             BNE.N    ??BlackRightBigChangeCheck_0
   3796            {  
   3797              //储存数组的有效性判断，若不足5个数，则无法进行大斜率检测，直接返回成功。
   3798              for(i = 0; i <= 4; i++)
   \   00000092   0x2300             MOVS     R3,#+0
   \   00000094   0xE000             B.N      ??BlackRightBigChangeCheck_1
   \                     ??BlackRightBigChangeCheck_2: (+1)
   \   00000096   0x1C5B             ADDS     R3,R3,#+1
   \                     ??BlackRightBigChangeCheck_1: (+1)
   \   00000098   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000009A   0x2B05             CMP      R3,#+5
   \   0000009C   0xDA07             BGE.N    ??BlackRightBigChangeCheck_3
   3799              {
   3800                if(BlackRightBigChangeNumx[i] == MaxValUint8)
   \   0000009E   0x.... 0x....      LDR.W    R4,??DataTable27
   \   000000A2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000A4   0x5D1C             LDRB     R4,[R3, R4]
   \   000000A6   0x2CFF             CMP      R4,#+255
   \   000000A8   0xD1F5             BNE.N    ??BlackRightBigChangeCheck_2
   3801                {
   3802                  return 1;
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0xE0F8             B.N      ??BlackRightBigChangeCheck_4
   3803                }
   3804              }
   3805              //改变标志位，下次就不进来了。
   3806              BlackRightBigChangeJumpFlag = 1;   
   \                     ??BlackRightBigChangeCheck_3: (+1)
   \   000000AE   0x2301             MOVS     R3,#+1
   \   000000B0   0x.... 0x....      LDR.W    R4,??DataTable27_1
   \   000000B4   0x7023             STRB     R3,[R4, #+0]
   3807            }
   3808            //走到这里说明通过了数组有效性判断。
   3809            
   3810            //取1，3，5点进行斜率计算。
   3811            //因为只有两个点，所以斜率的计算采取斜率的初始定义的方式，不采取最小二乘法，可以省很多时间。
   3812            tempslope1 = (BlackRightBigChangeNumy[2] - BlackRightBigChangeNumy[0]) 
   3813                      * LeastSquareMulti   //乘以了这么多倍。跟最小二乘法一样。
   3814                      / (BlackRightBigChangeNumx[2] - BlackRightBigChangeNumx[0]);
   \                     ??BlackRightBigChangeCheck_0: (+1)
   \   000000B6   0x.... 0x....      LDR.W    R3,??DataTable26_6
   \   000000BA   0x789B             LDRB     R3,[R3, #+2]
   \   000000BC   0x.... 0x....      LDR.W    R4,??DataTable26_6
   \   000000C0   0x7824             LDRB     R4,[R4, #+0]
   \   000000C2   0x1B1B             SUBS     R3,R3,R4
   \   000000C4   0xF44F 0x747A      MOV      R4,#+1000
   \   000000C8   0x4363             MULS     R3,R4,R3
   \   000000CA   0x.... 0x....      LDR.W    R4,??DataTable27
   \   000000CE   0x78A4             LDRB     R4,[R4, #+2]
   \   000000D0   0x.... 0x....      LDR.W    R5,??DataTable27
   \   000000D4   0x782D             LDRB     R5,[R5, #+0]
   \   000000D6   0x1B64             SUBS     R4,R4,R5
   \   000000D8   0xFB93 0xF3F4      SDIV     R3,R3,R4
   3815            tempslope2 = (BlackRightBigChangeNumy[4] - BlackRightBigChangeNumy[2]) 
   3816                      * LeastSquareMulti   //乘以了这么多倍。跟最小二乘法一样。
   3817                      / (BlackRightBigChangeNumx[4] - BlackRightBigChangeNumx[2]);
   \   000000DC   0x.... 0x....      LDR.W    R4,??DataTable26_6
   \   000000E0   0x7924             LDRB     R4,[R4, #+4]
   \   000000E2   0x.... 0x....      LDR.W    R5,??DataTable26_6
   \   000000E6   0x78AD             LDRB     R5,[R5, #+2]
   \   000000E8   0x1B64             SUBS     R4,R4,R5
   \   000000EA   0xF44F 0x757A      MOV      R5,#+1000
   \   000000EE   0x436C             MULS     R4,R5,R4
   \   000000F0   0x.... 0x....      LDR.W    R5,??DataTable27
   \   000000F4   0x792D             LDRB     R5,[R5, #+4]
   \   000000F6   0x.... 0x....      LDR.W    R6,??DataTable27
   \   000000FA   0x78B6             LDRB     R6,[R6, #+2]
   \   000000FC   0x1BAD             SUBS     R5,R5,R6
   \   000000FE   0xFB94 0xF4F5      SDIV     R4,R4,R5
   3818            BlackRightBigChangeSlopeStore = tempslope1;
   \   00000102   0x.... 0x....      LDR.W    R5,??DataTable27_2
   \   00000106   0x602B             STR      R3,[R5, #+0]
   3819            //小5点斜率储存在数组中，由于储存的是tempslope1，所以大跳变点不会记录，会出现多行相同值。
   3820            BlackRight5Slope[BlackRight5SlopeIndex] = BlackRightBigChangeSlopeStore;
   \   00000108   0x.... 0x....      LDR.W    R5,??DataTable27_2
   \   0000010C   0x682D             LDR      R5,[R5, #+0]
   \   0000010E   0x.... 0x....      LDR.W    R6,??DataTable27_3
   \   00000112   0x.... 0x....      LDR.W    R7,??DataTable27_4
   \   00000116   0x783F             LDRB     R7,[R7, #+0]
   \   00000118   0xF846 0x5027      STR      R5,[R6, R7, LSL #+2]
   3821            BlackRight5SlopeRow[BlackRight5SlopeIndex] = newrow;
   \   0000011C   0x.... 0x....      LDR.W    R5,??DataTable27_5
   \   00000120   0x.... 0x....      LDR.W    R6,??DataTable27_4
   \   00000124   0x7836             LDRB     R6,[R6, #+0]
   \   00000126   0x5570             STRB     R0,[R6, R5]
   3822            BlackRight5SlopeIndex++;  
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable27_4
   \   0000012C   0x7800             LDRB     R0,[R0, #+0]
   \   0000012E   0x1C40             ADDS     R0,R0,#+1
   \   00000130   0x.... 0x....      LDR.W    R5,??DataTable27_4
   \   00000134   0x7028             STRB     R0,[R5, #+0]
   3823            //1. 前后两次的斜率是相反的。
   3824            if(tempslope1 >= 0 && tempslope2 < 0)
   \   00000136   0x2B00             CMP      R3,#+0
   \   00000138   0xD457             BMI.N    ??BlackRightBigChangeCheck_5
   \   0000013A   0x2C00             CMP      R4,#+0
   \   0000013C   0xD555             BPL.N    ??BlackRightBigChangeCheck_5
   3825            {
   3826              //2. 两者差值很大很大。
   3827              if(tempslope1 >= tempslope2 + BlackRightBigChangeSlopeLimit)
   \   0000013E   0xF514 0x607A      ADDS     R0,R4,#+4000
   \   00000142   0x4283             CMP      R3,R0
   \   00000144   0xDB4F             BLT.N    ??BlackRightBigChangeCheck_6
   3828              {
   3829                //两者差值的确很大。不会刷新储存值。
   3830                //if(use == 2)                    //另一种方案是在连续2行的第2行调用时才置成功标志位。
   3831                //{
   3832                  //置成功标志位。
   3833                  BlackRightBigChangeFlag = 1;
   \   00000146   0x2001             MOVS     R0,#+1
   \   00000148   0x.... 0x....      LDR.W    R3,??DataTable27_6
   \   0000014C   0x7018             STRB     R0,[R3, #+0]
   3834                //}
   3835                //else
   3836                //{
   3837                //}
   3838                //此次行不进入队列。
   3839                BlackRightBigChangeNumx[4] = BlackRightBigChangeNumx[3];
   \   0000014E   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000152   0x78C0             LDRB     R0,[R0, #+3]
   \   00000154   0x.... 0x....      LDR.W    R3,??DataTable27
   \   00000158   0x7118             STRB     R0,[R3, #+4]
   3840                BlackRightBigChangeNumx[3] = BlackRightBigChangeNumx[2];
   \   0000015A   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000015E   0x7880             LDRB     R0,[R0, #+2]
   \   00000160   0x.... 0x....      LDR.W    R3,??DataTable27
   \   00000164   0x70D8             STRB     R0,[R3, #+3]
   3841                BlackRightBigChangeNumx[2] = BlackRightBigChangeNumx[1];
   \   00000166   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000016A   0x7840             LDRB     R0,[R0, #+1]
   \   0000016C   0x.... 0x....      LDR.W    R3,??DataTable27
   \   00000170   0x7098             STRB     R0,[R3, #+2]
   3842                BlackRightBigChangeNumx[1] = BlackRightBigChangeNumx[0];
   \   00000172   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000176   0x7800             LDRB     R0,[R0, #+0]
   \   00000178   0x.... 0x....      LDR.W    R3,??DataTable27
   \   0000017C   0x7058             STRB     R0,[R3, #+1]
   3843                BlackRightBigChangeNumx[0] = tempstorex;
   \   0000017E   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000182   0x7001             STRB     R1,[R0, #+0]
   3844                BlackRightBigChangeNumy[4] = BlackRightBigChangeNumy[3];
   \   00000184   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000188   0x78C0             LDRB     R0,[R0, #+3]
   \   0000018A   0x.... 0x....      LDR.W    R1,??DataTable26_6
   \   0000018E   0x7108             STRB     R0,[R1, #+4]
   3845                BlackRightBigChangeNumy[3] = BlackRightBigChangeNumy[2];
   \   00000190   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000194   0x7880             LDRB     R0,[R0, #+2]
   \   00000196   0x.... 0x....      LDR.W    R1,??DataTable26_6
   \   0000019A   0x70C8             STRB     R0,[R1, #+3]
   3846                BlackRightBigChangeNumy[2] = BlackRightBigChangeNumy[1];
   \   0000019C   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   000001A0   0x7840             LDRB     R0,[R0, #+1]
   \   000001A2   0x.... 0x....      LDR.W    R1,??DataTable26_6
   \   000001A6   0x7088             STRB     R0,[R1, #+2]
   3847                BlackRightBigChangeNumy[1] = BlackRightBigChangeNumy[0];
   \   000001A8   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   000001AC   0x7800             LDRB     R0,[R0, #+0]
   \   000001AE   0x.... 0x....      LDR.W    R1,??DataTable26_6
   \   000001B2   0x7048             STRB     R0,[R1, #+1]
   3848                BlackRightBigChangeNumy[0] = tempstorey;
   \   000001B4   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   000001B8   0x7002             STRB     R2,[R0, #+0]
   3849          
   3850                //将前面3个右黑线(共4个)的值置无效值。图像上更连续。
   3851                BlackRightLoc[BlackRightBigChangeNumx[4]][0] = MaxValUint8;
   \   000001BA   0x20FF             MOVS     R0,#+255
   \   000001BC   0x.... 0x....      LDR.W    R1,??DataTable26_4
   \   000001C0   0x.... 0x....      LDR.W    R2,??DataTable27
   \   000001C4   0x7912             LDRB     R2,[R2, #+4]
   \   000001C6   0x2303             MOVS     R3,#+3
   \   000001C8   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000001CC   0x7008             STRB     R0,[R1, #+0]
   3852                BlackRightLoc[BlackRightBigChangeNumx[3]][0] = MaxValUint8;
   \   000001CE   0x20FF             MOVS     R0,#+255
   \   000001D0   0x.... 0x....      LDR.W    R1,??DataTable26_4
   \   000001D4   0x.... 0x....      LDR.W    R2,??DataTable27
   \   000001D8   0x78D2             LDRB     R2,[R2, #+3]
   \   000001DA   0x2303             MOVS     R3,#+3
   \   000001DC   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000001E0   0x7008             STRB     R0,[R1, #+0]
   3853                //BlackRightLoc[BlackRightBigChangeNumx[2]][0] = MaxValUint8;
   3854                
   3855                return 0;
   \   000001E2   0x2000             MOVS     R0,#+0
   \   000001E4   0xE05C             B.N      ??BlackRightBigChangeCheck_4
   3856              }
   3857              else
   3858              {
   3859                //刷新斜率储存值。
   3860                //BlackRightBigChangeSlopeStore = tempslope;
   3861                return 1;
   \                     ??BlackRightBigChangeCheck_6: (+1)
   \   000001E6   0x2001             MOVS     R0,#+1
   \   000001E8   0xE05A             B.N      ??BlackRightBigChangeCheck_4
   3862              }
   3863            }
   3864            //1. 前后两次的斜率是相反的。
   3865            else if(tempslope1 < 0 && tempslope2 >= 0)
   \                     ??BlackRightBigChangeCheck_5: (+1)
   \   000001EA   0x2B00             CMP      R3,#+0
   \   000001EC   0xD557             BPL.N    ??BlackRightBigChangeCheck_7
   \   000001EE   0x2C00             CMP      R4,#+0
   \   000001F0   0xD455             BMI.N    ??BlackRightBigChangeCheck_7
   3866            {
   3867              //2. 两者差值很大很大。
   3868              if(tempslope2 >= tempslope1 + BlackRightBigChangeSlopeLimit)
   \   000001F2   0xF513 0x607A      ADDS     R0,R3,#+4000
   \   000001F6   0x4284             CMP      R4,R0
   \   000001F8   0xDB4F             BLT.N    ??BlackRightBigChangeCheck_8
   3869              {
   3870                //两者差值的确很大。不会刷新储存值。
   3871                //if(use == 2)                    //另一种方案是在连续2行的第2行调用时才置成功标志位。
   3872                //{
   3873                  //置成功标志位。
   3874                  BlackRightBigChangeFlag = 1;
   \   000001FA   0x2001             MOVS     R0,#+1
   \   000001FC   0x.... 0x....      LDR.W    R3,??DataTable27_6
   \   00000200   0x7018             STRB     R0,[R3, #+0]
   3875                //}
   3876                //else
   3877                //{
   3878                //}
   3879                //此次行不进入队列。
   3880                BlackRightBigChangeNumx[4] = BlackRightBigChangeNumx[3];
   \   00000202   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000206   0x78C0             LDRB     R0,[R0, #+3]
   \   00000208   0x.... 0x....      LDR.W    R3,??DataTable27
   \   0000020C   0x7118             STRB     R0,[R3, #+4]
   3881                BlackRightBigChangeNumx[3] = BlackRightBigChangeNumx[2];
   \   0000020E   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000212   0x7880             LDRB     R0,[R0, #+2]
   \   00000214   0x.... 0x....      LDR.W    R3,??DataTable27
   \   00000218   0x70D8             STRB     R0,[R3, #+3]
   3882                BlackRightBigChangeNumx[2] = BlackRightBigChangeNumx[1];
   \   0000021A   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000021E   0x7840             LDRB     R0,[R0, #+1]
   \   00000220   0x.... 0x....      LDR.W    R3,??DataTable27
   \   00000224   0x7098             STRB     R0,[R3, #+2]
   3883                BlackRightBigChangeNumx[1] = BlackRightBigChangeNumx[0];
   \   00000226   0x.... 0x....      LDR.W    R0,??DataTable27
   \   0000022A   0x7800             LDRB     R0,[R0, #+0]
   \   0000022C   0x.... 0x....      LDR.W    R3,??DataTable27
   \   00000230   0x7058             STRB     R0,[R3, #+1]
   3884                BlackRightBigChangeNumx[0] = tempstorex;
   \   00000232   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000236   0x7001             STRB     R1,[R0, #+0]
   3885                BlackRightBigChangeNumy[4] = BlackRightBigChangeNumy[3];
   \   00000238   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   0000023C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000023E   0x.... 0x....      LDR.W    R1,??DataTable26_6
   \   00000242   0x7108             STRB     R0,[R1, #+4]
   3886                BlackRightBigChangeNumy[3] = BlackRightBigChangeNumy[2];
   \   00000244   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000248   0x7880             LDRB     R0,[R0, #+2]
   \   0000024A   0x.... 0x....      LDR.W    R1,??DataTable26_6
   \   0000024E   0x70C8             STRB     R0,[R1, #+3]
   3887                BlackRightBigChangeNumy[2] = BlackRightBigChangeNumy[1];
   \   00000250   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000254   0x7840             LDRB     R0,[R0, #+1]
   \   00000256   0x.... 0x....      LDR.W    R1,??DataTable26_6
   \   0000025A   0x7088             STRB     R0,[R1, #+2]
   3888                BlackRightBigChangeNumy[1] = BlackRightBigChangeNumy[0];
   \   0000025C   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   00000260   0x7800             LDRB     R0,[R0, #+0]
   \   00000262   0x.... 0x....      LDR.W    R1,??DataTable26_6
   \   00000266   0x7048             STRB     R0,[R1, #+1]
   3889                BlackRightBigChangeNumy[0] = tempstorey;
   \   00000268   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   0000026C   0x7002             STRB     R2,[R0, #+0]
   3890                
   3891                //将前面3个右黑线(共4个)的值置无效值。图像上更连续。
   3892                BlackRightLoc[BlackRightBigChangeNumx[4]][0] = MaxValUint8;
   \   0000026E   0x20FF             MOVS     R0,#+255
   \   00000270   0x.... 0x....      LDR.W    R1,??DataTable26_4
   \   00000274   0x.... 0x....      LDR.W    R2,??DataTable27
   \   00000278   0x7912             LDRB     R2,[R2, #+4]
   \   0000027A   0x2303             MOVS     R3,#+3
   \   0000027C   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000280   0x7008             STRB     R0,[R1, #+0]
   3893                BlackRightLoc[BlackRightBigChangeNumx[3]][0] = MaxValUint8;
   \   00000282   0x20FF             MOVS     R0,#+255
   \   00000284   0x.... 0x....      LDR.W    R1,??DataTable26_4
   \   00000288   0x.... 0x....      LDR.W    R2,??DataTable27
   \   0000028C   0x78D2             LDRB     R2,[R2, #+3]
   \   0000028E   0x2303             MOVS     R3,#+3
   \   00000290   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000294   0x7008             STRB     R0,[R1, #+0]
   3894                //BlackRightLoc[BlackRightBigChangeNumx[2]][0] = MaxValUint8;   
   3895                
   3896                return 0;
   \   00000296   0x2000             MOVS     R0,#+0
   \   00000298   0xE002             B.N      ??BlackRightBigChangeCheck_4
   3897              }
   3898              else
   3899              {
   3900                //刷新斜率储存值。
   3901                //BlackRightBigChangeSlopeStore = tempslope;
   3902                return 1;
   \                     ??BlackRightBigChangeCheck_8: (+1)
   \   0000029A   0x2001             MOVS     R0,#+1
   \   0000029C   0xE000             B.N      ??BlackRightBigChangeCheck_4
   3903              }    
   3904            }
   3905            //若不相反，则判定无大斜率的跳变。返回成功。
   3906            else
   3907            {
   3908              //刷新斜率储存值。
   3909              //BlackRightBigChangeSlopeStore = tempslope;
   3910              return 1;
   \                     ??BlackRightBigChangeCheck_7: (+1)
   \   0000029E   0x2001             MOVS     R0,#+1
   \                     ??BlackRightBigChangeCheck_4: (+1)
   \   000002A0   0xBCF0             POP      {R4-R7}
   \   000002A2   0x4770             BX       LR               ;; return
   3911            }
   3912            
   3913          }
   3914          
   3915          
   3916          //单纯的、从左往右的、一定窗口内的、扫描跳变沿的函数.可以精简Step2Win, CrossSpeWin等诸多内容。
   3917          //返回的是跳变沿的白点所在位置。

   \                                 In section .text, align 2, keep-with-next
   3918          uint8 BlackGetRightJustWin(uint8 row, int32 colleft, int32 colright)
   3919          {
   \                     BlackGetRightJustWin: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0015             MOVS     R5,R2
   3920            uint8 abs1;
   3921            uint8 tempwhite;
   3922            uint8 temp1;
   3923            
   3924            //左右边界限幅
   3925            colleft = BoundaryLimitRe(colleft, 0, CameraRealWidth - 1);
   \   00000008   0x22F9             MOVS     R2,#+249
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x0030             MOVS     R0,R6
   \   0000000E   0x.... 0x....      BL       BoundaryLimitRe
   \   00000012   0x0006             MOVS     R6,R0
   3926            colright = BoundaryLimitRe(colright, 0, CameraRealWidth - 1);
   \   00000014   0x22F9             MOVS     R2,#+249
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       BoundaryLimitRe
   \   0000001E   0x0005             MOVS     R5,R0
   \   00000020   0xE000             B.N      ??BlackGetRightJustWin_0
   3927            
   3928            for(; colleft < colright; colleft++) 
   \                     ??BlackGetRightJustWin_1: (+1)
   \   00000022   0x1C76             ADDS     R6,R6,#+1
   \                     ??BlackGetRightJustWin_0: (+1)
   \   00000024   0x42AE             CMP      R6,R5
   \   00000026   0xF280 0x80B2      BGE.W    ??BlackGetRightJustWin_2
   3929            {
   3930              //左白点与右黑点的像素差
   3931              if(ImgNew[row][colleft] > ImgNew[row][colleft+1+BlackRightEdgeNum])
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable27_7
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x21FA             MOVS     R1,#+250
   \   00000032   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000036   0x1830             ADDS     R0,R6,R0
   \   00000038   0x7900             LDRB     R0,[R0, #+4]
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0x22FA             MOVS     R2,#+250
   \   00000042   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000046   0x5C71             LDRB     R1,[R6, R1]
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD210             BCS.N    ??BlackGetRightJustWin_3
   3932              {
   3933                abs1 = ImgNew[row][colleft] - ImgNew[row][colleft+1+BlackRightEdgeNum];
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable27_7
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0x21FA             MOVS     R1,#+250
   \   00000054   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000058   0x5C30             LDRB     R0,[R6, R0]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   0000005E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000060   0x22FA             MOVS     R2,#+250
   \   00000062   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000066   0x1871             ADDS     R1,R6,R1
   \   00000068   0x7909             LDRB     R1,[R1, #+4]
   \   0000006A   0x1A40             SUBS     R0,R0,R1
   \   0000006C   0xE000             B.N      ??BlackGetRightJustWin_4
   3934              }
   3935              else
   3936              {
   3937                abs1 = 0;
   \                     ??BlackGetRightJustWin_3: (+1)
   \   0000006E   0x2000             MOVS     R0,#+0
   3938              }
   3939          
   3940              if( //跳变沿的第一批条件：
   3941                  //黑够黑，白够白，差够大。
   3942                  //这里的3个阈值是自适应之后调整的值
   3943                    (abs1 > LimitRightWB - LimitRightWBAdjust[row]) //两者的差够大
   3944                  &&(ImgNew[row][colleft] > LimitRightW)                     //白点够白
   3945                  &&(ImgNew[row][colleft+1+BlackRightEdgeNum] < LimitRightB)                   //黑点够黑
   3946                 )
   \                     ??BlackGetRightJustWin_4: (+1)
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable28
   \   00000074   0x7809             LDRB     R1,[R1, #+0]
   \   00000076   0x.... 0x....      LDR.W    R2,??DataTable28_1
   \   0000007A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007C   0x5CA2             LDRB     R2,[R4, R2]
   \   0000007E   0x1A89             SUBS     R1,R1,R2
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0x4281             CMP      R1,R0
   \   00000084   0xDACD             BGE.N    ??BlackGetRightJustWin_1
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable28_2
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   00000090   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000092   0x22FA             MOVS     R2,#+250
   \   00000094   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000098   0x5C71             LDRB     R1,[R6, R1]
   \   0000009A   0x4288             CMP      R0,R1
   \   0000009C   0xD2C1             BCS.N    ??BlackGetRightJustWin_1
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable27_7
   \   000000A2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A4   0x21FA             MOVS     R1,#+250
   \   000000A6   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000AA   0x1830             ADDS     R0,R6,R0
   \   000000AC   0x7900             LDRB     R0,[R0, #+4]
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable29
   \   000000B2   0x7809             LDRB     R1,[R1, #+0]
   \   000000B4   0x4288             CMP      R0,R1
   \   000000B6   0xD2B4             BCS.N    ??BlackGetRightJustWin_1
   3947              {
   3948                    //如果左边白点不够话，就不用判断白点是否满足阈值了。
   3949                    if(colleft > 2)
   \   000000B8   0x2E03             CMP      R6,#+3
   \   000000BA   0xDB1F             BLT.N    ??BlackGetRightJustWin_5
   3950                    {
   3951                      tempwhite = ((ImgNew[row][colleft-1] > LimitRightW) && (ImgNew[row][colleft-2] > LimitRightW));
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable28_2
   \   000000C0   0x7800             LDRB     R0,[R0, #+0]
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   000000C6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C8   0x22FA             MOVS     R2,#+250
   \   000000CA   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000CE   0x1871             ADDS     R1,R6,R1
   \   000000D0   0xF811 0x1C01      LDRB     R1,[R1, #-1]
   \   000000D4   0x4288             CMP      R0,R1
   \   000000D6   0xD20F             BCS.N    ??BlackGetRightJustWin_6
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable28_2
   \   000000DC   0x7800             LDRB     R0,[R0, #+0]
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   000000E2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E4   0x22FA             MOVS     R2,#+250
   \   000000E6   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000EA   0x1871             ADDS     R1,R6,R1
   \   000000EC   0xF811 0x1C02      LDRB     R1,[R1, #-2]
   \   000000F0   0x4288             CMP      R0,R1
   \   000000F2   0xD201             BCS.N    ??BlackGetRightJustWin_6
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0xE002             B.N      ??BlackGetRightJustWin_7
   \                     ??BlackGetRightJustWin_6: (+1)
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xE000             B.N      ??BlackGetRightJustWin_7
   3952                    }
   3953                    else
   3954                    {
   3955                      tempwhite = 1;
   \                     ??BlackGetRightJustWin_5: (+1)
   \   000000FC   0x2001             MOVS     R0,#+1
   3956                    }
   3957                    
   3958                    //近处的行，向右3个点仍为黑点，向左2个点仍为白点。
   3959                    if(row > BlackMiddleLine)
   \                     ??BlackGetRightJustWin_7: (+1)
   \   000000FE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000100   0x2C33             CMP      R4,#+51
   \   00000102   0xDB20             BLT.N    ??BlackGetRightJustWin_8
   3960                    {
   3961                      temp1 = (
   3962                                (ImgNew[row][colleft+2+BlackRightEdgeNum] < LimitRightB)
   3963                              &&(ImgNew[row][colleft+3+BlackRightEdgeNum] < LimitRightB)
   3964                              //&&(ImgNew[row][colleft+4+BlackRightEdgeNum] < LimitRightB)
   3965                              &&(tempwhite == 1)
   3966                              );
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   00000108   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000010A   0x22FA             MOVS     R2,#+250
   \   0000010C   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000110   0x1871             ADDS     R1,R6,R1
   \   00000112   0x7949             LDRB     R1,[R1, #+5]
   \   00000114   0x.... 0x....      LDR.W    R2,??DataTable29
   \   00000118   0x7812             LDRB     R2,[R2, #+0]
   \   0000011A   0x4291             CMP      R1,R2
   \   0000011C   0xD211             BCS.N    ??BlackGetRightJustWin_9
   \   0000011E   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   00000122   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000124   0x22FA             MOVS     R2,#+250
   \   00000126   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000012A   0x1871             ADDS     R1,R6,R1
   \   0000012C   0x7989             LDRB     R1,[R1, #+6]
   \   0000012E   0x.... 0x....      LDR.W    R2,??DataTable29
   \   00000132   0x7812             LDRB     R2,[R2, #+0]
   \   00000134   0x4291             CMP      R1,R2
   \   00000136   0xD204             BCS.N    ??BlackGetRightJustWin_9
   \   00000138   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013A   0x2801             CMP      R0,#+1
   \   0000013C   0xD101             BNE.N    ??BlackGetRightJustWin_9
   \   0000013E   0x2001             MOVS     R0,#+1
   \   00000140   0xE01E             B.N      ??BlackGetRightJustWin_10
   \                     ??BlackGetRightJustWin_9: (+1)
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0xE01C             B.N      ??BlackGetRightJustWin_10
   3967                    }
   3968                    else
   3969                    {
   3970                      //中间的行 ，向右2个点为仍为黑点，向左1个点仍为白点。
   3971                      if(row > BlackFarLine)
   \                     ??BlackGetRightJustWin_8: (+1)
   \   00000146   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000148   0x2C29             CMP      R4,#+41
   \   0000014A   0xDB13             BLT.N    ??BlackGetRightJustWin_11
   3972                      {
   3973                        temp1 = (
   3974                                  (ImgNew[row][colleft+2+BlackRightEdgeNum] < LimitRightB)
   3975                                //&&(ImgNew[row][colleft+3+BlackRightEdgeNum] < LimitRightB)
   3976                                &&(tempwhite == 1)
   3977                                );
   \   0000014C   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   00000150   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000152   0x22FA             MOVS     R2,#+250
   \   00000154   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000158   0x1871             ADDS     R1,R6,R1
   \   0000015A   0x7949             LDRB     R1,[R1, #+5]
   \   0000015C   0x.... 0x....      LDR.W    R2,??DataTable29
   \   00000160   0x7812             LDRB     R2,[R2, #+0]
   \   00000162   0x4291             CMP      R1,R2
   \   00000164   0xD204             BCS.N    ??BlackGetRightJustWin_12
   \   00000166   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000168   0x2801             CMP      R0,#+1
   \   0000016A   0xD101             BNE.N    ??BlackGetRightJustWin_12
   \   0000016C   0x2001             MOVS     R0,#+1
   \   0000016E   0xE007             B.N      ??BlackGetRightJustWin_10
   \                     ??BlackGetRightJustWin_12: (+1)
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0xE005             B.N      ??BlackGetRightJustWin_10
   3978                      }          
   3979                      else
   3980                      {
   3981                        //远处的行，向右1个点仍为黑点，向左0个点仍为白点。
   3982                        if(row > BlackFarfarLine)
   \                     ??BlackGetRightJustWin_11: (+1)
   \   00000174   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000176   0x2C15             CMP      R4,#+21
   \   00000178   0xDB01             BLT.N    ??BlackGetRightJustWin_13
   3983                        {
   3984                          //temp1 = (ImgNew[row][colleft+2+BlackRightEdgeNum] < LimitRightB);
   3985                          temp1 = 1;
   \   0000017A   0x2001             MOVS     R0,#+1
   \   0000017C   0xE000             B.N      ??BlackGetRightJustWin_10
   3986                        }
   3987                        //很远处的行，只对跳变有要求，对周围黑点无要求。
   3988                        else
   3989                        {
   3990                          temp1 = 1;
   \                     ??BlackGetRightJustWin_13: (+1)
   \   0000017E   0x2001             MOVS     R0,#+1
   3991                        }
   3992                      }
   3993                    }
   3994                    
   3995                    //跳变沿的第二批条件：
   3996                    if(temp1 == 1)
   \                     ??BlackGetRightJustWin_10: (+1)
   \   00000180   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000182   0x2801             CMP      R0,#+1
   \   00000184   0xF47F 0xAF4D      BNE.W    ??BlackGetRightJustWin_1
   3997                    {
   3998                      //两批条件均满足，返回白点位置，不是黑点位置！
   3999                      return colleft;
   \   00000188   0x0030             MOVS     R0,R6
   \   0000018A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000018C   0xE000             B.N      ??BlackGetRightJustWin_14
   4000                      
   4001                    //break;               
   4002                    }// end of 跳变沿检测的第2批条件
   4003              }// end of 跳变沿检测的第1批条件
   4004              
   4005              
   4006              
   4007            }// end of for循环
   4008            
   4009            //如果一直到窗口最左边还没有找到跳变沿，返回无效值。
   4010            return MaxValUint8;
   \                     ??BlackGetRightJustWin_2: (+1)
   \   0000018E   0x20FF             MOVS     R0,#+255
   \                     ??BlackGetRightJustWin_14: (+1)
   \   00000190   0xBD70             POP      {R4-R6,PC}       ;; return
   4011              
   4012          }
   4013          
   4014          
   4015          //======================================================================
   4016          //函数名：BlackGetRightStep1Edge
   4017          //功  能：右黑线提取中，第1阶段跳变检测函数,处理该右左线的可疑黑点
   4018          //参  数：待检测的行号row, 第几次使用use, 黑线预处理标志preflag(1是预处理)
   4019          //返  回：1成功 0失败
   4020          //影  响：BlackRightRealWB[], BlackRightRealW[], BlackRightRealB[]
   4021          //        BlackRightLoc[][]
   4022          //说  明：1. 对第row行的跳变向右进行检测，成功就赋相应的值（有3个备用值），失败则赋255
   4023          //        2. 两批条件均满足时。则检测成功。会有最多3个值进行记录，现阶段只用到了第1个值
   4024          //        3. 里面有涉及3个关键值的实际值的记录，CrossFlag的情况就不用记录（也就不用更改）
   4025          //        4. 若1个黑点也没有，或者超过3个黑点，则检测失败。
   4026          //        5. 若要检测黑到白的跳变，或者任意跳变，改变第一批条件即可。
   4027          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   4028          uint8 BlackGetRightStep1Edge(uint8 row, uint8 use, uint8 preflag)
   4029          {
   \                     BlackGetRightStep1Edge: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0017             MOVS     R7,R2
   4030            uint8 index, col, temp1;
   4031            uint8 abs1;
   4032            uint8 RightBeginCol; //右线跳变检测起点
   4033            uint8 tempwhite;
   4034            uint8 avgr1, avgl1;
   4035            uint8 i;
   4036              
   4037            //根据上一幅有效图像的中线来预估这一幅图像的左右黑线扫描起点，右线起点需要在中线往左一个黑线宽度。 
   4038            RightBeginCol = (uint8)MaxRe((int32)BlackRightEdgeStartCol-10,0);
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x380A             SUBS     R0,R0,#+10
   \   00000012   0x.... 0x....      BL       MaxRe
   \   00000016   0x0004             MOVS     R4,R0
   4039            
   4040            //左线开始扫描。
   4041            //如果是预处理，也不用考虑这个情况。直接往下走就好。
   4042            if((BlackGetPreDir == 0 || BlackGetPreDir == 2)
   4043            &&(BlackLeftLoc[row][0] != MaxValUint8)
   4044            &&(preflag == 0)
   4045              )
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable29_2
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD004             BEQ.N    ??BlackGetRightStep1Edge_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable29_2
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x2802             CMP      R0,#+2
   \   0000002A   0xD145             BNE.N    ??BlackGetRightStep1Edge_1
   \                     ??BlackGetRightStep1Edge_0: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable29_3
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2103             MOVS     R1,#+3
   \   00000034   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x28FF             CMP      R0,#+255
   \   0000003C   0xD03C             BEQ.N    ??BlackGetRightStep1Edge_1
   \   0000003E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000040   0x2F00             CMP      R7,#+0
   \   00000042   0xD139             BNE.N    ??BlackGetRightStep1Edge_1
   4046            {
   4047              //如果上一幅图是单线，则右线扫描起点必须在左线的左边一个单线宽度。
   4048              if(
   4049                (row > CameraHight - 5)
   4050              &&(SingleBlackLastAllFlag == 1)
   4051                 )
   \   00000044   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000046   0x2D38             CMP      R5,#+56
   \   00000048   0xDB1A             BLT.N    ??BlackGetRightStep1Edge_2
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable29_4
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xD115             BNE.N    ??BlackGetRightStep1Edge_2
   4052              {
   4053                RightBeginCol = MinRe(RightBeginCol, MaxRe(0, BlackLeftLoc[row][0] - SingleBlackWidthMax[row]));
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable29_3
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x2103             MOVS     R1,#+3
   \   0000005C   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000060   0x7800             LDRB     R0,[R0, #+0]
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable29_5
   \   00000066   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000068   0x5C69             LDRB     R1,[R5, R1]
   \   0000006A   0x1A41             SUBS     R1,R0,R1
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x.... 0x....      BL       MaxRe
   \   00000072   0x0001             MOVS     R1,R0
   \   00000074   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       MinRe
   \   0000007C   0x0004             MOVS     R4,R0
   \   0000007E   0xE01B             B.N      ??BlackGetRightStep1Edge_1
   4054              }
   4055              //如果上一幅图不是单线，且最近四行没有采集到单线，那就视为不可能出现单线。所以右线扫描起点必须在左线的右边
   4056              else if(
   4057                     (row <= CameraHight - 5)
   4058                   //&&(SingleBlackLastAllFlag == 0)
   4059                      )
   \                     ??BlackGetRightStep1Edge_2: (+1)
   \   00000080   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000082   0x2D38             CMP      R5,#+56
   \   00000084   0xDA0C             BGE.N    ??BlackGetRightStep1Edge_3
   4060              {
   4061                RightBeginCol = MaxRe(RightBeginCol, BlackLeftLoc[row][0]);
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable29_3
   \   0000008A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008C   0x2103             MOVS     R1,#+3
   \   0000008E   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000092   0x7801             LDRB     R1,[R0, #+0]
   \   00000094   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000096   0x0020             MOVS     R0,R4
   \   00000098   0x.... 0x....      BL       MaxRe
   \   0000009C   0x0004             MOVS     R4,R0
   \   0000009E   0xE00B             B.N      ??BlackGetRightStep1Edge_1
   4062              }
   4063              else
   4064              {
   4065                RightBeginCol = MaxRe(RightBeginCol, BlackLeftLoc[row][0]);
   \                     ??BlackGetRightStep1Edge_3: (+1)
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable29_3
   \   000000A4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A6   0x2103             MOVS     R1,#+3
   \   000000A8   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   000000AC   0x7801             LDRB     R1,[R0, #+0]
   \   000000AE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B0   0x0020             MOVS     R0,R4
   \   000000B2   0x.... 0x....      BL       MaxRe
   \   000000B6   0x0004             MOVS     R4,R0
   4066              }
   4067              
   4068            }
   4069            else
   4070            {    
   4071            }
   4072            
   4073            //窗口预测值记录
   4074            BlackRightPredictL[row] = RightBeginCol;
   \                     ??BlackGetRightStep1Edge_1: (+1)
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable29_6
   \   000000BC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BE   0x542C             STRB     R4,[R5, R0]
   4075            BlackRightPredictR[row] = CameraRealWidth - 5 - BlackRightEdgeNum;
   \   000000C0   0x20F2             MOVS     R0,#+242
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable29_7
   \   000000C6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C8   0x5468             STRB     R0,[R5, R1]
   4076            
   4077            index = 0;         //可疑点的序号
   \   000000CA   0x2000             MOVS     R0,#+0
   4078            //从中间到最右边扫描，隔1个点求差
   4079            for(col = RightBeginCol; col <= CameraRealWidth - 5 - BlackRightEdgeNum; col++) 
   \   000000CC   0xE000             B.N      ??BlackGetRightStep1Edge_4
   \                     ??BlackGetRightStep1Edge_5: (+1)
   \   000000CE   0x1C64             ADDS     R4,R4,#+1
   \                     ??BlackGetRightStep1Edge_4: (+1)
   \   000000D0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D2   0x2CF3             CMP      R4,#+243
   \   000000D4   0xF280 0x80F1      BGE.W    ??BlackGetRightStep1Edge_6
   4080            {
   4081                //左白点与右黑点的像素差
   4082                if(ImgNew[row][col] > ImgNew[row][col+1+BlackRightEdgeNum])
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   000000DC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000DE   0x22FA             MOVS     R2,#+250
   \   000000E0   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   000000E4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E6   0x1861             ADDS     R1,R4,R1
   \   000000E8   0x7909             LDRB     R1,[R1, #+4]
   \   000000EA   0x.... 0x....      LDR.W    R2,??DataTable27_7
   \   000000EE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F0   0x23FA             MOVS     R3,#+250
   \   000000F2   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   000000F6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F8   0x5CA2             LDRB     R2,[R4, R2]
   \   000000FA   0x4291             CMP      R1,R2
   \   000000FC   0xD212             BCS.N    ??BlackGetRightStep1Edge_7
   4083                {
   4084                  abs1 = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum];
   \   000000FE   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   00000102   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000104   0x22FA             MOVS     R2,#+250
   \   00000106   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   0000010A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000010C   0x5C61             LDRB     R1,[R4, R1]
   \   0000010E   0x.... 0x....      LDR.W    R2,??DataTable27_7
   \   00000112   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000114   0x23FA             MOVS     R3,#+250
   \   00000116   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   0000011A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000011C   0x18A2             ADDS     R2,R4,R2
   \   0000011E   0x7912             LDRB     R2,[R2, #+4]
   \   00000120   0x1A89             SUBS     R1,R1,R2
   \   00000122   0xE000             B.N      ??BlackGetRightStep1Edge_8
   4085                }
   4086                else
   4087                {
   4088                  abs1 = 0;
   \                     ??BlackGetRightStep1Edge_7: (+1)
   \   00000124   0x2100             MOVS     R1,#+0
   4089                }
   4090                
   4091                if( //跳变沿的第一批条件：
   4092                    //黑够黑，白够白，差够大。
   4093                    //这里的3个阈值为初始值，不是自适应之后调整的值。
   4094                    (abs1 > LimitRightWB - LimitRightWBAdjust[row]) //两者的差够大
   4095                  &&(ImgNew[row][col] > LimitRightW)                     //白点够白
   4096                  &&(ImgNew[row][col+1+BlackRightEdgeNum] < LimitRightB) //黑点够黑
   4097                   )
   \                     ??BlackGetRightStep1Edge_8: (+1)
   \   00000126   0x.... 0x....      LDR.W    R2,??DataTable28
   \   0000012A   0x7812             LDRB     R2,[R2, #+0]
   \   0000012C   0x.... 0x....      LDR.W    R3,??DataTable28_1
   \   00000130   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000132   0x5CEB             LDRB     R3,[R5, R3]
   \   00000134   0x1AD2             SUBS     R2,R2,R3
   \   00000136   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000138   0x428A             CMP      R2,R1
   \   0000013A   0xDAC8             BGE.N    ??BlackGetRightStep1Edge_5
   \   0000013C   0x.... 0x....      LDR.W    R1,??DataTable28_2
   \   00000140   0x7809             LDRB     R1,[R1, #+0]
   \   00000142   0x.... 0x....      LDR.W    R2,??DataTable27_7
   \   00000146   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000148   0x23FA             MOVS     R3,#+250
   \   0000014A   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   0000014E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000150   0x5CA2             LDRB     R2,[R4, R2]
   \   00000152   0x4291             CMP      R1,R2
   \   00000154   0xD2BB             BCS.N    ??BlackGetRightStep1Edge_5
   \   00000156   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   0000015A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000015C   0x22FA             MOVS     R2,#+250
   \   0000015E   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000162   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000164   0x1861             ADDS     R1,R4,R1
   \   00000166   0x7909             LDRB     R1,[R1, #+4]
   \   00000168   0x.... 0x....      LDR.W    R2,??DataTable29
   \   0000016C   0x7812             LDRB     R2,[R2, #+0]
   \   0000016E   0x4291             CMP      R1,R2
   \   00000170   0xD2AD             BCS.N    ??BlackGetRightStep1Edge_5
   4098                {         
   4099                    //左边没有白点的话就不会判断白点是否满足阈值了。
   4100                    if(col > 2)
   \   00000172   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000174   0x2C03             CMP      R4,#+3
   \   00000176   0xDB21             BLT.N    ??BlackGetRightStep1Edge_9
   4101                    {
   4102                      tempwhite = ((ImgNew[row][col-1] > LimitRightW) && (ImgNew[row][col-2] > LimitRightW));
   \   00000178   0x.... 0x....      LDR.W    R1,??DataTable28_2
   \   0000017C   0x7809             LDRB     R1,[R1, #+0]
   \   0000017E   0x.... 0x....      LDR.W    R2,??DataTable27_7
   \   00000182   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000184   0x23FA             MOVS     R3,#+250
   \   00000186   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   0000018A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000018C   0x18A2             ADDS     R2,R4,R2
   \   0000018E   0xF812 0x2C01      LDRB     R2,[R2, #-1]
   \   00000192   0x4291             CMP      R1,R2
   \   00000194   0xD210             BCS.N    ??BlackGetRightStep1Edge_10
   \   00000196   0x.... 0x....      LDR.W    R1,??DataTable28_2
   \   0000019A   0x7809             LDRB     R1,[R1, #+0]
   \   0000019C   0x.... 0x....      LDR.W    R2,??DataTable27_7
   \   000001A0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001A2   0x23FA             MOVS     R3,#+250
   \   000001A4   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   000001A8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001AA   0x18A2             ADDS     R2,R4,R2
   \   000001AC   0xF812 0x2C02      LDRB     R2,[R2, #-2]
   \   000001B0   0x4291             CMP      R1,R2
   \   000001B2   0xD201             BCS.N    ??BlackGetRightStep1Edge_10
   \   000001B4   0x2101             MOVS     R1,#+1
   \   000001B6   0xE002             B.N      ??BlackGetRightStep1Edge_11
   \                     ??BlackGetRightStep1Edge_10: (+1)
   \   000001B8   0x2100             MOVS     R1,#+0
   \   000001BA   0xE000             B.N      ??BlackGetRightStep1Edge_11
   4103                    }
   4104                    else
   4105                    {
   4106                      tempwhite = 1;
   \                     ??BlackGetRightStep1Edge_9: (+1)
   \   000001BC   0x2101             MOVS     R1,#+1
   4107                    }
   4108                    
   4109                    //跳变沿的第二批条件：
   4110                    //近处的行，向右3个点仍为黑点，向左2个点仍为白点。
   4111                    if(row > BlackMiddleLine)
   \                     ??BlackGetRightStep1Edge_11: (+1)
   \   000001BE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001C0   0x2D33             CMP      R5,#+51
   \   000001C2   0xDB30             BLT.N    ??BlackGetRightStep1Edge_12
   4112                    {
   4113                      temp1 = (
   4114                                (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB)
   4115                              &&(ImgNew[row][col+3+BlackRightEdgeNum] < LimitRightB)
   4116                              &&(ImgNew[row][col+4+BlackRightEdgeNum] < LimitRightB)
   4117                              &&(tempwhite == 1)
   4118                              );
   \   000001C4   0x.... 0x....      LDR.W    R2,??DataTable27_7
   \   000001C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001CA   0x23FA             MOVS     R3,#+250
   \   000001CC   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   000001D0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001D2   0x18A2             ADDS     R2,R4,R2
   \   000001D4   0x7952             LDRB     R2,[R2, #+5]
   \   000001D6   0x.... 0x....      LDR.W    R3,??DataTable29
   \   000001DA   0x781B             LDRB     R3,[R3, #+0]
   \   000001DC   0x429A             CMP      R2,R3
   \   000001DE   0xD220             BCS.N    ??BlackGetRightStep1Edge_13
   \   000001E0   0x.... 0x....      LDR.W    R2,??DataTable27_7
   \   000001E4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001E6   0x23FA             MOVS     R3,#+250
   \   000001E8   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   000001EC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001EE   0x18A2             ADDS     R2,R4,R2
   \   000001F0   0x7992             LDRB     R2,[R2, #+6]
   \   000001F2   0x.... 0x....      LDR.W    R3,??DataTable29
   \   000001F6   0x781B             LDRB     R3,[R3, #+0]
   \   000001F8   0x429A             CMP      R2,R3
   \   000001FA   0xD212             BCS.N    ??BlackGetRightStep1Edge_13
   \   000001FC   0x.... 0x....      LDR.W    R2,??DataTable27_7
   \   00000200   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000202   0x23FA             MOVS     R3,#+250
   \   00000204   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   00000208   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000020A   0x18A2             ADDS     R2,R4,R2
   \   0000020C   0x79D2             LDRB     R2,[R2, #+7]
   \   0000020E   0x.... 0x....      LDR.W    R3,??DataTable29
   \   00000212   0x781B             LDRB     R3,[R3, #+0]
   \   00000214   0x429A             CMP      R2,R3
   \   00000216   0xD204             BCS.N    ??BlackGetRightStep1Edge_13
   \   00000218   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000021A   0x2901             CMP      R1,#+1
   \   0000021C   0xD101             BNE.N    ??BlackGetRightStep1Edge_13
   \   0000021E   0x2101             MOVS     R1,#+1
   \   00000220   0xE03D             B.N      ??BlackGetRightStep1Edge_14
   \                     ??BlackGetRightStep1Edge_13: (+1)
   \   00000222   0x2100             MOVS     R1,#+0
   \   00000224   0xE03B             B.N      ??BlackGetRightStep1Edge_14
   4119                    }
   4120                    else
   4121                    {
   4122                      if(row > BlackFarLine)
   \                     ??BlackGetRightStep1Edge_12: (+1)
   \   00000226   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000228   0x2D29             CMP      R5,#+41
   \   0000022A   0xDB22             BLT.N    ??BlackGetRightStep1Edge_15
   4123                      {
   4124                        //中间的行，向右2个点仍为黑点，向左1个点仍为白点。
   4125                        temp1 = (
   4126                                  (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB)
   4127                                &&(ImgNew[row][col+3+BlackRightEdgeNum] < LimitRightB)
   4128                                &&(tempwhite == 1)
   4129                                );
   \   0000022C   0x.... 0x....      LDR.W    R2,??DataTable27_7
   \   00000230   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000232   0x23FA             MOVS     R3,#+250
   \   00000234   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   00000238   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000023A   0x18A2             ADDS     R2,R4,R2
   \   0000023C   0x7952             LDRB     R2,[R2, #+5]
   \   0000023E   0x.... 0x....      LDR.W    R3,??DataTable29
   \   00000242   0x781B             LDRB     R3,[R3, #+0]
   \   00000244   0x429A             CMP      R2,R3
   \   00000246   0xD212             BCS.N    ??BlackGetRightStep1Edge_16
   \   00000248   0x.... 0x....      LDR.W    R2,??DataTable27_7
   \   0000024C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000024E   0x23FA             MOVS     R3,#+250
   \   00000250   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   00000254   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000256   0x18A2             ADDS     R2,R4,R2
   \   00000258   0x7992             LDRB     R2,[R2, #+6]
   \   0000025A   0x.... 0x....      LDR.W    R3,??DataTable29
   \   0000025E   0x781B             LDRB     R3,[R3, #+0]
   \   00000260   0x429A             CMP      R2,R3
   \   00000262   0xD204             BCS.N    ??BlackGetRightStep1Edge_16
   \   00000264   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000266   0x2901             CMP      R1,#+1
   \   00000268   0xD101             BNE.N    ??BlackGetRightStep1Edge_16
   \   0000026A   0x2101             MOVS     R1,#+1
   \   0000026C   0xE017             B.N      ??BlackGetRightStep1Edge_14
   \                     ??BlackGetRightStep1Edge_16: (+1)
   \   0000026E   0x2100             MOVS     R1,#+0
   \   00000270   0xE015             B.N      ??BlackGetRightStep1Edge_14
   4130                      }
   4131                      else
   4132                      {
   4133                        //远处的行，向右1个点仍为黑点，向左0个点仍为白点。
   4134                        if(row > BlackFarfarLine)
   \                     ??BlackGetRightStep1Edge_15: (+1)
   \   00000272   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000274   0x2D15             CMP      R5,#+21
   \   00000276   0xDB11             BLT.N    ??BlackGetRightStep1Edge_17
   4135                        {
   4136                          temp1 = (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB);
   \   00000278   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   0000027C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000027E   0x22FA             MOVS     R2,#+250
   \   00000280   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000284   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000286   0x1861             ADDS     R1,R4,R1
   \   00000288   0x7949             LDRB     R1,[R1, #+5]
   \   0000028A   0x.... 0x....      LDR.W    R2,??DataTable29
   \   0000028E   0x7812             LDRB     R2,[R2, #+0]
   \   00000290   0x4291             CMP      R1,R2
   \   00000292   0xD201             BCS.N    ??BlackGetRightStep1Edge_18
   \   00000294   0x2101             MOVS     R1,#+1
   \   00000296   0xE002             B.N      ??BlackGetRightStep1Edge_14
   \                     ??BlackGetRightStep1Edge_18: (+1)
   \   00000298   0x2100             MOVS     R1,#+0
   \   0000029A   0xE000             B.N      ??BlackGetRightStep1Edge_14
   4137                        }
   4138                        //很远处的行，只对跳变有要求，对周围黑点无要求。
   4139                        else
   4140                        {
   4141                          temp1 = 1;
   \                     ??BlackGetRightStep1Edge_17: (+1)
   \   0000029C   0x2101             MOVS     R1,#+1
   4142                        }             
   4143                      }
   4144                    }
   4145                    
   4146                    if(temp1)
   \                     ??BlackGetRightStep1Edge_14: (+1)
   \   0000029E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002A0   0x2900             CMP      R1,#+0
   \   000002A2   0xF43F 0xAF14      BEQ.W    ??BlackGetRightStep1Edge_5
   4147                    {
   4148                        //跳变检测成功，取黑点
   4149                        BlackRightLoc[row][index] = col + 1 + BlackRightEdgeNum;          
   \   000002A6   0x.... 0x....      LDR.W    R1,??DataTable26_4
   \   000002AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002AC   0x2203             MOVS     R2,#+3
   \   000002AE   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   000002B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002B4   0x1D22             ADDS     R2,R4,#+4
   \   000002B6   0x5442             STRB     R2,[R0, R1]
   4150                        index++;
   \   000002B8   0x1C40             ADDS     R0,R0,#+1
   4151                        break;
   4152                      
   4153                    }    //end of 跳变沿的第二批条件
   4154                }   //end of 跳变沿的第一批条件
   4155            }// end of 从中间到最左边扫描，隔1个点求差
   4156            
   4157            //1个可疑黑点也没有，则报错。
   4158            if(index == 0)
   \                     ??BlackGetRightStep1Edge_6: (+1)
   \   000002BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002BC   0x2800             CMP      R0,#+0
   \   000002BE   0xD10E             BNE.N    ??BlackGetRightStep1Edge_19
   4159            {
   4160              //如果是黑线预处理的调用，也不用更新这几个值。
   4161              if(preflag == 0)
   \   000002C0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002C2   0x2F00             CMP      R7,#+0
   \   000002C4   0xD101             BNE.N    ??BlackGetRightStep1Edge_20
   4162              {
   4163                //对3个关键值的实际值清零
   4164                BlackRightRealClear();
   \   000002C6   0x.... 0x....      BL       BlackRightRealClear
   4165              }
   4166                
   4167              //该行定位黑线失败，赋无效值
   4168              BlackRightLoc[row][0] = MaxValUint8;
   \                     ??BlackGetRightStep1Edge_20: (+1)
   \   000002CA   0x20FF             MOVS     R0,#+255
   \   000002CC   0x.... 0x....      LDR.W    R1,??DataTable26_4
   \   000002D0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002D2   0x2203             MOVS     R2,#+3
   \   000002D4   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   000002D8   0x7008             STRB     R0,[R1, #+0]
   4169              return 0;
   \   000002DA   0x2000             MOVS     R0,#+0
   \   000002DC   0xE1CE             B.N      ??BlackGetRightStep1Edge_21
   4170            }
   4171            
   4172            //不是黑线预处理的调用，则需要进行大跳变的检测。
   4173            if(preflag == 0)
   \                     ??BlackGetRightStep1Edge_19: (+1)
   \   000002DE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002E0   0x2F00             CMP      R7,#+0
   \   000002E2   0xF040 0x813E      BNE.W    ??BlackGetRightStep1Edge_22
   4174            {
   4175              //最终确认前，需要对大斜率进行检测。
   4176              if(BlackRightBigChangeCheck(row, use) == 1)
   \   000002E6   0x0031             MOVS     R1,R6
   \   000002E8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002EA   0x0028             MOVS     R0,R5
   \   000002EC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002EE   0x.... 0x....      BL       BlackRightBigChangeCheck
   \   000002F2   0x2801             CMP      R0,#+1
   \   000002F4   0xF040 0x8186      BNE.W    ??BlackGetRightStep1Edge_23
   4177              {
   4178                //从左线开始的扫描。单线一定出现在BlackGetPreDir == 0的情况。
   4179                //若已经确认为单线了，就不用再次确认了。
   4180                if(
   4181                  (SingleBlackAllFlag == 0) 
   4182                &&(BlackGetPreDir == 0 || BlackGetPreDir == 2)   //0713文件夹里的error002.txt里的第31幅图过渡到第32幅图时，若BlackGetPreDir不等于2的话，会出问题。
   4183                  )
   \   000002F8   0x.... 0x....      LDR.W    R0,??DataTable31
   \   000002FC   0x7800             LDRB     R0,[R0, #+0]
   \   000002FE   0x2800             CMP      R0,#+0
   \   00000300   0xF040 0x812F      BNE.W    ??BlackGetRightStep1Edge_22
   \   00000304   0x.... 0x....      LDR.W    R0,??DataTable29_2
   \   00000308   0x7800             LDRB     R0,[R0, #+0]
   \   0000030A   0x2800             CMP      R0,#+0
   \   0000030C   0xD005             BEQ.N    ??BlackGetRightStep1Edge_24
   \   0000030E   0x.... 0x....      LDR.W    R0,??DataTable29_2
   \   00000312   0x7800             LDRB     R0,[R0, #+0]
   \   00000314   0x2802             CMP      R0,#+2
   \   00000316   0xF040 0x8124      BNE.W    ??BlackGetRightStep1Edge_22
   4184                {
   4185                  //若该行左右黑线均检测成功，且右线在左线的左边一定范围内，则该行判定为单线。
   4186                  if((BlackLeftLoc[row][0] != MaxValUint8)
   4187                   &&(BlackRightLoc[row][0] != MaxValUint8)
   4188                   &&(BlackRightLoc[row][0] < BlackLeftLoc[row][0])
   4189                   &&(BlackRightLoc[row][0] - BlackLeftLoc[row][0] < SingleBlackWidthMax[row]) //结果是负数也会满足，所以必须小于。
   4190                  )
   \                     ??BlackGetRightStep1Edge_24: (+1)
   \   0000031A   0x.... 0x....      LDR.W    R0,??DataTable29_3
   \   0000031E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000320   0x2103             MOVS     R1,#+3
   \   00000322   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000326   0x7800             LDRB     R0,[R0, #+0]
   \   00000328   0x28FF             CMP      R0,#+255
   \   0000032A   0xF000 0x8165      BEQ.W    ??BlackGetRightStep1Edge_25
   \   0000032E   0x....             LDR.N    R0,??DataTable26_4
   \   00000330   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000332   0x2103             MOVS     R1,#+3
   \   00000334   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000338   0x7800             LDRB     R0,[R0, #+0]
   \   0000033A   0x28FF             CMP      R0,#+255
   \   0000033C   0xF000 0x815C      BEQ.W    ??BlackGetRightStep1Edge_25
   \   00000340   0x....             LDR.N    R0,??DataTable26_4
   \   00000342   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000344   0x2103             MOVS     R1,#+3
   \   00000346   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000034A   0x7800             LDRB     R0,[R0, #+0]
   \   0000034C   0x.... 0x....      LDR.W    R1,??DataTable29_3
   \   00000350   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000352   0x2203             MOVS     R2,#+3
   \   00000354   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000358   0x7809             LDRB     R1,[R1, #+0]
   \   0000035A   0x4288             CMP      R0,R1
   \   0000035C   0xF080 0x814C      BCS.W    ??BlackGetRightStep1Edge_25
   \   00000360   0x....             LDR.N    R0,??DataTable26_4
   \   00000362   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000364   0x2103             MOVS     R1,#+3
   \   00000366   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000036A   0x7800             LDRB     R0,[R0, #+0]
   \   0000036C   0x.... 0x....      LDR.W    R1,??DataTable29_3
   \   00000370   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000372   0x2203             MOVS     R2,#+3
   \   00000374   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000378   0x7809             LDRB     R1,[R1, #+0]
   \   0000037A   0x1A40             SUBS     R0,R0,R1
   \   0000037C   0x.... 0x....      LDR.W    R1,??DataTable29_5
   \   00000380   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000382   0x5C69             LDRB     R1,[R5, R1]
   \   00000384   0x4288             CMP      R0,R1
   \   00000386   0xF280 0x8137      BGE.W    ??BlackGetRightStep1Edge_25
   4191                  {
   4192                    //检查5个白点的平均值是否相近，若相近，则是单线，若不相近，则置无效值。
   4193                    if(
   4194                      (BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 5 < 0)
   4195                    ||(BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 5 > CameraRealWidth - 1)
   4196                      )
   \   0000038A   0x....             LDR.N    R0,??DataTable26_4
   \   0000038C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000038E   0x2103             MOVS     R1,#+3
   \   00000390   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000394   0x7800             LDRB     R0,[R0, #+0]
   \   00000396   0x3809             SUBS     R0,R0,#+9
   \   00000398   0x2800             CMP      R0,#+0
   \   0000039A   0xD409             BMI.N    ??BlackGetRightStep1Edge_26
   \   0000039C   0x.... 0x....      LDR.W    R0,??DataTable29_3
   \   000003A0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003A2   0x2103             MOVS     R1,#+3
   \   000003A4   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   000003A8   0x7800             LDRB     R0,[R0, #+0]
   \   000003AA   0x3009             ADDS     R0,R0,#+9
   \   000003AC   0x28FA             CMP      R0,#+250
   \   000003AE   0xDB1E             BLT.N    ??BlackGetRightStep1Edge_27
   4197                    {
   4198                      //不哆5个点。
   4199                      //因为进行过大跳变，所以要清除。只针对最近几行。
   4200                      if(row > CameraHight - 5)
   \                     ??BlackGetRightStep1Edge_26: (+1)
   \   000003B0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003B2   0x2D38             CMP      R5,#+56
   \   000003B4   0xDB12             BLT.N    ??BlackGetRightStep1Edge_28
   4201                      {
   4202                          for(i = 0; i <= 4; i++)
   \   000003B6   0x2000             MOVS     R0,#+0
   \   000003B8   0xE009             B.N      ??BlackGetRightStep1Edge_29
   4203                          {
   4204                              BlackRightBigChangeNumx[i] = MaxValUint8;
   \                     ??BlackGetRightStep1Edge_30: (+1)
   \   000003BA   0x21FF             MOVS     R1,#+255
   \   000003BC   0x.... 0x....      LDR.W    R2,??DataTable27
   \   000003C0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003C2   0x5481             STRB     R1,[R0, R2]
   4205                              BlackRightBigChangeNumy[i] = MaxValUint8;
   \   000003C4   0x21FF             MOVS     R1,#+255
   \   000003C6   0x....             LDR.N    R2,??DataTable26_6
   \   000003C8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003CA   0x5481             STRB     R1,[R0, R2]
   4206                          }
   \   000003CC   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackGetRightStep1Edge_29: (+1)
   \   000003CE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003D0   0x2805             CMP      R0,#+5
   \   000003D2   0xDBF2             BLT.N    ??BlackGetRightStep1Edge_30
   4207                          BlackRightBigChangeJumpFlag = 0;
   \   000003D4   0x2000             MOVS     R0,#+0
   \   000003D6   0x.... 0x....      LDR.W    R1,??DataTable27_1
   \   000003DA   0x7008             STRB     R0,[R1, #+0]
   4208                      }
   4209                      else
   4210                      {
   4211                      }
   4212                      //该行定位黑线失败，赋无效值
   4213                      BlackRightLoc[row][0] = MaxValUint8;
   \                     ??BlackGetRightStep1Edge_28: (+1)
   \   000003DC   0x20FF             MOVS     R0,#+255
   \   000003DE   0x....             LDR.N    R1,??DataTable26_4
   \   000003E0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003E2   0x2203             MOVS     R2,#+3
   \   000003E4   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   000003E8   0x7008             STRB     R0,[R1, #+0]
   4214                      return 0;
   \   000003EA   0x2000             MOVS     R0,#+0
   \   000003EC   0xE146             B.N      ??BlackGetRightStep1Edge_21
   4215                    }
   4216                    else
   4217                    {
   4218                      //该行右线的白点平均值
   4219                      avgr1 = (ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 1]
   4220                             + ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 2]
   4221                             + ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 3]
   4222                             + ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 4]
   4223                             + ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 5])
   4224                             / 5;
   \                     ??BlackGetRightStep1Edge_27: (+1)
   \   000003EE   0x.... 0x....      LDR.W    R0,??DataTable27_7
   \   000003F2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003F4   0x21FA             MOVS     R1,#+250
   \   000003F6   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   000003FA   0x....             LDR.N    R1,??DataTable26_4
   \   000003FC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003FE   0x2203             MOVS     R2,#+3
   \   00000400   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000404   0x7809             LDRB     R1,[R1, #+0]
   \   00000406   0x1808             ADDS     R0,R1,R0
   \   00000408   0xF810 0x0C05      LDRB     R0,[R0, #-5]
   \   0000040C   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   00000410   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000412   0x22FA             MOVS     R2,#+250
   \   00000414   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000418   0x....             LDR.N    R2,??DataTable26_4
   \   0000041A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000041C   0x2303             MOVS     R3,#+3
   \   0000041E   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   00000422   0x7812             LDRB     R2,[R2, #+0]
   \   00000424   0x1851             ADDS     R1,R2,R1
   \   00000426   0xF811 0x1C06      LDRB     R1,[R1, #-6]
   \   0000042A   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   0000042E   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   00000432   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000434   0x22FA             MOVS     R2,#+250
   \   00000436   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   0000043A   0x....             LDR.N    R2,??DataTable26_4
   \   0000043C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000043E   0x2303             MOVS     R3,#+3
   \   00000440   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   00000444   0x7812             LDRB     R2,[R2, #+0]
   \   00000446   0x1851             ADDS     R1,R2,R1
   \   00000448   0xF811 0x1C07      LDRB     R1,[R1, #-7]
   \   0000044C   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   00000450   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   00000454   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000456   0x22FA             MOVS     R2,#+250
   \   00000458   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   0000045C   0x....             LDR.N    R2,??DataTable26_4
   \   0000045E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000460   0x2303             MOVS     R3,#+3
   \   00000462   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   00000466   0x7812             LDRB     R2,[R2, #+0]
   \   00000468   0x1851             ADDS     R1,R2,R1
   \   0000046A   0xF811 0x1C08      LDRB     R1,[R1, #-8]
   \   0000046E   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   00000472   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   00000476   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000478   0x22FA             MOVS     R2,#+250
   \   0000047A   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   0000047E   0x....             LDR.N    R2,??DataTable26_4
   \   00000480   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000482   0x2303             MOVS     R3,#+3
   \   00000484   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   00000488   0x7812             LDRB     R2,[R2, #+0]
   \   0000048A   0x1851             ADDS     R1,R2,R1
   \   0000048C   0xF811 0x1C09      LDRB     R1,[R1, #-9]
   \   00000490   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   00000494   0x2105             MOVS     R1,#+5
   \   00000496   0xFB90 0xF0F1      SDIV     R0,R0,R1
   4225                      //该行左线的白点平均值
   4226                      avgl1 = (ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 1]
   4227                             + ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 2]
   4228                             + ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 3]
   4229                             + ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 4]
   4230                             + ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 5])
   4231                             / 5;    
   \   0000049A   0x.... 0x....      LDR.W    R1,??DataTable27_7
   \   0000049E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004A0   0x22FA             MOVS     R2,#+250
   \   000004A2   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   000004A6   0x.... 0x....      LDR.W    R2,??DataTable29_3
   \   000004AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004AC   0x2303             MOVS     R3,#+3
   \   000004AE   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   000004B2   0x7812             LDRB     R2,[R2, #+0]
   \   000004B4   0x1851             ADDS     R1,R2,R1
   \   000004B6   0x7949             LDRB     R1,[R1, #+5]
   \   000004B8   0x.... 0x....      LDR.W    R2,??DataTable27_7
   \   000004BC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004BE   0x23FA             MOVS     R3,#+250
   \   000004C0   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   000004C4   0x.... 0x....      LDR.W    R3,??DataTable29_3
   \   000004C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004CA   0xF05F 0x0C03      MOVS     R12,#+3
   \   000004CE   0xFB0C 0x3305      MLA      R3,R12,R5,R3
   \   000004D2   0x781B             LDRB     R3,[R3, #+0]
   \   000004D4   0x189A             ADDS     R2,R3,R2
   \   000004D6   0x7992             LDRB     R2,[R2, #+6]
   \   000004D8   0xFA52 0xF181      UXTAB    R1,R2,R1
   \   000004DC   0x.... 0x....      LDR.W    R2,??DataTable27_7
   \   000004E0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004E2   0x23FA             MOVS     R3,#+250
   \   000004E4   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   000004E8   0x.... 0x....      LDR.W    R3,??DataTable29_3
   \   000004EC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004EE   0xF05F 0x0C03      MOVS     R12,#+3
   \   000004F2   0xFB0C 0x3305      MLA      R3,R12,R5,R3
   \   000004F6   0x781B             LDRB     R3,[R3, #+0]
   \   000004F8   0x189A             ADDS     R2,R3,R2
   \   000004FA   0x79D2             LDRB     R2,[R2, #+7]
   \   000004FC   0xFA51 0xF182      UXTAB    R1,R1,R2
   \   00000500   0x....             LDR.N    R2,??DataTable27_7
   \   00000502   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000504   0x23FA             MOVS     R3,#+250
   \   00000506   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   0000050A   0x.... 0x....      LDR.W    R3,??DataTable29_3
   \   0000050E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000510   0xF05F 0x0C03      MOVS     R12,#+3
   \   00000514   0xFB0C 0x3305      MLA      R3,R12,R5,R3
   \   00000518   0x781B             LDRB     R3,[R3, #+0]
   \   0000051A   0x189A             ADDS     R2,R3,R2
   \   0000051C   0x7A12             LDRB     R2,[R2, #+8]
   \   0000051E   0xFA51 0xF182      UXTAB    R1,R1,R2
   \   00000522   0x....             LDR.N    R2,??DataTable27_7
   \   00000524   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000526   0x23FA             MOVS     R3,#+250
   \   00000528   0xFB03 0x2205      MLA      R2,R3,R5,R2
   \   0000052C   0x.... 0x....      LDR.W    R3,??DataTable29_3
   \   00000530   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000532   0xF05F 0x0C03      MOVS     R12,#+3
   \   00000536   0xFB0C 0x3305      MLA      R3,R12,R5,R3
   \   0000053A   0x781B             LDRB     R3,[R3, #+0]
   \   0000053C   0x189A             ADDS     R2,R3,R2
   \   0000053E   0x7A52             LDRB     R2,[R2, #+9]
   \   00000540   0xFA51 0xF182      UXTAB    R1,R1,R2
   \   00000544   0x2205             MOVS     R2,#+5
   \   00000546   0xFB91 0xF1F2      SDIV     R1,R1,R2
   4232                      if(AbsInt(avgr1 - avgl1) < 20)
   \   0000054A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000054C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000054E   0x1A40             SUBS     R0,R0,R1
   \   00000550   0x.... 0x....      BL       AbsInt
   \   00000554   0x2814             CMP      R0,#+20
   \   00000556   0xDA32             BGE.N    ??BlackGetRightStep1Edge_31
   4233                      {
   4234                        //5个白点之间的差别够小，单线判断成功。
   4235                        SingleBlackFlag[row] = 1;      
   \   00000558   0x2001             MOVS     R0,#+1
   \   0000055A   0x.... 0x....      LDR.W    R1,??DataTable32
   \   0000055E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000560   0x5468             STRB     R0,[R5, R1]
   4236                        //SingleBlackAllFlag = 1;   //总幅图像的单线标志，只要有一行检测单线成功，则置1.
   4237                      }
   4238                      else
   4239                      {
   4240                        //5个白点之间的差别太大，单线判断失败。
   4241                        //因为进行过大跳变，所以要清除。只针对最近几行。
   4242                        if(row > CameraHight - 5)
   4243                        {
   4244                            for(i = 0; i <= 4; i++)
   4245                            {
   4246                                BlackRightBigChangeNumx[i] = MaxValUint8;
   4247                                BlackRightBigChangeNumy[i] = MaxValUint8;
   4248                            }
   4249                            BlackRightBigChangeJumpFlag = 0;
   4250                        }
   4251                        else
   4252                        {
   4253                        }
   4254                        
   4255                        //该行定位黑线失败，赋无效值
   4256                        BlackRightLoc[row][0] = MaxValUint8;
   4257                        return 0;              
   4258                      }
   4259                    }          
   4260                  }
   4261                  else
   4262                  {
   4263                    //否则该行单线标志为0.
   4264                    SingleBlackFlag[row] = 0;
   4265                  }
   4266                }
   4267                //从右线开始的扫描，右线不用检测是否有单线，左线去检测即可。
   4268                else
   4269                {
   4270                }
   4271                
   4272                //没有报错，就会走到这里，黑点查找成功，会有1，2，3个黑点
   4273                //return 1;
   4274              }
   4275              else
   4276              {
   4277                //没通过大跳变检测。
   4278                BlackRightBigChangeCheckRow[row] = 1;
   4279                BlackRightBigChangeCheckAllRow = 1;
   4280                
   4281                //return 1;
   4282                
   4283                //该行定位黑线失败，赋无效值
   4284                BlackRightLoc[row][0] = MaxValUint8;
   4285                return 0;
   4286              }
   4287            }
   4288            //是黑线预处理的调用，不需大跳变的检测，直接返回成功。
   4289            else
   4290            {
   4291              //return 1;
   4292            }
   4293          
   4294            //如果是黑线预处理的调用，也不用更新这几个值。
   4295            if(preflag == 0)
   \                     ??BlackGetRightStep1Edge_22: (+1)
   \   00000562   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000564   0x2F00             CMP      R7,#+0
   \   00000566   0xF040 0x8088      BNE.W    ??BlackGetRightStep1Edge_32
   4296            {
   4297              //进入这里说明跳变沿的二批条件均满足，进入黑点记录阶段
   4298              //记录3个关键值的实际信息，作为后面的参考。
   4299              if(use == 1)
   \   0000056A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000056C   0x2E01             CMP      R6,#+1
   \   0000056E   0xD15B             BNE.N    ??BlackGetRightStep1Edge_33
   4300              {
   4301                BlackRightRealWB[0] = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum]; 
   \   00000570   0x....             LDR.N    R0,??DataTable27_7
   \   00000572   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000574   0x21FA             MOVS     R1,#+250
   \   00000576   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000057A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000057C   0x5C20             LDRB     R0,[R4, R0]
   \   0000057E   0x....             LDR.N    R1,??DataTable27_7
   \   00000580   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000582   0x22FA             MOVS     R2,#+250
   \   00000584   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000588   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000058A   0x1861             ADDS     R1,R4,R1
   \   0000058C   0x7909             LDRB     R1,[R1, #+4]
   \   0000058E   0x1A40             SUBS     R0,R0,R1
   \   00000590   0x....             LDR.N    R1,??DataTable26
   \   00000592   0x7008             STRB     R0,[R1, #+0]
   4302                BlackRightRealW[0] = ImgNew[row][col];
   \   00000594   0x....             LDR.N    R0,??DataTable27_7
   \   00000596   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000598   0x21FA             MOVS     R1,#+250
   \   0000059A   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000059E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000005A0   0x5C20             LDRB     R0,[R4, R0]
   \   000005A2   0x....             LDR.N    R1,??DataTable26_1
   \   000005A4   0x7008             STRB     R0,[R1, #+0]
   4303                BlackRightRealB[0] = ImgNew[row][col+1+BlackRightEdgeNum];
   \   000005A6   0x....             LDR.N    R0,??DataTable27_7
   \   000005A8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005AA   0x21FA             MOVS     R1,#+250
   \   000005AC   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   000005B0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000005B2   0x1820             ADDS     R0,R4,R0
   \   000005B4   0x7900             LDRB     R0,[R0, #+4]
   \   000005B6   0x.... 0x....      LDR.W    R1,??DataTable32_1
   \   000005BA   0x7008             STRB     R0,[R1, #+0]
   \   000005BC   0xE05D             B.N      ??BlackGetRightStep1Edge_32
   4304              }
   \                     ??BlackGetRightStep1Edge_31: (+1)
   \   000005BE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005C0   0x2D38             CMP      R5,#+56
   \   000005C2   0xDB10             BLT.N    ??BlackGetRightStep1Edge_34
   \   000005C4   0x2000             MOVS     R0,#+0
   \   000005C6   0xE008             B.N      ??BlackGetRightStep1Edge_35
   \                     ??BlackGetRightStep1Edge_36: (+1)
   \   000005C8   0x21FF             MOVS     R1,#+255
   \   000005CA   0x....             LDR.N    R2,??DataTable27
   \   000005CC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005CE   0x5481             STRB     R1,[R0, R2]
   \   000005D0   0x21FF             MOVS     R1,#+255
   \   000005D2   0x....             LDR.N    R2,??DataTable26_6
   \   000005D4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005D6   0x5481             STRB     R1,[R0, R2]
   \   000005D8   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackGetRightStep1Edge_35: (+1)
   \   000005DA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005DC   0x2805             CMP      R0,#+5
   \   000005DE   0xDBF3             BLT.N    ??BlackGetRightStep1Edge_36
   \   000005E0   0x2000             MOVS     R0,#+0
   \   000005E2   0x....             LDR.N    R1,??DataTable27_1
   \   000005E4   0x7008             STRB     R0,[R1, #+0]
   \                     ??BlackGetRightStep1Edge_34: (+1)
   \   000005E6   0x20FF             MOVS     R0,#+255
   \   000005E8   0x....             LDR.N    R1,??DataTable26_4
   \   000005EA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005EC   0x2203             MOVS     R2,#+3
   \   000005EE   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   000005F2   0x7008             STRB     R0,[R1, #+0]
   \   000005F4   0x2000             MOVS     R0,#+0
   \   000005F6   0xE041             B.N      ??BlackGetRightStep1Edge_21
   \                     ??BlackGetRightStep1Edge_25: (+1)
   \   000005F8   0x2000             MOVS     R0,#+0
   \   000005FA   0x.... 0x....      LDR.W    R1,??DataTable32
   \   000005FE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000600   0x5468             STRB     R0,[R5, R1]
   \   00000602   0xE7AE             B.N      ??BlackGetRightStep1Edge_22
   \                     ??BlackGetRightStep1Edge_23: (+1)
   \   00000604   0x2001             MOVS     R0,#+1
   \   00000606   0x.... 0x....      LDR.W    R1,??DataTable32_2
   \   0000060A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000060C   0x5468             STRB     R0,[R5, R1]
   \   0000060E   0x2001             MOVS     R0,#+1
   \   00000610   0x.... 0x....      LDR.W    R1,??DataTable32_3
   \   00000614   0x7008             STRB     R0,[R1, #+0]
   \   00000616   0x20FF             MOVS     R0,#+255
   \   00000618   0x....             LDR.N    R1,??DataTable26_4
   \   0000061A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000061C   0x2203             MOVS     R2,#+3
   \   0000061E   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000622   0x7008             STRB     R0,[R1, #+0]
   \   00000624   0x2000             MOVS     R0,#+0
   \   00000626   0xE029             B.N      ??BlackGetRightStep1Edge_21
   4305              else if(use == 2)
   \                     ??BlackGetRightStep1Edge_33: (+1)
   \   00000628   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000062A   0x2E02             CMP      R6,#+2
   \   0000062C   0xD125             BNE.N    ??BlackGetRightStep1Edge_32
   4306              {
   4307                BlackRightRealWB[1] = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum]; 
   \   0000062E   0x....             LDR.N    R0,??DataTable27_7
   \   00000630   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000632   0x21FA             MOVS     R1,#+250
   \   00000634   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000638   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000063A   0x5C20             LDRB     R0,[R4, R0]
   \   0000063C   0x....             LDR.N    R1,??DataTable27_7
   \   0000063E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000640   0x22FA             MOVS     R2,#+250
   \   00000642   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000646   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000648   0x1861             ADDS     R1,R4,R1
   \   0000064A   0x7909             LDRB     R1,[R1, #+4]
   \   0000064C   0x1A40             SUBS     R0,R0,R1
   \   0000064E   0x....             LDR.N    R1,??DataTable26
   \   00000650   0x7048             STRB     R0,[R1, #+1]
   4308                BlackRightRealW[1] = ImgNew[row][col];
   \   00000652   0x....             LDR.N    R0,??DataTable27_7
   \   00000654   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000656   0x21FA             MOVS     R1,#+250
   \   00000658   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000065C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000065E   0x5C20             LDRB     R0,[R4, R0]
   \   00000660   0x....             LDR.N    R1,??DataTable26_1
   \   00000662   0x7048             STRB     R0,[R1, #+1]
   4309                BlackRightRealB[1] = ImgNew[row][col+1+BlackRightEdgeNum];
   \   00000664   0x....             LDR.N    R0,??DataTable27_7
   \   00000666   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000668   0x21FA             MOVS     R1,#+250
   \   0000066A   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000066E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000670   0x1820             ADDS     R0,R4,R0
   \   00000672   0x7900             LDRB     R0,[R0, #+4]
   \   00000674   0x.... 0x....      LDR.W    R1,??DataTable32_1
   \   00000678   0x7048             STRB     R0,[R1, #+1]
   4310              }
   4311              else
   4312              {
   4313              }
   4314            }
   4315            
   4316            return 1;
   \                     ??BlackGetRightStep1Edge_32: (+1)
   \   0000067A   0x2001             MOVS     R0,#+1
   \                     ??BlackGetRightStep1Edge_21: (+1)
   \   0000067C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   4317          }
   4318          
   4319          
   4320          //======================================================================
   4321          //函数名：BlackGetRightStep2Win
   4322          //功  能：右黑线提取中，第2阶段窗口内跳变检测函数
   4323          //参  数：待处理行号row, 窗口大小win, 预测的跳变点的位置predict, 第几次使用use.
   4324          //返  回：1成功  0失败
   4325          //影  响：BlackRightLoc[][0]
   4326          //说  明：1. 满足两批条件，才能检测成功。只有一个点的记录。
   4327          //        2. 窗口内没有检测到，则检测失败。
   4328          //        3. 窗缩小可以减少一定的时间，但如果遇到斜率过大的情况，就有可能检测不到。     
   4329          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   4330          uint8 BlackGetRightStep2Win(uint8 row, uint8 win, uint8 predict, uint8 use)
   4331          {
   \                     BlackGetRightStep2Win: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x001D             MOVS     R5,R3
   4332            uint8 col, temp;
   4333          
   4334            //在规划好的窗口内，从左往右查找跳变沿
   4335            //防止溢出
   4336            //对右边界的限制 
   4337            if((predict + win) >= (CameraRealWidth - 5 - BlackRightEdgeNum)) 
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0xFA51 0xF082      UXTAB    R0,R1,R2
   \   0000000C   0x28F2             CMP      R0,#+242
   \   0000000E   0xDB01             BLT.N    ??BlackGetRightStep2Win_0
   4338            {
   4339              temp = CameraRealWidth - 5 - BlackRightEdgeNum;
   \   00000010   0x26F2             MOVS     R6,#+242
   \   00000012   0xE000             B.N      ??BlackGetRightStep2Win_1
   4340            }  
   4341            else
   4342            {
   4343              temp = predict + win;
   \                     ??BlackGetRightStep2Win_0: (+1)
   \   00000014   0x188E             ADDS     R6,R1,R2
   4344            }
   4345            //对左边界的限制
   4346            if(predict <= win)
   \                     ??BlackGetRightStep2Win_1: (+1)
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001A   0x4291             CMP      R1,R2
   \   0000001C   0xD301             BCC.N    ??BlackGetRightStep2Win_2
   4347            {
   4348              col = 0;
   \   0000001E   0x2700             MOVS     R7,#+0
   \   00000020   0xE000             B.N      ??BlackGetRightStep2Win_3
   4349            }
   4350            else
   4351            {
   4352              col = predict - win;  
   \                     ??BlackGetRightStep2Win_2: (+1)
   \   00000022   0x1A57             SUBS     R7,R2,R1
   4353            }
   4354            //左线开始扫描且没有出现单线时，右线的扫描左边界必须在该行有效左黑线的右边。
   4355            if((BlackGetPreDir == 0 || BlackGetPreDir == 2)
   4356            &&(SingleBlackAllFlag == 0)
   4357            &&(BlackLeftLoc[row][0] != MaxValUint8)
   4358              )
   \                     ??BlackGetRightStep2Win_3: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable29_2
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD004             BEQ.N    ??BlackGetRightStep2Win_4
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable29_2
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x2802             CMP      R0,#+2
   \   00000036   0xD119             BNE.N    ??BlackGetRightStep2Win_5
   \                     ??BlackGetRightStep2Win_4: (+1)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable31
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD114             BNE.N    ??BlackGetRightStep2Win_5
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable29_3
   \   00000046   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   0x2103             MOVS     R1,#+3
   \   0000004A   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0x28FF             CMP      R0,#+255
   \   00000052   0xD00B             BEQ.N    ??BlackGetRightStep2Win_5
   4359            {
   4360              col = MaxRe(col, BlackLeftLoc[row][0]);
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable29_3
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0x2103             MOVS     R1,#+3
   \   0000005C   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000060   0x7801             LDRB     R1,[R0, #+0]
   \   00000062   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000064   0x0038             MOVS     R0,R7
   \   00000066   0x.... 0x....      BL       MaxRe
   \   0000006A   0x0007             MOVS     R7,R0
   4361            }
   4362            else
   4363            {
   4364            }
   4365            
   4366            //窗口预测值记录
   4367            BlackRightPredictL[row] = col;
   \                     ??BlackGetRightStep2Win_5: (+1)
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable29_6
   \   00000070   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000072   0x5427             STRB     R7,[R4, R0]
   4368            BlackRightPredictR[row] = temp;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable29_7
   \   00000078   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007A   0x5426             STRB     R6,[R4, R0]
   4369            
   4370            //左边界在右边界的右边，直接返回失败。
   4371            if(col >= temp) return 0;
   \   0000007C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000007E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000080   0x42B7             CMP      R7,R6
   \   00000082   0xD301             BCC.N    ??BlackGetRightStep2Win_6
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xE090             B.N      ??BlackGetRightStep2Win_7
   4372             
   4373            //开窗扫描跳变沿
   4374            col = BlackGetRightJustWin(row, col, temp);
   \                     ??BlackGetRightStep2Win_6: (+1)
   \   00000088   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008A   0x0032             MOVS     R2,R6
   \   0000008C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000008E   0x0039             MOVS     R1,R7
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000094   0x.... 0x....      BL       BlackGetRightJustWin
   \   00000098   0x0007             MOVS     R7,R0
   4375            if(col != MaxValUint8)
   \   0000009A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000009C   0x2FFF             CMP      R7,#+255
   \   0000009E   0xD07B             BEQ.N    ??BlackGetRightStep2Win_8
   4376            {
   4377              //两批条件均满足，直接记录该点为黑线，返回即可
   4378              BlackRightLoc[row][0] = col + 1 + BlackRightEdgeNum;
   \   000000A0   0x1D38             ADDS     R0,R7,#+4
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable33
   \   000000A6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A8   0x2203             MOVS     R2,#+3
   \   000000AA   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000AE   0x7008             STRB     R0,[R1, #+0]
   4379                       
   4380              //最终确认前，需要对大斜率进行检测。
   4381              if(BlackRightBigChangeCheck(row, use) == 0)
   \   000000B0   0x0029             MOVS     R1,R5
   \   000000B2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B8   0x.... 0x....      BL       BlackRightBigChangeCheck
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD112             BNE.N    ??BlackGetRightStep2Win_9
   4382              {
   4383                //没通过大跳变检测。
   4384                BlackRightBigChangeCheckRow[row] = 1;
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable32_2
   \   000000C6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C8   0x5460             STRB     R0,[R4, R1]
   4385                BlackRightBigChangeCheckAllRow = 1;             
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable32_3
   \   000000D0   0x7008             STRB     R0,[R1, #+0]
   4386                
   4387                BlackRightLoc[row][0] = MaxValUint8;
   \   000000D2   0x20FF             MOVS     R0,#+255
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable33
   \   000000D8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DA   0x2203             MOVS     R2,#+3
   \   000000DC   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000E0   0x7008             STRB     R0,[R1, #+0]
   4388                return 0;
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0xE061             B.N      ??BlackGetRightStep2Win_7
   4389              }
   4390              else
   4391              {
   4392              }
   4393              
   4394              
   4395              //记录3个关键值的实际信息，作为后面的参考。
   4396              if(use == 1)
   \                     ??BlackGetRightStep2Win_9: (+1)
   \   000000E6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E8   0x2D01             CMP      R5,#+1
   \   000000EA   0xD128             BNE.N    ??BlackGetRightStep2Win_10
   4397              {
   4398                BlackRightRealWB[0] = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum]; 
   \   000000EC   0x....             LDR.N    R0,??DataTable27_7
   \   000000EE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F0   0x21FA             MOVS     R1,#+250
   \   000000F2   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000F6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F8   0x5C38             LDRB     R0,[R7, R0]
   \   000000FA   0x....             LDR.N    R1,??DataTable27_7
   \   000000FC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FE   0x22FA             MOVS     R2,#+250
   \   00000100   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000104   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000106   0x1879             ADDS     R1,R7,R1
   \   00000108   0x7909             LDRB     R1,[R1, #+4]
   \   0000010A   0x1A40             SUBS     R0,R0,R1
   \   0000010C   0x.... 0x....      LDR.W    R1,??DataTable32_4
   \   00000110   0x7008             STRB     R0,[R1, #+0]
   4399                BlackRightRealW[0] = ImgNew[row][col];
   \   00000112   0x....             LDR.N    R0,??DataTable27_7
   \   00000114   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000116   0x21FA             MOVS     R1,#+250
   \   00000118   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000011C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000011E   0x5C38             LDRB     R0,[R7, R0]
   \   00000120   0x.... 0x....      LDR.W    R1,??DataTable32_5
   \   00000124   0x7008             STRB     R0,[R1, #+0]
   4400                BlackRightRealB[0] = ImgNew[row][col+1+BlackRightEdgeNum];
   \   00000126   0x....             LDR.N    R0,??DataTable27_7
   \   00000128   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000012A   0x21FA             MOVS     R1,#+250
   \   0000012C   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000130   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000132   0x1838             ADDS     R0,R7,R0
   \   00000134   0x7900             LDRB     R0,[R0, #+4]
   \   00000136   0x.... 0x....      LDR.W    R1,??DataTable32_1
   \   0000013A   0x7008             STRB     R0,[R1, #+0]
   \   0000013C   0xE02A             B.N      ??BlackGetRightStep2Win_11
   4401              }
   4402              else if(use == 2)
   \                     ??BlackGetRightStep2Win_10: (+1)
   \   0000013E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000140   0x2D02             CMP      R5,#+2
   \   00000142   0xD127             BNE.N    ??BlackGetRightStep2Win_11
   4403              {
   4404                BlackRightRealWB[1] = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum]; 
   \   00000144   0x....             LDR.N    R0,??DataTable27_7
   \   00000146   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000148   0x21FA             MOVS     R1,#+250
   \   0000014A   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000014E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000150   0x5C38             LDRB     R0,[R7, R0]
   \   00000152   0x....             LDR.N    R1,??DataTable27_7
   \   00000154   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000156   0x22FA             MOVS     R2,#+250
   \   00000158   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000015C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000015E   0x1879             ADDS     R1,R7,R1
   \   00000160   0x7909             LDRB     R1,[R1, #+4]
   \   00000162   0x1A40             SUBS     R0,R0,R1
   \   00000164   0x.... 0x....      LDR.W    R1,??DataTable32_4
   \   00000168   0x7048             STRB     R0,[R1, #+1]
   4405                BlackRightRealW[1] = ImgNew[row][col];
   \   0000016A   0x....             LDR.N    R0,??DataTable27_7
   \   0000016C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000016E   0x21FA             MOVS     R1,#+250
   \   00000170   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000174   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000176   0x5C38             LDRB     R0,[R7, R0]
   \   00000178   0x.... 0x....      LDR.W    R1,??DataTable32_5
   \   0000017C   0x7048             STRB     R0,[R1, #+1]
   4406                BlackRightRealB[1] = ImgNew[row][col+1+BlackRightEdgeNum];
   \   0000017E   0x....             LDR.N    R0,??DataTable27_7
   \   00000180   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000182   0x21FA             MOVS     R1,#+250
   \   00000184   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000188   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000018A   0x1838             ADDS     R0,R7,R0
   \   0000018C   0x7900             LDRB     R0,[R0, #+4]
   \   0000018E   0x.... 0x....      LDR.W    R1,??DataTable32_1
   \   00000192   0x7048             STRB     R0,[R1, #+1]
   4407              }
   4408              else
   4409              {
   4410              }
   4411                
   4412              return 1;   
   \                     ??BlackGetRightStep2Win_11: (+1)
   \   00000194   0x2001             MOVS     R0,#+1
   \   00000196   0xE008             B.N      ??BlackGetRightStep2Win_7
   4413            }
   4414            else
   4415            {
   4416              //窗口内没有扫描到跳变沿，该行的黑线位置记为无效值，返回0失败.
   4417              BlackRightLoc[row][0] = MaxValUint8;
   \                     ??BlackGetRightStep2Win_8: (+1)
   \   00000198   0x20FF             MOVS     R0,#+255
   \   0000019A   0x.... 0x....      LDR.W    R1,??DataTable33
   \   0000019E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001A0   0x2203             MOVS     R2,#+3
   \   000001A2   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000001A6   0x7008             STRB     R0,[R1, #+0]
   4418              return 0;
   \   000001A8   0x2000             MOVS     R0,#+0
   \                     ??BlackGetRightStep2Win_7: (+1)
   \   000001AA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   4419            }
   4420          }
   4421          
   4422          
   4423          
   4424          //======================================================================
   4425          //函数名：BlackGetRightStep1Scan
   4426          //功  能：右黑线提取中，第1阶段的行扫描函数
   4427          //参  数：扫描起始行FirstLine, 扫描结束行LastLine
   4428          //返  回：0~CameraHight - 1行数 255采集失败
   4429          //影  响：BlackRightRealWB[], BlackRightRealW[], BlackRightRealB[], BlackRightLoc[][],
   4430          //        LimitRightWB, LimitRightW, LimitRightB
   4431          //说  明：1. 可用于正常地第1阶段行扫描，也可用于十字再检测时的行扫描
   4432          //        2. 正常第1阶段扫描时，会更改3个关键阈值的值。
   4433          //             
   4434          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   4435          uint8 BlackGetRightStep1Scan(uint8 FirstLine, uint8 LastLine, uint8 CrossFlag)
   4436          {
   \                     BlackGetRightStep1Scan: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   4437              uint8 row, temp1, temp2;
   4438              uint8 abs1;
   4439              uint8 tempWB, tempW, tempB;
   4440              uint8 flag, i;
   4441              
   4442              flag = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   4443              //最近的BlackStep1Size行用差值法找黑线
   4444              for(row = FirstLine; row > LastLine; row -= 2)
   \   0000000C   0x46A0             MOV      R8,R4
   \   0000000E   0xE00A             B.N      ??BlackGetRightStep1Scan_0
   4445              {
   4446                //判断是否连续两行检测到跳变，可疑黑点有3个点，暂取其中一个
   4447                temp1 = BlackGetRightStep1Edge(row, 1, 0);
   4448                temp2 = BlackGetRightStep1Edge(row-1, 2, 0);
   4449                if(temp1 == 1 && temp2 == 1)//这里可以这么写，不用嵌套if，因为&&的特点
   4450                {
   4451                  abs1 = AbsRe(BlackRightLoc[row-1][0], BlackRightLoc[row][0]);
   4452                  //进一步判断连续两行的黑点的间隔是否够小，且暂取第1个可疑黑点。
   4453                  if(abs1 < BlackRightStep1ScanMinus)
   4454                  {
   4455                    //检测到了连续的黑线，停止差值法找跳变沿，节省时间，下面进入第2阶段                                     
   4456                    //如果不是十字再检测的情况，就更新一下实际的3个关键值，否则不更新。
   4457                    if(CrossFlag == 1)
   4458                      {           
   4459                        //差值的处理，留有裕度，且有上下界。
   4460                        tempWB = (BlackRightRealWB[0] + BlackRightRealWB[1]) / 2 - LimitRightWBMargin; 
   4461                        if(tempWB < LimitRightWBMin) tempWB = LimitRightWBMin;
   4462                        else if(tempWB > LimitRightWBMax) tempWB = LimitRightWBMax;
   4463                        else ;
   4464                        LimitRightWB = tempWB;
   4465                        
   4466                        //白点的处理，留有裕度，且有上下界。
   4467                        tempW = (BlackRightRealW[0] + BlackRightRealW[1]) / 2 - LimitRightWMargin;
   4468                        if(tempW < LimitRightWMin) tempW = LimitRightWMin;
   4469                        else if(tempW > LimitRightWMax) tempW = LimitRightWMax;
   4470                        else ;
   4471                        LimitRightW = tempW;
   4472                        
   4473                        //黑点的处理，留有裕度，且有上下界。
   4474                        tempB = (BlackRightRealB[0] + BlackRightRealB[1]) / 2 + LimitRightBMargin;
   4475                        if(tempB < LimitRightBMin) tempB = LimitRightBMin;
   4476                        else if(tempB > LimitRightBMax) tempB = LimitRightBMax;
   4477                        else ;
   4478                        //黑色阈值不能超过白色
   4479                        if(tempB >= LimitRightW)
   4480                        {
   4481                          tempB = LimitRightW - 1;
   4482                        }
   4483                        else
   4484                        {
   4485                        }             
   4486                        LimitRightB = tempB;           
   4487                      }
   4488                    break;
   4489                  }
   4490                  else
   4491                  {
   4492                    //连续两行相差的列太大，视为错误点。
   4493                    BlackRightLoc[row][0] = MaxValUint8;
   4494                    BlackRightLoc[row-1][0] = MaxValUint8;
   4495                    //大跳变检测数组的复位。
   4496                    BlackRightBigChangeNumx[3] = MaxValUint8;
   4497                    BlackRightBigChangeNumx[4] = MaxValUint8;
   4498                    BlackRightBigChangeNumy[3] = MaxValUint8;
   4499                    BlackRightBigChangeNumy[4] = MaxValUint8;
   4500                    BlackRightBigChangeJumpFlag = 0;
   4501                  }
   4502                }
   4503                else if(temp1 == 0 && temp2 == 1)
   4504                {
   4505                  //走到这里，说明双黑线检测成功之前有双线之一采集成功。
   4506                  flag = 1;
   4507                }
   4508                else if(temp1 == 1 && temp2 == 0)
   \                     ??BlackGetRightStep1Scan_1: (+1)
   \   00000010   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000014   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000018   0xD103             BNE.N    ??BlackGetRightStep1Scan_2
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD100             BNE.N    ??BlackGetRightStep1Scan_2
   4509                {
   4510                  //走到这里，说明双黑线检测成功之前有双线之一采集成功。
   4511                  flag = 1;
   \   00000020   0x2701             MOVS     R7,#+1
   4512                }
   \                     ??BlackGetRightStep1Scan_2: (+1)
   \   00000022   0xF1B8 0x0802      SUBS     R8,R8,#+2
   \                     ??BlackGetRightStep1Scan_0: (+1)
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000002C   0x4545             CMP      R5,R8
   \   0000002E   0xF080 0x8099      BCS.W    ??BlackGetRightStep1Scan_3
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x.... 0x....      BL       BlackGetRightStep1Edge
   \   0000003E   0x4681             MOV      R9,R0
   \   00000040   0x2200             MOVS     R2,#+0
   \   00000042   0x2102             MOVS     R1,#+2
   \   00000044   0xF1B8 0x0001      SUBS     R0,R8,#+1
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x.... 0x....      BL       BlackGetRightStep1Edge
   \   0000004E   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000052   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000056   0xF040 0x80B4      BNE.W    ??BlackGetRightStep1Scan_4
   \   0000005A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xF040 0x80B0      BNE.W    ??BlackGetRightStep1Scan_4
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable33
   \   00000066   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000006A   0x2103             MOVS     R1,#+3
   \   0000006C   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00000070   0x7801             LDRB     R1,[R0, #+0]
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable33
   \   00000076   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000007A   0x2203             MOVS     R2,#+3
   \   0000007C   0xFB02 0x0008      MLA      R0,R2,R8,R0
   \   00000080   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000084   0x.... 0x....      BL       AbsRe
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0x2808             CMP      R0,#+8
   \   0000008C   0xDA71             BGE.N    ??BlackGetRightStep1Scan_5
   \   0000008E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000090   0x2E01             CMP      R6,#+1
   \   00000092   0xD167             BNE.N    ??BlackGetRightStep1Scan_6
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable32_4
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable32_4
   \   0000009E   0x7849             LDRB     R1,[R1, #+1]
   \   000000A0   0x1808             ADDS     R0,R1,R0
   \   000000A2   0x2102             MOVS     R1,#+2
   \   000000A4   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000A8   0x3814             SUBS     R0,R0,#+20
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable33_1
   \   000000AE   0x7809             LDRB     R1,[R1, #+0]
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0x4288             CMP      R0,R1
   \   000000B4   0xD203             BCS.N    ??BlackGetRightStep1Scan_7
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable33_1
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0xE008             B.N      ??BlackGetRightStep1Scan_8
   \                     ??BlackGetRightStep1Scan_7: (+1)
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable33_2
   \   000000C2   0x7809             LDRB     R1,[R1, #+0]
   \   000000C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C6   0x4281             CMP      R1,R0
   \   000000C8   0xD202             BCS.N    ??BlackGetRightStep1Scan_8
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable33_2
   \   000000CE   0x7800             LDRB     R0,[R0, #+0]
   \                     ??BlackGetRightStep1Scan_8: (+1)
   \   000000D0   0x....             LDR.N    R1,??DataTable28
   \   000000D2   0x7008             STRB     R0,[R1, #+0]
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable32_5
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0x.... 0x....      LDR.W    R1,??DataTable32_5
   \   000000DE   0x7849             LDRB     R1,[R1, #+1]
   \   000000E0   0x1808             ADDS     R0,R1,R0
   \   000000E2   0x2102             MOVS     R1,#+2
   \   000000E4   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000E8   0x3828             SUBS     R0,R0,#+40
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable33_3
   \   000000EE   0x7809             LDRB     R1,[R1, #+0]
   \   000000F0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F2   0x4288             CMP      R0,R1
   \   000000F4   0xD203             BCS.N    ??BlackGetRightStep1Scan_9
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable33_3
   \   000000FA   0x7800             LDRB     R0,[R0, #+0]
   \   000000FC   0xE008             B.N      ??BlackGetRightStep1Scan_10
   \                     ??BlackGetRightStep1Scan_9: (+1)
   \   000000FE   0x.... 0x....      LDR.W    R1,??DataTable33_4
   \   00000102   0x7809             LDRB     R1,[R1, #+0]
   \   00000104   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000106   0x4281             CMP      R1,R0
   \   00000108   0xD202             BCS.N    ??BlackGetRightStep1Scan_10
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable33_4
   \   0000010E   0x7800             LDRB     R0,[R0, #+0]
   \                     ??BlackGetRightStep1Scan_10: (+1)
   \   00000110   0x....             LDR.N    R1,??DataTable28_2
   \   00000112   0x7008             STRB     R0,[R1, #+0]
   \   00000114   0x.... 0x....      LDR.W    R0,??DataTable32_1
   \   00000118   0x7800             LDRB     R0,[R0, #+0]
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable32_1
   \   0000011E   0x7849             LDRB     R1,[R1, #+1]
   \   00000120   0x1808             ADDS     R0,R1,R0
   \   00000122   0x2102             MOVS     R1,#+2
   \   00000124   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000128   0x3023             ADDS     R0,R0,#+35
   \   0000012A   0x.... 0x....      LDR.W    R1,??DataTable33_5
   \   0000012E   0x7809             LDRB     R1,[R1, #+0]
   \   00000130   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000132   0x4288             CMP      R0,R1
   \   00000134   0xD203             BCS.N    ??BlackGetRightStep1Scan_11
   \   00000136   0x.... 0x....      LDR.W    R0,??DataTable33_5
   \   0000013A   0x7800             LDRB     R0,[R0, #+0]
   \   0000013C   0xE008             B.N      ??BlackGetRightStep1Scan_12
   \                     ??BlackGetRightStep1Scan_11: (+1)
   \   0000013E   0x.... 0x....      LDR.W    R1,??DataTable33_6
   \   00000142   0x7809             LDRB     R1,[R1, #+0]
   \   00000144   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000146   0x4281             CMP      R1,R0
   \   00000148   0xD202             BCS.N    ??BlackGetRightStep1Scan_12
   \   0000014A   0x.... 0x....      LDR.W    R0,??DataTable33_6
   \   0000014E   0x7800             LDRB     R0,[R0, #+0]
   \                     ??BlackGetRightStep1Scan_12: (+1)
   \   00000150   0x....             LDR.N    R1,??DataTable28_2
   \   00000152   0x7809             LDRB     R1,[R1, #+0]
   \   00000154   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000156   0x4288             CMP      R0,R1
   \   00000158   0xD302             BCC.N    ??BlackGetRightStep1Scan_13
   \   0000015A   0x....             LDR.N    R0,??DataTable28_2
   \   0000015C   0x7800             LDRB     R0,[R0, #+0]
   \   0000015E   0x1E40             SUBS     R0,R0,#+1
   \                     ??BlackGetRightStep1Scan_13: (+1)
   \   00000160   0x....             LDR.N    R1,??DataTable29
   \   00000162   0x7008             STRB     R0,[R1, #+0]
   4513                else
   4514                {
   4515                }
   4516              }   
   4517              
   4518              //检测了BlackStep1Size行也没有检测到连续的黑线，说明黑线检测失败
   4519              if(row <= LastLine)
   \                     ??BlackGetRightStep1Scan_6: (+1)
   \                     ??BlackGetRightStep1Scan_3: (+1)
   \   00000164   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000166   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000016A   0x4545             CMP      R5,R8
   \   0000016C   0xD335             BCC.N    ??BlackGetRightStep1Scan_14
   4520              {
   4521                return MaxValUint8;
   \   0000016E   0x20FF             MOVS     R0,#+255
   \   00000170   0xE05E             B.N      ??BlackGetRightStep1Scan_15
   4522              }               
   \                     ??BlackGetRightStep1Scan_5: (+1)
   \   00000172   0x20FF             MOVS     R0,#+255
   \   00000174   0x.... 0x....      LDR.W    R1,??DataTable33
   \   00000178   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000017C   0x2203             MOVS     R2,#+3
   \   0000017E   0xFB02 0x1108      MLA      R1,R2,R8,R1
   \   00000182   0x7008             STRB     R0,[R1, #+0]
   \   00000184   0x20FF             MOVS     R0,#+255
   \   00000186   0x.... 0x....      LDR.W    R1,??DataTable33
   \   0000018A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000018E   0x2203             MOVS     R2,#+3
   \   00000190   0xFB02 0x1108      MLA      R1,R2,R8,R1
   \   00000194   0xF801 0x0C03      STRB     R0,[R1, #-3]
   \   00000198   0x20FF             MOVS     R0,#+255
   \   0000019A   0x.... 0x....      LDR.W    R1,??DataTable31_1
   \   0000019E   0x70C8             STRB     R0,[R1, #+3]
   \   000001A0   0x20FF             MOVS     R0,#+255
   \   000001A2   0x.... 0x....      LDR.W    R1,??DataTable31_1
   \   000001A6   0x7108             STRB     R0,[R1, #+4]
   \   000001A8   0x20FF             MOVS     R0,#+255
   \   000001AA   0x.... 0x....      LDR.W    R1,??DataTable33_7
   \   000001AE   0x70C8             STRB     R0,[R1, #+3]
   \   000001B0   0x20FF             MOVS     R0,#+255
   \   000001B2   0x.... 0x....      LDR.W    R1,??DataTable33_7
   \   000001B6   0x7108             STRB     R0,[R1, #+4]
   \   000001B8   0x2000             MOVS     R0,#+0
   \   000001BA   0x.... 0x....      LDR.W    R1,??DataTable34
   \   000001BE   0x7008             STRB     R0,[R1, #+0]
   \   000001C0   0xE72F             B.N      ??BlackGetRightStep1Scan_2
   \                     ??BlackGetRightStep1Scan_4: (+1)
   \   000001C2   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001C6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001CA   0xF47F 0xAF21      BNE.W    ??BlackGetRightStep1Scan_1
   \   000001CE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001D0   0x2801             CMP      R0,#+1
   \   000001D2   0xF47F 0xAF1D      BNE.W    ??BlackGetRightStep1Scan_1
   \   000001D6   0x2701             MOVS     R7,#+1
   \   000001D8   0xE723             B.N      ??BlackGetRightStep1Scan_2
   4523              else
   4524              {
   4525                  //双黑线检测成功 且 双黑线检测成功之前有双线之一采集成功。
   4526                  if(flag == 1)
   \                     ??BlackGetRightStep1Scan_14: (+1)
   \   000001DA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001DC   0x2F01             CMP      R7,#+1
   \   000001DE   0xD125             BNE.N    ??BlackGetRightStep1Scan_16
   4527                  {
   4528                      //把前面的双线之一都去掉。
   4529                      for(i = FirstLine; ; i--)
   \   000001E0   0xE008             B.N      ??BlackGetRightStep1Scan_17
   4530                      {
   4531                          if(i == row) break;
   4532                          BlackRightLoc[i][0] = MaxValUint8;
   \                     ??BlackGetRightStep1Scan_18: (+1)
   \   000001E2   0x20FF             MOVS     R0,#+255
   \   000001E4   0x.... 0x....      LDR.W    R1,??DataTable33
   \   000001E8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001EA   0x2203             MOVS     R2,#+3
   \   000001EC   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000001F0   0x7008             STRB     R0,[R1, #+0]
   \   000001F2   0x1E64             SUBS     R4,R4,#+1
   \                     ??BlackGetRightStep1Scan_17: (+1)
   \   000001F4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001F6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001FA   0x4544             CMP      R4,R8
   \   000001FC   0xD1F1             BNE.N    ??BlackGetRightStep1Scan_18
   4533                          
   4534                      }
   4535                      
   4536                      //第一次scan
   4537                      if(CrossFlag == 1)
   \   000001FE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000200   0x2E01             CMP      R6,#+1
   \   00000202   0xD113             BNE.N    ??BlackGetRightStep1Scan_16
   4538                      {
   4539                        //把前3个大斜率检测储存值都去掉，后面2个不用，因为是对的。
   4540                        for(i = 0; i <= 2; i++)
   \   00000204   0x2400             MOVS     R4,#+0
   \   00000206   0xE00E             B.N      ??BlackGetRightStep1Scan_19
   4541                        {
   4542                            BlackRightBigChangeNumx[i] = MaxValUint8;
   \                     ??BlackGetRightStep1Scan_20: (+1)
   \   00000208   0x20FF             MOVS     R0,#+255
   \   0000020A   0x.... 0x....      LDR.W    R1,??DataTable31_1
   \   0000020E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000210   0x5460             STRB     R0,[R4, R1]
   4543                            BlackRightBigChangeNumy[i] = MaxValUint8;
   \   00000212   0x20FF             MOVS     R0,#+255
   \   00000214   0x.... 0x....      LDR.W    R1,??DataTable33_7
   \   00000218   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000021A   0x5460             STRB     R0,[R4, R1]
   4544                            BlackRightBigChangeJumpFlag = 0; //小细节。
   \   0000021C   0x2000             MOVS     R0,#+0
   \   0000021E   0x.... 0x....      LDR.W    R1,??DataTable34
   \   00000222   0x7008             STRB     R0,[R1, #+0]
   4545                        }
   \   00000224   0x1C64             ADDS     R4,R4,#+1
   \                     ??BlackGetRightStep1Scan_19: (+1)
   \   00000226   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000228   0x2C03             CMP      R4,#+3
   \   0000022A   0xDBED             BLT.N    ??BlackGetRightStep1Scan_20
   4546                      }
   4547                      else
   4548                      {
   4549                      }
   4550                      
   4551                  }
   4552                  else
   4553                  {
   4554          
   4555                  }
   4556                  
   4557                  return row;
   \                     ??BlackGetRightStep1Scan_16: (+1)
   \   0000022C   0x4640             MOV      R0,R8
   \   0000022E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??BlackGetRightStep1Scan_15: (+1)
   \   00000230   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   4558              }
   4559            
   4560          }
   4561          
   4562          
   4563          //======================================================================
   4564          //函数名：BlackRightCrossStep3
   4565          //功  能：右线提取中，十字检测第3阶段，脑补线函数
   4566          //参  数：第1段有效黑线的最后一行FirstLine， 第2段有效黑线的第一行LastLine
   4567          //返  回：1成功 0失败
   4568          //影  响：BlackRightLoc[][0]
   4569          //说  明：1. 这里有一些浮点运算，会占时间，在调用本函数时要慎重，尽量不要用。
   4570          //        2. 这里的两点间连线的思路很不错，float强转和uint8强转用得很好。
   4571          //             
   4572          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   4573          uint8 BlackRightCrossStep3(uint8 FirstLine, uint8 LastLine)
   4574          {
   \                     BlackRightCrossStep3: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   4575            int32 delta_x, delta_y, delta, index;
   4576            uint8 row, temp1, temp2;
   4577            uint8 i;
   4578            //uint8 temp3, temp4, flag1, flag2;
   4579            
   4580            //超始行比结束行还高，报错！
   4581            if(LastLine >= FirstLine)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xD301             BCC.N    ??BlackRightCrossStep3_0
   4582            {
   4583              //uart_sendN(UART0, (uint8 *)"\nError In BlackRightCrossStep3!", 31);
   4584              return 0;  
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE08F             B.N      ??BlackRightCrossStep3_1
   4585            }
   4586            
   4587            //有可能出现被大斜率检测删掉的情况，这种情况下该行黑线判断为错误，就不进行十字补线了。
   4588            if(BlackRightLoc[LastLine][0] == MaxValUint8)
   \                     ??BlackRightCrossStep3_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R2,??DataTable33
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x2303             MOVS     R3,#+3
   \   00000016   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   0000001A   0x7812             LDRB     R2,[R2, #+0]
   \   0000001C   0x2AFF             CMP      R2,#+255
   \   0000001E   0xD10F             BNE.N    ??BlackRightCrossStep3_2
   4589            {
   4590              //返回失败前扫屁股
   4591              for(i = FirstLine - 1; ; i--)
   \   00000020   0x1E40             SUBS     R0,R0,#+1
   \   00000022   0xE000             B.N      ??BlackRightCrossStep3_3
   \                     ??BlackRightCrossStep3_4: (+1)
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   4592              {
   4593                BlackRightLoc[i][0] = MaxValUint8;
   \                     ??BlackRightCrossStep3_3: (+1)
   \   00000026   0x21FF             MOVS     R1,#+255
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable33
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x2303             MOVS     R3,#+3
   \   00000030   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000034   0x7011             STRB     R1,[R2, #+0]
   4594                if(i == 0) break;
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD1F3             BNE.N    ??BlackRightCrossStep3_4
   4595              }
   4596              
   4597              return 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE076             B.N      ??BlackRightCrossStep3_1
   4598            }
   4599            else
   4600            {
   4601            }
   4602            
   4603            temp1 = BlackRightLoc[FirstLine][0];
   \                     ??BlackRightCrossStep3_2: (+1)
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable33
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x2303             MOVS     R3,#+3
   \   00000048   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000004C   0x7814             LDRB     R4,[R2, #+0]
   4604            temp2 = BlackRightLoc[LastLine][0];
   \   0000004E   0x.... 0x....      LDR.W    R2,??DataTable33
   \   00000052   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000054   0x2303             MOVS     R3,#+3
   \   00000056   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   0000005A   0x7812             LDRB     R2,[R2, #+0]
   4605            
   4606            /*
   4607            flag1 = 1;
   4608            flag2 = 1;
   4609            //确认这两个点是直角处的点，也就是往右6个点仍为黑点
   4610            if(temp1 <= (CameraRealWidth - 9))
   4611            {
   4612              temp3 = (
   4613                      (ImgNew[FirstLine+1][temp1+6] < LimitRightB)
   4614                    &&(ImgNew[FirstLine+1][temp1+7] < LimitRightB)
   4615                    &&(ImgNew[FirstLine+1][temp1+8] < LimitRightB)
   4616                    );
   4617              if(temp3)
   4618              {
   4619                flag1 = 0;  
   4620              }
   4621            }
   4622            
   4623            if(temp2 <= (CameraRealWidth - 9))
   4624            {
   4625              temp4 = (
   4626                      (ImgNew[LastLine-1][temp2+6] < LimitRightB)
   4627                    &&(ImgNew[LastLine-1][temp2+7] < LimitRightB)
   4628                    &&(ImgNew[LastLine-1][temp2+8] < LimitRightB)
   4629                    );
   4630              if(temp4)
   4631              {
   4632                flag2 = 0;  
   4633              }
   4634            }
   4635            
   4636            if((flag1 == 0) || (flag2 == 0))
   4637            {
   4638              return 0;  
   4639            }
   4640            
   4641            */
   4642            
   4643            delta_y = FirstLine - LastLine;
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000060   0x1A43             SUBS     R3,R0,R1
   4644            
   4645            
   4646            //斜率向右
   4647            if(temp1 < temp2)
   \   00000062   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000064   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000066   0x4294             CMP      R4,R2
   \   00000068   0xD226             BCS.N    ??BlackRightCrossStep3_5
   4648            {
   4649              //放大BlackRightCrossStep3Multi倍
   4650              delta_x = temp2 - temp1;
   \   0000006A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0x1B12             SUBS     R2,R2,R4
   4651              delta = delta_x * BlackRightCrossStep3Multi / delta_y; 
   \   00000070   0xF44F 0x747A      MOV      R4,#+1000
   \   00000074   0x4362             MULS     R2,R4,R2
   \   00000076   0xFB92 0xF3F3      SDIV     R3,R2,R3
   4652              
   4653              index = 1;
   \   0000007A   0x2401             MOVS     R4,#+1
   4654              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \   0000007C   0x1E42             SUBS     R2,R0,#+1
   \                     ??BlackRightCrossStep3_6: (+1)
   \   0000007E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000080   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000082   0x1C4D             ADDS     R5,R1,#+1
   \   00000084   0x42AA             CMP      R2,R5
   \   00000086   0xDB51             BLT.N    ??BlackRightCrossStep3_7
   4655              {
   4656                //每次右移一点点
   4657                BlackRightLoc[row][0] = (uint8)(BlackRightLoc[FirstLine][0] + delta * index / BlackRightCrossStep3Multi);
   \   00000088   0x.... 0x....      LDR.W    R5,??DataTable33
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0x2603             MOVS     R6,#+3
   \   00000090   0xFB06 0x5500      MLA      R5,R6,R0,R5
   \   00000094   0x782D             LDRB     R5,[R5, #+0]
   \   00000096   0xFB04 0xF603      MUL      R6,R4,R3
   \   0000009A   0xF44F 0x777A      MOV      R7,#+1000
   \   0000009E   0xFB96 0xF6F7      SDIV     R6,R6,R7
   \   000000A2   0x1975             ADDS     R5,R6,R5
   \   000000A4   0x.... 0x....      LDR.W    R6,??DataTable33
   \   000000A8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000AA   0x2703             MOVS     R7,#+3
   \   000000AC   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   000000B0   0x7035             STRB     R5,[R6, #+0]
   4658                index += 1;
   \   000000B2   0x1C64             ADDS     R4,R4,#+1
   4659              }
   \   000000B4   0x1E52             SUBS     R2,R2,#+1
   \   000000B6   0xE7E2             B.N      ??BlackRightCrossStep3_6
   4660            }
   4661            //斜率向左
   4662            else if(temp1 > temp2)
   \                     ??BlackRightCrossStep3_5: (+1)
   \   000000B8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000BA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BC   0x42A2             CMP      R2,R4
   \   000000BE   0xD226             BCS.N    ??BlackRightCrossStep3_8
   4663            {
   4664              //放大BlackRightCrossStep3Multi倍
   4665              delta_x = temp1 - temp2;
   \   000000C0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000C4   0x1AA2             SUBS     R2,R4,R2
   4666              delta = delta_x * BlackRightCrossStep3Multi / delta_y;
   \   000000C6   0xF44F 0x747A      MOV      R4,#+1000
   \   000000CA   0x4362             MULS     R2,R4,R2
   \   000000CC   0xFB92 0xF3F3      SDIV     R3,R2,R3
   4667              
   4668              index = 1;
   \   000000D0   0x2401             MOVS     R4,#+1
   4669              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \   000000D2   0x1E42             SUBS     R2,R0,#+1
   \                     ??BlackRightCrossStep3_9: (+1)
   \   000000D4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000D6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D8   0x1C4D             ADDS     R5,R1,#+1
   \   000000DA   0x42AA             CMP      R2,R5
   \   000000DC   0xDB26             BLT.N    ??BlackRightCrossStep3_7
   4670              {
   4671                //每次右移一点点
   4672                BlackRightLoc[row][0] = (uint8)(BlackRightLoc[FirstLine][0] - delta * index / BlackRightCrossStep3Multi);
   \   000000DE   0x.... 0x....      LDR.W    R5,??DataTable33
   \   000000E2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E4   0x2603             MOVS     R6,#+3
   \   000000E6   0xFB06 0x5500      MLA      R5,R6,R0,R5
   \   000000EA   0x782D             LDRB     R5,[R5, #+0]
   \   000000EC   0xFB04 0xF603      MUL      R6,R4,R3
   \   000000F0   0xF44F 0x777A      MOV      R7,#+1000
   \   000000F4   0xFB96 0xF6F7      SDIV     R6,R6,R7
   \   000000F8   0x1BAD             SUBS     R5,R5,R6
   \   000000FA   0x.... 0x....      LDR.W    R6,??DataTable33
   \   000000FE   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000100   0x2703             MOVS     R7,#+3
   \   00000102   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   00000106   0x7035             STRB     R5,[R6, #+0]
   4673                index += 1;
   \   00000108   0x1C64             ADDS     R4,R4,#+1
   4674              }
   \   0000010A   0x1E52             SUBS     R2,R2,#+1
   \   0000010C   0xE7E2             B.N      ??BlackRightCrossStep3_9
   4675            }
   4676            //斜率直走，这个不太可能出现
   4677            else
   4678            {
   4679              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \                     ??BlackRightCrossStep3_8: (+1)
   \   0000010E   0x1E42             SUBS     R2,R0,#+1
   \   00000110   0xE007             B.N      ??BlackRightCrossStep3_10
   4680              {
   4681                //赋相同的值
   4682                BlackRightLoc[row][0] = temp1;
   \                     ??BlackRightCrossStep3_11: (+1)
   \   00000112   0x.... 0x....      LDR.W    R0,??DataTable33
   \   00000116   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000118   0x2303             MOVS     R3,#+3
   \   0000011A   0xFB03 0x0002      MLA      R0,R3,R2,R0
   \   0000011E   0x7004             STRB     R4,[R0, #+0]
   4683              }
   \   00000120   0x1E52             SUBS     R2,R2,#+1
   \                     ??BlackRightCrossStep3_10: (+1)
   \   00000122   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000124   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000126   0x1C48             ADDS     R0,R1,#+1
   \   00000128   0x4282             CMP      R2,R0
   \   0000012A   0xDAF2             BGE.N    ??BlackRightCrossStep3_11
   4684            }
   4685            
   4686            return 1;
   \                     ??BlackRightCrossStep3_7: (+1)
   \   0000012C   0x2001             MOVS     R0,#+1
   \                     ??BlackRightCrossStep3_1: (+1)
   \   0000012E   0xBCF0             POP      {R4-R7}
   \   00000130   0x4770             BX       LR               ;; return
   4687              
   4688          }
   4689          
   4690          //======================================================================
   4691          //函数名：BlackRightCrossConfirm
   4692          //功  能：十字再检测时 ，线头有效性的确认。
   4693          //参  数：第1段黑线的真实结束行Row1RealLastLine，第2段黑线的真实起始行Row2RealFirstLine
   4694          //返  回：1成功 0失败
   4695          //影  响：无
   4696          //说  明：1. 为了应对270度弯道十字误检测而诞生，编写过程中没有过多考虑其它情况。
   4697          //      
   4698          //             
   4699          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   4700          uint8 BlackRightCrossConfirm(uint8 Row1RealLastLine, uint8 Row2RealFirstLine)
   4701          {
   \                     BlackRightCrossConfirm: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x000C             MOVS     R4,R1
   4702            uint8 row, index;
   4703            uint8 x[BlackCrossConfirmNum];
   4704            uint8 y[BlackCrossConfirmNum];
   4705            
   4706            int32 a0, a1, temp;
   4707            
   4708            //1. 先进行第二段黑线起始点方向判定，若不满足右十字该有方向，则判定为错误点。直接返回0.
   4709            if(BlackRightLoc[Row2RealFirstLine][0] < BlackRightLoc[Row2RealFirstLine-1][0]) 
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable33
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2203             MOVS     R2,#+3
   \   0000000E   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000012   0x7809             LDRB     R1,[R1, #+0]
   \   00000014   0x.... 0x....      LDR.W    R2,??DataTable33
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2303             MOVS     R3,#+3
   \   0000001C   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   00000020   0xF812 0x2C03      LDRB     R2,[R2, #-3]
   \   00000024   0x4291             CMP      R1,R2
   \   00000026   0xD201             BCS.N    ??BlackRightCrossConfirm_0
   4710            {
   4711              return 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE0A3             B.N      ??BlackRightCrossConfirm_1
   4712            }
   4713            //2. 再进行第二段黑线起始两点的斜率判定，也就是对两点的列差作限定，太大则有可能是大弯回弯。针对回弯十字误补。
   4714            else if((BlackRightLoc[Row2RealFirstLine][0] > BlackRightLoc[Row2RealFirstLine-1][0])
   4715             &&(BlackRightLoc[Row2RealFirstLine][0] - BlackRightLoc[Row2RealFirstLine-1][0] >= 3)
   4716              )
   \                     ??BlackRightCrossConfirm_0: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable33
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x2203             MOVS     R2,#+3
   \   00000034   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000038   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   0000003C   0x.... 0x....      LDR.W    R2,??DataTable33
   \   00000040   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000042   0x2303             MOVS     R3,#+3
   \   00000044   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   00000048   0x7812             LDRB     R2,[R2, #+0]
   \   0000004A   0x4291             CMP      R1,R2
   \   0000004C   0xD213             BCS.N    ??BlackRightCrossConfirm_2
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable33
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x2203             MOVS     R2,#+3
   \   00000056   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000005A   0x7809             LDRB     R1,[R1, #+0]
   \   0000005C   0x.... 0x....      LDR.W    R2,??DataTable33
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0x2303             MOVS     R3,#+3
   \   00000064   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   00000068   0xF812 0x2C03      LDRB     R2,[R2, #-3]
   \   0000006C   0x1A89             SUBS     R1,R1,R2
   \   0000006E   0x2903             CMP      R1,#+3
   \   00000070   0xDB01             BLT.N    ??BlackRightCrossConfirm_2
   4717            {
   4718              return 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xE07E             B.N      ??BlackRightCrossConfirm_1
   4719            }
   4720            //3. 再对上一幅图的左线斜率和左线头进行检查。这里的左线斜率与左线头因为还没更新，所以是上一幅图的。针对回弯十字误补。
   4721            else if((SlopeL + BlackCrossConfirmSlopeLimit < 0) //上一幅图的左线斜率很大。
   4722             &&(BlackLeftHeadLine < BlackCrossConfirmHeadLineLimit) //上一幅图的左线线头比较高。（防止因为线特别短而造成的斜率不准确）
   4723               )
   \                     ??BlackRightCrossConfirm_2: (+1)
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable34_1
   \   0000007A   0x6809             LDR      R1,[R1, #+0]
   \   0000007C   0xF601 0x31B8      ADDW     R1,R1,#+3000
   \   00000080   0x2900             CMP      R1,#+0
   \   00000082   0xD506             BPL.N    ??BlackRightCrossConfirm_3
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable34_2
   \   00000088   0x7809             LDRB     R1,[R1, #+0]
   \   0000008A   0x2928             CMP      R1,#+40
   \   0000008C   0xDA01             BGE.N    ??BlackRightCrossConfirm_3
   4724            {
   4725              return 0;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xE070             B.N      ??BlackRightCrossConfirm_1
   4726            }
   4727            else
   4728            {
   4729            }
   4730            
   4731            //第一段黑线太短，无法检测正确性时，检查要补的行是不是够长，如果够长，就视为正确。
   4732            //if(Row1RealLastLine >= CameraHight - 5 && Row2RealFirstLine > Row1RealLastLine + BlackRightCrossConfirmGapLine) return 1;
   4733            //if(Row1RealLastLine >= CameraHight - 5) return 0;
   4734            
   4735            //以左上角为原点，向下为x轴正方向（0~49），向右为y轴正方向(0~249)
   4736            index = 0;
   \                     ??BlackRightCrossConfirm_3: (+1)
   \   00000092   0x2100             MOVS     R1,#+0
   4737            for(row = Row1RealLastLine; ; row++)
   \   00000094   0xE000             B.N      ??BlackRightCrossConfirm_4
   \                     ??BlackRightCrossConfirm_5: (+1)
   \   00000096   0x1C40             ADDS     R0,R0,#+1
   4738            {
   4739              //有效行的记录
   4740              if(BlackRightLoc[row][0] != MaxValUint8)
   \                     ??BlackRightCrossConfirm_4: (+1)
   \   00000098   0x.... 0x....      LDR.W    R2,??DataTable33
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0x2303             MOVS     R3,#+3
   \   000000A0   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000A4   0x7812             LDRB     R2,[R2, #+0]
   \   000000A6   0x2AFF             CMP      R2,#+255
   \   000000A8   0xD00D             BEQ.N    ??BlackRightCrossConfirm_6
   4741              {
   4742                y[index] = BlackRightLoc[row][0];
   \   000000AA   0x.... 0x....      LDR.W    R2,??DataTable33
   \   000000AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B0   0x2303             MOVS     R3,#+3
   \   000000B2   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000B6   0x7812             LDRB     R2,[R2, #+0]
   \   000000B8   0xAB00             ADD      R3,SP,#+0
   \   000000BA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000BC   0x54CA             STRB     R2,[R1, R3]
   4743                x[index] = row;
   \   000000BE   0xAA01             ADD      R2,SP,#+4
   \   000000C0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C2   0x5488             STRB     R0,[R1, R2]
   4744                index++;
   \   000000C4   0x1C49             ADDS     R1,R1,#+1
   4745              }
   4746              //点数够多，则跳出。
   4747              if(index == BlackCrossConfirmNum) break;
   \                     ??BlackRightCrossConfirm_6: (+1)
   \   000000C6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C8   0x2904             CMP      R1,#+4
   \   000000CA   0xD10B             BNE.N    ??BlackRightCrossConfirm_7
   4748              //直到最低行仍没有凑够足够的点数，说明第一段有效黑线太短.
   4749              if(row == CameraHight - 1) 
   4750              {
   4751                if(index == 0) return 0;
   4752                //判断第二段黑点起点是不是在第一段黑点末尾的左边一定范围内
   4753                if(BlackRightLoc[Row2RealFirstLine][0] < y[0] && y[0] - BlackRightLoc[Row2RealFirstLine][0] < 50)
   4754                {
   4755                  return 1;
   4756                }
   4757                else
   4758                {
   4759                  return 0;
   4760                }      
   4761              }
   4762              else
   4763              {
   4764              }
   4765            }
   4766            
   4767            //最小二乘法
   4768            //y = a0 + a1 * x
   4769            a1 = LeastSquarea1(x, y, BlackCrossConfirmNum);
   \   000000CC   0x2204             MOVS     R2,#+4
   \   000000CE   0xA900             ADD      R1,SP,#+0
   \   000000D0   0xA801             ADD      R0,SP,#+4
   \   000000D2   0x.... 0x....      BL       LeastSquarea1
   \   000000D6   0x0005             MOVS     R5,R0
   4770            
   4771            //判断斜率是不是从左下到右上，如果是，则返回失败。
   4772            if(a1 + BlackRightCrossConfirmSlopeLimit < 0) return 0;
   \   000000D8   0xF205 0x404C      ADDW     R0,R5,#+1100
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD524             BPL.N    ??BlackRightCrossConfirm_8
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0xE047             B.N      ??BlackRightCrossConfirm_1
   \                     ??BlackRightCrossConfirm_7: (+1)
   \   000000E4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E6   0x283B             CMP      R0,#+59
   \   000000E8   0xD1D5             BNE.N    ??BlackRightCrossConfirm_5
   \   000000EA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000EC   0x2900             CMP      R1,#+0
   \   000000EE   0xD101             BNE.N    ??BlackRightCrossConfirm_9
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0xE03F             B.N      ??BlackRightCrossConfirm_1
   \                     ??BlackRightCrossConfirm_9: (+1)
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable33
   \   000000F8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FA   0x2103             MOVS     R1,#+3
   \   000000FC   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000100   0x7800             LDRB     R0,[R0, #+0]
   \   00000102   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   00000106   0x4288             CMP      R0,R1
   \   00000108   0xD20D             BCS.N    ??BlackRightCrossConfirm_10
   \   0000010A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable33
   \   00000112   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000114   0x2203             MOVS     R2,#+3
   \   00000116   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000011A   0x7809             LDRB     R1,[R1, #+0]
   \   0000011C   0x1A40             SUBS     R0,R0,R1
   \   0000011E   0x2832             CMP      R0,#+50
   \   00000120   0xDA01             BGE.N    ??BlackRightCrossConfirm_10
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0xE026             B.N      ??BlackRightCrossConfirm_1
   \                     ??BlackRightCrossConfirm_10: (+1)
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0xE024             B.N      ??BlackRightCrossConfirm_1
   4773            
   4774            a0 = LeastSquarea0(x, y, a1, BlackCrossConfirmNum);
   \                     ??BlackRightCrossConfirm_8: (+1)
   \   0000012A   0x2304             MOVS     R3,#+4
   \   0000012C   0x002A             MOVS     R2,R5
   \   0000012E   0xA900             ADD      R1,SP,#+0
   \   00000130   0xA801             ADD      R0,SP,#+4
   \   00000132   0x.... 0x....      BL       LeastSquarea0
   4775            
   4776            //temp为第2段黑线起始行本应该在的位置。
   4777            temp = (a0 + a1 * Row2RealFirstLine) / LeastSquareMulti;
   \   00000136   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000138   0xFB04 0x0005      MLA      R0,R4,R5,R0
   \   0000013C   0xF44F 0x717A      MOV      R1,#+1000
   \   00000140   0xFB90 0xF0F1      SDIV     R0,R0,R1
   4778          
   4779            //把这个点限定在窗内
   4780            if(
   4781              (BlackRightLoc[Row2RealFirstLine][0] > temp - BlackCrossConfirmWin)  //向左的值太大的话，会在“下双上单”的时候出现十字误补线。
   4782            &&(BlackRightLoc[Row2RealFirstLine][0] < temp + BlackCrossConfirmWin)  
   4783              )
   \   00000144   0xF1B0 0x0128      SUBS     R1,R0,#+40
   \   00000148   0x.... 0x....      LDR.W    R2,??DataTable33
   \   0000014C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000014E   0x2303             MOVS     R3,#+3
   \   00000150   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   00000154   0x7812             LDRB     R2,[R2, #+0]
   \   00000156   0x4291             CMP      R1,R2
   \   00000158   0xDA0B             BGE.N    ??BlackRightCrossConfirm_11
   \   0000015A   0x.... 0x....      LDR.W    R1,??DataTable33
   \   0000015E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000160   0x2203             MOVS     R2,#+3
   \   00000162   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000166   0x7809             LDRB     R1,[R1, #+0]
   \   00000168   0x3028             ADDS     R0,R0,#+40
   \   0000016A   0x4281             CMP      R1,R0
   \   0000016C   0xDA01             BGE.N    ??BlackRightCrossConfirm_11
   4784            {
   4785              return 1;
   \   0000016E   0x2001             MOVS     R0,#+1
   \   00000170   0xE000             B.N      ??BlackRightCrossConfirm_1
   4786            }
   4787            else
   4788            {
   4789              return 0;
   \                     ??BlackRightCrossConfirm_11: (+1)
   \   00000172   0x2000             MOVS     R0,#+0
   \                     ??BlackRightCrossConfirm_1: (+1)
   \   00000174   0xBD3E             POP      {R1-R5,PC}       ;; return
   4790            }
   4791              
   4792            
   4793          }
   4794          
   4795          
   4796          
   4797          //======================================================================
   4798          //函数名：BlackGetRightCrossSpeWin
   4799          //功  能：右黑线十字再检测时，窗口的特殊扫描
   4800          //参  数：待处理行号row, 窗口左边界colleft, 窗口右边界colright, 第几次使用use.
   4801          //返  回：1成功  0失败
   4802          //影  响：BlackRightLoc[][0]
   4803          //说  明：1. 满足两批条件，才能检测成功。只有一个点的记录。
   4804          //        2. 窗口内没有检测到，则检测失败。
   4805          //        3. 跟普通窗口扫描不一样，前者输入变量是预测值和窗口大小，后者是左右边界。  
   4806          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   4807          uint8 BlackGetRightCrossSpeWin(uint8 row, uint8 colleft, uint8 colright, uint8 use)
   4808          {
   \                     BlackGetRightCrossSpeWin: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0008             MOVS     R0,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001D             MOVS     R5,R3
   4809            uint8 col;
   4810          
   4811            //在规划好的窗口内，从左往右查找跳变沿
   4812            //防止溢出
   4813            //对右边界的限制 
   4814            if(colright >= (CameraRealWidth - 5 - BlackRightEdgeNum)) 
   \   0000000A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000000C   0x2EF2             CMP      R6,#+242
   \   0000000E   0xDB00             BLT.N    ??BlackGetRightCrossSpeWin_0
   4815            {
   4816              colright = CameraRealWidth - 5 - BlackRightEdgeNum;
   \   00000010   0x26F2             MOVS     R6,#+242
   4817            }  
   4818            else
   4819            {
   4820            }
   4821            
   4822            //左线开始扫描时，若该幅图像没有单线，则右线扫描的左边界必须在该行有效左黑线的右边。
   4823            if((BlackGetPreDir == 0 || BlackGetPreDir == 2)
   4824             &&(SingleBlackAllFlag == 0)
   4825             &&(BlackLeftLoc[row][0] != MaxValUint8)
   4826               )
   \                     ??BlackGetRightCrossSpeWin_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable34_3
   \   00000016   0x7809             LDRB     R1,[R1, #+0]
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD004             BEQ.N    ??BlackGetRightCrossSpeWin_1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable34_3
   \   00000020   0x7809             LDRB     R1,[R1, #+0]
   \   00000022   0x2902             CMP      R1,#+2
   \   00000024   0xD116             BNE.N    ??BlackGetRightCrossSpeWin_2
   \                     ??BlackGetRightCrossSpeWin_1: (+1)
   \   00000026   0x....             LDR.N    R1,??DataTable31
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD112             BNE.N    ??BlackGetRightCrossSpeWin_2
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable34_4
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0x2203             MOVS     R2,#+3
   \   00000036   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000003A   0x7809             LDRB     R1,[R1, #+0]
   \   0000003C   0x29FF             CMP      R1,#+255
   \   0000003E   0xD009             BEQ.N    ??BlackGetRightCrossSpeWin_2
   4827            {
   4828              colleft = MaxRe(colleft, BlackLeftLoc[row][0]);
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable34_4
   \   00000044   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000046   0x2203             MOVS     R2,#+3
   \   00000048   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000004C   0x7809             LDRB     R1,[R1, #+0]
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x.... 0x....      BL       MaxRe
   4829            }
   4830            else
   4831            {
   4832            }
   4833            
   4834            //窗口预测值记录
   4835            BlackRightPredictL[row] = colleft;
   \                     ??BlackGetRightCrossSpeWin_2: (+1)
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable34_5
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0x5460             STRB     R0,[R4, R1]
   4836            BlackRightPredictR[row] = colright;
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable34_6
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0x5466             STRB     R6,[R4, R1]
   4837            
   4838            //若左边界在右边界右边，直接返回失败。
   4839            if(colleft >= colright) return 0;
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000068   0x42B0             CMP      R0,R6
   \   0000006A   0xD301             BCC.N    ??BlackGetRightCrossSpeWin_3
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE090             B.N      ??BlackGetRightCrossSpeWin_4
   4840            
   4841            //开窗扫描跳变沿
   4842            col = BlackGetRightJustWin(row, colleft, colright);
   \                     ??BlackGetRightCrossSpeWin_3: (+1)
   \   00000070   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000072   0x0032             MOVS     R2,R6
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0x0001             MOVS     R1,R0
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0x.... 0x....      BL       BlackGetRightJustWin
   \   00000080   0x0006             MOVS     R6,R0
   4843            if(col != MaxValUint8)
   \   00000082   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000084   0x2EFF             CMP      R6,#+255
   \   00000086   0xD07B             BEQ.N    ??BlackGetRightCrossSpeWin_5
   4844            {
   4845              //两批条件均满足，直接记录该点为黑线，返回即可
   4846              BlackRightLoc[row][0] = col + 1 + BlackRightEdgeNum;
   \   00000088   0x1D30             ADDS     R0,R6,#+4
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable33
   \   0000008E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000090   0x2203             MOVS     R2,#+3
   \   00000092   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000096   0x7008             STRB     R0,[R1, #+0]
   4847              
   4848              //最终确认前，需要对大斜率进行检测。
   4849              if(BlackRightBigChangeCheck(row, use) == 0)
   \   00000098   0x0029             MOVS     R1,R5
   \   0000009A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009C   0x0020             MOVS     R0,R4
   \   0000009E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A0   0x.... 0x....      BL       BlackRightBigChangeCheck
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD110             BNE.N    ??BlackGetRightCrossSpeWin_6
   4850              {
   4851                //没通过大跳变检测。
   4852                BlackRightBigChangeCheckRow[row] = 1;
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0x....             LDR.N    R1,??DataTable32_2
   \   000000AC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AE   0x5460             STRB     R0,[R4, R1]
   4853                BlackRightBigChangeCheckAllRow = 1;             
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0x....             LDR.N    R1,??DataTable32_3
   \   000000B4   0x7008             STRB     R0,[R1, #+0]
   4854                
   4855                BlackRightLoc[row][0] = MaxValUint8;
   \   000000B6   0x20FF             MOVS     R0,#+255
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable33
   \   000000BC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BE   0x2203             MOVS     R2,#+3
   \   000000C0   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000C4   0x7008             STRB     R0,[R1, #+0]
   4856                return 0;
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xE063             B.N      ??BlackGetRightCrossSpeWin_4
   4857              }
   4858              else
   4859              {
   4860              }
   4861              
   4862              //记录3个关键值的实际信息，作为后面的参考。
   4863              if(use == 1)
   \                     ??BlackGetRightCrossSpeWin_6: (+1)
   \   000000CA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CC   0x2D01             CMP      R5,#+1
   \   000000CE   0xD129             BNE.N    ??BlackGetRightCrossSpeWin_7
   4864              {
   4865                BlackRightRealWB[0] = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum]; 
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable34_7
   \   000000D4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D6   0x21FA             MOVS     R1,#+250
   \   000000D8   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000DC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000DE   0x5C30             LDRB     R0,[R6, R0]
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable34_7
   \   000000E4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E6   0x22FA             MOVS     R2,#+250
   \   000000E8   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000EC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000EE   0x1871             ADDS     R1,R6,R1
   \   000000F0   0x7909             LDRB     R1,[R1, #+4]
   \   000000F2   0x1A40             SUBS     R0,R0,R1
   \   000000F4   0x....             LDR.N    R1,??DataTable32_4
   \   000000F6   0x7008             STRB     R0,[R1, #+0]
   4866                BlackRightRealW[0] = ImgNew[row][col];
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable34_7
   \   000000FC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FE   0x21FA             MOVS     R1,#+250
   \   00000100   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000104   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000106   0x5C30             LDRB     R0,[R6, R0]
   \   00000108   0x....             LDR.N    R1,??DataTable32_5
   \   0000010A   0x7008             STRB     R0,[R1, #+0]
   4867                BlackRightRealB[0] = ImgNew[row][col+1+BlackRightEdgeNum];
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable34_7
   \   00000110   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000112   0x21FA             MOVS     R1,#+250
   \   00000114   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000118   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000011A   0x1830             ADDS     R0,R6,R0
   \   0000011C   0x7900             LDRB     R0,[R0, #+4]
   \   0000011E   0x....             LDR.N    R1,??DataTable32_1
   \   00000120   0x7008             STRB     R0,[R1, #+0]
   \   00000122   0xE02B             B.N      ??BlackGetRightCrossSpeWin_8
   4868              }
   4869              else if(use == 2)
   \                     ??BlackGetRightCrossSpeWin_7: (+1)
   \   00000124   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000126   0x2D02             CMP      R5,#+2
   \   00000128   0xD128             BNE.N    ??BlackGetRightCrossSpeWin_8
   4870              {
   4871                BlackRightRealWB[1] = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum]; 
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable34_7
   \   0000012E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000130   0x21FA             MOVS     R1,#+250
   \   00000132   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000136   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000138   0x5C30             LDRB     R0,[R6, R0]
   \   0000013A   0x.... 0x....      LDR.W    R1,??DataTable34_7
   \   0000013E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000140   0x22FA             MOVS     R2,#+250
   \   00000142   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000146   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000148   0x1871             ADDS     R1,R6,R1
   \   0000014A   0x7909             LDRB     R1,[R1, #+4]
   \   0000014C   0x1A40             SUBS     R0,R0,R1
   \   0000014E   0x....             LDR.N    R1,??DataTable32_4
   \   00000150   0x7048             STRB     R0,[R1, #+1]
   4872                BlackRightRealW[1] = ImgNew[row][col];
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable34_7
   \   00000156   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000158   0x21FA             MOVS     R1,#+250
   \   0000015A   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000015E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000160   0x5C30             LDRB     R0,[R6, R0]
   \   00000162   0x....             LDR.N    R1,??DataTable32_5
   \   00000164   0x7048             STRB     R0,[R1, #+1]
   4873                BlackRightRealB[1] = ImgNew[row][col+1+BlackRightEdgeNum];
   \   00000166   0x.... 0x....      LDR.W    R0,??DataTable34_7
   \   0000016A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000016C   0x21FA             MOVS     R1,#+250
   \   0000016E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000172   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000174   0x1830             ADDS     R0,R6,R0
   \   00000176   0x7900             LDRB     R0,[R0, #+4]
   \   00000178   0x....             LDR.N    R1,??DataTable32_1
   \   0000017A   0x7048             STRB     R0,[R1, #+1]
   4874              }
   4875              else
   4876              {
   4877              }
   4878                
   4879              return 1;
   \                     ??BlackGetRightCrossSpeWin_8: (+1)
   \   0000017C   0x2001             MOVS     R0,#+1
   \   0000017E   0xE008             B.N      ??BlackGetRightCrossSpeWin_4
   4880            }
   4881            else
   4882            {
   4883              //窗口内没有检测到跳变沿，该行黑线置无效值，返回0失败。
   4884              BlackRightLoc[row][0] = MaxValUint8;
   \                     ??BlackGetRightCrossSpeWin_5: (+1)
   \   00000180   0x20FF             MOVS     R0,#+255
   \   00000182   0x.... 0x....      LDR.W    R1,??DataTable33
   \   00000186   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000188   0x2203             MOVS     R2,#+3
   \   0000018A   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000018E   0x7008             STRB     R0,[R1, #+0]
   4885              return 0;   
   \   00000190   0x2000             MOVS     R0,#+0
   \                     ??BlackGetRightCrossSpeWin_4: (+1)
   \   00000192   0xBD70             POP      {R4-R6,PC}       ;; return
   4886            }
   4887          
   4888          }
   4889          
   4890          
   4891          
   4892          //======================================================================
   4893          //函数名：BlackGetRightCrossSpeScan
   4894          //功  能：十字再检测时，右线头的特殊扫描
   4895          //参  数：第2段黑线的预测起始行Row2FirstLine， 第2段黑线的预测结束行Row2LastLine，
   4896          //        最近一次的窗口预测值LastWinPredict
   4897          //返  回：MaxValUint8失败，否则成功。
   4898          //影  响：
   4899          //说  明：
   4900          //      
   4901          //             
   4902          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   4903          uint8 BlackGetRightCrossSpeScan(uint8 Row2FirstLine, uint8 Row2LastLine, uint8 LastWinPredict)
   4904          {
   \                     BlackGetRightCrossSpeScan: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0010             MOVS     R0,R2
   4905            uint8 row;
   4906            uint8 temp1, temp2, temppredict, tempminus;
   4907            uint8 colleft, colright;
   4908            uint8 i;
   4909            
   4910            //最近一次的窗口预测值。
   4911            temppredict = LastWinPredict;
   4912            
   4913            //colright的确定
   4914            //对于右黑线扫描，colright表示之前所有有效右黑线的最右点。
   4915            //找第1个有效右黑线。
   4916            for(i = Row2FirstLine+1; ; i++)
   \   0000000A   0x1C61             ADDS     R1,R4,#+1
   \   0000000C   0xE000             B.N      ??BlackGetRightCrossSpeScan_0
   \                     ??BlackGetRightCrossSpeScan_1: (+1)
   \   0000000E   0x1C49             ADDS     R1,R1,#+1
   4917            {
   4918              if(BlackRightLoc[i][0] != MaxValUint8)
   \                     ??BlackGetRightCrossSpeScan_0: (+1)
   \   00000010   0x.... 0x....      LDR.W    R2,??DataTable33
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x2303             MOVS     R3,#+3
   \   00000018   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   0000001C   0x7812             LDRB     R2,[R2, #+0]
   \   0000001E   0x2AFF             CMP      R2,#+255
   \   00000020   0xD007             BEQ.N    ??BlackGetRightCrossSpeScan_2
   4919              {
   4920                colright = BlackRightLoc[i][0];
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable33
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0x2303             MOVS     R3,#+3
   \   0000002A   0xFB03 0x2101      MLA      R1,R3,R1,R2
   \   0000002E   0x780E             LDRB     R6,[R1, #+0]
   4921                break;
   4922              }
   4923              else
   4924              {
   4925              }
   4926              //若一直到最近一行仍没有有效左黑线，则返回失败。理论上不可能走到这里。
   4927              if(i == CameraHight - 1) return MaxValUint8;
   4928            }
   4929            //暂时不用最右边的左黑线，也就相当于用最左边的左黑线。
   4930          //  //找最右的有效右黑线。
   4931          //  for( ; ; i++)
   4932          //  {
   4933          //    if(BlackRightLoc[i][0] != MaxValUint8)
   4934          //    {
   4935          //      if(BlackRightLoc[i][0] > colright)
   4936          //      {
   4937          //        colright = BlackRightLoc[i][0];
   4938          //      }
   4939          //      else
   4940          //      {
   4941          //      }
   4942          //    }
   4943          //    else
   4944          //    {
   4945          //    }
   4946          //    
   4947          //    if(i == CameraHight - 1) break;
   4948          //  }
   4949            
   4950            for(row = Row2FirstLine; ; row -= 2)
   \   00000030   0xE005             B.N      ??BlackGetRightCrossSpeScan_3
   \                     ??BlackGetRightCrossSpeScan_2: (+1)
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0x293B             CMP      R1,#+59
   \   00000036   0xD1EA             BNE.N    ??BlackGetRightCrossSpeScan_1
   \   00000038   0x20FF             MOVS     R0,#+255
   \   0000003A   0xE089             B.N      ??BlackGetRightCrossSpeScan_4
   \                     ??BlackGetRightCrossSpeScan_5: (+1)
   \   0000003C   0x1EA4             SUBS     R4,R4,#+2
   4951            {
   4952              //colleft的确定
   4953              colleft = BoundaryLimitRe(temppredict - BlackRightWinVal * 2,
   4954                                        0,
   4955                                        CameraRealWidth - 1); 
   \                     ??BlackGetRightCrossSpeScan_3: (+1)
   \   0000003E   0x22F9             MOVS     R2,#+249
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x381E             SUBS     R0,R0,#+30
   \   00000046   0x.... 0x....      BL       BoundaryLimitRe
   \   0000004A   0x4680             MOV      R8,R0
   4956              //为了防止窗口有错，所以最右边不得大于BlackRightEdgeStartColOffset。
   4957              colleft = MinRe(colleft, CameraRealWidth / 2 - 1 - BlackRightEdgeStartColOffset[row]);
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable36
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0x5C20             LDRB     R0,[R4, R0]
   \   00000054   0xF1D0 0x017C      RSBS     R1,R0,#+124
   \   00000058   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000005C   0x4640             MOV      R0,R8
   \   0000005E   0x.... 0x....      BL       MinRe
   \   00000062   0x4680             MOV      R8,R0
   4958              
   4959              //连续2行检测黑点。
   4960              temp1 = BlackGetRightCrossSpeWin(row, colleft, colright, 1);
   \   00000064   0x2301             MOVS     R3,#+1
   \   00000066   0x0032             MOVS     R2,R6
   \   00000068   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006A   0x4641             MOV      R1,R8
   \   0000006C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0x.... 0x....      BL       BlackGetRightCrossSpeWin
   \   00000076   0x0007             MOVS     R7,R0
   4961              temp2 = BlackGetRightCrossSpeWin(row-1, colleft, colright, 2);
   \   00000078   0x2302             MOVS     R3,#+2
   \   0000007A   0x0032             MOVS     R2,R6
   \   0000007C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000007E   0x4641             MOV      R1,R8
   \   00000080   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000082   0x1E60             SUBS     R0,R4,#+1
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0x.... 0x....      BL       BlackGetRightCrossSpeWin
   4962              //连续2行开窗检测黑点成功，则线头检测成功。跳出。
   4963              if(temp1 == 1 && temp2 == 1)
   \   0000008A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000008C   0x2F01             CMP      R7,#+1
   \   0000008E   0xD105             BNE.N    ??BlackGetRightCrossSpeScan_6
   \   00000090   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000092   0x2801             CMP      R0,#+1
   \   00000094   0xD102             BNE.N    ??BlackGetRightCrossSpeScan_6
   4964              {
   4965                return row;
   \   00000096   0x0020             MOVS     R0,R4
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009A   0xE059             B.N      ??BlackGetRightCrossSpeScan_4
   4966              }
   4967              //连续2行开窗检测黑线失败，则窗口预测点继续变化，继续开窗检测。
   4968              else if(temp1 == 0 && temp2 == 0)
   \                     ??BlackGetRightCrossSpeScan_6: (+1)
   \   0000009C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000009E   0x2F00             CMP      R7,#+0
   \   000000A0   0xD121             BNE.N    ??BlackGetRightCrossSpeScan_7
   \   000000A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD11E             BNE.N    ??BlackGetRightCrossSpeScan_7
   4969              {
   4970                //预测点按趋势走也要限幅。
   4971                tempminus = BoundaryLimitRe(BlackRightWinPredictStore2 + BlackRightWinPredictStore2 - BlackRightWinPredictStore1,
   4972                                            0,
   4973                                            CameraRealWidth - 1);
   \   000000A8   0x22F9             MOVS     R2,#+249
   \   000000AA   0x2100             MOVS     R1,#+0
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable38
   \   000000B0   0x7800             LDRB     R0,[R0, #+0]
   \   000000B2   0x.... 0x....      LDR.W    R3,??DataTable38
   \   000000B6   0x781B             LDRB     R3,[R3, #+0]
   \   000000B8   0x1818             ADDS     R0,R3,R0
   \   000000BA   0x.... 0x....      LDR.W    R3,??DataTable37
   \   000000BE   0x781B             LDRB     R3,[R3, #+0]
   \   000000C0   0x1AC0             SUBS     R0,R0,R3
   \   000000C2   0x.... 0x....      BL       BoundaryLimitRe
   4974                //temp在这里表示窗口预测点位置。
   4975                temppredict = tempminus;
   4976                BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable37
   \   000000CA   0x7809             LDRB     R1,[R1, #+0]
   \   000000CC   0x.... 0x....      LDR.W    R2,??DataTable37_1
   \   000000D0   0x7011             STRB     R1,[R2, #+0]
   4977                BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable38
   \   000000D6   0x7809             LDRB     R1,[R1, #+0]
   \   000000D8   0x.... 0x....      LDR.W    R2,??DataTable37
   \   000000DC   0x7011             STRB     R1,[R2, #+0]
   4978                BlackRightWinPredictStore2 = temppredict;      
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable38
   \   000000E2   0x7008             STRB     R0,[R1, #+0]
   \   000000E4   0xE02E             B.N      ??BlackGetRightCrossSpeScan_8
   4979              }
   4980              //其中一行开窗检测成功，则当作干扰点，窗口预测点继续变化，继续开窗检测。
   4981              else
   4982              {
   4983                //当作干扰点滤掉。
   4984                BlackRightLoc[row][0] = MaxValUint8;
   \                     ??BlackGetRightCrossSpeScan_7: (+1)
   \   000000E6   0x20FF             MOVS     R0,#+255
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable33
   \   000000EC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EE   0x2203             MOVS     R2,#+3
   \   000000F0   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000000F4   0x7008             STRB     R0,[R1, #+0]
   4985                BlackRightLoc[row-1][0] = MaxValUint8;
   \   000000F6   0x20FF             MOVS     R0,#+255
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable33
   \   000000FC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FE   0x2203             MOVS     R2,#+3
   \   00000100   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000104   0xF801 0x0C03      STRB     R0,[R1, #-3]
   4986                
   4987                //预测点按趋势走也要限幅。
   4988                tempminus = BoundaryLimitRe(BlackRightWinPredictStore2 + BlackRightWinPredictStore2 - BlackRightWinPredictStore1,
   4989                                            0,
   4990                                            CameraRealWidth - 1);
   \   00000108   0x22F9             MOVS     R2,#+249
   \   0000010A   0x2100             MOVS     R1,#+0
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable38
   \   00000110   0x7800             LDRB     R0,[R0, #+0]
   \   00000112   0x.... 0x....      LDR.W    R3,??DataTable38
   \   00000116   0x781B             LDRB     R3,[R3, #+0]
   \   00000118   0x1818             ADDS     R0,R3,R0
   \   0000011A   0x.... 0x....      LDR.W    R3,??DataTable37
   \   0000011E   0x781B             LDRB     R3,[R3, #+0]
   \   00000120   0x1AC0             SUBS     R0,R0,R3
   \   00000122   0x.... 0x....      BL       BoundaryLimitRe
   4991                //temp在这里表示窗口预测点位置。
   4992                temppredict = tempminus;
   4993                BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
   \   00000126   0x.... 0x....      LDR.W    R1,??DataTable37
   \   0000012A   0x7809             LDRB     R1,[R1, #+0]
   \   0000012C   0x.... 0x....      LDR.W    R2,??DataTable37_1
   \   00000130   0x7011             STRB     R1,[R2, #+0]
   4994                BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable38
   \   00000136   0x7809             LDRB     R1,[R1, #+0]
   \   00000138   0x.... 0x....      LDR.W    R2,??DataTable37
   \   0000013C   0x7011             STRB     R1,[R2, #+0]
   4995                BlackRightWinPredictStore2 = temppredict;         
   \   0000013E   0x.... 0x....      LDR.W    R1,??DataTable38
   \   00000142   0x7008             STRB     R0,[R1, #+0]
   4996              }
   4997                
   4998                
   4999                
   5000              //一直到第Row2LastLine行也没有连续2行检测成功，则返回失败。
   5001              if(row == Row2LastLine) 
   \                     ??BlackGetRightCrossSpeScan_8: (+1)
   \   00000144   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000146   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000148   0x42AC             CMP      R4,R5
   \   0000014A   0xF47F 0xAF77      BNE.W    ??BlackGetRightCrossSpeScan_5
   5002              {
   5003                return MaxValUint8;
   \   0000014E   0x20FF             MOVS     R0,#+255
   \                     ??BlackGetRightCrossSpeScan_4: (+1)
   \   00000150   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   5004              }
   5005              else
   5006              {
   5007              }
   5008            }
   5009           
   5010          
   5011          }
   5012          
   5013          
   5014          
   5015          
   5016          //======================================================================
   5017          //函数名：BlackRightAgainForCross
   5018          //功  能：右黑线提取中，针对十字的再检测程序
   5019          //参  数：第2段黑线的预测起始行Row2FirstLine， 第2段黑线的预测结束行Row2LastLine，
   5020          //        第1段黑线的实际结束行Row1RealLastLine, 最近一次的窗口预测值LastWinPredict
   5021          //返  回：1成功 0失败
   5022          //影  响：BlackRightLoc[][]。 （不会影响那几个阈值。）
   5023          //说  明：1. 本函数会调用浮点运算的函数，预计花费较多时间，调用入口需谨慎。
   5024          //        2. 本函数仅影响了BlackRightLoc[][]，以后也应该保持。
   5025          //             
   5026          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   5027          uint8 BlackRightAgainForCross(uint8 Row2FirstLine, uint8 Row2LastLine, uint8 Row1RealLastLine, uint8 LastWinPredict)
   5028          {
   \                     BlackRightAgainForCross: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
   5029              uint8 row, temp, temp1, temp2;
   5030              uint8 Row2RealFirstLine; //第2段黑线的真实起始行
   5031              uint8 i;
   5032              
   5033              uint8 tempWB, tempW, tempB;
   5034              uint8 tempminus;
   5035              
   5036              //第1段黑线的真实结束行有可能因为大跳变被删掉，所以需要重新查找并更新。
   5037              for(i = Row1RealLastLine; i <= CameraHight - 1; i++)
   \   0000000A   0x0028             MOVS     R0,R5
   \   0000000C   0xE000             B.N      ??BlackRightAgainForCross_0
   \                     ??BlackRightAgainForCross_1: (+1)
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackRightAgainForCross_0: (+1)
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x283C             CMP      R0,#+60
   \   00000014   0xDA09             BGE.N    ??BlackRightAgainForCross_2
   5038              {
   5039                if(BlackRightLoc[i][0] != MaxValUint8)
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable38_1
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x2203             MOVS     R2,#+3
   \   0000001E   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   00000022   0x7809             LDRB     R1,[R1, #+0]
   \   00000024   0x29FF             CMP      R1,#+255
   \   00000026   0xD0F2             BEQ.N    ??BlackRightAgainForCross_1
   5040                {
   5041                  Row1RealLastLine = i;
   \   00000028   0x0005             MOVS     R5,R0
   5042                  break;
   5043                }
   5044                else
   5045                {
   5046                }
   5047              }
   5048              //由于直角黑块不允许检测十字再补线，所以当第1段黑线真实结束行的斜上方有黑块时，不允许补线。
   5049              //取5列。
   5050              for(i = 0; i <= 5; i++)
   \                     ??BlackRightAgainForCross_2: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE000             B.N      ??BlackRightAgainForCross_3
   \                     ??BlackRightAgainForCross_4: (+1)
   \   0000002E   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackRightAgainForCross_3: (+1)
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x2806             CMP      R0,#+6
   \   00000034   0xDA35             BGE.N    ??BlackRightAgainForCross_5
   5051              {
   5052                if(ImgNew[Row1RealLastLine - 4][BlackRightLoc[Row1RealLastLine][0] - 5 - i] < LimitRightB) //往远5行。斜左上方。
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable34_7
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x22FA             MOVS     R2,#+250
   \   0000003E   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000042   0x.... 0x....      LDR.W    R2,??DataTable38_1
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2703             MOVS     R7,#+3
   \   0000004A   0xFB07 0x2205      MLA      R2,R7,R5,R2
   \   0000004E   0x7812             LDRB     R2,[R2, #+0]
   \   00000050   0x1F52             SUBS     R2,R2,#+5
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0x1A12             SUBS     R2,R2,R0
   \   00000056   0x1851             ADDS     R1,R2,R1
   \   00000058   0xF5B1 0x717A      SUBS     R1,R1,#+1000
   \   0000005C   0x7809             LDRB     R1,[R1, #+0]
   \   0000005E   0x.... 0x....      LDR.W    R2,??DataTable37_2
   \   00000062   0x7812             LDRB     R2,[R2, #+0]
   \   00000064   0x4291             CMP      R1,R2
   \   00000066   0xD201             BCS.N    ??BlackRightAgainForCross_6
   5053                {
   5054                  return 0;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xE1A0             B.N      ??BlackRightAgainForCross_7
   5055                }
   5056                else if(ImgNew[Row1RealLastLine - 5][BlackRightLoc[Row1RealLastLine][0] - 5 - i] < LimitRightB) //往远5行。斜左上方。
   \                     ??BlackRightAgainForCross_6: (+1)
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable34_7
   \   00000070   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000072   0x22FA             MOVS     R2,#+250
   \   00000074   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000078   0x.... 0x....      LDR.W    R2,??DataTable38_1
   \   0000007C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000007E   0x2703             MOVS     R7,#+3
   \   00000080   0xFB07 0x2205      MLA      R2,R7,R5,R2
   \   00000084   0x7812             LDRB     R2,[R2, #+0]
   \   00000086   0x1F52             SUBS     R2,R2,#+5
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0x1A12             SUBS     R2,R2,R0
   \   0000008C   0x1851             ADDS     R1,R2,R1
   \   0000008E   0xF2A1 0x41E2      SUBW     R1,R1,#+1250
   \   00000092   0x7809             LDRB     R1,[R1, #+0]
   \   00000094   0x.... 0x....      LDR.W    R2,??DataTable37_2
   \   00000098   0x7812             LDRB     R2,[R2, #+0]
   \   0000009A   0x4291             CMP      R1,R2
   \   0000009C   0xD2C7             BCS.N    ??BlackRightAgainForCross_4
   5057                {
   5058                  return 0;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xE185             B.N      ??BlackRightAgainForCross_7
   5059                }
   5060                else
   5061                {
   5062                }      
   5063              }
   5064              
   5065              //十字再检测第1阶段，找线头。
   5066              //temp = BlackGetRightStep1Scan(Row2FirstLine, Row2LastLine, 0); //第3个参数0表示是十字再检测，不用更新3个关键值
   5067              
   5068              //十字再检测第1阶段，找线头，不采用Scan的方式，采用Win的方式。
   5069              temp = BlackGetRightCrossSpeScan(Row2FirstLine, Row2LastLine, LastWinPredict);
   \                     ??BlackRightAgainForCross_5: (+1)
   \   000000A2   0x001A             MOVS     R2,R3
   \   000000A4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000A6   0x0021             MOVS     R1,R4
   \   000000A8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000AA   0x0030             MOVS     R0,R6
   \   000000AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AE   0x.... 0x....      BL       BlackGetRightCrossSpeScan
   \   000000B2   0x4680             MOV      R8,R0
   5070              
   5071              //线头查找失败，或找到最远两行（继续执行后面会数组超出界限），就直接判定为失败。
   5072              if(
   5073                (temp == MaxValUint8)
   5074              ||(temp <= 1)
   5075              ||(BlackAgainForCrossFar10CutSwitch == 1 && temp <= 9)  //当远10行删除开关开启时，且十字再检测时的第2段黑线线头在最远的10行，则十字再检测失败。
   5076                )
   \   000000B4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000B8   0xF1B8 0x0FFF      CMP      R8,#+255
   \   000000BC   0xD009             BEQ.N    ??BlackRightAgainForCross_8
   \   000000BE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000C2   0xF1B8 0x0F02      CMP      R8,#+2
   \   000000C6   0xDB04             BLT.N    ??BlackRightAgainForCross_8
   \   000000C8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000CC   0xF1B8 0x0F0A      CMP      R8,#+10
   \   000000D0   0xDA0F             BGE.N    ??BlackRightAgainForCross_9
   5077              {
   5078                //扫屁股工作。        //i >= Row2LastLine
   5079                for(i = Row2FirstLine; ; i--)
   \                     ??BlackRightAgainForCross_8: (+1)
   \   000000D2   0x0030             MOVS     R0,R6
   \   000000D4   0xE000             B.N      ??BlackRightAgainForCross_10
   \                     ??BlackRightAgainForCross_11: (+1)
   \   000000D6   0x1E40             SUBS     R0,R0,#+1
   5080                {
   5081                  BlackRightLoc[i][0] = MaxValUint8;
   \                     ??BlackRightAgainForCross_10: (+1)
   \   000000D8   0x21FF             MOVS     R1,#+255
   \   000000DA   0x.... 0x....      LDR.W    R2,??DataTable38_1
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0x2303             MOVS     R3,#+3
   \   000000E2   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000E6   0x7011             STRB     R1,[R2, #+0]
   5082                  if(i == 0) break;
   \   000000E8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD1F3             BNE.N    ??BlackRightAgainForCross_11
   5083                }
   5084                return 0;  
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0xE15D             B.N      ??BlackRightAgainForCross_7
   5085              }
   5086              else 
   5087              {
   5088                ////////////////如果要注释，就从这里开始注释
   5089                
   5090                //十字再检测的线头不在限定的范围内，认为是干扰点，不用顺着线头找线了，直接退出。
   5091                if(BlackRightCrossConfirm(Row1RealLastLine+1, temp) == 0)
   \                     ??BlackRightAgainForCross_9: (+1)
   \   000000F2   0x4641             MOV      R1,R8
   \   000000F4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000F6   0x1C68             ADDS     R0,R5,#+1
   \   000000F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000FA   0x.... 0x....      BL       BlackRightCrossConfirm
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD113             BNE.N    ??BlackRightAgainForCross_12
   5092                { //扫屁股工作。         //i >= (temp-1)
   5093                  BlackRightCrossConfirmFlag = 1;  //右十字线头标志确认失败，超出预想范围。
   \   00000102   0x2001             MOVS     R0,#+1
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable38_2
   \   00000108   0x7008             STRB     R0,[R1, #+0]
   5094                  for(i = Row2FirstLine; ; i--)
   \   0000010A   0x0030             MOVS     R0,R6
   \   0000010C   0xE000             B.N      ??BlackRightAgainForCross_13
   \                     ??BlackRightAgainForCross_14: (+1)
   \   0000010E   0x1E40             SUBS     R0,R0,#+1
   5095                  {
   5096                    BlackRightLoc[i][0] = MaxValUint8;
   \                     ??BlackRightAgainForCross_13: (+1)
   \   00000110   0x21FF             MOVS     R1,#+255
   \   00000112   0x.... 0x....      LDR.W    R2,??DataTable38_1
   \   00000116   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000118   0x2303             MOVS     R3,#+3
   \   0000011A   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000011E   0x7011             STRB     R1,[R2, #+0]
   5097                    if(i == 0) break;
   \   00000120   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD1F3             BNE.N    ??BlackRightAgainForCross_14
   5098                  }
   5099                  return 0;
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0xE141             B.N      ??BlackRightAgainForCross_7
   5100                }
   5101                //十字再检测的线头的确在限定的范围内，可以继续。
   5102                else
   5103                {
   5104                  BlackRightCrossConfirmFlag = 2;  //右十字线头标志确认成功。
   \                     ??BlackRightAgainForCross_12: (+1)
   \   0000012A   0x2002             MOVS     R0,#+2
   \   0000012C   0x.... 0x....      LDR.W    R1,??DataTable38_2
   \   00000130   0x7008             STRB     R0,[R1, #+0]
   5105                  row = temp;
   \   00000132   0x4647             MOV      R7,R8
   5106                }
   5107                
   5108                ////////////////如果要注释，就从这里结束注释
   5109                
   5110                //暂时不用confirm函数，如果要用的话 ，就把后面这句话去掉，前面注释去掉。
   5111                //row = temp;
   5112              }
   5113              
   5114              Row2RealFirstLine = row; //记录第2段黑线的真实起始行
   \   00000134   0x003E             MOVS     R6,R7
   5115              
   5116              //十字再检测第2阶段，顺着线头找线。
   5117              //temp为预测的黑点位置
   5118              temp = BoundaryLimitRe(BlackRightLoc[row-1][0] + BlackRightLoc[row-1][0] - BlackRightLoc[row][0],
   5119                                     0,
   5120                                     CameraRealWidth - 1);
   \   00000136   0x22F9             MOVS     R2,#+249
   \   00000138   0x2100             MOVS     R1,#+0
   \   0000013A   0x.... 0x....      LDR.W    R0,??DataTable38_1
   \   0000013E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000140   0x2303             MOVS     R3,#+3
   \   00000142   0xFB03 0x0007      MLA      R0,R3,R7,R0
   \   00000146   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000014A   0x.... 0x....      LDR.W    R3,??DataTable38_1
   \   0000014E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000150   0xF05F 0x0C03      MOVS     R12,#+3
   \   00000154   0xFB0C 0x3307      MLA      R3,R12,R7,R3
   \   00000158   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   0000015C   0xFA53 0xF080      UXTAB    R0,R3,R0
   \   00000160   0x.... 0x....      LDR.W    R3,??DataTable38_1
   \   00000164   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000166   0xF05F 0x0C03      MOVS     R12,#+3
   \   0000016A   0xFB0C 0x3307      MLA      R3,R12,R7,R3
   \   0000016E   0x781B             LDRB     R3,[R3, #+0]
   \   00000170   0x1AC0             SUBS     R0,R0,R3
   \   00000172   0x.... 0x....      BL       BoundaryLimitRe
   \   00000176   0x4680             MOV      R8,R0
   5121              //预测值更新后就刷新一次堆栈，堆栈顶部丢失。
   5122              BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
   \   00000178   0x.... 0x....      LDR.W    R0,??DataTable37
   \   0000017C   0x7800             LDRB     R0,[R0, #+0]
   \   0000017E   0x.... 0x....      LDR.W    R1,??DataTable37_1
   \   00000182   0x7008             STRB     R0,[R1, #+0]
   5123              BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
   \   00000184   0x.... 0x....      LDR.W    R0,??DataTable38
   \   00000188   0x7800             LDRB     R0,[R0, #+0]
   \   0000018A   0x.... 0x....      LDR.W    R1,??DataTable37
   \   0000018E   0x7008             STRB     R0,[R1, #+0]
   5124              BlackRightWinPredictStore2 = temp;
   \   00000190   0x.... 0x....      LDR.W    R0,??DataTable38
   \   00000194   0xF880 0x8000      STRB     R8,[R0, #+0]
   5125              
   5126              //从最近的认证行到取最远的行
   5127              for(row -= 2; ; row -= 2)
   \   00000198   0x1EBF             SUBS     R7,R7,#+2
   \   0000019A   0xE000             B.N      ??BlackRightAgainForCross_15
   \                     ??BlackRightAgainForCross_16: (+1)
   \   0000019C   0x1EBF             SUBS     R7,R7,#+2
   5128              {
   5129                //连续2行检测黑点
   5130                temp1 = BlackGetRightStep2Win(row, BlackRightWinVal, temp, 1);
   \                     ??BlackRightAgainForCross_15: (+1)
   \   0000019E   0x2301             MOVS     R3,#+1
   \   000001A0   0x4642             MOV      R2,R8
   \   000001A2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001A4   0x210F             MOVS     R1,#+15
   \   000001A6   0x0038             MOVS     R0,R7
   \   000001A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001AA   0x.... 0x....      BL       BlackGetRightStep2Win
   \   000001AE   0x4681             MOV      R9,R0
   5131                temp2 = BlackGetRightStep2Win(row-1, BlackRightWinVal, temp, 2);
   \   000001B0   0x2302             MOVS     R3,#+2
   \   000001B2   0x4642             MOV      R2,R8
   \   000001B4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001B6   0x210F             MOVS     R1,#+15
   \   000001B8   0x1E78             SUBS     R0,R7,#+1
   \   000001BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001BC   0x.... 0x....      BL       BlackGetRightStep2Win
   5132                
   5133                //若连续2行的黑点检测成功，则更新3个阈值，更新预测点的位置
   5134                if(temp1 && temp2) 
   \   000001C0   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001C4   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001C8   0xF000 0x8097      BEQ.W    ??BlackRightAgainForCross_17
   \   000001CC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001CE   0x2800             CMP      R0,#+0
   \   000001D0   0xF000 0x8093      BEQ.W    ??BlackRightAgainForCross_17
   5135                {
   5136                  //差值的处理，留有裕度，且有上下界。
   5137                  tempWB = (BlackRightRealWB[0] + BlackRightRealWB[1]) / 2 - LimitRightWBMargin; 
   \   000001D4   0x.... 0x....      LDR.W    R0,??DataTable38_3
   \   000001D8   0x7800             LDRB     R0,[R0, #+0]
   \   000001DA   0x.... 0x....      LDR.W    R1,??DataTable38_3
   \   000001DE   0x7849             LDRB     R1,[R1, #+1]
   \   000001E0   0x1808             ADDS     R0,R1,R0
   \   000001E2   0x2102             MOVS     R1,#+2
   \   000001E4   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000001E8   0x3814             SUBS     R0,R0,#+20
   5138                  if(tempWB < LimitRightWBMin) tempWB = LimitRightWBMin;
   \   000001EA   0x....             LDR.N    R1,??DataTable33_1
   \   000001EC   0x7809             LDRB     R1,[R1, #+0]
   \   000001EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001F0   0x4288             CMP      R0,R1
   \   000001F2   0xD202             BCS.N    ??BlackRightAgainForCross_18
   \   000001F4   0x....             LDR.N    R0,??DataTable33_1
   \   000001F6   0x7800             LDRB     R0,[R0, #+0]
   \   000001F8   0xE006             B.N      ??BlackRightAgainForCross_19
   5139                  else if(tempWB > LimitRightWBMax) tempWB = LimitRightWBMax;
   \                     ??BlackRightAgainForCross_18: (+1)
   \   000001FA   0x....             LDR.N    R1,??DataTable33_2
   \   000001FC   0x7809             LDRB     R1,[R1, #+0]
   \   000001FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000200   0x4281             CMP      R1,R0
   \   00000202   0xD201             BCS.N    ??BlackRightAgainForCross_19
   \   00000204   0x....             LDR.N    R0,??DataTable33_2
   \   00000206   0x7800             LDRB     R0,[R0, #+0]
   5140                  else ;
   5141                  LimitRightWB = tempWB;
   \                     ??BlackRightAgainForCross_19: (+1)
   \   00000208   0x.... 0x....      LDR.W    R1,??DataTable38_4
   \   0000020C   0x7008             STRB     R0,[R1, #+0]
   5142                  
   5143                  //白点的处理，留有裕度，且有上下界。
   5144                  tempW = (BlackRightRealW[0] + BlackRightRealW[1]) / 2 - LimitRightWMargin;
   \   0000020E   0x.... 0x....      LDR.W    R0,??DataTable38_5
   \   00000212   0x7800             LDRB     R0,[R0, #+0]
   \   00000214   0x.... 0x....      LDR.W    R1,??DataTable38_5
   \   00000218   0x7849             LDRB     R1,[R1, #+1]
   \   0000021A   0x1808             ADDS     R0,R1,R0
   \   0000021C   0x2102             MOVS     R1,#+2
   \   0000021E   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000222   0x3828             SUBS     R0,R0,#+40
   5145                  if(tempW < LimitRightWMin) tempW = LimitRightWMin;
   \   00000224   0x....             LDR.N    R1,??DataTable33_3
   \   00000226   0x7809             LDRB     R1,[R1, #+0]
   \   00000228   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000022A   0x4288             CMP      R0,R1
   \   0000022C   0xD202             BCS.N    ??BlackRightAgainForCross_20
   \   0000022E   0x....             LDR.N    R0,??DataTable33_3
   \   00000230   0x7800             LDRB     R0,[R0, #+0]
   \   00000232   0xE006             B.N      ??BlackRightAgainForCross_21
   5146                  else if(tempW > LimitRightWMax) tempW = LimitRightWMax;
   \                     ??BlackRightAgainForCross_20: (+1)
   \   00000234   0x....             LDR.N    R1,??DataTable33_4
   \   00000236   0x7809             LDRB     R1,[R1, #+0]
   \   00000238   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000023A   0x4281             CMP      R1,R0
   \   0000023C   0xD201             BCS.N    ??BlackRightAgainForCross_21
   \   0000023E   0x....             LDR.N    R0,??DataTable33_4
   \   00000240   0x7800             LDRB     R0,[R0, #+0]
   5147                  else ;
   5148                  LimitRightW = tempW;
   \                     ??BlackRightAgainForCross_21: (+1)
   \   00000242   0x.... 0x....      LDR.W    R1,??DataTable38_6
   \   00000246   0x7008             STRB     R0,[R1, #+0]
   5149                  
   5150                  //黑点的处理，留有裕度，且有上下界。
   5151                  tempB = (BlackRightRealB[0] + BlackRightRealB[1]) / 2 + LimitRightBMargin;
   \   00000248   0x.... 0x....      LDR.W    R0,??DataTable38_7
   \   0000024C   0x7800             LDRB     R0,[R0, #+0]
   \   0000024E   0x.... 0x....      LDR.W    R1,??DataTable38_7
   \   00000252   0x7849             LDRB     R1,[R1, #+1]
   \   00000254   0x1808             ADDS     R0,R1,R0
   \   00000256   0x2102             MOVS     R1,#+2
   \   00000258   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000025C   0x3023             ADDS     R0,R0,#+35
   5152                  if(tempB < LimitRightBMin) tempB = LimitRightBMin;
   \   0000025E   0x....             LDR.N    R1,??DataTable33_5
   \   00000260   0x7809             LDRB     R1,[R1, #+0]
   \   00000262   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000264   0x4288             CMP      R0,R1
   \   00000266   0xD202             BCS.N    ??BlackRightAgainForCross_22
   \   00000268   0x....             LDR.N    R0,??DataTable33_5
   \   0000026A   0x7800             LDRB     R0,[R0, #+0]
   \   0000026C   0xE006             B.N      ??BlackRightAgainForCross_23
   5153                  else if(tempB > LimitRightBMax) tempB = LimitRightBMax;
   \                     ??BlackRightAgainForCross_22: (+1)
   \   0000026E   0x....             LDR.N    R1,??DataTable33_6
   \   00000270   0x7809             LDRB     R1,[R1, #+0]
   \   00000272   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000274   0x4281             CMP      R1,R0
   \   00000276   0xD201             BCS.N    ??BlackRightAgainForCross_23
   \   00000278   0x....             LDR.N    R0,??DataTable33_6
   \   0000027A   0x7800             LDRB     R0,[R0, #+0]
   5154                  else ;
   5155                  //黑色阈值不能超过白色
   5156                  if(tempB >= LimitRightW)
   \                     ??BlackRightAgainForCross_23: (+1)
   \   0000027C   0x.... 0x....      LDR.W    R1,??DataTable38_6
   \   00000280   0x7809             LDRB     R1,[R1, #+0]
   \   00000282   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000284   0x4288             CMP      R0,R1
   \   00000286   0xD303             BCC.N    ??BlackRightAgainForCross_24
   5157                  {
   5158                    tempB = LimitRightW - 1;
   \   00000288   0x.... 0x....      LDR.W    R0,??DataTable38_6
   \   0000028C   0x7800             LDRB     R0,[R0, #+0]
   \   0000028E   0x1E40             SUBS     R0,R0,#+1
   5159                  }
   5160                  else
   5161                  {
   5162                  }              
   5163                  LimitRightB = tempB;     
   \                     ??BlackRightAgainForCross_24: (+1)
   \   00000290   0x.... 0x....      LDR.W    R1,??DataTable37_2
   \   00000294   0x7008             STRB     R0,[R1, #+0]
   5164                  
   5165                  //对预测值的更新。
   5166                  temp = BoundaryLimitRe(BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0],
   5167                                         0,
   5168                                         CameraRealWidth - 1);
   \   00000296   0x22F9             MOVS     R2,#+249
   \   00000298   0x2100             MOVS     R1,#+0
   \   0000029A   0x.... 0x....      LDR.W    R0,??DataTable38_1
   \   0000029E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002A0   0x2303             MOVS     R3,#+3
   \   000002A2   0xFB03 0x0007      MLA      R0,R3,R7,R0
   \   000002A6   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000002AA   0x.... 0x....      LDR.W    R3,??DataTable38_1
   \   000002AE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002B0   0xF05F 0x0C03      MOVS     R12,#+3
   \   000002B4   0xFB0C 0x3307      MLA      R3,R12,R7,R3
   \   000002B8   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   000002BC   0xFA53 0xF080      UXTAB    R0,R3,R0
   \   000002C0   0x.... 0x....      LDR.W    R3,??DataTable38_1
   \   000002C4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002C6   0xF05F 0x0C03      MOVS     R12,#+3
   \   000002CA   0xFB0C 0x3307      MLA      R3,R12,R7,R3
   \   000002CE   0x781B             LDRB     R3,[R3, #+0]
   \   000002D0   0x1AC0             SUBS     R0,R0,R3
   \   000002D2   0x.... 0x....      BL       BoundaryLimitRe
   \   000002D6   0x4680             MOV      R8,R0
   5169                  //预测值更新后就刷新一次堆栈，堆栈顶部丢失。
   5170                  BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
   \   000002D8   0x.... 0x....      LDR.W    R0,??DataTable37
   \   000002DC   0x7800             LDRB     R0,[R0, #+0]
   \   000002DE   0x.... 0x....      LDR.W    R1,??DataTable37_1
   \   000002E2   0x7008             STRB     R0,[R1, #+0]
   5171                  BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
   \   000002E4   0x.... 0x....      LDR.W    R0,??DataTable38
   \   000002E8   0x7800             LDRB     R0,[R0, #+0]
   \   000002EA   0x.... 0x....      LDR.W    R1,??DataTable37
   \   000002EE   0x7008             STRB     R0,[R1, #+0]
   5172                  BlackRightWinPredictStore2 = temp;
   \   000002F0   0x.... 0x....      LDR.W    R0,??DataTable38
   \   000002F4   0xF880 0x8000      STRB     R8,[R0, #+0]
   \   000002F8   0xE01F             B.N      ??BlackRightAgainForCross_25
   5173                }
   5174                //如果没能连续两行检测黑点成功，原本打算用原位置的预测点，后来发现效果不好，所以决定按预测点的趋势走。
   5175                else
   5176                {        
   5177                  //预测点按趋势走也要限幅。
   5178                  tempminus = BoundaryLimitRe(BlackRightWinPredictStore2 + BlackRightWinPredictStore2 - BlackRightWinPredictStore1,
   5179                                              0,
   5180                                              CameraRealWidth - 1);
   \                     ??BlackRightAgainForCross_17: (+1)
   \   000002FA   0x22F9             MOVS     R2,#+249
   \   000002FC   0x2100             MOVS     R1,#+0
   \   000002FE   0x.... 0x....      LDR.W    R0,??DataTable38
   \   00000302   0x7800             LDRB     R0,[R0, #+0]
   \   00000304   0x.... 0x....      LDR.W    R3,??DataTable38
   \   00000308   0x781B             LDRB     R3,[R3, #+0]
   \   0000030A   0x1818             ADDS     R0,R3,R0
   \   0000030C   0x.... 0x....      LDR.W    R3,??DataTable37
   \   00000310   0x781B             LDRB     R3,[R3, #+0]
   \   00000312   0x1AC0             SUBS     R0,R0,R3
   \   00000314   0x.... 0x....      BL       BoundaryLimitRe
   \   00000318   0x4680             MOV      R8,R0
   5181                  //temp在这里表示窗口预测点位置。
   5182                  temp = tempminus;
   5183                  BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
   \   0000031A   0x.... 0x....      LDR.W    R0,??DataTable37
   \   0000031E   0x7800             LDRB     R0,[R0, #+0]
   \   00000320   0x.... 0x....      LDR.W    R1,??DataTable37_1
   \   00000324   0x7008             STRB     R0,[R1, #+0]
   5184                  BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
   \   00000326   0x.... 0x....      LDR.W    R0,??DataTable38
   \   0000032A   0x7800             LDRB     R0,[R0, #+0]
   \   0000032C   0x.... 0x....      LDR.W    R1,??DataTable37
   \   00000330   0x7008             STRB     R0,[R1, #+0]
   5185                  BlackRightWinPredictStore2 = temp;
   \   00000332   0x.... 0x....      LDR.W    R0,??DataTable38
   \   00000336   0xF880 0x8000      STRB     R8,[R0, #+0]
   5186                }
   5187                
   5188                if((row == Row2LastLine) || (row == Row2LastLine+1)) break;      
   \                     ??BlackRightAgainForCross_25: (+1)
   \   0000033A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000033C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000033E   0x42A7             CMP      R7,R4
   \   00000340   0xD005             BEQ.N    ??BlackRightAgainForCross_26
   \   00000342   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000344   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000346   0x1C60             ADDS     R0,R4,#+1
   \   00000348   0x4287             CMP      R7,R0
   \   0000034A   0xF47F 0xAF27      BNE.W    ??BlackRightAgainForCross_16
   5189              }
   5190              
   5191              //检查是否因大斜率而被削头。如果有，则更新头的位置，如果没有，则正常补线。
   5192              if (BlackRightLoc[Row1RealLastLine][0] == MaxValUint8)
   \                     ??BlackRightAgainForCross_26: (+1)
   \   0000034E   0x.... 0x....      LDR.W    R0,??DataTable38_1
   \   00000352   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000354   0x2103             MOVS     R1,#+3
   \   00000356   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000035A   0x7800             LDRB     R0,[R0, #+0]
   \   0000035C   0x28FF             CMP      R0,#+255
   \   0000035E   0xD11B             BNE.N    ??BlackRightAgainForCross_27
   5193              {
   5194          
   5195                  //头足够高，找回头。
   5196                  for (i = Row1RealLastLine; ; i++)
   \   00000360   0x0028             MOVS     R0,R5
   \   00000362   0xE000             B.N      ??BlackRightAgainForCross_28
   \                     ??BlackRightAgainForCross_29: (+1)
   \   00000364   0x1C40             ADDS     R0,R0,#+1
   5197                  {
   5198                      if (BlackRightLoc[i][0] != MaxValUint8)
   \                     ??BlackRightAgainForCross_28: (+1)
   \   00000366   0x.... 0x....      LDR.W    R1,??DataTable38_1
   \   0000036A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000036C   0x2203             MOVS     R2,#+3
   \   0000036E   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   00000372   0x7809             LDRB     R1,[R1, #+0]
   \   00000374   0x29FF             CMP      R1,#+255
   \   00000376   0xD00A             BEQ.N    ??BlackRightAgainForCross_30
   5199                      {
   5200                          Row1RealLastLine = i;
   \   00000378   0x0005             MOVS     R5,R0
   5201                          break;
   5202                      }
   5203                      else
   5204                      {
   5205                      }
   5206                      //直到最后一行也没有找到有效行，不用补线，直接返回1.
   5207                      if (i == CameraHight - 1) return 1;
   5208                  }
   5209          
   5210                  //十字再检测第3阶段，脑补两段线的接线。
   5211                  if (BlackRightCrossStep3(Row1RealLastLine, Row2RealFirstLine) == 0)
   \   0000037A   0x0031             MOVS     R1,R6
   \   0000037C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000037E   0x0028             MOVS     R0,R5
   \   00000380   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000382   0x.... 0x....      BL       BlackRightCrossStep3
   \   00000386   0x2800             CMP      R0,#+0
   \   00000388   0xD110             BNE.N    ??BlackRightAgainForCross_31
   5212                  {
   5213                      return 0;
   \   0000038A   0x2000             MOVS     R0,#+0
   \   0000038C   0xE00F             B.N      ??BlackRightAgainForCross_7
   5214                  }
   \                     ??BlackRightAgainForCross_30: (+1)
   \   0000038E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000390   0x283B             CMP      R0,#+59
   \   00000392   0xD1E7             BNE.N    ??BlackRightAgainForCross_29
   \   00000394   0x2001             MOVS     R0,#+1
   \   00000396   0xE00A             B.N      ??BlackRightAgainForCross_7
   5215          
   5216              }
   5217              else
   5218              {
   5219                  //没有被大斜率削头。
   5220                  //十字再检测第3阶段，脑补两段线的接线。
   5221                  if (BlackRightCrossStep3(Row1RealLastLine, Row2RealFirstLine) == 0)
   \                     ??BlackRightAgainForCross_27: (+1)
   \   00000398   0x0031             MOVS     R1,R6
   \   0000039A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000039C   0x0028             MOVS     R0,R5
   \   0000039E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003A0   0x.... 0x....      BL       BlackRightCrossStep3
   \   000003A4   0x2800             CMP      R0,#+0
   \   000003A6   0xD101             BNE.N    ??BlackRightAgainForCross_31
   5222                  {
   5223                      return 0;
   \   000003A8   0x2000             MOVS     R0,#+0
   \   000003AA   0xE000             B.N      ??BlackRightAgainForCross_7
   5224                  }
   5225              }
   5226              
   5227              return 1;
   \                     ??BlackRightAgainForCross_31: (+1)
   \   000003AC   0x2001             MOVS     R0,#+1
   \                     ??BlackRightAgainForCross_7: (+1)
   \   000003AE   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   5228                  
   5229          }
   5230          
   5231          
   5232          //======================================================================
   5233          //函数名：BlackRightStep4BackLine
   5234          //功  能：右黑线提取中，第4阶段十字向后补线函数。
   5235          //参  数：Step4StartLine开始行,flag标志0表示正常调用，1表示单线错误的调用
   5236          //返  回：1成功 0失败
   5237          //影  响：BlackRightLoc[][0]
   5238          //说  明：1. 这里引用了float型的函数，有可能占用较长的时间。
   5239          //        2. 想要减少时间，可以把宏定义BlackBackLineNum减至3或者2.
   5240          //        3. 单线错误的调用时，不用检测十字外尾
   5241          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   5242          uint8 BlackRightStep4BackLine(uint8 Step4StartLine, uint8 flag)
   5243          {
   \                     BlackRightStep4BackLine: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   5244            uint8 row;
   5245            uint8 i, index;
   5246            uint8 x[BlackBackLineNum];   //取多少个点在一开始有定义。
   5247            uint8 y[BlackBackLineNum];
   5248            uint8 j;
   5249            uint8 temp1;
   5250            uint8 tempend;
   5251            
   5252            int32 temp;
   5253            int32 a0;
   5254            int32 a1;
   5255            
   5256            //正常调用时，需要检测十字外尾
   5257            if(flag == 0)
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xF040 0x80C5      BNE.W    ??BlackRightStep4BackLine_0
   5258            {
   5259              //十字外尾处理
   5260              //第1阶段的线头比较高的话，就开始十字外尾检测。否则不用管。
   5261              if(BlackRightStep1ScanRow < BlackRightCrossTailRowLimit)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable38_8
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2832             CMP      R0,#+50
   \   00000016   0xF280 0x80BB      BGE.W    ??BlackRightStep4BackLine_1
   5262              {
   5263                //检查线头处的斜率是不是很大，若很大，则怀疑有十字外尾。否则不用管。
   5264                //这里用的斜率是十字外尾专用斜率。
   5265                if(BlackRight5Slope[0] > BlackRightCrossTailSlopeLimit)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable38_9
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF640 0x5149      MOVW     R1,#+3401
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xF2C0 0x80AE      BLT.W    ??BlackRightStep4BackLine_2
   5266                {
   5267                  //十字外尾标志置位。
   5268                  BlackRightCrossTailFlag = 1;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable38_10
   \   00000030   0x7008             STRB     R0,[R1, #+0]
   5269                  BlackRightHeadEndSearch();
   \   00000032   0x.... 0x....      BL       BlackRightHeadEndSearch
   5270                  if (BlackRightEndLine - BlackRightHeadLine <= 5 && BlackLeftHeadLine != MaxValUint8 && BlackLeftEndLine != MaxValUint8)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable38_11
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable38_12
   \   00000040   0x7809             LDRB     R1,[R1, #+0]
   \   00000042   0x1A40             SUBS     R0,R0,R1
   \   00000044   0x2806             CMP      R0,#+6
   \   00000046   0xDA1D             BGE.N    ??BlackRightStep4BackLine_3
   \   00000048   0x....             LDR.N    R0,??DataTable34_2
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x28FF             CMP      R0,#+255
   \   0000004E   0xD019             BEQ.N    ??BlackRightStep4BackLine_3
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable38_13
   \   00000054   0x7800             LDRB     R0,[R0, #+0]
   \   00000056   0x28FF             CMP      R0,#+255
   \   00000058   0xD014             BEQ.N    ??BlackRightStep4BackLine_3
   5271                  {
   5272                      //这种情况有可能是回弯导致的，过滤掉
   5273                      for (i = BlackRightHeadLine; i <= BlackRightEndLine; i++)
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable38_12
   \   0000005E   0x7800             LDRB     R0,[R0, #+0]
   \   00000060   0xE008             B.N      ??BlackRightStep4BackLine_4
   5274                      {
   5275                          BlackRightLoc[i][0] = MaxValUint8;
   \                     ??BlackRightStep4BackLine_5: (+1)
   \   00000062   0x21FF             MOVS     R1,#+255
   \   00000064   0x.... 0x....      LDR.W    R2,??DataTable38_1
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0x2303             MOVS     R3,#+3
   \   0000006C   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000070   0x7011             STRB     R1,[R2, #+0]
   5276                      }
   \   00000072   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackRightStep4BackLine_4: (+1)
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable38_11
   \   00000078   0x7809             LDRB     R1,[R1, #+0]
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0x4281             CMP      R1,R0
   \   0000007E   0xD2F0             BCS.N    ??BlackRightStep4BackLine_5
   5277                      return 0;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xE0F6             B.N      ??BlackRightStep4BackLine_6
   5278                  }
   5279                  else if (BlackRight5Slope[0] == MaxValInt16)
   \                     ??BlackRightStep4BackLine_3: (+1)
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable38_9
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0xF647 0x71FF      MOVW     R1,#+32767
   \   0000008E   0x4288             CMP      R0,R1
   \   00000090   0xD10F             BNE.N    ??BlackRightStep4BackLine_7
   5280                  {
   5281                      //这种情况有可能是回弯导致的，过滤掉
   5282                      for (i = 0; i <= 59; i++)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xE008             B.N      ??BlackRightStep4BackLine_8
   5283                      {
   5284                          BlackRightLoc[i][0] = MaxValUint8;
   \                     ??BlackRightStep4BackLine_9: (+1)
   \   00000096   0x21FF             MOVS     R1,#+255
   \   00000098   0x.... 0x....      LDR.W    R2,??DataTable38_1
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0x2303             MOVS     R3,#+3
   \   000000A0   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000A4   0x7011             STRB     R1,[R2, #+0]
   5285                      }
   \   000000A6   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackRightStep4BackLine_8: (+1)
   \   000000A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AA   0x283C             CMP      R0,#+60
   \   000000AC   0xDBF3             BLT.N    ??BlackRightStep4BackLine_9
   5286                      return 0;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xE0DF             B.N      ??BlackRightStep4BackLine_6
   5287                  }
   5288                  //5Slope数组有可能已经删掉了一些黑点，所以也要参考实际的有效黑点数。
   5289                  if(BlackRightEndLine - BlackRightHeadLine - 4 < 0 || BlackRight5SlopeIndex - 1 < 0)
   \                     ??BlackRightStep4BackLine_7: (+1)
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable38_11
   \   000000B6   0x7800             LDRB     R0,[R0, #+0]
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable38_12
   \   000000BC   0x7809             LDRB     R1,[R1, #+0]
   \   000000BE   0x1A40             SUBS     R0,R0,R1
   \   000000C0   0x1F00             SUBS     R0,R0,#+4
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD405             BMI.N    ??BlackRightStep4BackLine_10
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable38_14
   \   000000CA   0x7800             LDRB     R0,[R0, #+0]
   \   000000CC   0x1E40             SUBS     R0,R0,#+1
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD501             BPL.N    ??BlackRightStep4BackLine_11
   5290                  {
   5291                    return 0;
   \                     ??BlackRightStep4BackLine_10: (+1)
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xE0CD             B.N      ??BlackRightStep4BackLine_6
   5292                  }
   5293                  else
   5294                  {
   5295                  }        
   5296                  tempend = MinRe(BlackRightEndLine - BlackRightHeadLine - 4, BlackRight5SlopeIndex - 1);
   \                     ??BlackRightStep4BackLine_11: (+1)
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable38_14
   \   000000DA   0x7800             LDRB     R0,[R0, #+0]
   \   000000DC   0x1E41             SUBS     R1,R0,#+1
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable38_11
   \   000000E2   0x7800             LDRB     R0,[R0, #+0]
   \   000000E4   0x.... 0x....      LDR.W    R2,??DataTable38_12
   \   000000E8   0x7812             LDRB     R2,[R2, #+0]
   \   000000EA   0x1A80             SUBS     R0,R0,R2
   \   000000EC   0x1F00             SUBS     R0,R0,#+4
   \   000000EE   0x.... 0x....      BL       MinRe
   \   000000F2   0x0001             MOVS     R1,R0
   5297                  //开始消除十字外尾，找十字外尾的处理最远行。
   5298                  for(i = 0; ; i++)
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0xE000             B.N      ??BlackRightStep4BackLine_12
   \                     ??BlackRightStep4BackLine_13: (+1)
   \   000000F8   0x1C40             ADDS     R0,R0,#+1
   5299                  {
   5300                    //找斜率在直道范围内的。这里用的斜率是判断为直道的斜率。
   5301                    if(BlackRight5Slope[i] < PathJudgeStraightSlopeLimit)
   \                     ??BlackRightStep4BackLine_12: (+1)
   \   000000FA   0x.... 0x....      LDR.W    R2,??DataTable38_9
   \   000000FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000100   0xF852 0x2020      LDR      R2,[R2, R0, LSL #+2]
   \   00000104   0xF640 0x0334      MOVW     R3,#+2100
   \   00000108   0x429A             CMP      R2,R3
   \   0000010A   0xDA22             BGE.N    ??BlackRightStep4BackLine_14
   5302                    {
   5303                      BlackRightCrossTailEndLine = BlackRight5SlopeRow[i];
   \   0000010C   0x.... 0x....      LDR.W    R1,??DataTable38_15
   \   00000110   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000112   0x5C40             LDRB     R0,[R0, R1]
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable38_16
   \   00000118   0x7008             STRB     R0,[R1, #+0]
   5304                      break;
   5305                    }
   5306                    
   5307                    if(i == tempend) return 0;  //一直都很斜，则有可能是回弯，直接返回失败。
   5308                    //按理说不会走到这里，因为回弯会导致向后补线出错，向后补线出错后进来本函数时会先检查出错的原因BlackRightStep4ErrorCheck()，会检测斜率是不是都是直线，若不是则不会进来。
   5309                  }
   5310                  //向近处4个点，也就是“5”点斜率的计算末尾。
   5311                  BlackRightCrossTailEndLine += 4;
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable38_16
   \   0000011E   0x7800             LDRB     R0,[R0, #+0]
   \   00000120   0x1D00             ADDS     R0,R0,#+4
   \   00000122   0x.... 0x....      LDR.W    R1,??DataTable38_16
   \   00000126   0x7008             STRB     R0,[R1, #+0]
   5312                  //取最开始采到的行
   5313                  i = MinRe(BlackRight5SlopeRow[0] + 4, CameraHight - 1);
   \   00000128   0x213B             MOVS     R1,#+59
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable38_15
   \   0000012E   0x7800             LDRB     R0,[R0, #+0]
   \   00000130   0x1D00             ADDS     R0,R0,#+4
   \   00000132   0x.... 0x....      BL       MinRe
   5314                  i = MaxRe(BlackRightStep1ScanRow, i);
   \   00000136   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000138   0x0001             MOVS     R1,R0
   \   0000013A   0x.... 0x....      LDR.W    R0,??DataTable38_8
   \   0000013E   0x7800             LDRB     R0,[R0, #+0]
   \   00000140   0x.... 0x....      BL       MaxRe
   5315                  if(i >= BlackRightCrossTailEndLine)
   \   00000144   0x.... 0x....      LDR.W    R1,??DataTable38_16
   \   00000148   0x7809             LDRB     R1,[R1, #+0]
   \   0000014A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014C   0x4288             CMP      R0,R1
   \   0000014E   0xD323             BCC.N    ??BlackRightStep4BackLine_0
   \   00000150   0xE006             B.N      ??BlackRightStep4BackLine_15
   \                     ??BlackRightStep4BackLine_14: (+1)
   \   00000152   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000154   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000156   0x4288             CMP      R0,R1
   \   00000158   0xD1CE             BNE.N    ??BlackRightStep4BackLine_13
   \   0000015A   0x2000             MOVS     R0,#+0
   \   0000015C   0xE089             B.N      ??BlackRightStep4BackLine_6
   5316                  {
   5317                    //开始删除十字外尾。
   5318                    for(; ; i--)
   \                     ??BlackRightStep4BackLine_16: (+1)
   \   0000015E   0x1E40             SUBS     R0,R0,#+1
   5319                    {
   5320                      BlackRightLoc[i][0] = MaxValUint8;
   \                     ??BlackRightStep4BackLine_15: (+1)
   \   00000160   0x21FF             MOVS     R1,#+255
   \   00000162   0x.... 0x....      LDR.W    R2,??DataTable38_1
   \   00000166   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000168   0x2303             MOVS     R3,#+3
   \   0000016A   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000016E   0x7011             STRB     R1,[R2, #+0]
   5321                      if(i == BlackRightCrossTailEndLine) break;
   \   00000170   0x.... 0x....      LDR.W    R1,??DataTable38_16
   \   00000174   0x7809             LDRB     R1,[R1, #+0]
   \   00000176   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000178   0x4288             CMP      R0,R1
   \   0000017A   0xD1F0             BNE.N    ??BlackRightStep4BackLine_16
   5322                    }
   5323                    //修改向后补线的起点。
   5324                    Step4StartLine = BlackRightCrossTailEndLine - 1;
   \   0000017C   0x.... 0x....      LDR.W    R0,??DataTable38_16
   \   00000180   0x7800             LDRB     R0,[R0, #+0]
   \   00000182   0x1E44             SUBS     R4,R0,#+1
   \   00000184   0xE008             B.N      ??BlackRightStep4BackLine_0
   5325                  }
   5326                  else
   5327                  {
   5328                  }
   5329                }
   5330                else
   5331                {
   5332                  //没有十字外尾。
   5333                  BlackRightCrossTailFlag = 0;      
   \                     ??BlackRightStep4BackLine_2: (+1)
   \   00000186   0x2000             MOVS     R0,#+0
   \   00000188   0x.... 0x....      LDR.W    R1,??DataTable38_10
   \   0000018C   0x7008             STRB     R0,[R1, #+0]
   \   0000018E   0xE003             B.N      ??BlackRightStep4BackLine_0
   5334                }
   5335              }
   5336              else
   5337              {    
   5338                //没有十字外尾。
   5339                BlackRightCrossTailFlag = 0;
   \                     ??BlackRightStep4BackLine_1: (+1)
   \   00000190   0x2000             MOVS     R0,#+0
   \   00000192   0x.... 0x....      LDR.W    R1,??DataTable38_10
   \   00000196   0x7008             STRB     R0,[R1, #+0]
   5340              }
   5341            }
   5342            //单线错误调用时，就不用检测十字外尾了。
   5343            else
   5344            {
   5345            }  
   5346            
   5347          
   5348            //正常的十字向后补线
   5349            if(Step4StartLine - BlackBackLineNum - BlackBackLineNum < 0)
   \                     ??BlackRightStep4BackLine_0: (+1)
   \   00000198   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000019A   0xF1B4 0x0008      SUBS     R0,R4,#+8
   \   0000019E   0x2800             CMP      R0,#+0
   \   000001A0   0xD501             BPL.N    ??BlackRightStep4BackLine_17
   5350            {
   5351              temp1 = 0;  
   \   000001A2   0x2200             MOVS     R2,#+0
   \   000001A4   0xE001             B.N      ??BlackRightStep4BackLine_18
   5352            }
   5353            else
   5354            {
   5355              temp1 = Step4StartLine - BlackBackLineNum - BlackBackLineNum;
   \                     ??BlackRightStep4BackLine_17: (+1)
   \   000001A6   0xF1B4 0x0208      SUBS     R2,R4,#+8
   5356            }
   5357            
   5358            //取BlackBackLineNum个点作为最小二乘法的基准点。
   5359            //以左上角为原点，向下为x轴正方向，向右为y轴正方向
   5360            index = 0;
   \                     ??BlackRightStep4BackLine_18: (+1)
   \   000001AA   0x2100             MOVS     R1,#+0
   5361            for(i = Step4StartLine; ; i--)
   \   000001AC   0x0020             MOVS     R0,R4
   \   000001AE   0xE000             B.N      ??BlackRightStep4BackLine_19
   \                     ??BlackRightStep4BackLine_20: (+1)
   \   000001B0   0x1E40             SUBS     R0,R0,#+1
   5362            {
   5363              if(BlackRightLoc[i][0] != MaxValUint8)
   \                     ??BlackRightStep4BackLine_19: (+1)
   \   000001B2   0x.... 0x....      LDR.W    R3,??DataTable38_1
   \   000001B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B8   0x2503             MOVS     R5,#+3
   \   000001BA   0xFB05 0x3300      MLA      R3,R5,R0,R3
   \   000001BE   0x781B             LDRB     R3,[R3, #+0]
   \   000001C0   0x2BFF             CMP      R3,#+255
   \   000001C2   0xD00D             BEQ.N    ??BlackRightStep4BackLine_21
   5364              {
   5365                y[index] = BlackRightLoc[i][0];
   \   000001C4   0x.... 0x....      LDR.W    R3,??DataTable38_1
   \   000001C8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001CA   0x2503             MOVS     R5,#+3
   \   000001CC   0xFB05 0x3300      MLA      R3,R5,R0,R3
   \   000001D0   0x781B             LDRB     R3,[R3, #+0]
   \   000001D2   0xAD00             ADD      R5,SP,#+0
   \   000001D4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001D6   0x554B             STRB     R3,[R1, R5]
   5366                x[index] = i;
   \   000001D8   0xAB01             ADD      R3,SP,#+4
   \   000001DA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001DC   0x54C8             STRB     R0,[R1, R3]
   5367                index++;
   \   000001DE   0x1C49             ADDS     R1,R1,#+1
   5368              }
   5369              if(index == BlackBackLineNum)
   \                     ??BlackRightStep4BackLine_21: (+1)
   \   000001E0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001E2   0x2904             CMP      R1,#+4
   \   000001E4   0xD10D             BNE.N    ??BlackRightStep4BackLine_22
   5370              {
   5371                break;  
   5372              }
   5373              if(i == temp1)
   5374              {
   5375                return 0;
   5376              }
   5377            }
   5378            
   5379            //最小二乘法
   5380            //y = a0 + a1 * x
   5381            a1 = LeastSquarea1(x, y, BlackBackLineNum);
   \   000001E6   0x2204             MOVS     R2,#+4
   \   000001E8   0xA900             ADD      R1,SP,#+0
   \   000001EA   0xA801             ADD      R0,SP,#+4
   \   000001EC   0x.... 0x....      BL       LeastSquarea1
   \   000001F0   0x0005             MOVS     R5,R0
   5382            /*
   5383             //如果直线是从左上到右下，则说明是取到了错误的线，不必再补线，全数组清零。
   5384            if(a1 + BlackRightBackLineSlope < 0)
   5385            {
   5386              for(row = Step4StartLine; ; row--)
   5387              {
   5388                BlackRightLoc[row][0] = MaxValUint8;
   5389                if(row == 0) break;
   5390              }
   5391              return 0;
   5392            }
   5393            //否则继续。
   5394            else
   5395            {
   5396            }
   5397            */
   5398            
   5399            //直着补，不是顺着补。
   5400            /*
   5401            for (row = Step4StartLine + 1; row <= CameraHight - 1; row++)
   5402            {
   5403              BlackRightLoc[row][0] = BlackRightLoc[Step4StartLine][0];
   5404            }
   5405            */
   5406            
   5407            //顺着补，不是直着补。
   5408            a0 = LeastSquarea0(x, y, a1, BlackBackLineNum);
   \   000001F2   0x2304             MOVS     R3,#+4
   \   000001F4   0x002A             MOVS     R2,R5
   \   000001F6   0xA900             ADD      R1,SP,#+0
   \   000001F8   0xA801             ADD      R0,SP,#+4
   \   000001FA   0x.... 0x....      BL       LeastSquarea0
   5409            
   5410            for(row = Step4StartLine + 1; row <= CameraHight - 1; row++)
   \   000001FE   0x1C61             ADDS     R1,R4,#+1
   \   00000200   0xE00D             B.N      ??BlackRightStep4BackLine_23
   \                     ??BlackRightStep4BackLine_22: (+1)
   \   00000202   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000204   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000206   0x4290             CMP      R0,R2
   \   00000208   0xD1D2             BNE.N    ??BlackRightStep4BackLine_20
   \   0000020A   0x2000             MOVS     R0,#+0
   \   0000020C   0xE031             B.N      ??BlackRightStep4BackLine_6
   5411            {
   5412              //补线也有个度，向右和向左都不能补出范围。
   5413              temp = (a0 + a1 * row) / LeastSquareMulti;
   5414              if(temp >= CameraRealWidth-1)
   5415              {
   5416                //BlackRightLoc[row][0] = CameraRealWidth - 1;
   5417                //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。
   5418                for(j = row; ; j++)
   5419                {
   5420                  BlackRightLoc[j][0] = CameraRealWidth-1;
   5421                  if(j == CameraHight - 1) break;
   5422                }
   5423                break;
   5424              }
   5425              else if(temp <= 0)
   5426              {
   5427                //BlackRightLoc[row][0] = 0;
   5428                //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。我
   5429                for(j = row; ; j++)
   5430                {
   5431                  BlackRightLoc[j][0] = 0;
   5432                  if(j == CameraHight - 1) break;
   5433                }
   5434                break;
   5435              }
   5436              else
   5437              {
   5438                BlackRightLoc[row][0] = (uint8)(temp); 
   \                     ??BlackRightStep4BackLine_24: (+1)
   \   0000020E   0x.... 0x....      LDR.W    R3,??DataTable38_1
   \   00000212   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000214   0x2403             MOVS     R4,#+3
   \   00000216   0xFB04 0x3301      MLA      R3,R4,R1,R3
   \   0000021A   0x701A             STRB     R2,[R3, #+0]
   5439              }
   \   0000021C   0x1C49             ADDS     R1,R1,#+1
   \                     ??BlackRightStep4BackLine_23: (+1)
   \   0000021E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000220   0x293C             CMP      R1,#+60
   \   00000222   0xDA25             BGE.N    ??BlackRightStep4BackLine_25
   \   00000224   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000226   0xFB01 0x0205      MLA      R2,R1,R5,R0
   \   0000022A   0xF44F 0x737A      MOV      R3,#+1000
   \   0000022E   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \   00000232   0x2AF9             CMP      R2,#+249
   \   00000234   0xDB0D             BLT.N    ??BlackRightStep4BackLine_26
   \   00000236   0xE000             B.N      ??BlackRightStep4BackLine_27
   \                     ??BlackRightStep4BackLine_28: (+1)
   \   00000238   0x1C49             ADDS     R1,R1,#+1
   \                     ??BlackRightStep4BackLine_27: (+1)
   \   0000023A   0x20F9             MOVS     R0,#+249
   \   0000023C   0x.... 0x....      LDR.W    R2,??DataTable38_1
   \   00000240   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000242   0x2303             MOVS     R3,#+3
   \   00000244   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000248   0x7010             STRB     R0,[R2, #+0]
   \   0000024A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000024C   0x293B             CMP      R1,#+59
   \   0000024E   0xD1F3             BNE.N    ??BlackRightStep4BackLine_28
   \   00000250   0xE00E             B.N      ??BlackRightStep4BackLine_25
   \                     ??BlackRightStep4BackLine_26: (+1)
   \   00000252   0x2A01             CMP      R2,#+1
   \   00000254   0xDADB             BGE.N    ??BlackRightStep4BackLine_24
   \   00000256   0xE000             B.N      ??BlackRightStep4BackLine_29
   \                     ??BlackRightStep4BackLine_30: (+1)
   \   00000258   0x1C49             ADDS     R1,R1,#+1
   \                     ??BlackRightStep4BackLine_29: (+1)
   \   0000025A   0x2000             MOVS     R0,#+0
   \   0000025C   0x.... 0x....      LDR.W    R2,??DataTable38_1
   \   00000260   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000262   0x2303             MOVS     R3,#+3
   \   00000264   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000268   0x7010             STRB     R0,[R2, #+0]
   \   0000026A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000026C   0x293B             CMP      R1,#+59
   \   0000026E   0xD1F3             BNE.N    ??BlackRightStep4BackLine_30
   5440            }
   5441            
   5442            
   5443            
   5444            return 1;
   \                     ??BlackRightStep4BackLine_25: (+1)
   \   00000270   0x2001             MOVS     R0,#+1
   \                     ??BlackRightStep4BackLine_6: (+1)
   \   00000272   0xBD3E             POP      {R1-R5,PC}       ;; return
   5445            
   5446          }
   5447          
   5448          
   5449          
   5450          
   5451          //右黑线连续性补线

   \                                 In section .text, align 2, keep-with-next
   5452          uint8 BlackRightContinueAdd(void)
   5453          {
   \                     BlackRightContinueAdd: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   5454              uint8 row, i, j;
   5455              uint8 tempfirst, templast;
   5456              uint8 fangHuiWanFlag = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   5457              uint8 fangDuanLieFlag = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   5458              
   5459              //右黑线连续性补线
   5460              //只有右黑线采集成功才补线
   5461              if(BlackRightDone == 1)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable38_17
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xF040 0x81F7      BNE.W    ??BlackRightContinueAdd_0
   5462              {        
   5463                  //找线尾
   5464                  for(row = CameraHight - 1; ; row--)
   \   00000012   0x203B             MOVS     R0,#+59
   \   00000014   0xE000             B.N      ??BlackRightContinueAdd_1
   \                     ??BlackRightContinueAdd_2: (+1)
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   5465                  {
   5466                    if(BlackRightLoc[row][0] != MaxValUint8)
   \                     ??BlackRightContinueAdd_1: (+1)
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable38_1
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x2203             MOVS     R2,#+3
   \   00000020   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   00000024   0x7809             LDRB     R1,[R1, #+0]
   \   00000026   0x29FF             CMP      R1,#+255
   \   00000028   0xD002             BEQ.N    ??BlackRightContinueAdd_3
   5467                    {
   5468                      break;
   5469                    }
   5470                    else
   5471                    {
   5472                    }
   5473                    
   5474                    if(row == 0)
   5475                    {
   5476                      BlackRightDone = 0;
   5477                      return 0;
   5478                    }
   5479                  }
   5480                  
   5481                  //给线头线尾初始化为无效值。
   5482                  tempfirst = MaxValUint8;
   \   0000002A   0x21FF             MOVS     R1,#+255
   5483                  templast = MaxValUint8;
   \   0000002C   0x22FF             MOVS     R2,#+255
   \   0000002E   0xE009             B.N      ??BlackRightContinueAdd_4
   \                     ??BlackRightContinueAdd_3: (+1)
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD1EF             BNE.N    ??BlackRightContinueAdd_2
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable38_17
   \   0000003C   0x7008             STRB     R0,[R1, #+0]
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE1DF             B.N      ??BlackRightContinueAdd_5
   5484                          
   5485                  //开始补线
   5486                  for (; ; row--)
   \                     ??BlackRightContinueAdd_6: (+1)
   \   00000042   0x1E40             SUBS     R0,R0,#+1
   5487                  {
   5488                      if (BlackRightLoc[row][0] == MaxValUint8)
   \                     ??BlackRightContinueAdd_4: (+1)
   \   00000044   0x.... 0x....      LDR.W    R2,??DataTable38_1
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x2303             MOVS     R3,#+3
   \   0000004C   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000050   0x7812             LDRB     R2,[R2, #+0]
   \   00000052   0x2AFF             CMP      R2,#+255
   \   00000054   0xD105             BNE.N    ??BlackRightContinueAdd_7
   5489                      {
   5490                          if (tempfirst == MaxValUint8)
   \   00000056   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000058   0x29FF             CMP      R1,#+255
   \   0000005A   0xF040 0x81CD      BNE.W    ??BlackRightContinueAdd_8
   5491                          {
   5492                              //若线头为无效值，就记录为线头。
   5493                              tempfirst = row + 1;
   \   0000005E   0x1C41             ADDS     R1,R0,#+1
   5494                              break;
   \   00000060   0xE1CE             B.N      ??BlackRightContinueAdd_0
   5495                          }
   5496                          else
   5497                          {
   5498                          }
   5499                      }
   5500                      else
   5501                      {
   5502                          if (tempfirst != MaxValUint8)
   \                     ??BlackRightContinueAdd_7: (+1)
   \   00000062   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000064   0x29FF             CMP      R1,#+255
   \   00000066   0xF000 0x81C7      BEQ.W    ??BlackRightContinueAdd_8
   5503                          {
   5504                              //若线头已经有赋值，则开始记录线尾。
   5505                              templast = row;
   \   0000006A   0x0002             MOVS     R2,R0
   5506                              
   5507                              if (templast > 5)
   \   0000006C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000006E   0x2A06             CMP      R2,#+6
   \   00000070   0xDB2B             BLT.N    ??BlackRightContinueAdd_9
   5508                              {
   5509                                  if (BlackRightLoc[templast - 1][0] != MaxValUint8 && BlackRightLoc[templast - 2][0] != MaxValUint8 && BlackRightLoc[templast - 3][0] != MaxValUint8
   5510                                      && BlackRightLoc[templast - 4][0] != MaxValUint8 )
   \   00000072   0x.... 0x....      LDR.W    R3,??DataTable38_1
   \   00000076   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000078   0x2403             MOVS     R4,#+3
   \   0000007A   0xFB04 0x3302      MLA      R3,R4,R2,R3
   \   0000007E   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   00000082   0x2BFF             CMP      R3,#+255
   \   00000084   0xD01F             BEQ.N    ??BlackRightContinueAdd_10
   \   00000086   0x.... 0x....      LDR.W    R3,??DataTable38_1
   \   0000008A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000008C   0x2403             MOVS     R4,#+3
   \   0000008E   0xFB04 0x3302      MLA      R3,R4,R2,R3
   \   00000092   0xF813 0x3C06      LDRB     R3,[R3, #-6]
   \   00000096   0x2BFF             CMP      R3,#+255
   \   00000098   0xD015             BEQ.N    ??BlackRightContinueAdd_10
   \   0000009A   0x.... 0x....      LDR.W    R3,??DataTable38_1
   \   0000009E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000A0   0x2403             MOVS     R4,#+3
   \   000000A2   0xFB04 0x3302      MLA      R3,R4,R2,R3
   \   000000A6   0xF813 0x3C09      LDRB     R3,[R3, #-9]
   \   000000AA   0x2BFF             CMP      R3,#+255
   \   000000AC   0xD00B             BEQ.N    ??BlackRightContinueAdd_10
   \   000000AE   0x.... 0x....      LDR.W    R3,??DataTable38_1
   \   000000B2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000B4   0x2403             MOVS     R4,#+3
   \   000000B6   0xFB04 0x3302      MLA      R3,R4,R2,R3
   \   000000BA   0xF813 0x3C0C      LDRB     R3,[R3, #-12]
   \   000000BE   0x2BFF             CMP      R3,#+255
   \   000000C0   0xD001             BEQ.N    ??BlackRightContinueAdd_10
   5511                                  {
   5512                                      fangDuanLieFlag = 0;
   \   000000C2   0x2300             MOVS     R3,#+0
   \   000000C4   0xE002             B.N      ??BlackRightContinueAdd_11
   5513                                  }
   5514                                  else
   5515                                  {
   5516                                      fangDuanLieFlag = 1;
   \                     ??BlackRightContinueAdd_10: (+1)
   \   000000C6   0x2301             MOVS     R3,#+1
   \   000000C8   0xE000             B.N      ??BlackRightContinueAdd_11
   5517                                  }
   5518                              }
   5519                              else
   5520                              {
   5521                                  fangDuanLieFlag = 1;
   \                     ??BlackRightContinueAdd_9: (+1)
   \   000000CA   0x2301             MOVS     R3,#+1
   5522                              }
   5523                              if (templast >= 8)
   \                     ??BlackRightContinueAdd_11: (+1)
   \   000000CC   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000CE   0x2A08             CMP      R2,#+8
   \   000000D0   0xDB53             BLT.N    ??BlackRightContinueAdd_12
   5524                              {
   5525                                  if (BlackRightLoc[templast - 1][0] != MaxValUint8 && BlackRightLoc[templast - 2][0] != MaxValUint8 && BlackRightLoc[templast - 3][0] != MaxValUint8
   5526                                      && BlackRightLoc[templast - 4][0] != MaxValUint8 && BlackRightLoc[templast - 5][0] != MaxValUint8
   5527                                          && BlackRightLoc[templast - 6][0] != MaxValUint8 && BlackRightLoc[templast - 7][0] != MaxValUint8 && BlackRightLoc[templast - 8][0] != MaxValUint8)
   \   000000D2   0x.... 0x....      LDR.W    R4,??DataTable38_1
   \   000000D6   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000D8   0x2503             MOVS     R5,#+3
   \   000000DA   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   000000DE   0xF814 0x4C03      LDRB     R4,[R4, #-3]
   \   000000E2   0x2CFF             CMP      R4,#+255
   \   000000E4   0xD047             BEQ.N    ??BlackRightContinueAdd_13
   \   000000E6   0x.... 0x....      LDR.W    R4,??DataTable38_1
   \   000000EA   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000EC   0x2503             MOVS     R5,#+3
   \   000000EE   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   000000F2   0xF814 0x4C06      LDRB     R4,[R4, #-6]
   \   000000F6   0x2CFF             CMP      R4,#+255
   \   000000F8   0xD03D             BEQ.N    ??BlackRightContinueAdd_13
   \   000000FA   0x.... 0x....      LDR.W    R4,??DataTable38_1
   \   000000FE   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000100   0x2503             MOVS     R5,#+3
   \   00000102   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   00000106   0xF814 0x4C09      LDRB     R4,[R4, #-9]
   \   0000010A   0x2CFF             CMP      R4,#+255
   \   0000010C   0xD033             BEQ.N    ??BlackRightContinueAdd_13
   \   0000010E   0x.... 0x....      LDR.W    R4,??DataTable38_1
   \   00000112   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000114   0x2503             MOVS     R5,#+3
   \   00000116   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   0000011A   0xF814 0x4C0C      LDRB     R4,[R4, #-12]
   \   0000011E   0x2CFF             CMP      R4,#+255
   \   00000120   0xD029             BEQ.N    ??BlackRightContinueAdd_13
   \   00000122   0x.... 0x....      LDR.W    R4,??DataTable38_1
   \   00000126   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000128   0x2503             MOVS     R5,#+3
   \   0000012A   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   0000012E   0xF814 0x4C0F      LDRB     R4,[R4, #-15]
   \   00000132   0x2CFF             CMP      R4,#+255
   \   00000134   0xD01F             BEQ.N    ??BlackRightContinueAdd_13
   \   00000136   0x.... 0x....      LDR.W    R4,??DataTable38_1
   \   0000013A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000013C   0x2503             MOVS     R5,#+3
   \   0000013E   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   00000142   0xF814 0x4C12      LDRB     R4,[R4, #-18]
   \   00000146   0x2CFF             CMP      R4,#+255
   \   00000148   0xD015             BEQ.N    ??BlackRightContinueAdd_13
   \   0000014A   0x.... 0x....      LDR.W    R4,??DataTable38_1
   \   0000014E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000150   0x2503             MOVS     R5,#+3
   \   00000152   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   00000156   0xF814 0x4C15      LDRB     R4,[R4, #-21]
   \   0000015A   0x2CFF             CMP      R4,#+255
   \   0000015C   0xD00B             BEQ.N    ??BlackRightContinueAdd_13
   \   0000015E   0x.... 0x....      LDR.W    R4,??DataTable38_1
   \   00000162   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000164   0x2503             MOVS     R5,#+3
   \   00000166   0xFB05 0x4402      MLA      R4,R5,R2,R4
   \   0000016A   0xF814 0x4C18      LDRB     R4,[R4, #-24]
   \   0000016E   0x2CFF             CMP      R4,#+255
   \   00000170   0xD001             BEQ.N    ??BlackRightContinueAdd_13
   5528                                  {
   5529                                      fangHuiWanFlag = 0;
   \   00000172   0x2400             MOVS     R4,#+0
   \   00000174   0xE002             B.N      ??BlackRightContinueAdd_14
   5530                                  }
   5531                                  else
   5532                                  {
   5533                                      fangHuiWanFlag = 1;
   \                     ??BlackRightContinueAdd_13: (+1)
   \   00000176   0x2401             MOVS     R4,#+1
   \   00000178   0xE000             B.N      ??BlackRightContinueAdd_14
   5534                                  }
   5535                              }
   5536                              else
   5537                              {
   5538                                  fangHuiWanFlag = 1;
   \                     ??BlackRightContinueAdd_12: (+1)
   \   0000017A   0x2401             MOVS     R4,#+1
   5539                              }
   5540                              
   5541                              if((BlackRightLoc[tempfirst][0]>=235&&BlackRightLoc[templast][0]>=235) && (tempfirst - templast) <= 12)
   \                     ??BlackRightContinueAdd_14: (+1)
   \   0000017C   0x.... 0x....      LDR.W    R5,??DataTable38_1
   \   00000180   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000182   0x2603             MOVS     R6,#+3
   \   00000184   0xFB06 0x5501      MLA      R5,R6,R1,R5
   \   00000188   0x782D             LDRB     R5,[R5, #+0]
   \   0000018A   0x2DEB             CMP      R5,#+235
   \   0000018C   0xDB2F             BLT.N    ??BlackRightContinueAdd_15
   \   0000018E   0x.... 0x....      LDR.W    R5,??DataTable38_1
   \   00000192   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000194   0x2603             MOVS     R6,#+3
   \   00000196   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   0000019A   0x782D             LDRB     R5,[R5, #+0]
   \   0000019C   0x2DEB             CMP      R5,#+235
   \   0000019E   0xDB26             BLT.N    ??BlackRightContinueAdd_15
   \   000001A0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001A2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001A4   0x1A8D             SUBS     R5,R1,R2
   \   000001A6   0x2D0D             CMP      R5,#+13
   \   000001A8   0xDA21             BGE.N    ??BlackRightContinueAdd_15
   5542                              {
   5543                                  //这种情况是防止黑线太靠镜头边界导致黑线不成功的
   5544                                  for (j = tempfirst - 1; ; j--)
   \   000001AA   0x1E4B             SUBS     R3,R1,#+1
   \   000001AC   0xE000             B.N      ??BlackRightContinueAdd_16
   \                     ??BlackRightContinueAdd_17: (+1)
   \   000001AE   0x1E5B             SUBS     R3,R3,#+1
   5545                                  {
   5546                                      BlackRightLoc[j][0] = (BlackRightLoc[tempfirst][0] + BlackRightLoc[templast][0]) / 2;
   \                     ??BlackRightContinueAdd_16: (+1)
   \   000001B0   0x.... 0x....      LDR.W    R4,??DataTable38_1
   \   000001B4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001B6   0x2503             MOVS     R5,#+3
   \   000001B8   0xFB05 0x4401      MLA      R4,R5,R1,R4
   \   000001BC   0x7824             LDRB     R4,[R4, #+0]
   \   000001BE   0x.... 0x....      LDR.W    R5,??DataTable38_1
   \   000001C2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001C4   0x2603             MOVS     R6,#+3
   \   000001C6   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   000001CA   0x782D             LDRB     R5,[R5, #+0]
   \   000001CC   0x192C             ADDS     R4,R5,R4
   \   000001CE   0x2502             MOVS     R5,#+2
   \   000001D0   0xFB94 0xF4F5      SDIV     R4,R4,R5
   \   000001D4   0x.... 0x....      LDR.W    R5,??DataTable38_1
   \   000001D8   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001DA   0x2603             MOVS     R6,#+3
   \   000001DC   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   000001E0   0x702C             STRB     R4,[R5, #+0]
   5547                                      if (j == templast + 1) break;
   \   000001E2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001E4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001E6   0x1C54             ADDS     R4,R2,#+1
   \   000001E8   0x42A3             CMP      R3,R4
   \   000001EA   0xD1E0             BNE.N    ??BlackRightContinueAdd_17
   \   000001EC   0xE0FE             B.N      ??BlackRightContinueAdd_18
   5548                                  }
   5549                              }
   5550                              else if ((BlackRightLoc[tempfirst][0] >= 235 && BlackRightLoc[templast][0] >= 235) && (tempfirst - templast) <20
   5551                                       && (BlackRightLoc[10][0] != MaxValUint8 || BlackRightLoc[9][0] != MaxValUint8 || BlackRightLoc[8][0] != MaxValUint8 || BlackRightLoc[7][0] != MaxValUint8 || BlackRightLoc[6][0] != MaxValUint8)
   5552                                       && fangHuiWanFlag == 0)
   \                     ??BlackRightContinueAdd_15: (+1)
   \   000001EE   0x.... 0x....      LDR.W    R5,??DataTable38_1
   \   000001F2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001F4   0x2603             MOVS     R6,#+3
   \   000001F6   0xFB06 0x5501      MLA      R5,R6,R1,R5
   \   000001FA   0x782D             LDRB     R5,[R5, #+0]
   \   000001FC   0x2DEB             CMP      R5,#+235
   \   000001FE   0xDB4B             BLT.N    ??BlackRightContinueAdd_19
   \   00000200   0x.... 0x....      LDR.W    R5,??DataTable38_1
   \   00000204   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000206   0x2603             MOVS     R6,#+3
   \   00000208   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   0000020C   0x782D             LDRB     R5,[R5, #+0]
   \   0000020E   0x2DEB             CMP      R5,#+235
   \   00000210   0xDB42             BLT.N    ??BlackRightContinueAdd_19
   \   00000212   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000214   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000216   0x1A8D             SUBS     R5,R1,R2
   \   00000218   0x2D14             CMP      R5,#+20
   \   0000021A   0xDA3D             BGE.N    ??BlackRightContinueAdd_19
   \   0000021C   0x.... 0x....      LDR.W    R5,??DataTable38_1
   \   00000220   0x7FAD             LDRB     R5,[R5, #+30]
   \   00000222   0x2DFF             CMP      R5,#+255
   \   00000224   0xD113             BNE.N    ??BlackRightContinueAdd_20
   \   00000226   0x.... 0x....      LDR.W    R5,??DataTable38_1
   \   0000022A   0x7EED             LDRB     R5,[R5, #+27]
   \   0000022C   0x2DFF             CMP      R5,#+255
   \   0000022E   0xD10E             BNE.N    ??BlackRightContinueAdd_20
   \   00000230   0x.... 0x....      LDR.W    R5,??DataTable38_1
   \   00000234   0x7E2D             LDRB     R5,[R5, #+24]
   \   00000236   0x2DFF             CMP      R5,#+255
   \   00000238   0xD109             BNE.N    ??BlackRightContinueAdd_20
   \   0000023A   0x.... 0x....      LDR.W    R5,??DataTable38_1
   \   0000023E   0x7D6D             LDRB     R5,[R5, #+21]
   \   00000240   0x2DFF             CMP      R5,#+255
   \   00000242   0xD104             BNE.N    ??BlackRightContinueAdd_20
   \   00000244   0x.... 0x....      LDR.W    R5,??DataTable38_1
   \   00000248   0x7CAD             LDRB     R5,[R5, #+18]
   \   0000024A   0x2DFF             CMP      R5,#+255
   \   0000024C   0xD024             BEQ.N    ??BlackRightContinueAdd_19
   \                     ??BlackRightContinueAdd_20: (+1)
   \   0000024E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000250   0x2C00             CMP      R4,#+0
   \   00000252   0xD121             BNE.N    ??BlackRightContinueAdd_19
   5553                              {
   5554                                  //这种情况是防止黑线太靠镜头边界导致黑线不成功的
   5555                                  for (j = tempfirst - 1; ; j--)
   \   00000254   0x1E4B             SUBS     R3,R1,#+1
   \   00000256   0xE000             B.N      ??BlackRightContinueAdd_21
   \                     ??BlackRightContinueAdd_22: (+1)
   \   00000258   0x1E5B             SUBS     R3,R3,#+1
   5556                                  {
   5557                                      BlackRightLoc[j][0] = (BlackRightLoc[tempfirst][0] + BlackRightLoc[templast][0]) / 2;
   \                     ??BlackRightContinueAdd_21: (+1)
   \   0000025A   0x.... 0x....      LDR.W    R4,??DataTable38_1
   \   0000025E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000260   0x2503             MOVS     R5,#+3
   \   00000262   0xFB05 0x4401      MLA      R4,R5,R1,R4
   \   00000266   0x7824             LDRB     R4,[R4, #+0]
   \   00000268   0x.... 0x....      LDR.W    R5,??DataTable38_1
   \   0000026C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000026E   0x2603             MOVS     R6,#+3
   \   00000270   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   00000274   0x782D             LDRB     R5,[R5, #+0]
   \   00000276   0x192C             ADDS     R4,R5,R4
   \   00000278   0x2502             MOVS     R5,#+2
   \   0000027A   0xFB94 0xF4F5      SDIV     R4,R4,R5
   \   0000027E   0x.... 0x....      LDR.W    R5,??DataTable38_1
   \   00000282   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000284   0x2603             MOVS     R6,#+3
   \   00000286   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   0000028A   0x702C             STRB     R4,[R5, #+0]
   5558                                      if (j == templast + 1) break;
   \   0000028C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000028E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000290   0x1C54             ADDS     R4,R2,#+1
   \   00000292   0x42A3             CMP      R3,R4
   \   00000294   0xD1E0             BNE.N    ??BlackRightContinueAdd_22
   \   00000296   0xE0A9             B.N      ??BlackRightContinueAdd_18
   5559                                  }
   5560                              }
   5561                              else if ((BlackRightLoc[tempfirst][0] >= 235 && BlackRightLoc[templast][0] >= 235) && (tempfirst - templast) <= 35
   5562                                       && (BlackRightLoc[6][0] != MaxValUint8 || BlackRightLoc[7][0] != MaxValUint8 || BlackRightLoc[8][0] != MaxValUint8 || BlackRightLoc[10][0] != MaxValUint8 || BlackRightLoc[9][0] != MaxValUint8)
   5563                                       && fangHuiWanFlag == 0)
   \                     ??BlackRightContinueAdd_19: (+1)
   \   00000298   0x.... 0x....      LDR.W    R5,??DataTable38_1
   \   0000029C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000029E   0x2603             MOVS     R6,#+3
   \   000002A0   0xFB06 0x5501      MLA      R5,R6,R1,R5
   \   000002A4   0x782D             LDRB     R5,[R5, #+0]
   \   000002A6   0x2DEB             CMP      R5,#+235
   \   000002A8   0xDB43             BLT.N    ??BlackRightContinueAdd_23
   \   000002AA   0x.... 0x....      LDR.W    R5,??DataTable38_1
   \   000002AE   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000002B0   0x2603             MOVS     R6,#+3
   \   000002B2   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   000002B6   0x782D             LDRB     R5,[R5, #+0]
   \   000002B8   0x2DEB             CMP      R5,#+235
   \   000002BA   0xDB3A             BLT.N    ??BlackRightContinueAdd_23
   \   000002BC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002BE   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000002C0   0x1A8D             SUBS     R5,R1,R2
   \   000002C2   0x2D24             CMP      R5,#+36
   \   000002C4   0xDA35             BGE.N    ??BlackRightContinueAdd_23
   \   000002C6   0x....             LDR.N    R5,??DataTable38_1
   \   000002C8   0x7CAD             LDRB     R5,[R5, #+18]
   \   000002CA   0x2DFF             CMP      R5,#+255
   \   000002CC   0xD10F             BNE.N    ??BlackRightContinueAdd_24
   \   000002CE   0x....             LDR.N    R5,??DataTable38_1
   \   000002D0   0x7D6D             LDRB     R5,[R5, #+21]
   \   000002D2   0x2DFF             CMP      R5,#+255
   \   000002D4   0xD10B             BNE.N    ??BlackRightContinueAdd_24
   \   000002D6   0x....             LDR.N    R5,??DataTable38_1
   \   000002D8   0x7E2D             LDRB     R5,[R5, #+24]
   \   000002DA   0x2DFF             CMP      R5,#+255
   \   000002DC   0xD107             BNE.N    ??BlackRightContinueAdd_24
   \   000002DE   0x....             LDR.N    R5,??DataTable38_1
   \   000002E0   0x7FAD             LDRB     R5,[R5, #+30]
   \   000002E2   0x2DFF             CMP      R5,#+255
   \   000002E4   0xD103             BNE.N    ??BlackRightContinueAdd_24
   \   000002E6   0x....             LDR.N    R5,??DataTable38_1
   \   000002E8   0x7EED             LDRB     R5,[R5, #+27]
   \   000002EA   0x2DFF             CMP      R5,#+255
   \   000002EC   0xD021             BEQ.N    ??BlackRightContinueAdd_23
   \                     ??BlackRightContinueAdd_24: (+1)
   \   000002EE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002F0   0x2C00             CMP      R4,#+0
   \   000002F2   0xD11E             BNE.N    ??BlackRightContinueAdd_23
   5564                              {
   5565                                  //这种情况是防止黑线太靠镜头边界导致黑线不成功的
   5566                                  for (j = tempfirst - 1; ; j--)
   \   000002F4   0x1E4B             SUBS     R3,R1,#+1
   \   000002F6   0xE000             B.N      ??BlackRightContinueAdd_25
   \                     ??BlackRightContinueAdd_26: (+1)
   \   000002F8   0x1E5B             SUBS     R3,R3,#+1
   5567                                  {
   5568                                      BlackRightLoc[j][0] = (BlackRightLoc[tempfirst][0] + BlackRightLoc[templast][0]) / 2;
   \                     ??BlackRightContinueAdd_25: (+1)
   \   000002FA   0x....             LDR.N    R4,??DataTable38_1
   \   000002FC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002FE   0x2503             MOVS     R5,#+3
   \   00000300   0xFB05 0x4401      MLA      R4,R5,R1,R4
   \   00000304   0x7824             LDRB     R4,[R4, #+0]
   \   00000306   0x....             LDR.N    R5,??DataTable38_1
   \   00000308   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000030A   0x2603             MOVS     R6,#+3
   \   0000030C   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   00000310   0x782D             LDRB     R5,[R5, #+0]
   \   00000312   0x192C             ADDS     R4,R5,R4
   \   00000314   0x2502             MOVS     R5,#+2
   \   00000316   0xFB94 0xF4F5      SDIV     R4,R4,R5
   \   0000031A   0x....             LDR.N    R5,??DataTable38_1
   \   0000031C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000031E   0x2603             MOVS     R6,#+3
   \   00000320   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   00000324   0x702C             STRB     R4,[R5, #+0]
   5569                                      if (j == templast + 1) break;
   \   00000326   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000328   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000032A   0x1C54             ADDS     R4,R2,#+1
   \   0000032C   0x42A3             CMP      R3,R4
   \   0000032E   0xD1E3             BNE.N    ??BlackRightContinueAdd_26
   \   00000330   0xE05C             B.N      ??BlackRightContinueAdd_18
   5570                                  }
   5571                              }
   5572                              //防边线断裂的
   5573                              else if (tempfirst - templast <= 5 && fangDuanLieFlag == 0)
   \                     ??BlackRightContinueAdd_23: (+1)
   \   00000332   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000334   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000336   0x1A8C             SUBS     R4,R1,R2
   \   00000338   0x2C06             CMP      R4,#+6
   \   0000033A   0xDA21             BGE.N    ??BlackRightContinueAdd_27
   \   0000033C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000033E   0x2B00             CMP      R3,#+0
   \   00000340   0xD11E             BNE.N    ??BlackRightContinueAdd_27
   5574                              {
   5575                                  for (j = tempfirst - 1; ; j--)
   \   00000342   0x1E4B             SUBS     R3,R1,#+1
   \   00000344   0xE000             B.N      ??BlackRightContinueAdd_28
   \                     ??BlackRightContinueAdd_29: (+1)
   \   00000346   0x1E5B             SUBS     R3,R3,#+1
   5576                                  {
   5577                                      BlackRightLoc[j][0] = (BlackRightLoc[tempfirst][0] + BlackRightLoc[templast][0]) / 2;
   \                     ??BlackRightContinueAdd_28: (+1)
   \   00000348   0x....             LDR.N    R4,??DataTable38_1
   \   0000034A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000034C   0x2503             MOVS     R5,#+3
   \   0000034E   0xFB05 0x4401      MLA      R4,R5,R1,R4
   \   00000352   0x7824             LDRB     R4,[R4, #+0]
   \   00000354   0x....             LDR.N    R5,??DataTable38_1
   \   00000356   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000358   0x2603             MOVS     R6,#+3
   \   0000035A   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   0000035E   0x782D             LDRB     R5,[R5, #+0]
   \   00000360   0x192C             ADDS     R4,R5,R4
   \   00000362   0x2502             MOVS     R5,#+2
   \   00000364   0xFB94 0xF4F5      SDIV     R4,R4,R5
   \   00000368   0x....             LDR.N    R5,??DataTable38_1
   \   0000036A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000036C   0x2603             MOVS     R6,#+3
   \   0000036E   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   00000372   0x702C             STRB     R4,[R5, #+0]
   5578                                      if (j == templast + 1) break;
   \   00000374   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000376   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000378   0x1C54             ADDS     R4,R2,#+1
   \   0000037A   0x42A3             CMP      R3,R4
   \   0000037C   0xD1E3             BNE.N    ??BlackRightContinueAdd_29
   \   0000037E   0xE035             B.N      ??BlackRightContinueAdd_18
   5579                                  }
   5580                              }
   5581                              else if(tempfirst - templast >= 3) 
   \                     ??BlackRightContinueAdd_27: (+1)
   \   00000380   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000382   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000384   0x1A8B             SUBS     R3,R1,R2
   \   00000386   0x2B03             CMP      R3,#+3
   \   00000388   0xDB12             BLT.N    ??BlackRightContinueAdd_30
   5582                              {
   5583                                //两者相差太多，则后面的行全部视为错误。
   5584                                for(i = tempfirst - 1; ; i--)
   \   0000038A   0x1E48             SUBS     R0,R1,#+1
   \   0000038C   0xE000             B.N      ??BlackRightContinueAdd_31
   \                     ??BlackRightContinueAdd_32: (+1)
   \   0000038E   0x1E40             SUBS     R0,R0,#+1
   5585                                {
   5586                                  BlackRightLoc[i][0] = MaxValUint8;
   \                     ??BlackRightContinueAdd_31: (+1)
   \   00000390   0x21FF             MOVS     R1,#+255
   \   00000392   0x....             LDR.N    R2,??DataTable38_1
   \   00000394   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000396   0x2303             MOVS     R3,#+3
   \   00000398   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000039C   0x7011             STRB     R1,[R2, #+0]
   5587                                  if(i == 0) break;
   \   0000039E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003A0   0x2800             CMP      R0,#+0
   \   000003A2   0xD1F4             BNE.N    ??BlackRightContinueAdd_32
   5588                                }
   5589                                //右黑线连续性标志出错。
   5590                                BlackRightContinueFlag = 2;
   \   000003A4   0x2002             MOVS     R0,#+2
   \   000003A6   0x.... 0x....      LDR.W    R1,??DataTable40
   \   000003AA   0x7008             STRB     R0,[R1, #+0]
   5591                                return 0;
   \   000003AC   0x2000             MOVS     R0,#+0
   \   000003AE   0xE028             B.N      ??BlackRightContinueAdd_5
   5592                              }
   5593                              else
   5594                              {
   5595                                //一共才1或2个点，直接插值就行。
   5596                                for(j = tempfirst - 1; ; j--)
   \                     ??BlackRightContinueAdd_30: (+1)
   \   000003B0   0x1E4B             SUBS     R3,R1,#+1
   \   000003B2   0xE000             B.N      ??BlackRightContinueAdd_33
   \                     ??BlackRightContinueAdd_34: (+1)
   \   000003B4   0x1E5B             SUBS     R3,R3,#+1
   5597                                {
   5598                                  BlackRightLoc[j][0] = (BlackRightLoc[tempfirst][0] + BlackRightLoc[templast][0]) / 2;
   \                     ??BlackRightContinueAdd_33: (+1)
   \   000003B6   0x....             LDR.N    R4,??DataTable38_1
   \   000003B8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000003BA   0x2503             MOVS     R5,#+3
   \   000003BC   0xFB05 0x4401      MLA      R4,R5,R1,R4
   \   000003C0   0x7824             LDRB     R4,[R4, #+0]
   \   000003C2   0x....             LDR.N    R5,??DataTable38_1
   \   000003C4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000003C6   0x2603             MOVS     R6,#+3
   \   000003C8   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   000003CC   0x782D             LDRB     R5,[R5, #+0]
   \   000003CE   0x192C             ADDS     R4,R5,R4
   \   000003D0   0x2502             MOVS     R5,#+2
   \   000003D2   0xFB94 0xF4F5      SDIV     R4,R4,R5
   \   000003D6   0x....             LDR.N    R5,??DataTable38_1
   \   000003D8   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000003DA   0x2603             MOVS     R6,#+3
   \   000003DC   0xFB06 0x5503      MLA      R5,R6,R3,R5
   \   000003E0   0x702C             STRB     R4,[R5, #+0]
   5599                                  if(j == templast + 1) break;
   \   000003E2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000003E4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000003E6   0x1C54             ADDS     R4,R2,#+1
   \   000003E8   0x42A3             CMP      R3,R4
   \   000003EA   0xD1E3             BNE.N    ??BlackRightContinueAdd_34
   5600                                }
   5601                              }
   5602                              tempfirst = MaxValUint8;
   \                     ??BlackRightContinueAdd_18: (+1)
   \   000003EC   0x21FF             MOVS     R1,#+255
   5603                              templast = MaxValUint8;
   \   000003EE   0x22FF             MOVS     R2,#+255
   5604                              //右黑线连续性标志置0，不连续。
   5605                              BlackRightContinueFlag = 0;
   \   000003F0   0x2200             MOVS     R2,#+0
   \   000003F2   0x.... 0x....      LDR.W    R3,??DataTable40
   \   000003F6   0x701A             STRB     R2,[R3, #+0]
   5606                          }
   5607                          else
   5608                          {
   5609                          }
   5610                      }
   5611          
   5612                      if (row == 0) break;
   \                     ??BlackRightContinueAdd_8: (+1)
   \   000003F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003FA   0x2800             CMP      R0,#+0
   \   000003FC   0xF47F 0xAE21      BNE.W    ??BlackRightContinueAdd_6
   5613                  }
   5614              }
   5615              else
   5616              {
   5617              }    
   5618              
   5619              return 1;
   \                     ??BlackRightContinueAdd_0: (+1)
   \   00000400   0x2001             MOVS     R0,#+1
   \                     ??BlackRightContinueAdd_5: (+1)
   \   00000402   0xBC70             POP      {R4-R6}
   \   00000404   0x4770             BX       LR               ;; return
   5620          }
   5621          
   5622          
   5623          
   5624          //右黑线的回弯特殊检测。进来前BlackRightDone已经置为1了。
   5625          //进来前已经进行左、右黑线的斜曲率检测。

   \                                 In section .text, align 2, keep-with-next
   5626          uint8 BlackRightRollCheck(void)
   5627          {
   5628            uint8 temp1, temp2, temp3;
   5629            
   5630            //当前为单线，不进行回弯特殊检测。
   5631            if(SingleBlackAllFlag == 1) return 1;
   \                     BlackRightRollCheck: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable40_1
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??BlackRightRollCheck_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE046             B.N      ??BlackRightRollCheck_1
   5632            
   5633            //斜率确认。
   5634            //若无效，直接确认。
   5635            if(SlopeR == MaxValInt16)
   \                     ??BlackRightRollCheck_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable40_2
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF647 0x71FF      MOVW     R1,#+32767
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD101             BNE.N    ??BlackRightRollCheck_2
   5636            {
   5637              temp1 = 1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE008             B.N      ??BlackRightRollCheck_3
   5638            }
   5639            else
   5640            {
   5641              //斜率的确太大。
   5642              if(SlopeR > BlackRightRollSlopeLimit)
   \                     ??BlackRightRollCheck_2: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable40_2
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   0000002A   0xDD01             BLE.N    ??BlackRightRollCheck_4
   5643              {
   5644                temp1 = 1;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE000             B.N      ??BlackRightRollCheck_3
   5645              }
   5646              //斜率不大。
   5647              else
   5648              {
   5649                temp1 = 0;
   \                     ??BlackRightRollCheck_4: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   5650              }
   5651            }
   5652            
   5653            //线长度确认。
   5654            //若无效，直接确认。
   5655            if(BlackRightHeadLine == MaxValUint8 || BlackRightEndLine == MaxValUint8)
   \                     ??BlackRightRollCheck_3: (+1)
   \   00000032   0x....             LDR.N    R1,??DataTable38_12
   \   00000034   0x7809             LDRB     R1,[R1, #+0]
   \   00000036   0x29FF             CMP      R1,#+255
   \   00000038   0xD003             BEQ.N    ??BlackRightRollCheck_5
   \   0000003A   0x....             LDR.N    R1,??DataTable38_11
   \   0000003C   0x7809             LDRB     R1,[R1, #+0]
   \   0000003E   0x29FF             CMP      R1,#+255
   \   00000040   0xD101             BNE.N    ??BlackRightRollCheck_6
   5656            {
   5657              temp2 = 1;
   \                     ??BlackRightRollCheck_5: (+1)
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0xE009             B.N      ??BlackRightRollCheck_7
   5658            }
   5659            else
   5660            {
   5661              //线确实很短。
   5662              if(BlackRightEndLine - BlackRightHeadLine < BlackRightRollLengthLimit)
   \                     ??BlackRightRollCheck_6: (+1)
   \   00000046   0x....             LDR.N    R1,??DataTable38_11
   \   00000048   0x7809             LDRB     R1,[R1, #+0]
   \   0000004A   0x....             LDR.N    R2,??DataTable38_12
   \   0000004C   0x7812             LDRB     R2,[R2, #+0]
   \   0000004E   0x1A89             SUBS     R1,R1,R2
   \   00000050   0x2908             CMP      R1,#+8
   \   00000052   0xDA01             BGE.N    ??BlackRightRollCheck_8
   5663              {
   5664                temp2 = 1;
   \   00000054   0x2101             MOVS     R1,#+1
   \   00000056   0xE000             B.N      ??BlackRightRollCheck_7
   5665              }
   5666              //线很长。
   5667              else
   5668              {
   5669                temp2 = 0;
   \                     ??BlackRightRollCheck_8: (+1)
   \   00000058   0x2100             MOVS     R1,#+0
   5670              }
   5671            }
   5672            
   5673            /*
   5674            //左线斜率确认。
   5675            //左线必须是右上到左下的，也就是负的斜率。而且斜率要求绝对值比较大。才能说明是270等大弯。
   5676            if(SlopeL == MaxValInt16)
   5677            {
   5678              temp3 = 1;    
   5679            }
   5680            else
   5681            {
   5682              if(SlopeL + BlackRightRollSlopeLLimit < 0)
   5683              {
   5684                temp3 = 1;
   5685              }
   5686              else
   5687              {
   5688                temp3 = 0;
   5689              }
   5690            }  
   5691            */
   5692            temp3 = 1;
   \                     ??BlackRightRollCheck_7: (+1)
   \   0000005A   0x2201             MOVS     R2,#+1
   5693            
   5694            if(
   5695              (BlackRightStep4Flag == 3 || SingleBlackLastAllFlag == 1)   //右向后补线标志，出错。或者因为上幅图像是单线，无法开启十字，无法置向后补线出错。
   5696            &&(BlackRightCrossDone == 1 || BlackRightCrossDone == 0)   //右十字标志，失败。或者未进入（线尾过高不会进行十字再检测）。
   5697            &&(temp1 == 1)                //斜率很大。
   5698            &&(temp2 == 1)                //线很短。
   5699            &&(temp3 == 1)                //右线
   5700              )
   \   0000005C   0x.... 0x....      LDR.W    R3,??DataTable40_3
   \   00000060   0x781B             LDRB     R3,[R3, #+0]
   \   00000062   0x2B03             CMP      R3,#+3
   \   00000064   0xD004             BEQ.N    ??BlackRightRollCheck_9
   \   00000066   0x.... 0x....      LDR.W    R3,??DataTable40_4
   \   0000006A   0x781B             LDRB     R3,[R3, #+0]
   \   0000006C   0x2B01             CMP      R3,#+1
   \   0000006E   0xD114             BNE.N    ??BlackRightRollCheck_10
   \                     ??BlackRightRollCheck_9: (+1)
   \   00000070   0x.... 0x....      LDR.W    R3,??DataTable40_5
   \   00000074   0x781B             LDRB     R3,[R3, #+0]
   \   00000076   0x2B01             CMP      R3,#+1
   \   00000078   0xD004             BEQ.N    ??BlackRightRollCheck_11
   \   0000007A   0x.... 0x....      LDR.W    R3,??DataTable40_5
   \   0000007E   0x781B             LDRB     R3,[R3, #+0]
   \   00000080   0x2B00             CMP      R3,#+0
   \   00000082   0xD10A             BNE.N    ??BlackRightRollCheck_10
   \                     ??BlackRightRollCheck_11: (+1)
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0x2801             CMP      R0,#+1
   \   00000088   0xD107             BNE.N    ??BlackRightRollCheck_10
   \   0000008A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008C   0x2901             CMP      R1,#+1
   \   0000008E   0xD104             BNE.N    ??BlackRightRollCheck_10
   \   00000090   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000092   0x2A01             CMP      R2,#+1
   \   00000094   0xD101             BNE.N    ??BlackRightRollCheck_10
   5701            {
   5702              //检测到回弯，返回0.
   5703              return 0;   
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xE000             B.N      ??BlackRightRollCheck_1
   5704            }
   5705            else
   5706            {
   5707              //没检测到回弯，返回1.
   5708              return 1;
   \                     ??BlackRightRollCheck_10: (+1)
   \   0000009A   0x2001             MOVS     R0,#+1
   \                     ??BlackRightRollCheck_1: (+1)
   \   0000009C   0x4770             BX       LR               ;; return
   5709            }
   5710          
   5711          }
   5712          
   5713          //向后补线标志出错时的检查，这个函数是防止回弯的很重要的函数。

   \                                 In section .text, align 2, keep-with-next
   5714          uint8 BlackRightStep4ErrorCheck(void)
   5715          {
   \                     BlackRightStep4ErrorCheck: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   5716            uint8 i;
   5717            
   5718            //检查斜率是不是都满足直线
   5719            for(i = 0; ; i++)
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE000             B.N      ??BlackRightStep4ErrorCheck_0
   \                     ??BlackRightStep4ErrorCheck_1: (+1)
   \   00000006   0x1C64             ADDS     R4,R4,#+1
   5720            {
   5721              if(BlackRight5Slope[i] == MaxValInt16) return 0;
   \                     ??BlackRightStep4ErrorCheck_0: (+1)
   \   00000008   0x....             LDR.N    R0,??DataTable38_9
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000010   0xF647 0x71FF      MOVW     R1,#+32767
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD101             BNE.N    ??BlackRightStep4ErrorCheck_2
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE00F             B.N      ??BlackRightStep4ErrorCheck_3
   5722              
   5723              if(AbsInt(BlackRight5Slope[i]) > PathJudgeStraightSlopeLimit)
   \                     ??BlackRightStep4ErrorCheck_2: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable38_9
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000024   0x.... 0x....      BL       AbsInt
   \   00000028   0xF640 0x0135      MOVW     R1,#+2101
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xDB01             BLT.N    ??BlackRightStep4ErrorCheck_4
   5724              {
   5725                return 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE003             B.N      ??BlackRightStep4ErrorCheck_3
   5726              }
   5727              else
   5728              {      
   5729              }
   5730              
   5731              if(i == 5) break;
   \                     ??BlackRightStep4ErrorCheck_4: (+1)
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x2C05             CMP      R4,#+5
   \   00000038   0xD1E5             BNE.N    ??BlackRightStep4ErrorCheck_1
   5732            }
   5733            
   5734            return 1;
   \   0000003A   0x2001             MOVS     R0,#+1
   \                     ??BlackRightStep4ErrorCheck_3: (+1)
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   5735            
   5736          }
   5737          
   5738          
   5739          
   5740          //右黑线提取前的参数初始化赋值

   \                                 In section .text, align 2, keep-with-next
   5741          uint8 BlackGetRightParaInit(void)
   5742          {
   5743            uint8 i;  
   5744            
   5745            //右线连续性标志。默认为1连续。
   5746            BlackRightContinueFlag = 1;  
   \                     BlackGetRightParaInit: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable40
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   5747            
   5748            //采集成功标志位
   5749            BlackRightDone = 1;  
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x....             LDR.N    R1,??DataTable38_17
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
   5750           
   5751            //右十字线头标志。0未进入，1超范围，2成功。
   5752            BlackRightCrossConfirmFlag = 0;  //默认为未进入。  
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             LDR.N    R1,??DataTable38_2
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   5753            
   5754            //小5点斜率储存数组置初始值。
   5755            BlackRight5SlopeIndex = 0;  
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR.N    R1,??DataTable38_14
   \   00000018   0x7008             STRB     R0,[R1, #+0]
   5756            for(i = 0; ; i++)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE000             B.N      ??BlackGetRightParaInit_0
   \                     ??BlackGetRightParaInit_1: (+1)
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   5757            {
   5758                BlackRight5Slope[i] = MaxValInt16;
   \                     ??BlackGetRightParaInit_0: (+1)
   \   00000020   0xF647 0x71FF      MOVW     R1,#+32767
   \   00000024   0x....             LDR.N    R2,??DataTable38_9
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   5759                BlackRight5SlopeRow[i] = MaxValUint8;
   \   0000002C   0x21FF             MOVS     R1,#+255
   \   0000002E   0x....             LDR.N    R2,??DataTable38_15
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x5481             STRB     R1,[R0, R2]
   5760                if(i == CameraHight - 1) break;
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x283B             CMP      R0,#+59
   \   00000038   0xD1F1             BNE.N    ??BlackGetRightParaInit_1
   5761            }  
   5762            
   5763            //回弯检测
   5764            BlackRightRollCheckFlag = 0;        //检测到回弯。
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable40_6
   \   00000040   0x7008             STRB     R0,[R1, #+0]
   5765            BlackRightBigChangeJumpFlag = 0;    //回弯跳过标志。
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable40_7
   \   00000048   0x7008             STRB     R0,[R1, #+0]
   5766          
   5767            //大斜率检测时，每幅图像的初始值初始化为无效值。
   5768            for(i = 0; i <= 4; i++)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xE00A             B.N      ??BlackGetRightParaInit_2
   5769            {
   5770              BlackRightBigChangeNumx[i] = MaxValUint8;
   \                     ??BlackGetRightParaInit_3: (+1)
   \   0000004E   0x21FF             MOVS     R1,#+255
   \   00000050   0x.... 0x....      LDR.W    R2,??DataTable40_8
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x5481             STRB     R1,[R0, R2]
   5771              BlackRightBigChangeNumy[i] = MaxValUint8; 
   \   00000058   0x21FF             MOVS     R1,#+255
   \   0000005A   0x.... 0x....      LDR.W    R2,??DataTable40_9
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x5481             STRB     R1,[R0, R2]
   5772            }
   \   00000062   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackGetRightParaInit_2: (+1)
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0x2805             CMP      R0,#+5
   \   00000068   0xDBF1             BLT.N    ??BlackGetRightParaInit_3
   5773            BlackRightBigChangeFlag = 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable40_10
   \   00000070   0x7008             STRB     R0,[R1, #+0]
   5774            BlackRightBigChangeSlopeStore = MaxValInt16;
   \   00000072   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable40_11
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   5775          
   5776            //大斜率检测时，每行的大跳变标志置0.
   5777            for(i = 0; ; i++)
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xE000             B.N      ??BlackGetRightParaInit_4
   \                     ??BlackGetRightParaInit_5: (+1)
   \   00000080   0x1C40             ADDS     R0,R0,#+1
   5778            {
   5779              BlackRightBigChangeCheckRow[i] = 0;
   \                     ??BlackGetRightParaInit_4: (+1)
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x.... 0x....      LDR.W    R2,??DataTable40_12
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0x5481             STRB     R1,[R0, R2]
   5780              if(i == CameraHight - 1) break;
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0x283B             CMP      R0,#+59
   \   00000090   0xD1F6             BNE.N    ??BlackGetRightParaInit_5
   5781            }
   5782            BlackRightBigChangeCheckAllRow = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable40_13
   \   00000098   0x7008             STRB     R0,[R1, #+0]
   5783          
   5784            //右黑线储存数组初始化为无效值。
   5785            for(i = 0; ; i++)
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xE000             B.N      ??BlackGetRightParaInit_6
   \                     ??BlackGetRightParaInit_7: (+1)
   \   0000009E   0x1C40             ADDS     R0,R0,#+1
   5786            {
   5787              BlackRightLoc[i][0] = MaxValUint8;
   \                     ??BlackGetRightParaInit_6: (+1)
   \   000000A0   0x21FF             MOVS     R1,#+255
   \   000000A2   0x....             LDR.N    R2,??DataTable38_1
   \   000000A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A6   0x2303             MOVS     R3,#+3
   \   000000A8   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000AC   0x7011             STRB     R1,[R2, #+0]
   5788              if(i == CameraHight - 1) break;
   \   000000AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B0   0x283B             CMP      R0,#+59
   \   000000B2   0xD1F4             BNE.N    ??BlackGetRightParaInit_7
   5789            }
   5790          
   5791            //十字外尾
   5792            BlackRightCrossTailFlag = 2;       //十字外尾标志，0失败，1确认，2未进入。
   \   000000B4   0x2002             MOVS     R0,#+2
   \   000000B6   0x....             LDR.N    R1,??DataTable38_10
   \   000000B8   0x7008             STRB     R0,[R1, #+0]
   5793          
   5794            //窗口预测值管理
   5795            for(i = 0; ; i++)
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xE000             B.N      ??BlackGetRightParaInit_8
   \                     ??BlackGetRightParaInit_9: (+1)
   \   000000BE   0x1C40             ADDS     R0,R0,#+1
   5796            {
   5797              BlackRightPredictL[i] = MaxValUint8;
   \                     ??BlackGetRightParaInit_8: (+1)
   \   000000C0   0x21FF             MOVS     R1,#+255
   \   000000C2   0x.... 0x....      LDR.W    R2,??DataTable40_14
   \   000000C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C8   0x5481             STRB     R1,[R0, R2]
   5798              BlackRightPredictR[i] = MaxValUint8; 
   \   000000CA   0x21FF             MOVS     R1,#+255
   \   000000CC   0x.... 0x....      LDR.W    R2,??DataTable40_15
   \   000000D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D2   0x5481             STRB     R1,[R0, R2]
   5799              if(i == CameraHight - 1) break;
   \   000000D4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D6   0x283B             CMP      R0,#+59
   \   000000D8   0xD1F1             BNE.N    ??BlackGetRightParaInit_9
   5800            }
   5801          
   5802            //窗口预测储存值
   5803            BlackRightWinPredictStore0 = MaxValUint8;
   \   000000DA   0x20FF             MOVS     R0,#+255
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable40_16
   \   000000E0   0x7008             STRB     R0,[R1, #+0]
   5804            BlackRightWinPredictStore1 = MaxValUint8;
   \   000000E2   0x20FF             MOVS     R0,#+255
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable40_17
   \   000000E8   0x7008             STRB     R0,[R1, #+0]
   5805            BlackRightWinPredictStore2 = MaxValUint8;
   \   000000EA   0x20FF             MOVS     R0,#+255
   \   000000EC   0x....             LDR.N    R1,??DataTable38
   \   000000EE   0x7008             STRB     R0,[R1, #+0]
   5806            
   5807            //第4阶段进入标志置为未进入。
   5808            BlackRightStep4Flag = 0;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable40_3
   \   000000F6   0x7008             STRB     R0,[R1, #+0]
   5809            BlackRightStep4StartLine = MaxValUint8;
   \   000000F8   0x20FF             MOVS     R0,#+255
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable40_18
   \   000000FE   0x7008             STRB     R0,[R1, #+0]
   5810            //默认十字检测标志置为未进入。
   5811            BlackRightCrossDone = 0;
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable40_5
   \   00000106   0x7008             STRB     R0,[R1, #+0]
   5812              
   5813            return 1;
   \   00000108   0x2001             MOVS     R0,#+1
   \   0000010A   0x4770             BX       LR               ;; return
   5814          }
   5815          
   5816          
   5817          //======================================================================
   5818          //函数名：BlackGetRight
   5819          //功  能：右黑线提取算法
   5820          //参  数：无
   5821          //返  回：1成功 0失败
   5822          //影  响：BlackRightCrossDone，BlackRightLoc[][],
   5823          //        BlackRightRealWB[], BlackRightRealW[], BlackRightRealB[],
   5824          //        LimitRightWB, LimitRightW, LimitRightB
   5825          //说  明：1. 暂时可以处理直道，弯道，十字路口3种情况。2014.11.10
   5826          //      
   5827          //       
   5828          //       
   5829          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   5830          uint8 BlackGetRight(void)
   5831          {
   \                     BlackGetRight: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   5832              uint8 row, temp, temp1, temp2, temp3, i;
   5833              uint8 GapCount, Row1RealLastLine, index, index1;
   5834              uint8 tempWB, tempW, tempB;
   5835              uint8 tempminus;
   5836              uint8 successRow = MaxValUint8;
   \   00000004   0xF04F 0x0AFF      MOV      R10,#+255
   5837              
   5838              int temp001;
   5839              
   5840              //右黑线提取时的参数初始化赋值
   5841              BlackGetRightParaInit();     
   \   00000008   0x.... 0x....      BL       BlackGetRightParaInit
   5842              
   5843              //第1阶段。这1阶段有可能会返回黑线提取失败
   5844              
   5845              //每幅有效图像的线头的3个阈值单独储存。Step1Scan前调用前一幅有效图像保存的3个阈值。
   5846              LimitRightWB = LimitRightHeadWB;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable40_19
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable40_20
   \   00000016   0x7008             STRB     R0,[R1, #+0]
   5847              LimitRightW = LimitRightHeadW;
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable40_21
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable40_22
   \   00000022   0x7008             STRB     R0,[R1, #+0]
   5848              LimitRightB = LimitRightHeadB;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable40_23
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable40_24
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
   5849                      
   5850              temp = BlackGetRightStep1Scan(CameraHight - 1, CameraHight - BlackStep1Size - 1, 1);
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x210B             MOVS     R1,#+11
   \   00000034   0x203B             MOVS     R0,#+59
   \   00000036   0x.... 0x....      BL       BlackGetRightStep1Scan
   \   0000003A   0x0004             MOVS     R4,R0
   5851              BlackRightStep1ScanRow = temp;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable40_25
   \   00000040   0x7004             STRB     R4,[R0, #+0]
   5852              
   5853              //左线开始扫描的情况下，右线尾比左线头高，直接返回失败。增加后面这个条件是为了防止十字误判。
   5854          //    if(
   5855          //       (BlackGetPreDir == 0 || BlackGetPreDir == 2)
   5856          //     &&(temp <= BlackLeftHeadLine)
   5857          //     &&(BlackLeftHeadLine < CameraHight - 7)
   5858          //      )
   5859          //    {
   5860          //        BlackRightLoc[temp][0] = MaxValUint8;
   5861          //        BlackRightLoc[temp - 1][0] = MaxValUint8;
   5862          //        return 0;
   5863          //    }
   5864          //    else
   5865          //    {
   5866          //    }
   5867              
   5868              if(temp == MaxValUint8)
   \   00000042   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000044   0x2CFF             CMP      R4,#+255
   \   00000046   0xD101             BNE.N    ??BlackGetRight_0
   5869              {
   5870                return 0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE2FB             B.N      ??BlackGetRight_1
   5871              }
   5872              else
   5873              {   
   5874                //每幅有效图像的线头的3个阈值单独储存。若线头提取成功，则该幅图像有效，线头3个阈值更新。
   5875                LimitRightHeadWB = LimitRightWB;
   \                     ??BlackGetRight_0: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable40_20
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable40_19
   \   00000056   0x7008             STRB     R0,[R1, #+0]
   5876                LimitRightHeadW = LimitRightW;
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable40_22
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable40_21
   \   00000062   0x7008             STRB     R0,[R1, #+0]
   5877                LimitRightHeadB = LimitRightB;
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable40_24
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable40_23
   \   0000006E   0x7008             STRB     R0,[R1, #+0]
   5878                
   5879                row = temp;
   \   00000070   0x0025             MOVS     R5,R4
   5880                //如果起始线头的位置非常高，就认为是十字的前两个角，需要进入第4阶段向后补线。    
   5881                if(row < CameraHight - BlackRightBackLineStart)
   \   00000072   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000074   0x2D0C             CMP      R5,#+12
   \   00000076   0xDA06             BGE.N    ??BlackGetRight_2
   5882                {
   5883                  BlackRightStep4Flag = 1;             //默认为失败。
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable40_3
   \   0000007E   0x7008             STRB     R0,[R1, #+0]
   5884                  BlackRightStep4StartLine = row;
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable40_18
   \   00000084   0x7005             STRB     R5,[R0, #+0]
   5885                }
   5886          
   5887              }
   5888                
   5889              //第2阶段。到了这一阶段，已经不会返回黑线提取失败 
   5890              //下面开始利用斜率找黑点。
   5891              //上次已经处理完了第row-1行，下一次要处理第row-2行
   5892              //BlackRightSlope();
   5893              
   5894              //temp为预测的黑点位置
   5895              //对预测值进行限定。
   5896              temp = BoundaryLimitRe(BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0],
   5897                                     0,
   5898                                     CameraRealWidth - 1);    
   \                     ??BlackGetRight_2: (+1)
   \   00000086   0x22F9             MOVS     R2,#+249
   \   00000088   0x2100             MOVS     R1,#+0
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable40_26
   \   0000008E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000090   0x2303             MOVS     R3,#+3
   \   00000092   0xFB03 0x0005      MLA      R0,R3,R5,R0
   \   00000096   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000009A   0x.... 0x....      LDR.W    R3,??DataTable40_26
   \   0000009E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A0   0x2403             MOVS     R4,#+3
   \   000000A2   0xFB04 0x3305      MLA      R3,R4,R5,R3
   \   000000A6   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   000000AA   0xFA53 0xF080      UXTAB    R0,R3,R0
   \   000000AE   0x.... 0x....      LDR.W    R3,??DataTable40_26
   \   000000B2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B4   0x2403             MOVS     R4,#+3
   \   000000B6   0xFB04 0x3305      MLA      R3,R4,R5,R3
   \   000000BA   0x781B             LDRB     R3,[R3, #+0]
   \   000000BC   0x1AC0             SUBS     R0,R0,R3
   \   000000BE   0x.... 0x....      BL       BoundaryLimitRe
   \   000000C2   0x0004             MOVS     R4,R0
   5899              //预测值更新后就刷新一次堆栈，堆栈顶部丢失。
   5900              BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable40_17
   \   000000C8   0x7800             LDRB     R0,[R0, #+0]
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable40_16
   \   000000CE   0x7008             STRB     R0,[R1, #+0]
   5901              BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable40_27
   \   000000D4   0x7800             LDRB     R0,[R0, #+0]
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable40_17
   \   000000DA   0x7008             STRB     R0,[R1, #+0]
   5902              BlackRightWinPredictStore2 = temp;
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable40_27
   \   000000E0   0x7004             STRB     R4,[R0, #+0]
   5903                  
   5904              index = 0;
   \   000000E2   0xF05F 0x0800      MOVS     R8,#+0
   5905              index1 = 0;
   \   000000E6   0xF05F 0x0900      MOVS     R9,#+0
   5906              
   5907              GapCount = 0;  //连续多少行没有采到黑线
   \   000000EA   0x2600             MOVS     R6,#+0
   5908              successRow = MaxValUint8; //记录最后一次成功的行
   \   000000EC   0xF04F 0x0AFF      MOV      R10,#+255
   5909              //从最近的认证行到取最远的行
   5910              for(row -= 2; ; row -= 2)
   \   000000F0   0x1EAD             SUBS     R5,R5,#+2
   \   000000F2   0xE000             B.N      ??BlackGetRight_3
   \                     ??BlackGetRight_4: (+1)
   \   000000F4   0x1EAD             SUBS     R5,R5,#+2
   5911              {  
   5912                //连续2行检测黑点位置。     
   5913                //近处的行已经将单线标志置位，则检测到左黑线头即可返回。
   5914                if(SingleBlackAllFlag == 1 && row < BlackLeftHeadLine) return 1;
   \                     ??BlackGetRight_3: (+1)
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable40_1
   \   000000FA   0x7800             LDRB     R0,[R0, #+0]
   \   000000FC   0x2801             CMP      R0,#+1
   \   000000FE   0xD107             BNE.N    ??BlackGetRight_5
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable40_28
   \   00000104   0x7800             LDRB     R0,[R0, #+0]
   \   00000106   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000108   0x4285             CMP      R5,R0
   \   0000010A   0xD201             BCS.N    ??BlackGetRight_5
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0xE299             B.N      ??BlackGetRight_1
   5915                temp1 = BlackGetRightStep2Win(row, BlackRightWinVal, temp, 1);
   \                     ??BlackGetRight_5: (+1)
   \   00000110   0x2301             MOVS     R3,#+1
   \   00000112   0x0022             MOVS     R2,R4
   \   00000114   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000116   0x210F             MOVS     R1,#+15
   \   00000118   0x0028             MOVS     R0,R5
   \   0000011A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011C   0x.... 0x....      BL       BlackGetRightStep2Win
   \   00000120   0x4683             MOV      R11,R0
   5916                if(SingleBlackAllFlag == 1 && row - 1 < BlackLeftHeadLine) return 1;
   \   00000122   0x.... 0x....      LDR.W    R0,??DataTable40_1
   \   00000126   0x7800             LDRB     R0,[R0, #+0]
   \   00000128   0x2801             CMP      R0,#+1
   \   0000012A   0xD108             BNE.N    ??BlackGetRight_6
   \   0000012C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000012E   0x1E68             SUBS     R0,R5,#+1
   \   00000130   0x.... 0x....      LDR.W    R1,??DataTable40_28
   \   00000134   0x7809             LDRB     R1,[R1, #+0]
   \   00000136   0x4288             CMP      R0,R1
   \   00000138   0xDA01             BGE.N    ??BlackGetRight_6
   \   0000013A   0x2001             MOVS     R0,#+1
   \   0000013C   0xE282             B.N      ??BlackGetRight_1
   5917                temp2 = BlackGetRightStep2Win(row-1, BlackRightWinVal, temp, 2);
   \                     ??BlackGetRight_6: (+1)
   \   0000013E   0x2302             MOVS     R3,#+2
   \   00000140   0x0022             MOVS     R2,R4
   \   00000142   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000144   0x210F             MOVS     R1,#+15
   \   00000146   0x1E68             SUBS     R0,R5,#+1
   \   00000148   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014A   0x.... 0x....      BL       BlackGetRightStep2Win
   5918                
   5919                temp3 = (
   5920                        (temp1 == 0)
   5921                      &&(temp2 == 0)
   5922                      //&&(BlackRightStep4Flag == 0)
   5923                        );
   \   0000014E   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000152   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000156   0xD104             BNE.N    ??BlackGetRight_7
   \   00000158   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xD101             BNE.N    ??BlackGetRight_7
   \   0000015E   0x2101             MOVS     R1,#+1
   \   00000160   0xE000             B.N      ??BlackGetRight_8
   \                     ??BlackGetRight_7: (+1)
   \   00000162   0x2100             MOVS     R1,#+0
   5924                //若连续2行的黑点检测成功，则更新3个阈值，更新预测点的位置
   5925                if(temp1 == 1 && temp2 == 1) 
   \                     ??BlackGetRight_8: (+1)
   \   00000164   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000168   0xF1BB 0x0F01      CMP      R11,#+1
   \   0000016C   0xF040 0x80A5      BNE.W    ??BlackGetRight_9
   \   00000170   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000172   0x2801             CMP      R0,#+1
   \   00000174   0xF040 0x80A1      BNE.W    ??BlackGetRight_9
   5926                {
   5927                  //只要连续采集到双黑线，则两个标志位重置为0.
   5928                  index = 0;
   \   00000178   0xF05F 0x0800      MOVS     R8,#+0
   5929                  index1 = 0;
   \   0000017C   0xF05F 0x0900      MOVS     R9,#+0
   5930                  successRow = row;
   \   00000180   0x46AA             MOV      R10,R5
   5931                
   5932                  //差值的处理，留有裕度，且有上下界。
   5933                  tempWB = (BlackRightRealWB[0] + BlackRightRealWB[1]) / 2 - LimitRightWBMargin; 
   \   00000182   0x.... 0x....      LDR.W    R0,??DataTable40_29
   \   00000186   0x7800             LDRB     R0,[R0, #+0]
   \   00000188   0x.... 0x....      LDR.W    R1,??DataTable40_29
   \   0000018C   0x7849             LDRB     R1,[R1, #+1]
   \   0000018E   0x1808             ADDS     R0,R1,R0
   \   00000190   0x2102             MOVS     R1,#+2
   \   00000192   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000196   0x3814             SUBS     R0,R0,#+20
   5934                  if(tempWB < LimitRightWBMin) tempWB = LimitRightWBMin;
   \   00000198   0x.... 0x....      LDR.W    R1,??DataTable40_30
   \   0000019C   0x7809             LDRB     R1,[R1, #+0]
   \   0000019E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001A0   0x4288             CMP      R0,R1
   \   000001A2   0xD203             BCS.N    ??BlackGetRight_10
   \   000001A4   0x.... 0x....      LDR.W    R0,??DataTable40_30
   \   000001A8   0x7800             LDRB     R0,[R0, #+0]
   \   000001AA   0xE008             B.N      ??BlackGetRight_11
   5935                  else if(tempWB > LimitRightWBMax) tempWB = LimitRightWBMax;
   \                     ??BlackGetRight_10: (+1)
   \   000001AC   0x.... 0x....      LDR.W    R1,??DataTable40_31
   \   000001B0   0x7809             LDRB     R1,[R1, #+0]
   \   000001B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B4   0x4281             CMP      R1,R0
   \   000001B6   0xD202             BCS.N    ??BlackGetRight_11
   \   000001B8   0x.... 0x....      LDR.W    R0,??DataTable40_31
   \   000001BC   0x7800             LDRB     R0,[R0, #+0]
   5936                  else ;
   5937                  LimitRightWB = tempWB;
   \                     ??BlackGetRight_11: (+1)
   \   000001BE   0x.... 0x....      LDR.W    R1,??DataTable40_20
   \   000001C2   0x7008             STRB     R0,[R1, #+0]
   5938                  
   5939                  //白点的处理，留有裕度，且有上下界。
   5940                  tempW = (BlackRightRealW[0] + BlackRightRealW[1]) / 2 - LimitRightWMargin;
   \   000001C4   0x.... 0x....      LDR.W    R0,??DataTable40_32
   \   000001C8   0x7800             LDRB     R0,[R0, #+0]
   \   000001CA   0x.... 0x....      LDR.W    R1,??DataTable40_32
   \   000001CE   0x7849             LDRB     R1,[R1, #+1]
   \   000001D0   0x1808             ADDS     R0,R1,R0
   \   000001D2   0x2102             MOVS     R1,#+2
   \   000001D4   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000001D8   0x3828             SUBS     R0,R0,#+40
   5941                  if(tempW < LimitRightWMin) tempW = LimitRightWMin;
   \   000001DA   0x.... 0x....      LDR.W    R1,??DataTable40_33
   \   000001DE   0x7809             LDRB     R1,[R1, #+0]
   \   000001E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001E2   0x4288             CMP      R0,R1
   \   000001E4   0xD203             BCS.N    ??BlackGetRight_12
   \   000001E6   0x.... 0x....      LDR.W    R0,??DataTable40_33
   \   000001EA   0x7800             LDRB     R0,[R0, #+0]
   \   000001EC   0xE008             B.N      ??BlackGetRight_13
   5942                  else if(tempW > LimitRightWMax) tempW = LimitRightWMax;
   \                     ??BlackGetRight_12: (+1)
   \   000001EE   0x.... 0x....      LDR.W    R1,??DataTable40_34
   \   000001F2   0x7809             LDRB     R1,[R1, #+0]
   \   000001F4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001F6   0x4281             CMP      R1,R0
   \   000001F8   0xD202             BCS.N    ??BlackGetRight_13
   \   000001FA   0x.... 0x....      LDR.W    R0,??DataTable40_34
   \   000001FE   0x7800             LDRB     R0,[R0, #+0]
   5943                  else ;
   5944                  LimitRightW = tempW;
   \                     ??BlackGetRight_13: (+1)
   \   00000200   0x.... 0x....      LDR.W    R1,??DataTable40_22
   \   00000204   0x7008             STRB     R0,[R1, #+0]
   5945                  
   5946                  //黑点的处理，留有裕度，且有上下界。
   5947                  tempB = (BlackRightRealB[0] + BlackRightRealB[1]) / 2 + LimitRightBMargin;
   \   00000206   0x.... 0x....      LDR.W    R0,??DataTable40_35
   \   0000020A   0x7800             LDRB     R0,[R0, #+0]
   \   0000020C   0x.... 0x....      LDR.W    R1,??DataTable40_35
   \   00000210   0x7849             LDRB     R1,[R1, #+1]
   \   00000212   0x1808             ADDS     R0,R1,R0
   \   00000214   0x2102             MOVS     R1,#+2
   \   00000216   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000021A   0x3023             ADDS     R0,R0,#+35
   5948                  if(tempB < LimitRightBMin) tempB = LimitRightBMin;
   \   0000021C   0x.... 0x....      LDR.W    R1,??DataTable40_36
   \   00000220   0x7809             LDRB     R1,[R1, #+0]
   \   00000222   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000224   0x4288             CMP      R0,R1
   \   00000226   0xD203             BCS.N    ??BlackGetRight_14
   \   00000228   0x.... 0x....      LDR.W    R0,??DataTable40_36
   \   0000022C   0x7800             LDRB     R0,[R0, #+0]
   \   0000022E   0xE008             B.N      ??BlackGetRight_15
   5949                  else if(tempB > LimitRightBMax) tempB = LimitRightBMax;
   \                     ??BlackGetRight_14: (+1)
   \   00000230   0x.... 0x....      LDR.W    R1,??DataTable40_37
   \   00000234   0x7809             LDRB     R1,[R1, #+0]
   \   00000236   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000238   0x4281             CMP      R1,R0
   \   0000023A   0xD202             BCS.N    ??BlackGetRight_15
   \   0000023C   0x.... 0x....      LDR.W    R0,??DataTable40_37
   \   00000240   0x7800             LDRB     R0,[R0, #+0]
   5950                  else ;
   5951                  //黑色阈值不能超过白色
   5952                  if(tempB >= LimitRightW)
   \                     ??BlackGetRight_15: (+1)
   \   00000242   0x.... 0x....      LDR.W    R1,??DataTable40_22
   \   00000246   0x7809             LDRB     R1,[R1, #+0]
   \   00000248   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000024A   0x4288             CMP      R0,R1
   \   0000024C   0xD303             BCC.N    ??BlackGetRight_16
   5953                  {
   5954                    tempB = LimitRightW - 1;
   \   0000024E   0x.... 0x....      LDR.W    R0,??DataTable40_22
   \   00000252   0x7800             LDRB     R0,[R0, #+0]
   \   00000254   0x1E40             SUBS     R0,R0,#+1
   5955                  }
   5956                  else
   5957                  {
   5958                  }             
   5959                  LimitRightB = tempB;   
   \                     ??BlackGetRight_16: (+1)
   \   00000256   0x.... 0x....      LDR.W    R1,??DataTable40_24
   \   0000025A   0x7008             STRB     R0,[R1, #+0]
   5960                   
   5961                  //对预测值进行限定。
   5962                  temp = BoundaryLimitRe(BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0],
   5963                                         0,
   5964                                         CameraRealWidth - 1); 
   \   0000025C   0x22F9             MOVS     R2,#+249
   \   0000025E   0x2100             MOVS     R1,#+0
   \   00000260   0x.... 0x....      LDR.W    R0,??DataTable40_26
   \   00000264   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000266   0x2303             MOVS     R3,#+3
   \   00000268   0xFB03 0x0005      MLA      R0,R3,R5,R0
   \   0000026C   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000270   0x.... 0x....      LDR.W    R3,??DataTable40_26
   \   00000274   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000276   0x2403             MOVS     R4,#+3
   \   00000278   0xFB04 0x3305      MLA      R3,R4,R5,R3
   \   0000027C   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   00000280   0xFA53 0xF080      UXTAB    R0,R3,R0
   \   00000284   0x.... 0x....      LDR.W    R3,??DataTable40_26
   \   00000288   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000028A   0x2403             MOVS     R4,#+3
   \   0000028C   0xFB04 0x3305      MLA      R3,R4,R5,R3
   \   00000290   0x781B             LDRB     R3,[R3, #+0]
   \   00000292   0x1AC0             SUBS     R0,R0,R3
   \   00000294   0x.... 0x....      BL       BoundaryLimitRe
   \   00000298   0x0004             MOVS     R4,R0
   5965                  //预测值更新后就刷新一次堆栈，堆栈顶部丢失。
   5966                  BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
   \   0000029A   0x.... 0x....      LDR.W    R0,??DataTable40_17
   \   0000029E   0x7800             LDRB     R0,[R0, #+0]
   \   000002A0   0x.... 0x....      LDR.W    R1,??DataTable40_16
   \   000002A4   0x7008             STRB     R0,[R1, #+0]
   5967                  BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
   \   000002A6   0x.... 0x....      LDR.W    R0,??DataTable40_27
   \   000002AA   0x7800             LDRB     R0,[R0, #+0]
   \   000002AC   0x.... 0x....      LDR.W    R1,??DataTable40_17
   \   000002B0   0x7008             STRB     R0,[R1, #+0]
   5968                  BlackRightWinPredictStore2 = temp;        
   \   000002B2   0x.... 0x....      LDR.W    R0,??DataTable40_27
   \   000002B6   0x7004             STRB     R4,[R0, #+0]
   \   000002B8   0xE197             B.N      ??BlackGetRight_17
   5969                }
   5970                //如果没能连续两行检测黑点成功，原本打算用原位置的预测点，后来发现效果不好，所以决定按预测点的趋势走。
   5971                //如果连续两行均采集黑线失败，则记数，记到一定值就再来一次Step1
   5972                //如果第4阶段检测标志置位，就不用进入十字检测了。
   5973                else if(temp3 == 1)
   \                     ??BlackGetRight_9: (+1)
   \   000002BA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002BC   0x2901             CMP      R1,#+1
   \   000002BE   0xF040 0x810D      BNE.W    ??BlackGetRight_18
   5974                {
   5975                  //若上一幅图是单线，则不允许开启十字。
   5976                  if(SingleBlackLastAllFlag == 1) break;        
   \   000002C2   0x.... 0x....      LDR.W    R0,??DataTable40_4
   \   000002C6   0x7800             LDRB     R0,[R0, #+0]
   \   000002C8   0x2801             CMP      R0,#+1
   \   000002CA   0xF000 0x8195      BEQ.W    ??BlackGetRight_19
   5977                  //直角黑块锁存期间，为了防止一边十字成功另一边不成功造成的中心线倾斜，所以不允许开启十字。
   5978                  if(AngleZoneConfirmLockFlag == 1) break;
   \                     ??BlackGetRight_20: (+1)
   \   000002CE   0x.... 0x....      LDR.W    R0,??DataTable40_38
   \   000002D2   0x7800             LDRB     R0,[R0, #+0]
   \   000002D4   0x2801             CMP      R0,#+1
   \   000002D6   0xF000 0x818F      BEQ.W    ??BlackGetRight_19
   5979                  
   5980                  //第一次检测到双线失败时，最后的几条线可能已经不太正确。
   5981                  if(index1 == 0)
   \                     ??BlackGetRight_21: (+1)
   \   000002DA   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000002DE   0xF1B9 0x0F00      CMP      R9,#+0
   \   000002E2   0xD16C             BNE.N    ??BlackGetRight_22
   5982                  {
   5983                    //如果储存的3个值趋势相同，也就是变化量同号，那么就按正常的来。否则就认为最后一个值已经错误。
   5984                    if(row <= CameraHight - 3)
   \   000002E4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002E6   0x2D3A             CMP      R5,#+58
   \   000002E8   0xDA67             BGE.N    ??BlackGetRight_23
   5985                    {
   5986                        if (BlackRightLoc[row + 1][0] != MaxValUint8 && BlackRightLoc[row + 2][0] != MaxValUint8)
   \   000002EA   0x.... 0x....      LDR.W    R0,??DataTable40_26
   \   000002EE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002F0   0x2103             MOVS     R1,#+3
   \   000002F2   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   000002F6   0x78C0             LDRB     R0,[R0, #+3]
   \   000002F8   0x28FF             CMP      R0,#+255
   \   000002FA   0xD029             BEQ.N    ??BlackGetRight_24
   \   000002FC   0x.... 0x....      LDR.W    R0,??DataTable40_26
   \   00000300   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000302   0x2103             MOVS     R1,#+3
   \   00000304   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000308   0x7980             LDRB     R0,[R0, #+6]
   \   0000030A   0x28FF             CMP      R0,#+255
   \   0000030C   0xD020             BEQ.N    ??BlackGetRight_24
   5987                        {
   5988                            //如果黑线点够，最好还是根据实际的黑点来更新窗口值。
   5989                            tempminus = BoundaryLimitRe(BlackRightLoc[row + 1][0] * 3 - BlackRightLoc[row + 2][0] * 2,
   5990                                                        0,
   5991                                                        CameraRealWidth - 1);
   \   0000030E   0x22F9             MOVS     R2,#+249
   \   00000310   0x2100             MOVS     R1,#+0
   \   00000312   0x.... 0x....      LDR.W    R0,??DataTable40_26
   \   00000316   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000318   0x2303             MOVS     R3,#+3
   \   0000031A   0xFB03 0x0005      MLA      R0,R3,R5,R0
   \   0000031E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000320   0x2303             MOVS     R3,#+3
   \   00000322   0x4358             MULS     R0,R3,R0
   \   00000324   0x.... 0x....      LDR.W    R3,??DataTable40_26
   \   00000328   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000032A   0x2403             MOVS     R4,#+3
   \   0000032C   0xFB04 0x3305      MLA      R3,R4,R5,R3
   \   00000330   0x799B             LDRB     R3,[R3, #+6]
   \   00000332   0xEBB0 0x0043      SUBS     R0,R0,R3, LSL #+1
   \   00000336   0x.... 0x....      BL       BoundaryLimitRe
   5992                            //斜入十字不管怎么摆，右十字的上段线一定在下段线的左边。
   5993                            tempminus = MinRe(tempminus, BlackRightLoc[row + 1][0]);
   \   0000033A   0x.... 0x....      LDR.W    R1,??DataTable40_26
   \   0000033E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000340   0x2203             MOVS     R2,#+3
   \   00000342   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000346   0x78C9             LDRB     R1,[R1, #+3]
   \   00000348   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000034A   0x.... 0x....      BL       MinRe
   \   0000034E   0xE031             B.N      ??BlackGetRight_25
   5994                        }
   5995                        else
   5996                        {
   5997                            temp001 = BlackRightWinPredictStore1 - BlackRightWinPredictStore0;
   \                     ??BlackGetRight_24: (+1)
   \   00000350   0x.... 0x....      LDR.W    R0,??DataTable40_17
   \   00000354   0x7800             LDRB     R0,[R0, #+0]
   \   00000356   0x.... 0x....      LDR.W    R1,??DataTable40_16
   \   0000035A   0x7809             LDRB     R1,[R1, #+0]
   \   0000035C   0x1A40             SUBS     R0,R0,R1
   5998                            BlackRightWinPredictStore0 += temp001;
   \   0000035E   0x.... 0x....      LDR.W    R1,??DataTable40_16
   \   00000362   0x7809             LDRB     R1,[R1, #+0]
   \   00000364   0x1841             ADDS     R1,R0,R1
   \   00000366   0x.... 0x....      LDR.W    R2,??DataTable40_16
   \   0000036A   0x7011             STRB     R1,[R2, #+0]
   5999                            BlackRightWinPredictStore1 += temp001;
   \   0000036C   0x.... 0x....      LDR.W    R1,??DataTable40_17
   \   00000370   0x7809             LDRB     R1,[R1, #+0]
   \   00000372   0x1840             ADDS     R0,R0,R1
   \   00000374   0x.... 0x....      LDR.W    R1,??DataTable40_17
   \   00000378   0x7008             STRB     R0,[R1, #+0]
   6000                            BlackRightWinPredictStore2 = BlackRightWinPredictStore1 + BlackRightWinPredictStore1 - BlackRightWinPredictStore0;
   \   0000037A   0x.... 0x....      LDR.W    R0,??DataTable40_17
   \   0000037E   0x7800             LDRB     R0,[R0, #+0]
   \   00000380   0x.... 0x....      LDR.W    R1,??DataTable40_17
   \   00000384   0x7809             LDRB     R1,[R1, #+0]
   \   00000386   0x1808             ADDS     R0,R1,R0
   \   00000388   0x.... 0x....      LDR.W    R1,??DataTable40_16
   \   0000038C   0x7809             LDRB     R1,[R1, #+0]
   \   0000038E   0x1A40             SUBS     R0,R0,R1
   \   00000390   0x.... 0x....      LDR.W    R1,??DataTable40_27
   \   00000394   0x7008             STRB     R0,[R1, #+0]
   6001                            tempminus = BoundaryLimitRe(BlackRightWinPredictStore2 + BlackRightWinPredictStore2 - BlackRightWinPredictStore1,
   6002                                                        0,
   6003                                                        CameraRealWidth - 1);
   \   00000396   0x22F9             MOVS     R2,#+249
   \   00000398   0x2100             MOVS     R1,#+0
   \   0000039A   0x.... 0x....      LDR.W    R0,??DataTable40_27
   \   0000039E   0x7800             LDRB     R0,[R0, #+0]
   \   000003A0   0x.... 0x....      LDR.W    R3,??DataTable40_27
   \   000003A4   0x781B             LDRB     R3,[R3, #+0]
   \   000003A6   0x1818             ADDS     R0,R3,R0
   \   000003A8   0x.... 0x....      LDR.W    R3,??DataTable40_17
   \   000003AC   0x781B             LDRB     R3,[R3, #+0]
   \   000003AE   0x1AC0             SUBS     R0,R0,R3
   \   000003B0   0x.... 0x....      BL       BoundaryLimitRe
   6004                        }
   6005                    }
   6006                    else
   6007                    {
   6008                        //理论上不会走到这里。
   6009                        return 0;
   6010                        
   6011                        /*
   6012                        //实在不行就根据Store的值来更新吧。
   6013                        //以上上次的窗口预测值为基准，加上2个上上次和上上上次的差。
   6014                        tempminus = BoundaryLimitRe(BlackRightWinPredictStore1 * 3 - BlackRightWinPredictStore0 * 2,
   6015                                                    0,
   6016                                                    CameraRealWidth - 1);
   6017                        //斜入十字不管怎么摆，右十字的上段线一定在下段线的左边。
   6018                        tempminus = MinRe(tempminus, BlackRightLoc[row + 1][0]);
   6019                      */
   6020                    }
   6021                    
   6022                    //进来一次后就再也不进来了。
   6023                    index1++;          
   \                     ??BlackGetRight_25: (+1)
   \   000003B4   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000003B8   0xE010             B.N      ??BlackGetRight_26
   \                     ??BlackGetRight_23: (+1)
   \   000003BA   0x2000             MOVS     R0,#+0
   \   000003BC   0xE142             B.N      ??BlackGetRight_1
   6024                  }
   6025                  else
   6026                  {
   6027                    //预测点按趋势走也要限幅。
   6028                    tempminus = BoundaryLimitRe(BlackRightWinPredictStore2 + BlackRightWinPredictStore2 - BlackRightWinPredictStore1,
   6029                                                0,
   6030                                                CameraRealWidth - 1);          
   \                     ??BlackGetRight_22: (+1)
   \   000003BE   0x22F9             MOVS     R2,#+249
   \   000003C0   0x2100             MOVS     R1,#+0
   \   000003C2   0x.... 0x....      LDR.W    R0,??DataTable40_27
   \   000003C6   0x7800             LDRB     R0,[R0, #+0]
   \   000003C8   0x.... 0x....      LDR.W    R3,??DataTable40_27
   \   000003CC   0x781B             LDRB     R3,[R3, #+0]
   \   000003CE   0x1818             ADDS     R0,R3,R0
   \   000003D0   0x.... 0x....      LDR.W    R3,??DataTable40_17
   \   000003D4   0x781B             LDRB     R3,[R3, #+0]
   \   000003D6   0x1AC0             SUBS     R0,R0,R3
   \   000003D8   0x.... 0x....      BL       BoundaryLimitRe
   6031                  }
   6032                  //temp在这里表示窗口预测点位置。
   6033                  temp = tempminus;
   \                     ??BlackGetRight_26: (+1)
   \   000003DC   0x0004             MOVS     R4,R0
   6034                  BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
   \   000003DE   0x.... 0x....      LDR.W    R0,??DataTable40_17
   \   000003E2   0x7800             LDRB     R0,[R0, #+0]
   \   000003E4   0x.... 0x....      LDR.W    R1,??DataTable40_16
   \   000003E8   0x7008             STRB     R0,[R1, #+0]
   6035                  BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
   \   000003EA   0x.... 0x....      LDR.W    R0,??DataTable40_27
   \   000003EE   0x7800             LDRB     R0,[R0, #+0]
   \   000003F0   0x.... 0x....      LDR.W    R1,??DataTable40_17
   \   000003F4   0x7008             STRB     R0,[R1, #+0]
   6036                  BlackRightWinPredictStore2 = temp;        
   \   000003F6   0x.... 0x....      LDR.W    R0,??DataTable40_27
   \   000003FA   0x7004             STRB     R4,[R0, #+0]
   6037                  
   6038                  //Row1RealLastLine记录第1段黑线的最后一行。
   6039                  if(index == 0)
   \   000003FC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000400   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000404   0xD118             BNE.N    ??BlackGetRight_27
   6040                  {          
   6041                    //进来一次后，就再也不会进来了。
   6042                    index++;
   \   00000406   0xF118 0x0801      ADDS     R8,R8,#+1
   6043                    for(i = row; i <= CameraHight - 1; i++)
   \   0000040A   0x0028             MOVS     R0,R5
   \   0000040C   0xE000             B.N      ??BlackGetRight_28
   \                     ??BlackGetRight_29: (+1)
   \   0000040E   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackGetRight_28: (+1)
   \   00000410   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000412   0x283C             CMP      R0,#+60
   \   00000414   0xDA09             BGE.N    ??BlackGetRight_30
   6044                    {
   6045                      if(BlackRightLoc[i][0] != MaxValUint8)
   \   00000416   0x.... 0x....      LDR.W    R1,??DataTable40_26
   \   0000041A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000041C   0x2203             MOVS     R2,#+3
   \   0000041E   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   00000422   0x7809             LDRB     R1,[R1, #+0]
   \   00000424   0x29FF             CMP      R1,#+255
   \   00000426   0xD0F2             BEQ.N    ??BlackGetRight_29
   6046                      {
   6047                        Row1RealLastLine = i;
   \   00000428   0x0007             MOVS     R7,R0
   6048                        break;
   6049                      }
   6050                    }
   6051                    if(Row1RealLastLine >= CameraHight - 1)
   \                     ??BlackGetRight_30: (+1)
   \   0000042A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000042C   0x2F3B             CMP      R7,#+59
   \   0000042E   0xDB00             BLT.N    ??BlackGetRight_31
   6052                    {
   6053                      Row1RealLastLine = CameraHight - 1;
   \   00000430   0x273B             MOVS     R7,#+59
   6054                    }
   6055                    else
   6056                    {
   6057                    }
   6058                    //记录为全局变量
   6059                    BlackRightRow1RealLastLine = Row1RealLastLine;
   \                     ??BlackGetRight_31: (+1)
   \   00000432   0x.... 0x....      LDR.W    R0,??DataTable40_39
   \   00000436   0x7007             STRB     R7,[R0, #+0]
   6060                  }
   6061                  
   6062                  GapCount += 2;
   \                     ??BlackGetRight_27: (+1)
   \   00000438   0x1CB6             ADDS     R6,R6,#+2
   6063                  if (successRow != MaxValUint8 && BlackRightLoc[successRow][0] >240 && BlackRightLoc[successRow - 1][0] >240) { }
   \   0000043A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000043E   0xF1BA 0x0FFF      CMP      R10,#+255
   \   00000442   0xD015             BEQ.N    ??BlackGetRight_32
   \   00000444   0x.... 0x....      LDR.W    R0,??DataTable40_26
   \   00000448   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000044C   0x2103             MOVS     R1,#+3
   \   0000044E   0xFB01 0x000A      MLA      R0,R1,R10,R0
   \   00000452   0x7800             LDRB     R0,[R0, #+0]
   \   00000454   0x28F1             CMP      R0,#+241
   \   00000456   0xDB0B             BLT.N    ??BlackGetRight_32
   \   00000458   0x.... 0x....      LDR.W    R0,??DataTable40_26
   \   0000045C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000460   0x2103             MOVS     R1,#+3
   \   00000462   0xFB01 0x000A      MLA      R0,R1,R10,R0
   \   00000466   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000046A   0x28F1             CMP      R0,#+241
   \   0000046C   0xF280 0x80BD      BGE.W    ??BlackGetRight_17
   6064                  ///////////////////////////////进入十字重新检测的条件还要再严格一些，减少没必要的时间，比如说前面最多只允许检测到多少行。
   6065                  else if(GapCount > BlackCrossGapLine)
   \                     ??BlackGetRight_32: (+1)
   \   00000470   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000472   0x2E0D             CMP      R6,#+13
   \   00000474   0xDB2E             BLT.N    ??BlackGetRight_33
   6066                  {
   6067                    //再检测时的行太远了，就没必要检测了。
   6068                    if(row < BlackRightCrossTooLowLine)
   \   00000476   0x.... 0x....      LDR.W    R0,??DataTable40_40
   \   0000047A   0x7800             LDRB     R0,[R0, #+0]
   \   0000047C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000047E   0x4285             CMP      R5,R0
   \   00000480   0xD20D             BCS.N    ??BlackGetRight_34
   6069                    {
   6070                      //扫屁股。
   6071                      for(i = row; ; i--)
   \   00000482   0x0028             MOVS     R0,R5
   \   00000484   0xE000             B.N      ??BlackGetRight_35
   \                     ??BlackGetRight_36: (+1)
   \   00000486   0x1E40             SUBS     R0,R0,#+1
   6072                      {
   6073                        BlackRightLoc[i][0] = MaxValUint8;
   \                     ??BlackGetRight_35: (+1)
   \   00000488   0x21FF             MOVS     R1,#+255
   \   0000048A   0x....             LDR.N    R2,??DataTable40_26
   \   0000048C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000048E   0x2303             MOVS     R3,#+3
   \   00000490   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000494   0x7011             STRB     R1,[R2, #+0]
   6074                        if(i == 0) break;
   \   00000496   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000498   0x2800             CMP      R0,#+0
   \   0000049A   0xD1F4             BNE.N    ??BlackGetRight_36
   6075                      }
   6076                      //跳出来。
   6077                      break;
   \   0000049C   0xE0AC             B.N      ??BlackGetRight_19
   6078                    }
   6079                    else
   6080                    {
   6081                    }
   6082                    
   6083                    //进入十字重新检测后，就不允许出现第4阶段向后补线的情况。
   6084                    if(BlackRightStep4Flag == 1)
   6085                    {
   6086                      //BlackRightStep4Flag = 3;   //向后补线出错。
   6087                      
   6088                      //直接跳出来的作法。不太好。
   6089                      /*
   6090                      BlackRightCrossDone = 1;   //十字检测失败。
   6091                      //扫屁股。
   6092                      for(i = row; ; i--)
   6093                      {
   6094                        BlackRightLoc[i][0] = MaxValUint8;
   6095                        if(i == 0) break;
   6096                      }
   6097                      //跳出来。
   6098                      break;
   6099                      */
   6100                    }
   6101                    else
   6102                    {
   6103                    }
   6104                    
   6105                    //十字再检测的话，Step1Scan的线头必须够近。
   6106                    //最后只剩第0，1行没有检测的话，就不用开启十字再检测了。
   6107                    if(BlackRightStep1ScanRow >= CameraHight - 3 && row > 3)
   \                     ??BlackGetRight_34: (+1)
   \   0000049E   0x....             LDR.N    R0,??DataTable40_25
   \   000004A0   0x7800             LDRB     R0,[R0, #+0]
   \   000004A2   0x2839             CMP      R0,#+57
   \   000004A4   0xDB15             BLT.N    ??BlackGetRight_37
   \   000004A6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004A8   0x2D04             CMP      R5,#+4
   \   000004AA   0xDB12             BLT.N    ??BlackGetRight_37
   6108                    {
   6109                      //正常的十字再检测。
   6110                      if(BlackRightAgainForCross(row - 2, 1, Row1RealLastLine, temp) == 0)
   \   000004AC   0x0023             MOVS     R3,R4
   \   000004AE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000004B0   0x003A             MOVS     R2,R7
   \   000004B2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000004B4   0x2101             MOVS     R1,#+1
   \   000004B6   0x1EA8             SUBS     R0,R5,#+2
   \   000004B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004BA   0x.... 0x....      BL       BlackRightAgainForCross
   \   000004BE   0x2800             CMP      R0,#+0
   \   000004C0   0xD103             BNE.N    ??BlackGetRight_38
   6111                      {
   6112                        BlackRightCrossDone = 1;  //十字检测失败            
   \   000004C2   0x2001             MOVS     R0,#+1
   \   000004C4   0x....             LDR.N    R1,??DataTable40_5
   \   000004C6   0x7008             STRB     R0,[R1, #+0]
   \   000004C8   0xE002             B.N      ??BlackGetRight_39
   6113                      }
   6114                      else
   6115                      {
   6116                        BlackRightCrossDone = 2;  //十字检测成功
   \                     ??BlackGetRight_38: (+1)
   \   000004CA   0x2002             MOVS     R0,#+2
   \   000004CC   0x....             LDR.N    R1,??DataTable40_5
   \   000004CE   0x7008             STRB     R0,[R1, #+0]
   6117                      }
   6118                      break;  //十字再检测里会开窗检测到指定的最后一行，所以不用再循环了，直接跳出
   \                     ??BlackGetRight_39: (+1)
   \   000004D0   0xE092             B.N      ??BlackGetRight_19
   6119                    }
   6120                    //线头太远，或者只剩第0，1行的时候，直接break就好，远处的行在初始化时已经置为无效值。
   6121                    else
   6122                    {
   6123                      break;
   \                     ??BlackGetRight_37: (+1)
   \   000004D2   0xE091             B.N      ??BlackGetRight_19
   6124                    }
   6125                  }
   6126                  else
   6127                  {
   6128                     BlackRightCrossDone = 0;    //十字检测未进入
   \                     ??BlackGetRight_33: (+1)
   \   000004D4   0x2000             MOVS     R0,#+0
   \   000004D6   0x....             LDR.N    R1,??DataTable40_5
   \   000004D8   0x7008             STRB     R0,[R1, #+0]
   \   000004DA   0xE086             B.N      ??BlackGetRight_17
   6129                  }
   6130                
   6131                }
   6132                //连续两线只有一线检测成功的情况，仍然要按趋势更新窗口预测值。
   6133                else if((temp1 == 1 && temp2 == 0) || (temp1 == 0 && temp2 == 1)) 
   \                     ??BlackGetRight_18: (+1)
   \   000004DC   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000004E0   0xF1BB 0x0F01      CMP      R11,#+1
   \   000004E4   0xD102             BNE.N    ??BlackGetRight_40
   \   000004E6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004E8   0x2800             CMP      R0,#+0
   \   000004EA   0xD007             BEQ.N    ??BlackGetRight_41
   \                     ??BlackGetRight_40: (+1)
   \   000004EC   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000004F0   0xF1BB 0x0F00      CMP      R11,#+0
   \   000004F4   0xD179             BNE.N    ??BlackGetRight_17
   \   000004F6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004F8   0x2801             CMP      R0,#+1
   \   000004FA   0xD176             BNE.N    ??BlackGetRight_17
   6134                {   
   6135                  //第一次检测到有单线失败时，最后的几条线可能已经不太正确。
   6136                  if(index1 == 0)
   \                     ??BlackGetRight_41: (+1)
   \   000004FC   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000500   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000504   0xD15A             BNE.N    ??BlackGetRight_42
   6137                  {
   6138                    //如果储存的3个值趋势相同，也就是变化量同号，那么就按正常的来。否则就认为最后一个值已经错误。
   6139                    if(row <= CameraHight - 3)
   \   00000506   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000508   0x2D3A             CMP      R5,#+58
   \   0000050A   0xDA55             BGE.N    ??BlackGetRight_43
   6140                    {
   6141                        if (BlackRightLoc[row + 1][0] != MaxValUint8 && BlackRightLoc[row + 2][0] != MaxValUint8)
   \   0000050C   0x....             LDR.N    R0,??DataTable40_26
   \   0000050E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000510   0x2103             MOVS     R1,#+3
   \   00000512   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000516   0x78C0             LDRB     R0,[R0, #+3]
   \   00000518   0x28FF             CMP      R0,#+255
   \   0000051A   0xD025             BEQ.N    ??BlackGetRight_44
   \   0000051C   0x....             LDR.N    R0,??DataTable40_26
   \   0000051E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000520   0x2103             MOVS     R1,#+3
   \   00000522   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000526   0x7980             LDRB     R0,[R0, #+6]
   \   00000528   0x28FF             CMP      R0,#+255
   \   0000052A   0xD01D             BEQ.N    ??BlackGetRight_44
   6142                        {
   6143                            //如果黑线点够，最好还是根据实际的黑点来更新窗口值。
   6144                            tempminus = BoundaryLimitRe(BlackRightLoc[row + 1][0] * 3 - BlackRightLoc[row + 2][0] * 2,
   6145                                                        0,
   6146                                                        CameraRealWidth - 1);
   \   0000052C   0x22F9             MOVS     R2,#+249
   \   0000052E   0x2100             MOVS     R1,#+0
   \   00000530   0x....             LDR.N    R0,??DataTable40_26
   \   00000532   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000534   0x2303             MOVS     R3,#+3
   \   00000536   0xFB03 0x0005      MLA      R0,R3,R5,R0
   \   0000053A   0x78C0             LDRB     R0,[R0, #+3]
   \   0000053C   0x2303             MOVS     R3,#+3
   \   0000053E   0x4358             MULS     R0,R3,R0
   \   00000540   0x....             LDR.N    R3,??DataTable40_26
   \   00000542   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000544   0x2403             MOVS     R4,#+3
   \   00000546   0xFB04 0x3305      MLA      R3,R4,R5,R3
   \   0000054A   0x799B             LDRB     R3,[R3, #+6]
   \   0000054C   0xEBB0 0x0043      SUBS     R0,R0,R3, LSL #+1
   \   00000550   0x.... 0x....      BL       BoundaryLimitRe
   6147                            //斜入十字不管怎么摆，右十字的上段线一定在下段线的左边。
   6148                            tempminus = MinRe(tempminus, BlackRightLoc[row + 1][0]);
   \   00000554   0x....             LDR.N    R1,??DataTable40_26
   \   00000556   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000558   0x2203             MOVS     R2,#+3
   \   0000055A   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   0000055E   0x78C9             LDRB     R1,[R1, #+3]
   \   00000560   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000562   0x.... 0x....      BL       MinRe
   \   00000566   0xE024             B.N      ??BlackGetRight_45
   6149                        }
   6150                        else
   6151                        {
   6152                            temp001 = BlackRightWinPredictStore1 - BlackRightWinPredictStore0;
   \                     ??BlackGetRight_44: (+1)
   \   00000568   0x....             LDR.N    R0,??DataTable40_17
   \   0000056A   0x7800             LDRB     R0,[R0, #+0]
   \   0000056C   0x....             LDR.N    R1,??DataTable40_16
   \   0000056E   0x7809             LDRB     R1,[R1, #+0]
   \   00000570   0x1A40             SUBS     R0,R0,R1
   6153                            BlackRightWinPredictStore0 += temp001;
   \   00000572   0x....             LDR.N    R1,??DataTable40_16
   \   00000574   0x7809             LDRB     R1,[R1, #+0]
   \   00000576   0x1841             ADDS     R1,R0,R1
   \   00000578   0x....             LDR.N    R2,??DataTable40_16
   \   0000057A   0x7011             STRB     R1,[R2, #+0]
   6154                            BlackRightWinPredictStore1 += temp001;
   \   0000057C   0x....             LDR.N    R1,??DataTable40_17
   \   0000057E   0x7809             LDRB     R1,[R1, #+0]
   \   00000580   0x1840             ADDS     R0,R0,R1
   \   00000582   0x....             LDR.N    R1,??DataTable40_17
   \   00000584   0x7008             STRB     R0,[R1, #+0]
   6155                            BlackRightWinPredictStore2 = BlackRightWinPredictStore1 + BlackRightWinPredictStore1 - BlackRightWinPredictStore0;
   \   00000586   0x....             LDR.N    R0,??DataTable40_17
   \   00000588   0x7800             LDRB     R0,[R0, #+0]
   \   0000058A   0x....             LDR.N    R1,??DataTable40_17
   \   0000058C   0x7809             LDRB     R1,[R1, #+0]
   \   0000058E   0x1808             ADDS     R0,R1,R0
   \   00000590   0x....             LDR.N    R1,??DataTable40_16
   \   00000592   0x7809             LDRB     R1,[R1, #+0]
   \   00000594   0x1A40             SUBS     R0,R0,R1
   \   00000596   0x....             LDR.N    R1,??DataTable40_27
   \   00000598   0x7008             STRB     R0,[R1, #+0]
   6156                            tempminus = BoundaryLimitRe(BlackRightWinPredictStore2 + BlackRightWinPredictStore2 - BlackRightWinPredictStore1,
   6157                                                        0,
   6158                                                        CameraRealWidth - 1);
   \   0000059A   0x22F9             MOVS     R2,#+249
   \   0000059C   0x2100             MOVS     R1,#+0
   \   0000059E   0x....             LDR.N    R0,??DataTable40_27
   \   000005A0   0x7800             LDRB     R0,[R0, #+0]
   \   000005A2   0x....             LDR.N    R3,??DataTable40_27
   \   000005A4   0x781B             LDRB     R3,[R3, #+0]
   \   000005A6   0x1818             ADDS     R0,R3,R0
   \   000005A8   0x....             LDR.N    R3,??DataTable40_17
   \   000005AA   0x781B             LDRB     R3,[R3, #+0]
   \   000005AC   0x1AC0             SUBS     R0,R0,R3
   \   000005AE   0x.... 0x....      BL       BoundaryLimitRe
   6159                        }
   6160                    }
   6161                    else
   6162                    {
   6163                        //理论上不会走到这里。
   6164                        return 0;
   6165                        
   6166                        /*
   6167                        //实在不行就根据Store的值来更新吧。
   6168                        //以上上次的窗口预测值为基准，加上2个上上次和上上上次的差。
   6169                        tempminus = BoundaryLimitRe(BlackRightWinPredictStore1 * 3 - BlackRightWinPredictStore0 * 2,
   6170                                                    0,
   6171                                                    CameraRealWidth - 1);
   6172                        //斜入十字不管怎么摆，右十字的上段线一定在下段线的左边。
   6173                        tempminus = MinRe(tempminus, BlackRightLoc[row + 1][0]);
   6174                        */
   6175                    }
   6176                    
   6177                    //进来一次后就再也不进来了。
   6178                    index1++;          
   \                     ??BlackGetRight_45: (+1)
   \   000005B2   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000005B6   0xE00D             B.N      ??BlackGetRight_46
   \                     ??BlackGetRight_43: (+1)
   \   000005B8   0x2000             MOVS     R0,#+0
   \   000005BA   0xE043             B.N      ??BlackGetRight_1
   6179                  }
   6180                  else
   6181                  {
   6182                    //预测点按趋势走也要限幅。
   6183                    tempminus = BoundaryLimitRe(BlackRightWinPredictStore2 + BlackRightWinPredictStore2 - BlackRightWinPredictStore1,
   6184                                                0,
   6185                                                CameraRealWidth - 1);          
   \                     ??BlackGetRight_42: (+1)
   \   000005BC   0x22F9             MOVS     R2,#+249
   \   000005BE   0x2100             MOVS     R1,#+0
   \   000005C0   0x....             LDR.N    R0,??DataTable40_27
   \   000005C2   0x7800             LDRB     R0,[R0, #+0]
   \   000005C4   0x....             LDR.N    R3,??DataTable40_27
   \   000005C6   0x781B             LDRB     R3,[R3, #+0]
   \   000005C8   0x1818             ADDS     R0,R3,R0
   \   000005CA   0x....             LDR.N    R3,??DataTable40_17
   \   000005CC   0x781B             LDRB     R3,[R3, #+0]
   \   000005CE   0x1AC0             SUBS     R0,R0,R3
   \   000005D0   0x.... 0x....      BL       BoundaryLimitRe
   6186                  }
   6187                  //temp在这里表示窗口预测点位置。
   6188                  temp = tempminus;
   \                     ??BlackGetRight_46: (+1)
   \   000005D4   0x0004             MOVS     R4,R0
   6189                  BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
   \   000005D6   0x....             LDR.N    R0,??DataTable40_17
   \   000005D8   0x7800             LDRB     R0,[R0, #+0]
   \   000005DA   0x....             LDR.N    R1,??DataTable40_16
   \   000005DC   0x7008             STRB     R0,[R1, #+0]
   6190                  BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
   \   000005DE   0x....             LDR.N    R0,??DataTable40_27
   \   000005E0   0x7800             LDRB     R0,[R0, #+0]
   \   000005E2   0x....             LDR.N    R1,??DataTable40_17
   \   000005E4   0x7008             STRB     R0,[R1, #+0]
   6191                  BlackRightWinPredictStore2 = temp;
   \   000005E6   0x....             LDR.N    R0,??DataTable40_27
   \   000005E8   0x7004             STRB     R4,[R0, #+0]
   6192                }
   6193                //理论上不会走到这里。
   6194                else
   6195                {       
   6196                }
   6197                
   6198                
   6199                if((row == 0) || (row == 1)) break;
   \                     ??BlackGetRight_17: (+1)
   \   000005EA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005EC   0x2D00             CMP      R5,#+0
   \   000005EE   0xD003             BEQ.N    ??BlackGetRight_47
   \   000005F0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005F2   0x2D01             CMP      R5,#+1
   \   000005F4   0xF47F 0xAD7E      BNE.W    ??BlackGetRight_4
   6200                
   6201              }
   6202              
   6203              
   6204              //第4阶段，采集到十字的前两个角，向后补线。这里有浮点运算，要严格控制调用。
   6205              if(BlackRightStep4Flag == 1)
   \                     ??BlackGetRight_47: (+1)
   \                     ??BlackGetRight_19: (+1)
   \   000005F8   0x....             LDR.N    R0,??DataTable40_3
   \   000005FA   0x7800             LDRB     R0,[R0, #+0]
   \   000005FC   0x2801             CMP      R0,#+1
   \   000005FE   0xD10E             BNE.N    ??BlackGetRight_48
   6206              {
   6207                if(BlackRightStep4BackLine(BlackRightStep4StartLine, 0) == 0)
   \   00000600   0x2100             MOVS     R1,#+0
   \   00000602   0x....             LDR.N    R0,??DataTable40_18
   \   00000604   0x7800             LDRB     R0,[R0, #+0]
   \   00000606   0x.... 0x....      BL       BlackRightStep4BackLine
   \   0000060A   0x2800             CMP      R0,#+0
   \   0000060C   0xD103             BNE.N    ??BlackGetRight_49
   6208                {
   6209                  BlackRightStep4Flag = 1;   //向后补线失败，有可能是点取不够，有可能是斜率不对。
   \   0000060E   0x2001             MOVS     R0,#+1
   \   00000610   0x....             LDR.N    R1,??DataTable40_3
   \   00000612   0x7008             STRB     R0,[R1, #+0]
   \   00000614   0xE015             B.N      ??BlackGetRight_50
   6210                  //return 0;  
   6211                }
   6212                else
   6213                {
   6214                  BlackRightStep4Flag = 2;   //向后补线成功。
   \                     ??BlackGetRight_49: (+1)
   \   00000616   0x2002             MOVS     R0,#+2
   \   00000618   0x....             LDR.N    R1,??DataTable40_3
   \   0000061A   0x7008             STRB     R0,[R1, #+0]
   \   0000061C   0xE011             B.N      ??BlackGetRight_50
   6215                }
   6216              }
   6217              //BlackRightStep4Flag出错的情况。
   6218              else if(BlackRightStep4Flag == 3)
   \                     ??BlackGetRight_48: (+1)
   \   0000061E   0x....             LDR.N    R0,??DataTable40_3
   \   00000620   0x7800             LDRB     R0,[R0, #+0]
   \   00000622   0x2803             CMP      R0,#+3
   \   00000624   0xD10D             BNE.N    ??BlackGetRight_50
   6219              {
   6220                //检查向后补线出错到底是为什么
   6221                if(BlackRightStep4ErrorCheck() == 1)
   \   00000626   0x.... 0x....      BL       BlackRightStep4ErrorCheck
   \   0000062A   0x2801             CMP      R0,#+1
   \   0000062C   0xD109             BNE.N    ??BlackGetRight_50
   6222                {      
   6223                  if(BlackRightStep4BackLine(BlackRightStep4StartLine, 0) == 0)
   \   0000062E   0x2100             MOVS     R1,#+0
   \   00000630   0x....             LDR.N    R0,??DataTable40_18
   \   00000632   0x7800             LDRB     R0,[R0, #+0]
   \   00000634   0x.... 0x....      BL       BlackRightStep4BackLine
   \   00000638   0x2800             CMP      R0,#+0
   \   0000063A   0xD002             BEQ.N    ??BlackGetRight_50
   6224                  {
   6225                    //BlackRightStep4Flag = 1;   //向后补线失败，有可能是点取不够，有可能是斜率不对。
   6226                    //return 0;  
   6227                  }
   6228                  else
   6229                  {
   6230                    BlackRightStep4Flag = 2;   //向后补线成功。
   \   0000063C   0x2002             MOVS     R0,#+2
   \   0000063E   0x....             LDR.N    R1,??DataTable40_3
   \   00000640   0x7008             STRB     R0,[R1, #+0]
   6231                  }
   6232                }
   6233                else
   6234                {
   6235                }
   6236              }
   6237              //BlackRightStep4Flag未进入的情况。
   6238              else
   6239              {
   6240              }
   6241          
   6242              return 1;
   \                     ??BlackGetRight_50: (+1)
   \   00000642   0x2001             MOVS     R0,#+1
   \                     ??BlackGetRight_1: (+1)
   \   00000644   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   6243          
   6244          }
   6245          
   6246          
   6247          
   6248          
   6249          //黑线提取预处理

   \                                 In section .text, align 2, keep-with-next
   6250          uint8 BlackGetPre(void)
   6251          {
   \                     BlackGetPre: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   6252            uint8 temp1, temp2;
   6253            
   6254            //如果是障碍特殊处理期间，黑线从控制线开始扫描。
   6255            if(BrickSpeDealFlag == 1)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable41
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD10F             BNE.N    ??BlackGetPre_0
   6256            {
   6257              //左障碍，固定从右线开始扫描。
   6258              if(BrickSpeDealDir == 0)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable41_1
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD104             BNE.N    ??BlackGetPre_1
   6259              {
   6260                BlackGetPreDir = 1;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable41_2
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
   \   0000001E   0xE003             B.N      ??BlackGetPre_2
   6261              }
   6262              //右障碍，固定从左线开始扫描。
   6263              else
   6264              {
   6265                BlackGetPreDir = 0;
   \                     ??BlackGetPre_1: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable41_2
   \   00000026   0x7008             STRB     R0,[R1, #+0]
   6266              }
   6267              
   6268              return 1;
   \                     ??BlackGetPre_2: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE060             B.N      ??BlackGetPre_3
   6269            }
   6270            else
   6271            {
   6272            }
   6273            
   6274            //先预扫描左线
   6275            BlackGetLeftParaInit();  //参数初始化
   \                     ??BlackGetPre_0: (+1)
   \   0000002C   0x.... 0x....      BL       BlackGetLeftParaInit
   6276            temp1 = BlackGetLeftStep1Edge(CameraHight - 1, 1, 1);  //第三个参数1表示是黑线预处理
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x203B             MOVS     R0,#+59
   \   00000036   0x.... 0x....      BL       BlackGetLeftStep1Edge
   \   0000003A   0x0004             MOVS     R4,R0
   6277            temp2 = BlackGetLeftStep1Edge(CameraHight - 2, 2, 1);  //第三个参数1表示是黑线预处理
   \   0000003C   0x2201             MOVS     R2,#+1
   \   0000003E   0x2102             MOVS     R1,#+2
   \   00000040   0x203A             MOVS     R0,#+58
   \   00000042   0x.... 0x....      BL       BlackGetLeftStep1Edge
   6278            if(
   6279              (temp1 == 1)
   6280            &&(temp2 == 1)
   6281            &&(AbsInt(BlackLeftLoc[CameraHight - 1][0] - BlackLeftLoc[CameraHight - 2][0]) < BlackLeftStep1ScanMinus)  //两点列差不能太大。
   6282              )
   \   00000046   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   0x2C01             CMP      R4,#+1
   \   0000004A   0xD115             BNE.N    ??BlackGetPre_4
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xD112             BNE.N    ??BlackGetPre_4
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable41_3
   \   00000056   0xF890 0x00B1      LDRB     R0,[R0, #+177]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable41_3
   \   0000005E   0xF891 0x10AE      LDRB     R1,[R1, #+174]
   \   00000062   0x1A40             SUBS     R0,R0,R1
   \   00000064   0x.... 0x....      BL       AbsInt
   \   00000068   0x2808             CMP      R0,#+8
   \   0000006A   0xDA05             BGE.N    ??BlackGetPre_4
   6283            {
   6284              //左线采集线头成功，从左线开始扫描。 
   6285              BlackGetPreDir = 0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable41_2
   \   00000072   0x7008             STRB     R0,[R1, #+0]
   6286              return 1;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xE03A             B.N      ??BlackGetPre_3
   6287            }
   6288            else
   6289            {
   6290              //有可能一行采集成功，所以要扫尾。
   6291              BlackLeftLoc[CameraHight - 1][0] = MaxValUint8;
   \                     ??BlackGetPre_4: (+1)
   \   00000078   0x20FF             MOVS     R0,#+255
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable41_3
   \   0000007E   0xF881 0x00B1      STRB     R0,[R1, #+177]
   6292              BlackLeftLoc[CameraHight - 2][0] = MaxValUint8;
   \   00000082   0x20FF             MOVS     R0,#+255
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable41_3
   \   00000088   0xF881 0x00AE      STRB     R0,[R1, #+174]
   6293            }
   6294            
   6295            //左线头扫描失败，则扫描右线头
   6296            BlackGetRightParaInit();  //参数初始化
   \   0000008C   0x.... 0x....      BL       BlackGetRightParaInit
   6297            temp1 = BlackGetRightStep1Edge(CameraHight - 1, 1, 1);  //第三个参数1表示是黑线预处理
   \   00000090   0x2201             MOVS     R2,#+1
   \   00000092   0x2101             MOVS     R1,#+1
   \   00000094   0x203B             MOVS     R0,#+59
   \   00000096   0x.... 0x....      BL       BlackGetRightStep1Edge
   \   0000009A   0x0004             MOVS     R4,R0
   6298            temp2 = BlackGetRightStep1Edge(CameraHight - 2, 2, 1);  //第三个参数1表示是黑线预处理
   \   0000009C   0x2201             MOVS     R2,#+1
   \   0000009E   0x2102             MOVS     R1,#+2
   \   000000A0   0x203A             MOVS     R0,#+58
   \   000000A2   0x.... 0x....      BL       BlackGetRightStep1Edge
   6299            if(
   6300              (temp1 == 1)
   6301            &&(temp2 == 1)
   6302            &&(AbsInt(BlackRightLoc[CameraHight - 1][0] - BlackRightLoc[CameraHight - 2][0]) < BlackRightStep1ScanMinus)  //两点列差不能太大。
   6303              )
   \   000000A6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A8   0x2C01             CMP      R4,#+1
   \   000000AA   0xD113             BNE.N    ??BlackGetPre_5
   \   000000AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AE   0x2801             CMP      R0,#+1
   \   000000B0   0xD110             BNE.N    ??BlackGetPre_5
   \   000000B2   0x....             LDR.N    R0,??DataTable40_26
   \   000000B4   0xF890 0x00B1      LDRB     R0,[R0, #+177]
   \   000000B8   0x....             LDR.N    R1,??DataTable40_26
   \   000000BA   0xF891 0x10AE      LDRB     R1,[R1, #+174]
   \   000000BE   0x1A40             SUBS     R0,R0,R1
   \   000000C0   0x.... 0x....      BL       AbsInt
   \   000000C4   0x2808             CMP      R0,#+8
   \   000000C6   0xDA05             BGE.N    ??BlackGetPre_5
   6304            {
   6305              //右线头采集成功，从右线开始扫描。
   6306              BlackGetPreDir = 1;
   \   000000C8   0x2001             MOVS     R0,#+1
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable41_2
   \   000000CE   0x7008             STRB     R0,[R1, #+0]
   6307              return 1;    
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0xE00C             B.N      ??BlackGetPre_3
   6308            }
   6309            else
   6310            {
   6311              //有可能一行采集成功，所以要扫尾。
   6312              BlackRightLoc[CameraHight - 1][0] = MaxValUint8;
   \                     ??BlackGetPre_5: (+1)
   \   000000D4   0x20FF             MOVS     R0,#+255
   \   000000D6   0x....             LDR.N    R1,??DataTable40_26
   \   000000D8   0xF881 0x00B1      STRB     R0,[R1, #+177]
   6313              BlackRightLoc[CameraHight - 2][0] = MaxValUint8;    
   \   000000DC   0x20FF             MOVS     R0,#+255
   \   000000DE   0x....             LDR.N    R1,??DataTable40_26
   \   000000E0   0xF881 0x00AE      STRB     R0,[R1, #+174]
   6314              
   6315              //两线线头均采集失败，则应该是十字，仍然从左线开始扫描。
   6316              BlackGetPreDir = 2;
   \   000000E4   0x2002             MOVS     R0,#+2
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable41_2
   \   000000EA   0x7008             STRB     R0,[R1, #+0]
   6317              return 1;
   \   000000EC   0x2001             MOVS     R0,#+1
   \                     ??BlackGetPre_3: (+1)
   \   000000EE   0xBD10             POP      {R4,PC}          ;; return
   6318            }
   6319          }
   6320          
   6321          
   6322          
   6323          //黑线检测最后一步，找单线错误。///////////////////////////////这种检测单线错误的方法对浅色或者白色地板，效果会很差。
   6324          //1正常（没检测到单线错误，或检测到单线错误并成功处理），0出错（这幅图像直接会判定为失败）

   \                                 In section .text, align 2, keep-with-next
   6325          uint8 BlackSingleSpeCheck(void)   
   6326          {
   \                     BlackSingleSpeCheck: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   6327            uint8 temp1, temp2, index1;
   6328            uint8 tempstep1row = MaxValUint8;
   \   00000002   0x24FF             MOVS     R4,#+255
   6329            int avgr1, avgr2, avgl1, avgl2;
   6330            int i;
   6331            
   6332            //两线都成功，不是单线。
   6333            if(
   6334               (BlackLeftDone == 1)
   6335             &&(BlackRightDone == 1)
   6336               )
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable41_4
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xF040 0x85CF      BNE.W    ??BlackSingleSpeCheck_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable41_5
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xF040 0x85C9      BNE.W    ??BlackSingleSpeCheck_0
   6337            {
   6338              //检查左线悬空，注意不要在十字误判。
   6339              if(
   6340                 (BlackRightStep1ScanRow == CameraHight - 1 && BlackLeftStep1ScanRow < CameraHight - 1) //左线尾较远，右线尾最近行。 
   6341               &&(BlackRightLoc[BlackRightStep1ScanRow][0] != MaxValUint8 && BlackLeftLoc[BlackLeftStep1ScanRow][0] != MaxValUint8) //没有被大跳变滤掉 
   6342               &&(BlackRightLoc[BlackRightStep1ScanRow-1][0] != MaxValUint8 && BlackLeftLoc[BlackLeftStep1ScanRow-1][0] != MaxValUint8) //没有被大跳变滤掉 
   6343               &&(BlackRightLoc[BlackRightStep1ScanRow-2][0] != MaxValUint8 && BlackLeftLoc[BlackLeftStep1ScanRow-2][0] != MaxValUint8) //没有被大跳变滤掉   
   6344                 )
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable42
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x283B             CMP      R0,#+59
   \   00000024   0xF040 0x82E1      BNE.W    ??BlackSingleSpeCheck_1
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable41_6
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x283B             CMP      R0,#+59
   \   00000030   0xF280 0x82DB      BGE.W    ??BlackSingleSpeCheck_1
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable42_1
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable42
   \   0000003C   0x7809             LDRB     R1,[R1, #+0]
   \   0000003E   0x2203             MOVS     R2,#+3
   \   00000040   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0x28FF             CMP      R0,#+255
   \   00000048   0xF000 0x82CF      BEQ.W    ??BlackSingleSpeCheck_1
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable41_3
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable41_6
   \   00000054   0x7809             LDRB     R1,[R1, #+0]
   \   00000056   0x2203             MOVS     R2,#+3
   \   00000058   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x28FF             CMP      R0,#+255
   \   00000060   0xF000 0x82C3      BEQ.W    ??BlackSingleSpeCheck_1
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable42_1
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable42
   \   0000006C   0x7809             LDRB     R1,[R1, #+0]
   \   0000006E   0x2203             MOVS     R2,#+3
   \   00000070   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000074   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000078   0x28FF             CMP      R0,#+255
   \   0000007A   0xF000 0x82B6      BEQ.W    ??BlackSingleSpeCheck_1
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable41_3
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable41_6
   \   00000086   0x7809             LDRB     R1,[R1, #+0]
   \   00000088   0x2203             MOVS     R2,#+3
   \   0000008A   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000008E   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000092   0x28FF             CMP      R0,#+255
   \   00000094   0xF000 0x82A9      BEQ.W    ??BlackSingleSpeCheck_1
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable42_1
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable42
   \   000000A0   0x7809             LDRB     R1,[R1, #+0]
   \   000000A2   0x2203             MOVS     R2,#+3
   \   000000A4   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000000A8   0xF810 0x0C06      LDRB     R0,[R0, #-6]
   \   000000AC   0x28FF             CMP      R0,#+255
   \   000000AE   0xF000 0x829C      BEQ.W    ??BlackSingleSpeCheck_1
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable41_3
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable41_6
   \   000000BA   0x7809             LDRB     R1,[R1, #+0]
   \   000000BC   0x2203             MOVS     R2,#+3
   \   000000BE   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000000C2   0xF810 0x0C06      LDRB     R0,[R0, #-6]
   \   000000C6   0x28FF             CMP      R0,#+255
   \   000000C8   0xF000 0x828F      BEQ.W    ??BlackSingleSpeCheck_1
   6345              {
   6346                //1. 检查左线的左边一个单线宽度内是不是有右线。      
   6347                if(
   6348                  (BlackLeftLoc[BlackLeftStep1ScanRow-1][0] > SingleBlackWidthMax[BlackLeftStep1ScanRow-1] * 1)
   6349                &&(BlackLeftLoc[BlackLeftStep1ScanRow-2][0] > SingleBlackWidthMax[BlackLeftStep1ScanRow-2] * 1) //左线头不能太靠左，至少要留出1个单线宽度。 
   6350                &&(BlackLeftLoc[BlackLeftStep1ScanRow-1][0] < CameraRealWidth / 2 + 60)  
   6351                &&(BlackLeftLoc[BlackLeftStep1ScanRow-2][0] < CameraRealWidth / 2 + 60)  //左线不能太靠右，大致要在左半边屏内。
   6352                  )
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable42_2
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable41_6
   \   000000D4   0x7809             LDRB     R1,[R1, #+0]
   \   000000D6   0x1808             ADDS     R0,R1,R0
   \   000000D8   0xF810 0x0C01      LDRB     R0,[R0, #-1]
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable41_3
   \   000000E0   0x.... 0x....      LDR.W    R2,??DataTable41_6
   \   000000E4   0x7812             LDRB     R2,[R2, #+0]
   \   000000E6   0x2303             MOVS     R3,#+3
   \   000000E8   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000000EC   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   000000F0   0x4288             CMP      R0,R1
   \   000000F2   0xF080 0x821F      BCS.W    ??BlackSingleSpeCheck_2
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable42_2
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable41_6
   \   000000FE   0x7809             LDRB     R1,[R1, #+0]
   \   00000100   0x1808             ADDS     R0,R1,R0
   \   00000102   0xF810 0x0C02      LDRB     R0,[R0, #-2]
   \   00000106   0x.... 0x....      LDR.W    R1,??DataTable41_3
   \   0000010A   0x.... 0x....      LDR.W    R2,??DataTable41_6
   \   0000010E   0x7812             LDRB     R2,[R2, #+0]
   \   00000110   0x2303             MOVS     R3,#+3
   \   00000112   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000116   0xF811 0x1C06      LDRB     R1,[R1, #-6]
   \   0000011A   0x4288             CMP      R0,R1
   \   0000011C   0xF080 0x820A      BCS.W    ??BlackSingleSpeCheck_2
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable41_3
   \   00000124   0x.... 0x....      LDR.W    R1,??DataTable41_6
   \   00000128   0x7809             LDRB     R1,[R1, #+0]
   \   0000012A   0x2203             MOVS     R2,#+3
   \   0000012C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000130   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000134   0x28B9             CMP      R0,#+185
   \   00000136   0xF280 0x81FD      BGE.W    ??BlackSingleSpeCheck_2
   \   0000013A   0x.... 0x....      LDR.W    R0,??DataTable41_3
   \   0000013E   0x.... 0x....      LDR.W    R1,??DataTable41_6
   \   00000142   0x7809             LDRB     R1,[R1, #+0]
   \   00000144   0x2203             MOVS     R2,#+3
   \   00000146   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000014A   0xF810 0x0C06      LDRB     R0,[R0, #-6]
   \   0000014E   0x28B9             CMP      R0,#+185
   \   00000150   0xF280 0x81F0      BGE.W    ??BlackSingleSpeCheck_2
   6353                {
   6354                  //开一个单线宽度的窗来检测是不是有右线。temp1和temp2为右黑线的白点位置。
   6355                  temp1 = BlackGetRightJustWin(BlackLeftStep1ScanRow-1, 
   6356                                               BlackLeftLoc[BlackLeftStep1ScanRow-1][0] - SingleBlackWidthMax[BlackLeftStep1ScanRow-1], //最多最多跨过15列，所以20列应该够。
   6357                                               BlackLeftLoc[BlackLeftStep1ScanRow-1][0]);
   \   00000154   0x.... 0x....      LDR.W    R0,??DataTable41_3
   \   00000158   0x.... 0x....      LDR.W    R1,??DataTable41_6
   \   0000015C   0x7809             LDRB     R1,[R1, #+0]
   \   0000015E   0x2203             MOVS     R2,#+3
   \   00000160   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000164   0xF810 0x2C03      LDRB     R2,[R0, #-3]
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable41_3
   \   0000016C   0x.... 0x....      LDR.W    R1,??DataTable41_6
   \   00000170   0x7809             LDRB     R1,[R1, #+0]
   \   00000172   0x2303             MOVS     R3,#+3
   \   00000174   0xFB03 0x0001      MLA      R0,R3,R1,R0
   \   00000178   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000017C   0x.... 0x....      LDR.W    R1,??DataTable42_2
   \   00000180   0x.... 0x....      LDR.W    R3,??DataTable41_6
   \   00000184   0x781B             LDRB     R3,[R3, #+0]
   \   00000186   0x1859             ADDS     R1,R3,R1
   \   00000188   0xF811 0x1C01      LDRB     R1,[R1, #-1]
   \   0000018C   0x1A41             SUBS     R1,R0,R1
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable41_6
   \   00000192   0x7800             LDRB     R0,[R0, #+0]
   \   00000194   0x1E40             SUBS     R0,R0,#+1
   \   00000196   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000198   0x.... 0x....      BL       BlackGetRightJustWin
   \   0000019C   0x0006             MOVS     R6,R0
   6358                  temp2 = BlackGetRightJustWin(BlackLeftStep1ScanRow-2, 
   6359                                               BlackLeftLoc[BlackLeftStep1ScanRow-2][0] - SingleBlackWidthMax[BlackLeftStep1ScanRow-2], //最多最多跨过15列，所以20列应该够。
   6360                                               BlackLeftLoc[BlackLeftStep1ScanRow-2][0]);
   \   0000019E   0x.... 0x....      LDR.W    R0,??DataTable41_3
   \   000001A2   0x.... 0x....      LDR.W    R1,??DataTable41_6
   \   000001A6   0x7809             LDRB     R1,[R1, #+0]
   \   000001A8   0x2203             MOVS     R2,#+3
   \   000001AA   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000001AE   0xF810 0x2C06      LDRB     R2,[R0, #-6]
   \   000001B2   0x.... 0x....      LDR.W    R0,??DataTable41_3
   \   000001B6   0x.... 0x....      LDR.W    R1,??DataTable41_6
   \   000001BA   0x7809             LDRB     R1,[R1, #+0]
   \   000001BC   0x2303             MOVS     R3,#+3
   \   000001BE   0xFB03 0x0001      MLA      R0,R3,R1,R0
   \   000001C2   0xF810 0x0C06      LDRB     R0,[R0, #-6]
   \   000001C6   0x.... 0x....      LDR.W    R1,??DataTable42_2
   \   000001CA   0x.... 0x....      LDR.W    R3,??DataTable41_6
   \   000001CE   0x781B             LDRB     R3,[R3, #+0]
   \   000001D0   0x1859             ADDS     R1,R3,R1
   \   000001D2   0xF811 0x1C02      LDRB     R1,[R1, #-2]
   \   000001D6   0x1A41             SUBS     R1,R0,R1
   \   000001D8   0x.... 0x....      LDR.W    R0,??DataTable41_6
   \   000001DC   0x7800             LDRB     R0,[R0, #+0]
   \   000001DE   0x1E80             SUBS     R0,R0,#+2
   \   000001E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001E2   0x.... 0x....      BL       BlackGetRightJustWin
   \   000001E6   0x0005             MOVS     R5,R0
   6361                  //必须连续两行有右黑线。而且两个黑点所在列不能相差太大。 
   6362                  if(temp1 != MaxValUint8 && temp2 != MaxValUint8 && AbsInt(temp1 - temp2) < 8)
   \   000001E8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001EA   0x2EFF             CMP      R6,#+255
   \   000001EC   0xF000 0x81A2      BEQ.W    ??BlackSingleSpeCheck_2
   \   000001F0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001F2   0x2DFF             CMP      R5,#+255
   \   000001F4   0xF000 0x819E      BEQ.W    ??BlackSingleSpeCheck_2
   \   000001F8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001FA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001FC   0x1B70             SUBS     R0,R6,R5
   \   000001FE   0x.... 0x....      BL       AbsInt
   \   00000202   0x2808             CMP      R0,#+8
   \   00000204   0xF280 0x8196      BGE.W    ??BlackSingleSpeCheck_2
   6363                  {          
   6364                    //第一行右线的白点平均值
   6365                    avgr1 = (ImgNew[BlackLeftStep1ScanRow-1][temp1 - 1]
   6366                           + ImgNew[BlackLeftStep1ScanRow-1][temp1 - 2]
   6367                           + ImgNew[BlackLeftStep1ScanRow-1][temp1 - 3]
   6368                           + ImgNew[BlackLeftStep1ScanRow-1][temp1 - 4]
   6369                           + ImgNew[BlackLeftStep1ScanRow-1][temp1 - 5])
   6370                           / 5;
   \   00000208   0x.... 0x....      LDR.W    R0,??DataTable42_3
   \   0000020C   0x.... 0x....      LDR.W    R1,??DataTable41_6
   \   00000210   0x7809             LDRB     R1,[R1, #+0]
   \   00000212   0x22FA             MOVS     R2,#+250
   \   00000214   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000218   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000021A   0x1830             ADDS     R0,R6,R0
   \   0000021C   0xF810 0x0CFB      LDRB     R0,[R0, #-251]
   \   00000220   0x.... 0x....      LDR.W    R1,??DataTable42_3
   \   00000224   0x.... 0x....      LDR.W    R2,??DataTable41_6
   \   00000228   0x7812             LDRB     R2,[R2, #+0]
   \   0000022A   0x23FA             MOVS     R3,#+250
   \   0000022C   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000230   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000232   0x1871             ADDS     R1,R6,R1
   \   00000234   0xF811 0x1CFC      LDRB     R1,[R1, #-252]
   \   00000238   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   0000023C   0x.... 0x....      LDR.W    R1,??DataTable42_3
   \   00000240   0x.... 0x....      LDR.W    R2,??DataTable41_6
   \   00000244   0x7812             LDRB     R2,[R2, #+0]
   \   00000246   0x23FA             MOVS     R3,#+250
   \   00000248   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   0000024C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000024E   0x1871             ADDS     R1,R6,R1
   \   00000250   0xF811 0x1CFD      LDRB     R1,[R1, #-253]
   \   00000254   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   00000258   0x.... 0x....      LDR.W    R1,??DataTable42_3
   \   0000025C   0x.... 0x....      LDR.W    R2,??DataTable41_6
   \   00000260   0x7812             LDRB     R2,[R2, #+0]
   \   00000262   0x23FA             MOVS     R3,#+250
   \   00000264   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000268   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000026A   0x1871             ADDS     R1,R6,R1
   \   0000026C   0xF811 0x1CFE      LDRB     R1,[R1, #-254]
   \   00000270   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   00000274   0x.... 0x....      LDR.W    R1,??DataTable42_3
   \   00000278   0x.... 0x....      LDR.W    R2,??DataTable41_6
   \   0000027C   0x7812             LDRB     R2,[R2, #+0]
   \   0000027E   0x23FA             MOVS     R3,#+250
   \   00000280   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000284   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000286   0x1871             ADDS     R1,R6,R1
   \   00000288   0xF811 0x1CFF      LDRB     R1,[R1, #-255]
   \   0000028C   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   00000290   0x2105             MOVS     R1,#+5
   \   00000292   0xFB90 0xF0F1      SDIV     R0,R0,R1
   6371                    //第一行左线的白点平均值
   6372                    avgl1 = (ImgNew[BlackLeftStep1ScanRow-1][BlackLeftLoc[BlackLeftStep1ScanRow-1][0] + 1 + BlackLeftEdgeNum + 1]
   6373                           + ImgNew[BlackLeftStep1ScanRow-1][BlackLeftLoc[BlackLeftStep1ScanRow-1][0] + 1 + BlackLeftEdgeNum + 2]
   6374                           + ImgNew[BlackLeftStep1ScanRow-1][BlackLeftLoc[BlackLeftStep1ScanRow-1][0] + 1 + BlackLeftEdgeNum + 3]
   6375                           + ImgNew[BlackLeftStep1ScanRow-1][BlackLeftLoc[BlackLeftStep1ScanRow-1][0] + 1 + BlackLeftEdgeNum + 4]
   6376                           + ImgNew[BlackLeftStep1ScanRow-1][BlackLeftLoc[BlackLeftStep1ScanRow-1][0] + 1 + BlackLeftEdgeNum + 5])
   6377                           / 5;          
   \   00000296   0x.... 0x....      LDR.W    R1,??DataTable42_3
   \   0000029A   0x.... 0x....      LDR.W    R2,??DataTable41_6
   \   0000029E   0x7812             LDRB     R2,[R2, #+0]
   \   000002A0   0x23FA             MOVS     R3,#+250
   \   000002A2   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000002A6   0x.... 0x....      LDR.W    R2,??DataTable41_3
   \   000002AA   0x.... 0x....      LDR.W    R3,??DataTable41_6
   \   000002AE   0x781B             LDRB     R3,[R3, #+0]
   \   000002B0   0x2603             MOVS     R6,#+3
   \   000002B2   0xFB06 0x2203      MLA      R2,R6,R3,R2
   \   000002B6   0xF812 0x2C03      LDRB     R2,[R2, #-3]
   \   000002BA   0x1851             ADDS     R1,R2,R1
   \   000002BC   0xF811 0x1CF5      LDRB     R1,[R1, #-245]
   \   000002C0   0x.... 0x....      LDR.W    R2,??DataTable42_3
   \   000002C4   0x.... 0x....      LDR.W    R3,??DataTable41_6
   \   000002C8   0x781B             LDRB     R3,[R3, #+0]
   \   000002CA   0x26FA             MOVS     R6,#+250
   \   000002CC   0xFB06 0x2203      MLA      R2,R6,R3,R2
   \   000002D0   0x.... 0x....      LDR.W    R3,??DataTable41_3
   \   000002D4   0x.... 0x....      LDR.W    R6,??DataTable41_6
   \   000002D8   0x7836             LDRB     R6,[R6, #+0]
   \   000002DA   0x2703             MOVS     R7,#+3
   \   000002DC   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   000002E0   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   000002E4   0x189A             ADDS     R2,R3,R2
   \   000002E6   0xF812 0x2CF4      LDRB     R2,[R2, #-244]
   \   000002EA   0xFA52 0xF181      UXTAB    R1,R2,R1
   \   000002EE   0x.... 0x....      LDR.W    R2,??DataTable42_3
   \   000002F2   0x.... 0x....      LDR.W    R3,??DataTable41_6
   \   000002F6   0x781B             LDRB     R3,[R3, #+0]
   \   000002F8   0x26FA             MOVS     R6,#+250
   \   000002FA   0xFB06 0x2203      MLA      R2,R6,R3,R2
   \   000002FE   0x.... 0x....      LDR.W    R3,??DataTable41_3
   \   00000302   0x.... 0x....      LDR.W    R6,??DataTable41_6
   \   00000306   0x7836             LDRB     R6,[R6, #+0]
   \   00000308   0x2703             MOVS     R7,#+3
   \   0000030A   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   0000030E   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   00000312   0x189A             ADDS     R2,R3,R2
   \   00000314   0xF812 0x2CF3      LDRB     R2,[R2, #-243]
   \   00000318   0xFA51 0xF182      UXTAB    R1,R1,R2
   \   0000031C   0x.... 0x....      LDR.W    R2,??DataTable42_3
   \   00000320   0x.... 0x....      LDR.W    R3,??DataTable41_6
   \   00000324   0x781B             LDRB     R3,[R3, #+0]
   \   00000326   0x26FA             MOVS     R6,#+250
   \   00000328   0xFB06 0x2203      MLA      R2,R6,R3,R2
   \   0000032C   0x.... 0x....      LDR.W    R3,??DataTable41_3
   \   00000330   0x.... 0x....      LDR.W    R6,??DataTable41_6
   \   00000334   0x7836             LDRB     R6,[R6, #+0]
   \   00000336   0x2703             MOVS     R7,#+3
   \   00000338   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   0000033C   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   00000340   0x189A             ADDS     R2,R3,R2
   \   00000342   0xF812 0x2CF2      LDRB     R2,[R2, #-242]
   \   00000346   0xFA51 0xF182      UXTAB    R1,R1,R2
   \   0000034A   0x.... 0x....      LDR.W    R2,??DataTable42_3
   \   0000034E   0x.... 0x....      LDR.W    R3,??DataTable41_6
   \   00000352   0x781B             LDRB     R3,[R3, #+0]
   \   00000354   0x26FA             MOVS     R6,#+250
   \   00000356   0xFB06 0x2203      MLA      R2,R6,R3,R2
   \   0000035A   0x.... 0x....      LDR.W    R3,??DataTable41_3
   \   0000035E   0x.... 0x....      LDR.W    R6,??DataTable41_6
   \   00000362   0x7836             LDRB     R6,[R6, #+0]
   \   00000364   0x2703             MOVS     R7,#+3
   \   00000366   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   0000036A   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   0000036E   0x189A             ADDS     R2,R3,R2
   \   00000370   0xF812 0x2CF1      LDRB     R2,[R2, #-241]
   \   00000374   0xFA51 0xF182      UXTAB    R1,R1,R2
   \   00000378   0x2205             MOVS     R2,#+5
   \   0000037A   0xFB91 0xF1F2      SDIV     R1,R1,R2
   6378                    //第二行右线的白点平均值
   6379                    avgr2 = (ImgNew[BlackLeftStep1ScanRow-2][temp2 - 1]
   6380                           + ImgNew[BlackLeftStep1ScanRow-2][temp2 - 2]
   6381                           + ImgNew[BlackLeftStep1ScanRow-2][temp2 - 3]
   6382                           + ImgNew[BlackLeftStep1ScanRow-2][temp2 - 4]
   6383                           + ImgNew[BlackLeftStep1ScanRow-2][temp2 - 5])
   6384                           / 5;
   \   0000037E   0x.... 0x....      LDR.W    R2,??DataTable42_3
   \   00000382   0x.... 0x....      LDR.W    R3,??DataTable41_6
   \   00000386   0x781B             LDRB     R3,[R3, #+0]
   \   00000388   0x26FA             MOVS     R6,#+250
   \   0000038A   0xFB06 0x2203      MLA      R2,R6,R3,R2
   \   0000038E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000390   0x18AA             ADDS     R2,R5,R2
   \   00000392   0xF2A2 0x12F5      SUBW     R2,R2,#+501
   \   00000396   0x7812             LDRB     R2,[R2, #+0]
   \   00000398   0x.... 0x....      LDR.W    R3,??DataTable42_3
   \   0000039C   0x.... 0x....      LDR.W    R6,??DataTable41_6
   \   000003A0   0x7836             LDRB     R6,[R6, #+0]
   \   000003A2   0x27FA             MOVS     R7,#+250
   \   000003A4   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   000003A8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003AA   0x18EB             ADDS     R3,R5,R3
   \   000003AC   0xF5B3 0x73FB      SUBS     R3,R3,#+502
   \   000003B0   0x781B             LDRB     R3,[R3, #+0]
   \   000003B2   0xFA53 0xF282      UXTAB    R2,R3,R2
   \   000003B6   0x.... 0x....      LDR.W    R3,??DataTable42_3
   \   000003BA   0x.... 0x....      LDR.W    R6,??DataTable41_6
   \   000003BE   0x7836             LDRB     R6,[R6, #+0]
   \   000003C0   0x27FA             MOVS     R7,#+250
   \   000003C2   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   000003C6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003C8   0x18EB             ADDS     R3,R5,R3
   \   000003CA   0xF2A3 0x13F7      SUBW     R3,R3,#+503
   \   000003CE   0x781B             LDRB     R3,[R3, #+0]
   \   000003D0   0xFA52 0xF283      UXTAB    R2,R2,R3
   \   000003D4   0x.... 0x....      LDR.W    R3,??DataTable42_3
   \   000003D8   0x.... 0x....      LDR.W    R6,??DataTable41_6
   \   000003DC   0x7836             LDRB     R6,[R6, #+0]
   \   000003DE   0x27FA             MOVS     R7,#+250
   \   000003E0   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   000003E4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003E6   0x18EB             ADDS     R3,R5,R3
   \   000003E8   0xF5B3 0x73FC      SUBS     R3,R3,#+504
   \   000003EC   0x781B             LDRB     R3,[R3, #+0]
   \   000003EE   0xFA52 0xF283      UXTAB    R2,R2,R3
   \   000003F2   0x.... 0x....      LDR.W    R3,??DataTable42_3
   \   000003F6   0x.... 0x....      LDR.W    R6,??DataTable41_6
   \   000003FA   0x7836             LDRB     R6,[R6, #+0]
   \   000003FC   0x27FA             MOVS     R7,#+250
   \   000003FE   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   00000402   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000404   0x18EB             ADDS     R3,R5,R3
   \   00000406   0xF2A3 0x13F9      SUBW     R3,R3,#+505
   \   0000040A   0x781B             LDRB     R3,[R3, #+0]
   \   0000040C   0xFA52 0xF283      UXTAB    R2,R2,R3
   \   00000410   0x2305             MOVS     R3,#+5
   \   00000412   0xFB92 0xF5F3      SDIV     R5,R2,R3
   6385                    //第二行左线的白点平均值
   6386                    avgl2 = (ImgNew[BlackLeftStep1ScanRow-2][BlackLeftLoc[BlackLeftStep1ScanRow-2][0] + 1 + BlackLeftEdgeNum + 1]
   6387                           + ImgNew[BlackLeftStep1ScanRow-2][BlackLeftLoc[BlackLeftStep1ScanRow-2][0] + 1 + BlackLeftEdgeNum + 2]
   6388                           + ImgNew[BlackLeftStep1ScanRow-2][BlackLeftLoc[BlackLeftStep1ScanRow-2][0] + 1 + BlackLeftEdgeNum + 3]
   6389                           + ImgNew[BlackLeftStep1ScanRow-2][BlackLeftLoc[BlackLeftStep1ScanRow-2][0] + 1 + BlackLeftEdgeNum + 4]
   6390                           + ImgNew[BlackLeftStep1ScanRow-2][BlackLeftLoc[BlackLeftStep1ScanRow-2][0] + 1 + BlackLeftEdgeNum + 5])
   6391                           / 5;          
   \   00000416   0x.... 0x....      LDR.W    R2,??DataTable42_3
   \   0000041A   0x.... 0x....      LDR.W    R3,??DataTable41_6
   \   0000041E   0x781B             LDRB     R3,[R3, #+0]
   \   00000420   0x26FA             MOVS     R6,#+250
   \   00000422   0xFB06 0x2203      MLA      R2,R6,R3,R2
   \   00000426   0x.... 0x....      LDR.W    R3,??DataTable41_3
   \   0000042A   0x.... 0x....      LDR.W    R6,??DataTable41_6
   \   0000042E   0x7836             LDRB     R6,[R6, #+0]
   \   00000430   0x2703             MOVS     R7,#+3
   \   00000432   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   00000436   0xF813 0x3C06      LDRB     R3,[R3, #-6]
   \   0000043A   0x189A             ADDS     R2,R3,R2
   \   0000043C   0xF2A2 0x12EF      SUBW     R2,R2,#+495
   \   00000440   0x7812             LDRB     R2,[R2, #+0]
   \   00000442   0x.... 0x....      LDR.W    R3,??DataTable42_3
   \   00000446   0x.... 0x....      LDR.W    R6,??DataTable41_6
   \   0000044A   0x7836             LDRB     R6,[R6, #+0]
   \   0000044C   0x27FA             MOVS     R7,#+250
   \   0000044E   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   00000452   0x.... 0x....      LDR.W    R6,??DataTable41_3
   \   00000456   0x.... 0x....      LDR.W    R7,??DataTable41_6
   \   0000045A   0x783F             LDRB     R7,[R7, #+0]
   \   0000045C   0xF05F 0x0C03      MOVS     R12,#+3
   \   00000460   0xFB0C 0x6607      MLA      R6,R12,R7,R6
   \   00000464   0xF816 0x6C06      LDRB     R6,[R6, #-6]
   \   00000468   0x18F3             ADDS     R3,R6,R3
   \   0000046A   0xF5B3 0x73F7      SUBS     R3,R3,#+494
   \   0000046E   0x781B             LDRB     R3,[R3, #+0]
   \   00000470   0xFA53 0xF282      UXTAB    R2,R3,R2
   \   00000474   0x.... 0x....      LDR.W    R3,??DataTable42_3
   \   00000478   0x.... 0x....      LDR.W    R6,??DataTable41_6
   \   0000047C   0x7836             LDRB     R6,[R6, #+0]
   \   0000047E   0x27FA             MOVS     R7,#+250
   \   00000480   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   00000484   0x.... 0x....      LDR.W    R6,??DataTable41_3
   \   00000488   0x.... 0x....      LDR.W    R7,??DataTable41_6
   \   0000048C   0x783F             LDRB     R7,[R7, #+0]
   \   0000048E   0xF05F 0x0C03      MOVS     R12,#+3
   \   00000492   0xFB0C 0x6607      MLA      R6,R12,R7,R6
   \   00000496   0xF816 0x6C06      LDRB     R6,[R6, #-6]
   \   0000049A   0x18F3             ADDS     R3,R6,R3
   \   0000049C   0xF2A3 0x13ED      SUBW     R3,R3,#+493
   \   000004A0   0x781B             LDRB     R3,[R3, #+0]
   \   000004A2   0xFA52 0xF283      UXTAB    R2,R2,R3
   \   000004A6   0x.... 0x....      LDR.W    R3,??DataTable42_3
   \   000004AA   0x.... 0x....      LDR.W    R6,??DataTable41_6
   \   000004AE   0x7836             LDRB     R6,[R6, #+0]
   \   000004B0   0x27FA             MOVS     R7,#+250
   \   000004B2   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   000004B6   0x.... 0x....      LDR.W    R6,??DataTable41_3
   \   000004BA   0x.... 0x....      LDR.W    R7,??DataTable41_6
   \   000004BE   0x783F             LDRB     R7,[R7, #+0]
   \   000004C0   0xF05F 0x0C03      MOVS     R12,#+3
   \   000004C4   0xFB0C 0x6607      MLA      R6,R12,R7,R6
   \   000004C8   0xF816 0x6C06      LDRB     R6,[R6, #-6]
   \   000004CC   0x18F3             ADDS     R3,R6,R3
   \   000004CE   0xF5B3 0x73F6      SUBS     R3,R3,#+492
   \   000004D2   0x781B             LDRB     R3,[R3, #+0]
   \   000004D4   0xFA52 0xF283      UXTAB    R2,R2,R3
   \   000004D8   0x.... 0x....      LDR.W    R3,??DataTable42_3
   \   000004DC   0x.... 0x....      LDR.W    R6,??DataTable41_6
   \   000004E0   0x7836             LDRB     R6,[R6, #+0]
   \   000004E2   0x27FA             MOVS     R7,#+250
   \   000004E4   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   000004E8   0x.... 0x....      LDR.W    R6,??DataTable41_3
   \   000004EC   0x.... 0x....      LDR.W    R7,??DataTable41_6
   \   000004F0   0x783F             LDRB     R7,[R7, #+0]
   \   000004F2   0xF05F 0x0C03      MOVS     R12,#+3
   \   000004F6   0xFB0C 0x6607      MLA      R6,R12,R7,R6
   \   000004FA   0xF816 0x6C06      LDRB     R6,[R6, #-6]
   \   000004FE   0x18F3             ADDS     R3,R6,R3
   \   00000500   0xF2A3 0x13EB      SUBW     R3,R3,#+491
   \   00000504   0x781B             LDRB     R3,[R3, #+0]
   \   00000506   0xFA52 0xF283      UXTAB    R2,R2,R3
   \   0000050A   0x2305             MOVS     R3,#+5
   \   0000050C   0xFB92 0xF6F3      SDIV     R6,R2,R3
   6392                    
   6393                    //最后一步，确认两者的白色点的平均值差别非常小。  /////////////////////此时若地板为浅色或者白色，就挂了。
   6394                    if(AbsInt(avgr1 - avgl1) < 15 && AbsInt(avgr2 - avgl2) < 15)
   \   00000510   0x1A40             SUBS     R0,R0,R1
   \   00000512   0x.... 0x....      BL       AbsInt
   \   00000516   0x280F             CMP      R0,#+15
   \   00000518   0xDA0C             BGE.N    ??BlackSingleSpeCheck_2
   \   0000051A   0x1BA8             SUBS     R0,R5,R6
   \   0000051C   0x.... 0x....      BL       AbsInt
   \   00000520   0x280F             CMP      R0,#+15
   \   00000522   0xDA07             BGE.N    ??BlackSingleSpeCheck_2
   6395                    {
   6396                      BlackSingleFlag = 1;        //单线错误标志置位。
   \   00000524   0x2001             MOVS     R0,#+1
   \   00000526   0x.... 0x....      LDR.W    R1,??DataTable42_4
   \   0000052A   0x7008             STRB     R0,[R1, #+0]
   6397                      BlackSingleDir = 0;         //表示是左线悬空的情况。
   \   0000052C   0x2000             MOVS     R0,#+0
   \   0000052E   0x.... 0x....      LDR.W    R1,??DataTable42_5
   \   00000532   0x7008             STRB     R0,[R1, #+0]
   6398                    }
   6399                    else
   6400                    {
   6401                    }
   6402                  }
   6403                  else
   6404                  {
   6405                  }
   6406                }
   6407                else
   6408                {
   6409                }
   6410                
   6411                //查看单线错误标志
   6412                if(BlackSingleFlag == 1)
   \                     ??BlackSingleSpeCheck_2: (+1)
   \   00000534   0x.... 0x....      LDR.W    R0,??DataTable42_4
   \   00000538   0x7800             LDRB     R0,[R0, #+0]
   \   0000053A   0x2801             CMP      R0,#+1
   \   0000053C   0xF040 0x8337      BNE.W    ??BlackSingleSpeCheck_0
   6413                {
   6414                  //确定是单线错误后，先把右黑线全置无效值。
   6415                  for(i = 0; ; i++)
   \   00000540   0x2500             MOVS     R5,#+0
   \   00000542   0xE000             B.N      ??BlackSingleSpeCheck_3
   \                     ??BlackSingleSpeCheck_4: (+1)
   \   00000544   0x1C6D             ADDS     R5,R5,#+1
   6416                  {
   6417                    BlackRightLoc[i][0] = MaxValUint8;           
   \                     ??BlackSingleSpeCheck_3: (+1)
   \   00000546   0x20FF             MOVS     R0,#+255
   \   00000548   0x.... 0x....      LDR.W    R1,??DataTable42_1
   \   0000054C   0x2203             MOVS     R2,#+3
   \   0000054E   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000552   0x7008             STRB     R0,[R1, #+0]
   6418                    if(i == CameraHight - 1) break;
   \   00000554   0x2D3B             CMP      R5,#+59
   \   00000556   0xD1F5             BNE.N    ??BlackSingleSpeCheck_4
   6419                  }
   6420                  
   6421                  index1 = 0;
   \   00000558   0x2700             MOVS     R7,#+0
   6422                  //然后从左线尾所在行开始开窗扫右线，一直到左线头所在行或者有未采到的行。
   6423                  for(i = BlackLeftStep1ScanRow; ; i--)
   \   0000055A   0x.... 0x....      LDR.W    R0,??DataTable41_6
   \   0000055E   0x7805             LDRB     R5,[R0, #+0]
   \   00000560   0xE000             B.N      ??BlackSingleSpeCheck_5
   \                     ??BlackSingleSpeCheck_6: (+1)
   \   00000562   0x1E6D             SUBS     R5,R5,#+1
   6424                  {
   6425                    temp1 = BlackGetRightJustWin(i, 
   6426                                                 BlackLeftLoc[i][0] - SingleBlackWidthMax[i], //最多最多跨过15列，所以20列应该够。
   6427                                                 BlackLeftLoc[i][0]);            
   \                     ??BlackSingleSpeCheck_5: (+1)
   \   00000564   0x.... 0x....      LDR.W    R0,??DataTable41_3
   \   00000568   0x2103             MOVS     R1,#+3
   \   0000056A   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000056E   0x7802             LDRB     R2,[R0, #+0]
   \   00000570   0x.... 0x....      LDR.W    R0,??DataTable41_3
   \   00000574   0x2103             MOVS     R1,#+3
   \   00000576   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000057A   0x7800             LDRB     R0,[R0, #+0]
   \   0000057C   0x.... 0x....      LDR.W    R1,??DataTable42_2
   \   00000580   0x5C69             LDRB     R1,[R5, R1]
   \   00000582   0x1A41             SUBS     R1,R0,R1
   \   00000584   0x0028             MOVS     R0,R5
   \   00000586   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000588   0x.... 0x....      BL       BlackGetRightJustWin
   \   0000058C   0x0006             MOVS     R6,R0
   6428                    if(temp1 != MaxValUint8)
   \   0000058E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000590   0x2EFF             CMP      R6,#+255
   \   00000592   0xD015             BEQ.N    ??BlackSingleSpeCheck_7
   6429                    {
   6430                      //该行扫描右黑线成功
   6431                      BlackRightLoc[i][0] = temp1 + 1 + BlackRightEdgeNum;
   \   00000594   0x1D30             ADDS     R0,R6,#+4
   \   00000596   0x.... 0x....      LDR.W    R1,??DataTable42_1
   \   0000059A   0x2203             MOVS     R2,#+3
   \   0000059C   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   000005A0   0x7008             STRB     R0,[R1, #+0]
   6432                      //记录右黑线扫描成功的最近行。
   6433                      if(index1 == 0)
   \   000005A2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000005A4   0x2F00             CMP      R7,#+0
   \   000005A6   0xD101             BNE.N    ??BlackSingleSpeCheck_8
   6434                      {
   6435                        tempstep1row = i;
   \   000005A8   0x002C             MOVS     R4,R5
   6436                        index1++;
   \   000005AA   0x1C7F             ADDS     R7,R7,#+1
   6437                      }
   6438                      else
   6439                      {
   6440                      }
   6441                    }
   6442                    else
   6443                    {
   6444                      //一旦没有采到，再远的行就不要了，直接退出。
   6445                      break;
   6446                    }
   6447                    //到左线头了，退出
   6448                    if(i == BlackLeftHeadLine) break;
   \                     ??BlackSingleSpeCheck_8: (+1)
   \   000005AC   0x.... 0x....      LDR.W    R0,??DataTable42_6
   \   000005B0   0x7800             LDRB     R0,[R0, #+0]
   \   000005B2   0x4285             CMP      R5,R0
   \   000005B4   0xD1D5             BNE.N    ??BlackSingleSpeCheck_6
   6449                  }
   6450                  
   6451                  //检测不到有效右黑线，返回失败。
   6452                  if(tempstep1row == MaxValUint8) return 0;
   \                     ??BlackSingleSpeCheck_9: (+1)
   \   000005B6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000005B8   0x2CFF             CMP      R4,#+255
   \   000005BA   0xD102             BNE.N    ??BlackSingleSpeCheck_10
   \   000005BC   0x2000             MOVS     R0,#+0
   \   000005BE   0xE2F7             B.N      ??BlackSingleSpeCheck_11
   \                     ??BlackSingleSpeCheck_7: (+1)
   \   000005C0   0xE7F9             B.N      ??BlackSingleSpeCheck_9
   6453                  
   6454                  //往远几行开始，向后补线。第2个输入参数是1。
   6455                  //不管左线之间的向后补线是否成功，都要放远几个点重新向后补一次
   6456                  if(BlackLeftStep4BackLine(BlackLeftStep1ScanRow - 2, 1) == 1 && BlackRightStep4BackLine(tempstep1row - 2, 1) == 1)
   \                     ??BlackSingleSpeCheck_10: (+1)
   \   000005C2   0x2101             MOVS     R1,#+1
   \   000005C4   0x.... 0x....      LDR.W    R0,??DataTable41_6
   \   000005C8   0x7800             LDRB     R0,[R0, #+0]
   \   000005CA   0x1E80             SUBS     R0,R0,#+2
   \   000005CC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005CE   0x.... 0x....      BL       BlackLeftStep4BackLine
   \   000005D2   0x2801             CMP      R0,#+1
   \   000005D4   0xD107             BNE.N    ??BlackSingleSpeCheck_12
   \   000005D6   0x2101             MOVS     R1,#+1
   \   000005D8   0x1EA0             SUBS     R0,R4,#+2
   \   000005DA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005DC   0x.... 0x....      BL       BlackRightStep4BackLine
   \   000005E0   0x2801             CMP      R0,#+1
   \   000005E2   0xF000 0x82E4      BEQ.W    ??BlackSingleSpeCheck_0
   6457                  {
   6458                  }
   6459                  else
   6460                  {
   6461                    //如果补线没有成功（有可能是点太少），那就直接返回失败，这幅图像直接判定为失败。
   6462                    return 0;
   \                     ??BlackSingleSpeCheck_12: (+1)
   \   000005E6   0x2000             MOVS     R0,#+0
   \   000005E8   0xE2E2             B.N      ??BlackSingleSpeCheck_11
   6463                  }           
   6464                  
   6465                  //置单线标志位SingleBlackAllFlag(用于CenterLineGet)。     
   6466                  //SingleBlackAllFlag = 1;     
   6467                  
   6468                }
   6469                //单线错误标志没有置位，不用作任何处理。
   6470                else
   6471                {
   6472                }
   6473                  
   6474              }
   6475              //检查右线悬空，注意不要在十字误判。
   6476              else if(
   6477                 (BlackLeftStep1ScanRow == CameraHight - 1 && BlackRightStep1ScanRow < CameraHight - 1) //右线尾较远，左线尾最近行。 
   6478               &&(BlackRightLoc[BlackRightStep1ScanRow][0] != MaxValUint8 && BlackLeftLoc[BlackLeftStep1ScanRow][0] != MaxValUint8) //没有被大跳变滤掉 
   6479               &&(BlackRightLoc[BlackRightStep1ScanRow-1][0] != MaxValUint8 && BlackLeftLoc[BlackLeftStep1ScanRow-1][0] != MaxValUint8) //没有被大跳变滤掉 
   6480               &&(BlackRightLoc[BlackRightStep1ScanRow-2][0] != MaxValUint8 && BlackLeftLoc[BlackLeftStep1ScanRow-2][0] != MaxValUint8) //没有被大跳变滤掉   
   6481                 )
   \                     ??BlackSingleSpeCheck_1: (+1)
   \   000005EA   0x.... 0x....      LDR.W    R0,??DataTable41_6
   \   000005EE   0x7800             LDRB     R0,[R0, #+0]
   \   000005F0   0x283B             CMP      R0,#+59
   \   000005F2   0xF040 0x82DC      BNE.W    ??BlackSingleSpeCheck_0
   \   000005F6   0x.... 0x....      LDR.W    R0,??DataTable42
   \   000005FA   0x7800             LDRB     R0,[R0, #+0]
   \   000005FC   0x283B             CMP      R0,#+59
   \   000005FE   0xF280 0x82D6      BGE.W    ??BlackSingleSpeCheck_0
   \   00000602   0x.... 0x....      LDR.W    R0,??DataTable42_1
   \   00000606   0x.... 0x....      LDR.W    R1,??DataTable42
   \   0000060A   0x7809             LDRB     R1,[R1, #+0]
   \   0000060C   0x2203             MOVS     R2,#+3
   \   0000060E   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000612   0x7800             LDRB     R0,[R0, #+0]
   \   00000614   0x28FF             CMP      R0,#+255
   \   00000616   0xF000 0x82CA      BEQ.W    ??BlackSingleSpeCheck_0
   \   0000061A   0x.... 0x....      LDR.W    R0,??DataTable41_3
   \   0000061E   0x.... 0x....      LDR.W    R1,??DataTable41_6
   \   00000622   0x7809             LDRB     R1,[R1, #+0]
   \   00000624   0x2203             MOVS     R2,#+3
   \   00000626   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000062A   0x7800             LDRB     R0,[R0, #+0]
   \   0000062C   0x28FF             CMP      R0,#+255
   \   0000062E   0xF000 0x82BE      BEQ.W    ??BlackSingleSpeCheck_0
   \   00000632   0x.... 0x....      LDR.W    R0,??DataTable42_1
   \   00000636   0x.... 0x....      LDR.W    R1,??DataTable42
   \   0000063A   0x7809             LDRB     R1,[R1, #+0]
   \   0000063C   0x2203             MOVS     R2,#+3
   \   0000063E   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000642   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000646   0x28FF             CMP      R0,#+255
   \   00000648   0xF000 0x82B1      BEQ.W    ??BlackSingleSpeCheck_0
   \   0000064C   0x.... 0x....      LDR.W    R0,??DataTable41_3
   \   00000650   0x.... 0x....      LDR.W    R1,??DataTable41_6
   \   00000654   0x7809             LDRB     R1,[R1, #+0]
   \   00000656   0x2203             MOVS     R2,#+3
   \   00000658   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000065C   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000660   0x28FF             CMP      R0,#+255
   \   00000662   0xF000 0x82A4      BEQ.W    ??BlackSingleSpeCheck_0
   \   00000666   0x.... 0x....      LDR.W    R0,??DataTable42_1
   \   0000066A   0x.... 0x....      LDR.W    R1,??DataTable42
   \   0000066E   0x7809             LDRB     R1,[R1, #+0]
   \   00000670   0x2203             MOVS     R2,#+3
   \   00000672   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000676   0xF810 0x0C06      LDRB     R0,[R0, #-6]
   \   0000067A   0x28FF             CMP      R0,#+255
   \   0000067C   0xF000 0x8297      BEQ.W    ??BlackSingleSpeCheck_0
   \   00000680   0x.... 0x....      LDR.W    R0,??DataTable41_3
   \   00000684   0x.... 0x....      LDR.W    R1,??DataTable41_6
   \   00000688   0x7809             LDRB     R1,[R1, #+0]
   \   0000068A   0x2203             MOVS     R2,#+3
   \   0000068C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000690   0xF810 0x0C06      LDRB     R0,[R0, #-6]
   \   00000694   0x28FF             CMP      R0,#+255
   \   00000696   0xF000 0x828A      BEQ.W    ??BlackSingleSpeCheck_0
   6482              {
   6483                //1. 检查右线的右边一个单线宽度内是不是有左线。      
   6484                if(
   6485                  (BlackRightLoc[BlackRightStep1ScanRow-1][0] < CameraRealWidth - 1 - SingleBlackWidthMax[BlackRightStep1ScanRow-1] * 1)
   6486                &&(BlackRightLoc[BlackRightStep1ScanRow-2][0] < CameraRealWidth - 1 - SingleBlackWidthMax[BlackRightStep1ScanRow-2] * 1) //右线头不能太靠右，至少要留出1个单线宽度。 
   6487                &&(BlackRightLoc[BlackRightStep1ScanRow-1][0] > CameraRealWidth / 2 - 60)  
   6488                &&(BlackRightLoc[BlackRightStep1ScanRow-2][0] > CameraRealWidth / 2 - 60)  //右线不能太靠左，大致要在右半边屏内。
   6489                  )
   \   0000069A   0x.... 0x....      LDR.W    R0,??DataTable42_1
   \   0000069E   0x.... 0x....      LDR.W    R1,??DataTable42
   \   000006A2   0x7809             LDRB     R1,[R1, #+0]
   \   000006A4   0x2203             MOVS     R2,#+3
   \   000006A6   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000006AA   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000006AE   0x.... 0x....      LDR.W    R1,??DataTable42_2
   \   000006B2   0x.... 0x....      LDR.W    R2,??DataTable42
   \   000006B6   0x7812             LDRB     R2,[R2, #+0]
   \   000006B8   0x1851             ADDS     R1,R2,R1
   \   000006BA   0xF811 0x1C01      LDRB     R1,[R1, #-1]
   \   000006BE   0xF1D1 0x01F9      RSBS     R1,R1,#+249
   \   000006C2   0x4288             CMP      R0,R1
   \   000006C4   0xF280 0x8222      BGE.W    ??BlackSingleSpeCheck_13
   \   000006C8   0x.... 0x....      LDR.W    R0,??DataTable42_1
   \   000006CC   0x.... 0x....      LDR.W    R1,??DataTable42
   \   000006D0   0x7809             LDRB     R1,[R1, #+0]
   \   000006D2   0x2203             MOVS     R2,#+3
   \   000006D4   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000006D8   0xF810 0x0C06      LDRB     R0,[R0, #-6]
   \   000006DC   0x.... 0x....      LDR.W    R1,??DataTable42_2
   \   000006E0   0x.... 0x....      LDR.W    R2,??DataTable42
   \   000006E4   0x7812             LDRB     R2,[R2, #+0]
   \   000006E6   0x1851             ADDS     R1,R2,R1
   \   000006E8   0xF811 0x1C02      LDRB     R1,[R1, #-2]
   \   000006EC   0xF1D1 0x01F9      RSBS     R1,R1,#+249
   \   000006F0   0x4288             CMP      R0,R1
   \   000006F2   0xF280 0x820B      BGE.W    ??BlackSingleSpeCheck_13
   \   000006F6   0x.... 0x....      LDR.W    R0,??DataTable42_1
   \   000006FA   0x.... 0x....      LDR.W    R1,??DataTable42
   \   000006FE   0x7809             LDRB     R1,[R1, #+0]
   \   00000700   0x2203             MOVS     R2,#+3
   \   00000702   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000706   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000070A   0x2842             CMP      R0,#+66
   \   0000070C   0xF2C0 0x81FE      BLT.W    ??BlackSingleSpeCheck_13
   \   00000710   0x.... 0x....      LDR.W    R0,??DataTable42_1
   \   00000714   0x.... 0x....      LDR.W    R1,??DataTable42
   \   00000718   0x7809             LDRB     R1,[R1, #+0]
   \   0000071A   0x2203             MOVS     R2,#+3
   \   0000071C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000720   0xF810 0x0C06      LDRB     R0,[R0, #-6]
   \   00000724   0x2842             CMP      R0,#+66
   \   00000726   0xF2C0 0x81F1      BLT.W    ??BlackSingleSpeCheck_13
   6490                {
   6491                  //开一个单线宽度的窗来检测是不是有左线。temp1和temp2为左黑线的白点位置。
   6492                  temp1 = BlackGetLeftJustWin(BlackRightStep1ScanRow-1, 
   6493                                               BlackRightLoc[BlackRightStep1ScanRow-1][0], //最多最多跨过15列，所以20列应该够。
   6494                                               BlackRightLoc[BlackRightStep1ScanRow-1][0] + SingleBlackWidthMax[BlackRightStep1ScanRow-1]);
   \   0000072A   0x.... 0x....      LDR.W    R0,??DataTable42_1
   \   0000072E   0x.... 0x....      LDR.W    R1,??DataTable42
   \   00000732   0x7809             LDRB     R1,[R1, #+0]
   \   00000734   0x2203             MOVS     R2,#+3
   \   00000736   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000073A   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000073E   0x.... 0x....      LDR.W    R1,??DataTable42_2
   \   00000742   0x.... 0x....      LDR.W    R2,??DataTable42
   \   00000746   0x7812             LDRB     R2,[R2, #+0]
   \   00000748   0x1851             ADDS     R1,R2,R1
   \   0000074A   0xF811 0x1C01      LDRB     R1,[R1, #-1]
   \   0000074E   0xFA51 0xF280      UXTAB    R2,R1,R0
   \   00000752   0x.... 0x....      LDR.W    R0,??DataTable42_1
   \   00000756   0x.... 0x....      LDR.W    R1,??DataTable42
   \   0000075A   0x7809             LDRB     R1,[R1, #+0]
   \   0000075C   0x2303             MOVS     R3,#+3
   \   0000075E   0xFB03 0x0001      MLA      R0,R3,R1,R0
   \   00000762   0xF810 0x1C03      LDRB     R1,[R0, #-3]
   \   00000766   0x.... 0x....      LDR.W    R0,??DataTable42
   \   0000076A   0x7800             LDRB     R0,[R0, #+0]
   \   0000076C   0x1E40             SUBS     R0,R0,#+1
   \   0000076E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000770   0x.... 0x....      BL       BlackGetLeftJustWin
   \   00000774   0x0006             MOVS     R6,R0
   6495                  temp2 = BlackGetLeftJustWin(BlackRightStep1ScanRow-2, 
   6496                                               BlackRightLoc[BlackRightStep1ScanRow-2][0], //最多最多跨过15列，所以20列应该够。
   6497                                               BlackRightLoc[BlackRightStep1ScanRow-2][0] + SingleBlackWidthMax[BlackRightStep1ScanRow-2]);
   \   00000776   0x.... 0x....      LDR.W    R0,??DataTable42_1
   \   0000077A   0x.... 0x....      LDR.W    R1,??DataTable42
   \   0000077E   0x7809             LDRB     R1,[R1, #+0]
   \   00000780   0x2203             MOVS     R2,#+3
   \   00000782   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000786   0xF810 0x0C06      LDRB     R0,[R0, #-6]
   \   0000078A   0x.... 0x....      LDR.W    R1,??DataTable42_2
   \   0000078E   0x.... 0x....      LDR.W    R2,??DataTable42
   \   00000792   0x7812             LDRB     R2,[R2, #+0]
   \   00000794   0x1851             ADDS     R1,R2,R1
   \   00000796   0xF811 0x1C02      LDRB     R1,[R1, #-2]
   \   0000079A   0xFA51 0xF280      UXTAB    R2,R1,R0
   \   0000079E   0x.... 0x....      LDR.W    R0,??DataTable42_1
   \   000007A2   0x.... 0x....      LDR.W    R1,??DataTable42
   \   000007A6   0x7809             LDRB     R1,[R1, #+0]
   \   000007A8   0x2303             MOVS     R3,#+3
   \   000007AA   0xFB03 0x0001      MLA      R0,R3,R1,R0
   \   000007AE   0xF810 0x1C06      LDRB     R1,[R0, #-6]
   \   000007B2   0x.... 0x....      LDR.W    R0,??DataTable42
   \   000007B6   0x7800             LDRB     R0,[R0, #+0]
   \   000007B8   0x1E80             SUBS     R0,R0,#+2
   \   000007BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000007BC   0x.... 0x....      BL       BlackGetLeftJustWin
   \   000007C0   0x0005             MOVS     R5,R0
   6498                  //必须连续两行有左黑线。而且两个黑点所在列不能相差太大。 
   6499                  if(temp1 != MaxValUint8 && temp2 != MaxValUint8 && AbsInt(temp1 - temp2) < 8)
   \   000007C2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000007C4   0x2EFF             CMP      R6,#+255
   \   000007C6   0xF000 0x81A1      BEQ.W    ??BlackSingleSpeCheck_13
   \   000007CA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000007CC   0x2DFF             CMP      R5,#+255
   \   000007CE   0xF000 0x819D      BEQ.W    ??BlackSingleSpeCheck_13
   \   000007D2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000007D4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000007D6   0x1B70             SUBS     R0,R6,R5
   \   000007D8   0x.... 0x....      BL       AbsInt
   \   000007DC   0x2808             CMP      R0,#+8
   \   000007DE   0xF280 0x8195      BGE.W    ??BlackSingleSpeCheck_13
   6500                  {          
   6501                    //第一行左线的白点平均值
   6502                    avgr1 = (ImgNew[BlackRightStep1ScanRow-1][temp1 + 1]
   6503                           + ImgNew[BlackRightStep1ScanRow-1][temp1 + 2]
   6504                           + ImgNew[BlackRightStep1ScanRow-1][temp1 + 3]
   6505                           + ImgNew[BlackRightStep1ScanRow-1][temp1 + 4]
   6506                           + ImgNew[BlackRightStep1ScanRow-1][temp1 + 5])
   6507                           / 5;
   \   000007E2   0x.... 0x....      LDR.W    R0,??DataTable42_3
   \   000007E6   0x.... 0x....      LDR.W    R1,??DataTable42
   \   000007EA   0x7809             LDRB     R1,[R1, #+0]
   \   000007EC   0x22FA             MOVS     R2,#+250
   \   000007EE   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000007F2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000007F4   0x1830             ADDS     R0,R6,R0
   \   000007F6   0xF810 0x0CF9      LDRB     R0,[R0, #-249]
   \   000007FA   0x.... 0x....      LDR.W    R1,??DataTable42_3
   \   000007FE   0x.... 0x....      LDR.W    R2,??DataTable42
   \   00000802   0x7812             LDRB     R2,[R2, #+0]
   \   00000804   0x23FA             MOVS     R3,#+250
   \   00000806   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   0000080A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000080C   0x1871             ADDS     R1,R6,R1
   \   0000080E   0xF811 0x1CF8      LDRB     R1,[R1, #-248]
   \   00000812   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000816   0x.... 0x....      LDR.W    R1,??DataTable42_3
   \   0000081A   0x.... 0x....      LDR.W    R2,??DataTable42
   \   0000081E   0x7812             LDRB     R2,[R2, #+0]
   \   00000820   0x23FA             MOVS     R3,#+250
   \   00000822   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000826   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000828   0x1871             ADDS     R1,R6,R1
   \   0000082A   0xF811 0x1CF7      LDRB     R1,[R1, #-247]
   \   0000082E   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   00000832   0x.... 0x....      LDR.W    R1,??DataTable42_3
   \   00000836   0x.... 0x....      LDR.W    R2,??DataTable42
   \   0000083A   0x7812             LDRB     R2,[R2, #+0]
   \   0000083C   0x23FA             MOVS     R3,#+250
   \   0000083E   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000842   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000844   0x1871             ADDS     R1,R6,R1
   \   00000846   0xF811 0x1CF6      LDRB     R1,[R1, #-246]
   \   0000084A   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   0000084E   0x.... 0x....      LDR.W    R1,??DataTable42_3
   \   00000852   0x.... 0x....      LDR.W    R2,??DataTable42
   \   00000856   0x7812             LDRB     R2,[R2, #+0]
   \   00000858   0x23FA             MOVS     R3,#+250
   \   0000085A   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   0000085E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000860   0x1871             ADDS     R1,R6,R1
   \   00000862   0xF811 0x1CF5      LDRB     R1,[R1, #-245]
   \   00000866   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   0000086A   0x2105             MOVS     R1,#+5
   \   0000086C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   6508                    //第一行右线的白点平均值
   6509                    avgl1 = (ImgNew[BlackRightStep1ScanRow-1][BlackRightLoc[BlackRightStep1ScanRow-1][0] - 1 - BlackRightEdgeNum - 1]
   6510                           + ImgNew[BlackRightStep1ScanRow-1][BlackRightLoc[BlackRightStep1ScanRow-1][0] - 1 - BlackRightEdgeNum - 2]
   6511                           + ImgNew[BlackRightStep1ScanRow-1][BlackRightLoc[BlackRightStep1ScanRow-1][0] - 1 - BlackRightEdgeNum - 3]
   6512                           + ImgNew[BlackRightStep1ScanRow-1][BlackRightLoc[BlackRightStep1ScanRow-1][0] - 1 - BlackRightEdgeNum - 4]
   6513                           + ImgNew[BlackRightStep1ScanRow-1][BlackRightLoc[BlackRightStep1ScanRow-1][0] - 1 - BlackRightEdgeNum - 5])
   6514                           / 5;
   \   00000870   0x.... 0x....      LDR.W    R1,??DataTable42_3
   \   00000874   0x.... 0x....      LDR.W    R2,??DataTable42
   \   00000878   0x7812             LDRB     R2,[R2, #+0]
   \   0000087A   0x23FA             MOVS     R3,#+250
   \   0000087C   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000880   0x.... 0x....      LDR.W    R2,??DataTable42_1
   \   00000884   0x.... 0x....      LDR.W    R3,??DataTable42
   \   00000888   0x781B             LDRB     R3,[R3, #+0]
   \   0000088A   0x2603             MOVS     R6,#+3
   \   0000088C   0xFB06 0x2203      MLA      R2,R6,R3,R2
   \   00000890   0xF812 0x2C03      LDRB     R2,[R2, #-3]
   \   00000894   0x1851             ADDS     R1,R2,R1
   \   00000896   0xF811 0x1CFF      LDRB     R1,[R1, #-255]
   \   0000089A   0x.... 0x....      LDR.W    R2,??DataTable42_3
   \   0000089E   0x.... 0x....      LDR.W    R3,??DataTable42
   \   000008A2   0x781B             LDRB     R3,[R3, #+0]
   \   000008A4   0x26FA             MOVS     R6,#+250
   \   000008A6   0xFB06 0x2203      MLA      R2,R6,R3,R2
   \   000008AA   0x.... 0x....      LDR.W    R3,??DataTable42_1
   \   000008AE   0x.... 0x....      LDR.W    R6,??DataTable42
   \   000008B2   0x7836             LDRB     R6,[R6, #+0]
   \   000008B4   0x2703             MOVS     R7,#+3
   \   000008B6   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   000008BA   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   000008BE   0x189A             ADDS     R2,R3,R2
   \   000008C0   0xF5B2 0x7280      SUBS     R2,R2,#+256
   \   000008C4   0x7812             LDRB     R2,[R2, #+0]
   \   000008C6   0xFA52 0xF181      UXTAB    R1,R2,R1
   \   000008CA   0x.... 0x....      LDR.W    R2,??DataTable42_3
   \   000008CE   0x.... 0x....      LDR.W    R3,??DataTable42
   \   000008D2   0x781B             LDRB     R3,[R3, #+0]
   \   000008D4   0x26FA             MOVS     R6,#+250
   \   000008D6   0xFB06 0x2203      MLA      R2,R6,R3,R2
   \   000008DA   0x.... 0x....      LDR.W    R3,??DataTable42_1
   \   000008DE   0x.... 0x....      LDR.W    R6,??DataTable42
   \   000008E2   0x7836             LDRB     R6,[R6, #+0]
   \   000008E4   0x2703             MOVS     R7,#+3
   \   000008E6   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   000008EA   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   000008EE   0x189A             ADDS     R2,R3,R2
   \   000008F0   0xF2A2 0x1201      SUBW     R2,R2,#+257
   \   000008F4   0x7812             LDRB     R2,[R2, #+0]
   \   000008F6   0xFA51 0xF182      UXTAB    R1,R1,R2
   \   000008FA   0x.... 0x....      LDR.W    R2,??DataTable42_3
   \   000008FE   0x.... 0x....      LDR.W    R3,??DataTable42
   \   00000902   0x781B             LDRB     R3,[R3, #+0]
   \   00000904   0x26FA             MOVS     R6,#+250
   \   00000906   0xFB06 0x2203      MLA      R2,R6,R3,R2
   \   0000090A   0x.... 0x....      LDR.W    R3,??DataTable42_1
   \   0000090E   0x.... 0x....      LDR.W    R6,??DataTable42
   \   00000912   0x7836             LDRB     R6,[R6, #+0]
   \   00000914   0x2703             MOVS     R7,#+3
   \   00000916   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   0000091A   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   0000091E   0x189A             ADDS     R2,R3,R2
   \   00000920   0xF5B2 0x7281      SUBS     R2,R2,#+258
   \   00000924   0x7812             LDRB     R2,[R2, #+0]
   \   00000926   0xFA51 0xF182      UXTAB    R1,R1,R2
   \   0000092A   0x.... 0x....      LDR.W    R2,??DataTable42_3
   \   0000092E   0x.... 0x....      LDR.W    R3,??DataTable42
   \   00000932   0x781B             LDRB     R3,[R3, #+0]
   \   00000934   0x26FA             MOVS     R6,#+250
   \   00000936   0xFB06 0x2203      MLA      R2,R6,R3,R2
   \   0000093A   0x.... 0x....      LDR.W    R3,??DataTable42_1
   \   0000093E   0x.... 0x....      LDR.W    R6,??DataTable42
   \   00000942   0x7836             LDRB     R6,[R6, #+0]
   \   00000944   0x2703             MOVS     R7,#+3
   \   00000946   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   0000094A   0xF813 0x3C03      LDRB     R3,[R3, #-3]
   \   0000094E   0x189A             ADDS     R2,R3,R2
   \   00000950   0xF2A2 0x1203      SUBW     R2,R2,#+259
   \   00000954   0x7812             LDRB     R2,[R2, #+0]
   \   00000956   0xFA51 0xF182      UXTAB    R1,R1,R2
   \   0000095A   0x2205             MOVS     R2,#+5
   \   0000095C   0xFB91 0xF1F2      SDIV     R1,R1,R2
   6515                    //第二行左线的白点平均值
   6516                    avgr2 = (ImgNew[BlackRightStep1ScanRow-2][temp2 + 1]
   6517                           + ImgNew[BlackRightStep1ScanRow-2][temp2 + 2]
   6518                           + ImgNew[BlackRightStep1ScanRow-2][temp2 + 3]
   6519                           + ImgNew[BlackRightStep1ScanRow-2][temp2 + 4]
   6520                           + ImgNew[BlackRightStep1ScanRow-2][temp2 + 5])
   6521                           / 5;
   \   00000960   0x.... 0x....      LDR.W    R2,??DataTable42_3
   \   00000964   0x.... 0x....      LDR.W    R3,??DataTable42
   \   00000968   0x781B             LDRB     R3,[R3, #+0]
   \   0000096A   0x26FA             MOVS     R6,#+250
   \   0000096C   0xFB06 0x2203      MLA      R2,R6,R3,R2
   \   00000970   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000972   0x18AA             ADDS     R2,R5,R2
   \   00000974   0xF2A2 0x12F3      SUBW     R2,R2,#+499
   \   00000978   0x7812             LDRB     R2,[R2, #+0]
   \   0000097A   0x.... 0x....      LDR.W    R3,??DataTable42_3
   \   0000097E   0x.... 0x....      LDR.W    R6,??DataTable42
   \   00000982   0x7836             LDRB     R6,[R6, #+0]
   \   00000984   0x27FA             MOVS     R7,#+250
   \   00000986   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   0000098A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000098C   0x18EB             ADDS     R3,R5,R3
   \   0000098E   0xF5B3 0x73F9      SUBS     R3,R3,#+498
   \   00000992   0x781B             LDRB     R3,[R3, #+0]
   \   00000994   0xFA53 0xF282      UXTAB    R2,R3,R2
   \   00000998   0x.... 0x....      LDR.W    R3,??DataTable42_3
   \   0000099C   0x.... 0x....      LDR.W    R6,??DataTable42
   \   000009A0   0x7836             LDRB     R6,[R6, #+0]
   \   000009A2   0x27FA             MOVS     R7,#+250
   \   000009A4   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   000009A8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000009AA   0x18EB             ADDS     R3,R5,R3
   \   000009AC   0xF2A3 0x13F1      SUBW     R3,R3,#+497
   \   000009B0   0x781B             LDRB     R3,[R3, #+0]
   \   000009B2   0xFA52 0xF283      UXTAB    R2,R2,R3
   \   000009B6   0x.... 0x....      LDR.W    R3,??DataTable42_3
   \   000009BA   0x.... 0x....      LDR.W    R6,??DataTable42
   \   000009BE   0x7836             LDRB     R6,[R6, #+0]
   \   000009C0   0x27FA             MOVS     R7,#+250
   \   000009C2   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   000009C6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000009C8   0x18EB             ADDS     R3,R5,R3
   \   000009CA   0xF5B3 0x73F8      SUBS     R3,R3,#+496
   \   000009CE   0x781B             LDRB     R3,[R3, #+0]
   \   000009D0   0xFA52 0xF283      UXTAB    R2,R2,R3
   \   000009D4   0x.... 0x....      LDR.W    R3,??DataTable42_3
   \   000009D8   0x.... 0x....      LDR.W    R6,??DataTable42
   \   000009DC   0x7836             LDRB     R6,[R6, #+0]
   \   000009DE   0x27FA             MOVS     R7,#+250
   \   000009E0   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   000009E4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000009E6   0x18EB             ADDS     R3,R5,R3
   \   000009E8   0xF2A3 0x13EF      SUBW     R3,R3,#+495
   \   000009EC   0x781B             LDRB     R3,[R3, #+0]
   \   000009EE   0xFA52 0xF283      UXTAB    R2,R2,R3
   \   000009F2   0x2305             MOVS     R3,#+5
   \   000009F4   0xFB92 0xF5F3      SDIV     R5,R2,R3
   6522                    //第二行右线的白点平均值
   6523                    avgl2 = (ImgNew[BlackRightStep1ScanRow-2][BlackRightLoc[BlackRightStep1ScanRow-2][0] - 1 - BlackRightEdgeNum - 1]
   6524                           + ImgNew[BlackRightStep1ScanRow-2][BlackRightLoc[BlackRightStep1ScanRow-2][0] - 1 - BlackRightEdgeNum - 2]
   6525                           + ImgNew[BlackRightStep1ScanRow-2][BlackRightLoc[BlackRightStep1ScanRow-2][0] - 1 - BlackRightEdgeNum - 3]
   6526                           + ImgNew[BlackRightStep1ScanRow-2][BlackRightLoc[BlackRightStep1ScanRow-2][0] - 1 - BlackRightEdgeNum - 4]
   6527                           + ImgNew[BlackRightStep1ScanRow-2][BlackRightLoc[BlackRightStep1ScanRow-2][0] - 1 - BlackRightEdgeNum - 5])
   6528                           / 5;      
   \   000009F8   0x.... 0x....      LDR.W    R2,??DataTable42_3
   \   000009FC   0x.... 0x....      LDR.W    R3,??DataTable42
   \   00000A00   0x781B             LDRB     R3,[R3, #+0]
   \   00000A02   0x26FA             MOVS     R6,#+250
   \   00000A04   0xFB06 0x2203      MLA      R2,R6,R3,R2
   \   00000A08   0x.... 0x....      LDR.W    R3,??DataTable42_1
   \   00000A0C   0x.... 0x....      LDR.W    R6,??DataTable42
   \   00000A10   0x7836             LDRB     R6,[R6, #+0]
   \   00000A12   0x2703             MOVS     R7,#+3
   \   00000A14   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   00000A18   0xF813 0x3C06      LDRB     R3,[R3, #-6]
   \   00000A1C   0x189A             ADDS     R2,R3,R2
   \   00000A1E   0xF2A2 0x12F9      SUBW     R2,R2,#+505
   \   00000A22   0x7812             LDRB     R2,[R2, #+0]
   \   00000A24   0x.... 0x....      LDR.W    R3,??DataTable42_3
   \   00000A28   0x.... 0x....      LDR.W    R6,??DataTable42
   \   00000A2C   0x7836             LDRB     R6,[R6, #+0]
   \   00000A2E   0x27FA             MOVS     R7,#+250
   \   00000A30   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   00000A34   0x.... 0x....      LDR.W    R6,??DataTable42_1
   \   00000A38   0x.... 0x....      LDR.W    R7,??DataTable42
   \   00000A3C   0x783F             LDRB     R7,[R7, #+0]
   \   00000A3E   0xF05F 0x0C03      MOVS     R12,#+3
   \   00000A42   0xFB0C 0x6607      MLA      R6,R12,R7,R6
   \   00000A46   0xF816 0x6C06      LDRB     R6,[R6, #-6]
   \   00000A4A   0x18F3             ADDS     R3,R6,R3
   \   00000A4C   0xF5B3 0x73FD      SUBS     R3,R3,#+506
   \   00000A50   0x781B             LDRB     R3,[R3, #+0]
   \   00000A52   0xFA53 0xF282      UXTAB    R2,R3,R2
   \   00000A56   0x.... 0x....      LDR.W    R3,??DataTable42_3
   \   00000A5A   0x.... 0x....      LDR.W    R6,??DataTable42
   \   00000A5E   0x7836             LDRB     R6,[R6, #+0]
   \   00000A60   0x27FA             MOVS     R7,#+250
   \   00000A62   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   00000A66   0x.... 0x....      LDR.W    R6,??DataTable42_1
   \   00000A6A   0x.... 0x....      LDR.W    R7,??DataTable42
   \   00000A6E   0x783F             LDRB     R7,[R7, #+0]
   \   00000A70   0xF05F 0x0C03      MOVS     R12,#+3
   \   00000A74   0xFB0C 0x6607      MLA      R6,R12,R7,R6
   \   00000A78   0xF816 0x6C06      LDRB     R6,[R6, #-6]
   \   00000A7C   0x18F3             ADDS     R3,R6,R3
   \   00000A7E   0xF2A3 0x13FB      SUBW     R3,R3,#+507
   \   00000A82   0x781B             LDRB     R3,[R3, #+0]
   \   00000A84   0xFA52 0xF283      UXTAB    R2,R2,R3
   \   00000A88   0x.... 0x....      LDR.W    R3,??DataTable42_3
   \   00000A8C   0x.... 0x....      LDR.W    R6,??DataTable42
   \   00000A90   0x7836             LDRB     R6,[R6, #+0]
   \   00000A92   0x27FA             MOVS     R7,#+250
   \   00000A94   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   00000A98   0x.... 0x....      LDR.W    R6,??DataTable42_1
   \   00000A9C   0x.... 0x....      LDR.W    R7,??DataTable42
   \   00000AA0   0x783F             LDRB     R7,[R7, #+0]
   \   00000AA2   0xF05F 0x0C03      MOVS     R12,#+3
   \   00000AA6   0xFB0C 0x6607      MLA      R6,R12,R7,R6
   \   00000AAA   0xF816 0x6C06      LDRB     R6,[R6, #-6]
   \   00000AAE   0x18F3             ADDS     R3,R6,R3
   \   00000AB0   0xF5B3 0x73FE      SUBS     R3,R3,#+508
   \   00000AB4   0x781B             LDRB     R3,[R3, #+0]
   \   00000AB6   0xFA52 0xF283      UXTAB    R2,R2,R3
   \   00000ABA   0x.... 0x....      LDR.W    R3,??DataTable42_3
   \   00000ABE   0x....             LDR.N    R6,??DataTable42
   \   00000AC0   0x7836             LDRB     R6,[R6, #+0]
   \   00000AC2   0x27FA             MOVS     R7,#+250
   \   00000AC4   0xFB07 0x3306      MLA      R3,R7,R6,R3
   \   00000AC8   0x....             LDR.N    R6,??DataTable42_1
   \   00000ACA   0x....             LDR.N    R7,??DataTable42
   \   00000ACC   0x783F             LDRB     R7,[R7, #+0]
   \   00000ACE   0xF05F 0x0C03      MOVS     R12,#+3
   \   00000AD2   0xFB0C 0x6607      MLA      R6,R12,R7,R6
   \   00000AD6   0xF816 0x6C06      LDRB     R6,[R6, #-6]
   \   00000ADA   0x18F3             ADDS     R3,R6,R3
   \   00000ADC   0xF2A3 0x13FD      SUBW     R3,R3,#+509
   \   00000AE0   0x781B             LDRB     R3,[R3, #+0]
   \   00000AE2   0xFA52 0xF283      UXTAB    R2,R2,R3
   \   00000AE6   0x2305             MOVS     R3,#+5
   \   00000AE8   0xFB92 0xF6F3      SDIV     R6,R2,R3
   6529                    
   6530                    //最后一步，确认两者的白色点的平均值差别非常小。  /////////////////////此时若地板为浅色或者白色，就挂了。
   6531                    if(AbsInt(avgr1 - avgl1) < 15 && AbsInt(avgr2 - avgl2) < 15)
   \   00000AEC   0x1A40             SUBS     R0,R0,R1
   \   00000AEE   0x.... 0x....      BL       AbsInt
   \   00000AF2   0x280F             CMP      R0,#+15
   \   00000AF4   0xDA0A             BGE.N    ??BlackSingleSpeCheck_13
   \   00000AF6   0x1BA8             SUBS     R0,R5,R6
   \   00000AF8   0x.... 0x....      BL       AbsInt
   \   00000AFC   0x280F             CMP      R0,#+15
   \   00000AFE   0xDA05             BGE.N    ??BlackSingleSpeCheck_13
   6532                    {
   6533                      BlackSingleFlag = 1;        //单线错误标志置位。
   \   00000B00   0x2001             MOVS     R0,#+1
   \   00000B02   0x....             LDR.N    R1,??DataTable42_4
   \   00000B04   0x7008             STRB     R0,[R1, #+0]
   6534                      BlackSingleDir = 1;         //表示是右线悬空的情况。
   \   00000B06   0x2001             MOVS     R0,#+1
   \   00000B08   0x....             LDR.N    R1,??DataTable42_5
   \   00000B0A   0x7008             STRB     R0,[R1, #+0]
   6535                    }
   6536                    else
   6537                    {
   6538                    }
   6539                  }
   6540                  else
   6541                  {
   6542                  }
   6543                }
   6544                else
   6545                {
   6546                }
   6547                
   6548                //查看单线错误标志
   6549                if(BlackSingleFlag == 1)
   \                     ??BlackSingleSpeCheck_13: (+1)
   \   00000B0C   0x....             LDR.N    R0,??DataTable42_4
   \   00000B0E   0x7800             LDRB     R0,[R0, #+0]
   \   00000B10   0x2801             CMP      R0,#+1
   \   00000B12   0xD14C             BNE.N    ??BlackSingleSpeCheck_0
   6550                {
   6551                  //确定是单线错误后，先把左黑线全置无效值。
   6552                  for(i = 0; ; i++)
   \   00000B14   0x2500             MOVS     R5,#+0
   \   00000B16   0xE000             B.N      ??BlackSingleSpeCheck_14
   \                     ??BlackSingleSpeCheck_15: (+1)
   \   00000B18   0x1C6D             ADDS     R5,R5,#+1
   6553                  {
   6554                    BlackLeftLoc[i][0] = MaxValUint8;           
   \                     ??BlackSingleSpeCheck_14: (+1)
   \   00000B1A   0x20FF             MOVS     R0,#+255
   \   00000B1C   0x....             LDR.N    R1,??DataTable41_3
   \   00000B1E   0x2203             MOVS     R2,#+3
   \   00000B20   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000B24   0x7008             STRB     R0,[R1, #+0]
   6555                    if(i == CameraHight - 1) break;
   \   00000B26   0x2D3B             CMP      R5,#+59
   \   00000B28   0xD1F6             BNE.N    ??BlackSingleSpeCheck_15
   6556                  }
   6557                  
   6558                  index1 = 0;
   \   00000B2A   0x2700             MOVS     R7,#+0
   6559                  //然后从右线尾所在行开始开窗扫右线，一直到左线头所在行或者有未采到的行。
   6560                  for(i = BlackRightStep1ScanRow; ; i--)
   \   00000B2C   0x....             LDR.N    R0,??DataTable42
   \   00000B2E   0x7805             LDRB     R5,[R0, #+0]
   \   00000B30   0xE000             B.N      ??BlackSingleSpeCheck_16
   \                     ??BlackSingleSpeCheck_17: (+1)
   \   00000B32   0x1E6D             SUBS     R5,R5,#+1
   6561                  {
   6562                    temp1 = BlackGetLeftJustWin(i, 
   6563                                                BlackRightLoc[i][0], //最多最多跨过15列，所以20列应该够。
   6564                                                BlackRightLoc[i][0] + SingleBlackWidthMax[i]);            
   \                     ??BlackSingleSpeCheck_16: (+1)
   \   00000B34   0x....             LDR.N    R0,??DataTable42_1
   \   00000B36   0x2103             MOVS     R1,#+3
   \   00000B38   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000B3C   0x7800             LDRB     R0,[R0, #+0]
   \   00000B3E   0x....             LDR.N    R1,??DataTable42_2
   \   00000B40   0x5C69             LDRB     R1,[R5, R1]
   \   00000B42   0x180A             ADDS     R2,R1,R0
   \   00000B44   0x....             LDR.N    R0,??DataTable42_1
   \   00000B46   0x2103             MOVS     R1,#+3
   \   00000B48   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000B4C   0x7801             LDRB     R1,[R0, #+0]
   \   00000B4E   0x0028             MOVS     R0,R5
   \   00000B50   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000B52   0x.... 0x....      BL       BlackGetLeftJustWin
   \   00000B56   0x0006             MOVS     R6,R0
   6565                    if(temp1 != MaxValUint8)
   \   00000B58   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000B5A   0x2EFF             CMP      R6,#+255
   \   00000B5C   0xD014             BEQ.N    ??BlackSingleSpeCheck_18
   6566                    {
   6567                      //该行扫描左黑线成功
   6568                      BlackLeftLoc[i][0] = temp1 - 1 - BlackLeftEdgeNum;
   \   00000B5E   0x1F30             SUBS     R0,R6,#+4
   \   00000B60   0x....             LDR.N    R1,??DataTable41_3
   \   00000B62   0x2203             MOVS     R2,#+3
   \   00000B64   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000B68   0x7008             STRB     R0,[R1, #+0]
   6569                      //记录左黑线扫描成功的最近行。
   6570                      if(index1 == 0)
   \   00000B6A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000B6C   0x2F00             CMP      R7,#+0
   \   00000B6E   0xD101             BNE.N    ??BlackSingleSpeCheck_19
   6571                      {
   6572                        tempstep1row = i;
   \   00000B70   0x002C             MOVS     R4,R5
   6573                        index1++;
   \   00000B72   0x1C7F             ADDS     R7,R7,#+1
   6574                      }
   6575                      else
   6576                      {
   6577                      }
   6578                    }
   6579                    else
   6580                    {
   6581                      //一旦没有采到，再远的行就不要了，直接退出。
   6582                      break;
   6583                    }
   6584                    //到右线头了，退出
   6585                    if(i == BlackRightHeadLine) break;
   \                     ??BlackSingleSpeCheck_19: (+1)
   \   00000B74   0x.... 0x....      LDR.W    R0,??DataTable43
   \   00000B78   0x7800             LDRB     R0,[R0, #+0]
   \   00000B7A   0x4285             CMP      R5,R0
   \   00000B7C   0xD1D9             BNE.N    ??BlackSingleSpeCheck_17
   6586                  }
   6587                  
   6588                  //检测不到有效左黑线，返回失败。
   6589                  if(tempstep1row == MaxValUint8) return 0;
   \                     ??BlackSingleSpeCheck_20: (+1)
   \   00000B7E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000B80   0x2CFF             CMP      R4,#+255
   \   00000B82   0xD102             BNE.N    ??BlackSingleSpeCheck_21
   \   00000B84   0x2000             MOVS     R0,#+0
   \   00000B86   0xE013             B.N      ??BlackSingleSpeCheck_11
   \                     ??BlackSingleSpeCheck_18: (+1)
   \   00000B88   0xE7F9             B.N      ??BlackSingleSpeCheck_20
   6590                   
   6591                  //往远几行开始，向后补线。第2个输入参数是1。
   6592                  //不管右线之间的向后补线是否成功，都要放远几个点重新向后补一次
   6593                  if(BlackRightStep4BackLine(BlackRightStep1ScanRow - 2, 1) == 1 && BlackLeftStep4BackLine(tempstep1row - 2, 1) == 1)
   \                     ??BlackSingleSpeCheck_21: (+1)
   \   00000B8A   0x2101             MOVS     R1,#+1
   \   00000B8C   0x....             LDR.N    R0,??DataTable42
   \   00000B8E   0x7800             LDRB     R0,[R0, #+0]
   \   00000B90   0x1E80             SUBS     R0,R0,#+2
   \   00000B92   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000B94   0x.... 0x....      BL       BlackRightStep4BackLine
   \   00000B98   0x2801             CMP      R0,#+1
   \   00000B9A   0xD106             BNE.N    ??BlackSingleSpeCheck_22
   \   00000B9C   0x2101             MOVS     R1,#+1
   \   00000B9E   0x1EA0             SUBS     R0,R4,#+2
   \   00000BA0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000BA2   0x.... 0x....      BL       BlackLeftStep4BackLine
   \   00000BA6   0x2801             CMP      R0,#+1
   \   00000BA8   0xD001             BEQ.N    ??BlackSingleSpeCheck_0
   6594                  {
   6595                  }
   6596                  else
   6597                  {
   6598                    //如果补线没有成功（有可能是点太少），那就直接返回失败，这幅图像直接判定为失败。
   6599                    return 0;
   \                     ??BlackSingleSpeCheck_22: (+1)
   \   00000BAA   0x2000             MOVS     R0,#+0
   \   00000BAC   0xE000             B.N      ??BlackSingleSpeCheck_11
   6600                  }           
   6601                  
   6602                  //置单线标志位SingleBlackAllFlag(用于CenterLineGet)。     
   6603                  //SingleBlackAllFlag = 1;
   6604                  
   6605                }
   6606                //单线错误标志没有置位，不用作任何处理。
   6607                else
   6608                {
   6609                }
   6610              }
   6611              else
   6612              {
   6613              }
   6614            }
   6615            else
   6616            {
   6617            }
   6618            
   6619            return 1;
   \                     ??BlackSingleSpeCheck_0: (+1)
   \   00000BAE   0x2001             MOVS     R0,#+1
   \                     ??BlackSingleSpeCheck_11: (+1)
   \   00000BB0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   6620          }
   6621           
   6622          
   6623          
   6624          
   6625          //大跳变最终检测，基本上是针对直角黑块斜入。
   6626          //返回1表示检测到大跳变，0表示没有检测到或没必要检测。 
   6627          //有FLASH烧写进来的开关控制，如果发现比赛赛道的直角黑块基本没有斜入的情况，那就关掉。
   6628          //直角黑块误判
   6629          //1. 5Slope数组，同号（左线同为负号，右线同为正号），但相差大于等于2500。
   6630          //   离直角黑块比较近的时候，一般相差3000及以上，但离得比较远的时候，有可能相差2500。
   6631          //2. 在5SlopeRow数组里可以找到相应的行，从该行（比如说是第13行），则最好把13、14、15、16（17）都删掉。

   \                                 In section .text, align 2, keep-with-next
   6632          uint8 BlackBigChangeFinalCheck(void)
   6633          {
   6634            //BlackLeft5Slope[]数组和BlackLeft5SlopeRow[]数组的下标为0~BlackLeft5SlopeIndex-1
   6635            //普通的BigChange中，出错的阈值是BlackLeftBigChangeSlopeLimit=4000左右（不是绝对值之差，就是两数之差）。
   6636            uint8 i, row;
   6637            uint8 tempend1, tempend2;
   6638            
   6639            return 0;         //不需要这个检测了，所以关闭
   \                     BlackBigChangeFinalCheck: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
   6640            
   6641            //1. 要求两线都成功
   6642            if(BlackLeftDone == 1 && BlackRightDone == 1)
   6643            {
   6644            }
   6645            else
   6646            {
   6647              return 0;
   6648            }
   6649            
   6650            //2. 要求线头必须都在最近行。
   6651            //左线开始扫描时
   6652            if(BlackGetPreDir == 0 || BlackGetPreDir == 2)
   6653            {
   6654              if(BlackLeftStep1ScanRow == CameraHight - 1 && BlackRightStep1ScanRow >= CameraHight - 5)
   6655              {
   6656              }
   6657              else
   6658              {
   6659                //线头太高，不用检测大跳变错误。
   6660                return 0;
   6661              }
   6662            }
   6663            //右线开始扫描时
   6664            else
   6665            {
   6666              if(BlackRightStep1ScanRow == CameraHight - 1 && BlackLeftStep1ScanRow >= CameraHight - 5)
   6667              {
   6668              }
   6669              else
   6670              {
   6671                //线头太高，不用检测大跳变错误。
   6672                return 0;
   6673              }    
   6674            }
   6675            
   6676            //左线
   6677            //左线出现直角黑块的大跳变，左线一定是右上到左下。斜率一定是负的。
   6678            if(SlopeL < 0 && BlackLeftEndLine - BlackLeftHeadLine - 5 > 0 && BlackLeft5SlopeIndex - 2 > 0)
   6679            {
   6680              //5Slope数组有可能已经删掉了一些黑点，所以也要参考实际的有效黑点数。
   6681              tempend1 = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 5, BlackLeft5SlopeIndex - 2);
   6682              //轮询5Slope数组
   6683              for(i = 0; ; i++)
   6684              {
   6685                //左线的直角黑块误判都是负号。
   6686                if(
   6687                  (BlackLeft5Slope[i] < 0)
   6688                &&(BlackLeft5Slope[i+1] < 0)
   6689                &&(BlackLeft5Slope[i] - BlackLeft5Slope[i+1] >= BlackBigChangeFinalCheckSlopeLimit)     //i+1比i小2500以上。不能是">"
   6690                  )
   6691                {
   6692                  //检测到直角黑块大跳变，跳出。
   6693                  break;
   6694                }
   6695                else
   6696                {      
   6697                }
   6698                
   6699                //到数组最后一个，跳出。
   6700                if(i == tempend1) break;
   6701              }
   6702              
   6703              //检测到直角黑块大跳变。
   6704              if(i != tempend1)
   6705              {
   6706                //要删掉4行，至少要有4行。
   6707                if(i > 4)
   6708                {
   6709                  row = BlackLeft5SlopeRow[i+1] + 3;
   6710                  //十字检测未进入或失败时，是需要检测最终大跳变的。
   6711                  //若十字检测成功，且row在第1段黑线真实结束行的远处时，不需要检测，防止因十字补线带来的斜率突变。
   6712                  if(BlackLeftCrossDone == 2 && row < BlackLeftRow1RealLastLine)
   6713                  {
   6714                    //返回不需要检测
   6715                    return 0;
   6716                  }
   6717                  else
   6718                  {
   6719                  }
   6720                  
   6721                  //删掉从倒退4行开始的往远处的所有行。
   6722                  for(; ; row--)
   6723                  {
   6724                    BlackLeftLoc[row][0] = MaxValUint8;
   6725                    
   6726                    if(row == 0) break;
   6727                  }
   6728            
   6729                  //置标志位。左线最终大跳变。
   6730                  BlackBigChangeFinalCheckFlag = 1;
   6731                  //返回1检测成功。
   6732                  return 1;
   6733                }
   6734                else
   6735                {     
   6736                }
   6737              }
   6738              //没检测到直角黑块大跳变，不作任何处理。
   6739              else
   6740              {    
   6741              }
   6742            }
   6743            else
   6744            {
   6745            }
   6746            
   6747            //右线
   6748            //右线出现直角黑块的大跳变，右线一定是左上到右下。斜率一定是正的。
   6749            if(SlopeR > 0 && BlackRightEndLine - BlackRightHeadLine - 5 > 0 && BlackRight5SlopeIndex - 2 > 0)
   6750            {
   6751              //5Slope数组有可能已经删掉了一些黑点，所以也要参考实际的有效黑点数。
   6752              tempend2 = MinRe(BlackRightEndLine - BlackRightHeadLine - 5, BlackRight5SlopeIndex - 2);
   6753              //轮询5Slope数组
   6754              for(i = 0; ; i++)
   6755              {
   6756                //右线的直角黑块误判都是正号。
   6757                if(
   6758                  (BlackRight5Slope[i] > 0)
   6759                &&(BlackRight5Slope[i+1] > 0)
   6760                &&(BlackRight5Slope[i+1] - BlackRight5Slope[i] >= BlackBigChangeFinalCheckSlopeLimit)     //i+1比i大2500以上。不能是">"
   6761                  )
   6762                {
   6763                  //检测到直角黑块大跳变，跳出。
   6764                  break;
   6765                }
   6766                else
   6767                {      
   6768                }
   6769                
   6770                //到数组最后一个，跳出。
   6771                if(i == tempend2) break;
   6772              }
   6773              
   6774              //检测到直角黑块大跳变。
   6775              if(i != tempend2)
   6776              {
   6777                //要删掉4行，至少要有4行。
   6778                if(i > 4)
   6779                {        
   6780                  row = BlackRight5SlopeRow[i+1] + 3;
   6781                  //十字检测未进入或失败时，是需要检测最终大跳变的。
   6782                  //若十字检测成功，且row在第1段黑线真实结束行的远处时，不需要检测，防止因十字补线带来的斜率突变。
   6783                  if(BlackRightCrossDone == 2 && row < BlackRightRow1RealLastLine)
   6784                  {
   6785                    //返回不需要检测
   6786                    return 0;
   6787                  }
   6788                  else
   6789                  {
   6790                  }
   6791                  
   6792                  //删掉从倒退4行开始的往远处的所有行。
   6793                  for(; ; row--)
   6794                  {
   6795                    BlackRightLoc[row][0] = MaxValUint8;
   6796                    
   6797                    if(row == 0) break;
   6798                  }
   6799                  
   6800                  //置标志位。右线最终大跳变。
   6801                  BlackBigChangeFinalCheckFlag = 2;
   6802                  //返回1检测成功。      
   6803                  return 1;
   6804                }
   6805                else
   6806                {     
   6807                }
   6808              }
   6809              //没检测到直角黑块大跳变，不作任何处理。
   6810              else
   6811              {    
   6812              }  
   6813            }
   6814            else
   6815            {
   6816            }
   6817            
   6818            //常态为0，即没检测到或没必要检测
   6819            return 0;
   6820          }
   6821          
   6822          
   6823          ////斜入直角黑块
   6824          ////返回1表示检测到，0表示没有检测到。
   6825          //uint8 BlackAngleZoneSpeCheck(void)
   6826          //{
   6827          //  uint8 temp1, temp2, i;
   6828          //  
   6829          //  //先检测右边有没有斜入的直角黑块。
   6830          //  //1. 初步检测
   6831          //  if(
   6832          //    (BlackLeftDone == 1 && BlackRightDone == 1)
   6833          //  &&(SlopeL + 3000 < 0)
   6834          //  &&(SlopeR > 0)
   6835          //  &&(CURVEL > 0)
   6836          //  &&(CURVER < 0)
   6837          //  &&(BlackGetPreDir == 0)
   6838          //  &&(BlackLeftStep1ScanRow == CameraHight - 1)
   6839          //  &&(AbsInt(BlackLeftHeadLine - BlackRightHeadLine) < 5)
   6840          //    )
   6841          //  {
   6842          //    //2. 左线头之前的5Slope均为负
   6843          //    //左线
   6844          //    //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
   6845          //    if(BlackLeftEndLine - BlackLeftHeadLine - 4 < 0 || BlackLeft5SlopeIndex - 1 < 0)
   6846          //    {
   6847          //      return 0;
   6848          //    }
   6849          //    else
   6850          //    {        
   6851          //    }
   6852          //    temp1 = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 4, BlackLeft5SlopeIndex - 1);
   6853          //    
   6854          //    //逐个判断小5点斜率是否满足条件
   6855          //    for(i = 0; ; i++)
   6856          //    {
   6857          //      if(BlackLeft5Slope[i] > 0) //一旦有正的，马上返回失败。
   6858          //      {
   6859          //        return 0;
   6860          //      }
   6861          //
   6862          //      if(i == temp1) break;
   6863          //    }
   6864          //    //3. 右线头之前的5Slope均为正
   6865          //    //右线
   6866          //    //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
   6867          //    if(BlackRightEndLine - BlackRightHeadLine - 4 < 0 || BlackRight5SlopeIndex - 1 < 0)
   6868          //    {
   6869          //      return 0;
   6870          //    }
   6871          //    else
   6872          //    {        
   6873          //    }
   6874          //    temp2 = MinRe(BlackRightEndLine - BlackRightHeadLine - 4, BlackRight5SlopeIndex - 1);
   6875          //    
   6876          //    //逐个判断小5点斜率是否满足条件
   6877          //    for(i = 0; ; i++)
   6878          //    {
   6879          //      if(BlackRight5Slope[i] < 0) //一旦有负的，马上返回失败。
   6880          //      {
   6881          //        return 0;
   6882          //      }
   6883          //
   6884          //      if(i == temp2) break;
   6885          //    }
   6886          //    //4. 存在有行的宽度很小。
   6887          //    temp1 = MinRe(BlackLeftEndLine, BlackRightEndLine);   //尾
   6888          //    temp2 = MaxRe(BlackLeftHeadLine, BlackRightHeadLine); //头
   6889          //    if(temp1 < temp2) 
   6890          //    {
   6891          //      return 0;
   6892          //    }
   6893          //    else
   6894          //    {
   6895          //      for(i = temp1; ; i--)
   6896          //      {
   6897          //        if(BlackRightLoc[i][0] - BlackLeftLoc[i][0] < 80) break;
   6898          //        
   6899          //        if(i == temp2) break;
   6900          //      }
   6901          //      
   6902          //      //确认存在宽度很小的行
   6903          //      if(i != temp2)
   6904          //      {
   6905          //        BlackAngleZoneSpeCheckFlag = 1; //标志位
   6906          //        BlackAngleZoneSpeCheckDir = 1;  //右边有这样的情况
   6907          //        return 1;
   6908          //      }
   6909          //      else
   6910          //      {
   6911          //      }
   6912          //    }
   6913          //  }
   6914          //  //右边没有斜入的黑块，接着检测左边有没有斜入的黑块。
   6915          //  else
   6916          //  {
   6917          //  }
   6918          //  
   6919          //
   6920          //  //先检测左边有没有斜入的直角黑块。
   6921          //  //1. 初步检测
   6922          //  if(
   6923          //    (BlackLeftDone == 1 && BlackRightDone == 1)
   6924          //  &&(SlopeL < 0)
   6925          //  &&(SlopeR > 3000)
   6926          //  &&(CURVEL > 0)
   6927          //  &&(CURVER < 0)
   6928          //  &&(BlackRightStep1ScanRow >= CameraHight - 5)
   6929          //  &&(AbsInt(BlackLeftHeadLine - BlackRightHeadLine) < 5)
   6930          //    )
   6931          //  {
   6932          //    //2. 左线头之前的5Slope均为负
   6933          //    //左线
   6934          //    //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
   6935          //    if(BlackLeftEndLine - BlackLeftHeadLine - 4 < 0 || BlackLeft5SlopeIndex - 1 < 0)
   6936          //    {
   6937          //      return 0;
   6938          //    }
   6939          //    else
   6940          //    {        
   6941          //    }
   6942          //    temp1 = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 4, BlackLeft5SlopeIndex - 1);
   6943          //    
   6944          //    //逐个判断小5点斜率是否满足条件
   6945          //    for(i = 0; ; i++)
   6946          //    {
   6947          //      if(BlackLeft5Slope[i] > 0) //一旦有正的，马上返回失败。
   6948          //      {
   6949          //        return 0;
   6950          //      }
   6951          //
   6952          //      if(i == temp1) break;
   6953          //    }
   6954          //    //3. 右线头之前的5Slope均为正
   6955          //    //右线
   6956          //    //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
   6957          //    if(BlackRightEndLine - BlackRightHeadLine - 4 < 0 || BlackRight5SlopeIndex - 1 < 0)
   6958          //    {
   6959          //      return 0;
   6960          //    }
   6961          //    else
   6962          //    {        
   6963          //    }
   6964          //    temp2 = MinRe(BlackRightEndLine - BlackRightHeadLine - 4, BlackRight5SlopeIndex - 1);
   6965          //    
   6966          //    //逐个判断小5点斜率是否满足条件
   6967          //    for(i = 0; ; i++)
   6968          //    {
   6969          //      if(BlackRight5Slope[i] < 0) //一旦有负的，马上返回失败。
   6970          //      {
   6971          //        return 0;
   6972          //      }
   6973          //
   6974          //      if(i == temp2) break;
   6975          //    }
   6976          //    //4. 存在有行的宽度很小。
   6977          //    temp1 = MinRe(BlackLeftEndLine, BlackRightEndLine);   //尾
   6978          //    temp2 = MaxRe(BlackLeftHeadLine, BlackRightHeadLine); //头
   6979          //    if(temp1 < temp2) 
   6980          //    {
   6981          //      return 0;
   6982          //    }
   6983          //    else
   6984          //    {
   6985          //      for(i = temp1; ; i--)
   6986          //      {
   6987          //        if(BlackRightLoc[i][0] - BlackLeftLoc[i][0] < 80) break;
   6988          //        
   6989          //        if(i == temp2) break;
   6990          //      }
   6991          //      
   6992          //      //确认存在宽度很小的行
   6993          //      if(i != temp2)
   6994          //      {
   6995          //        BlackAngleZoneSpeCheckFlag = 1; //标志位
   6996          //        BlackAngleZoneSpeCheckDir = 0;  //左边有这样的情况
   6997          //        return 1;
   6998          //      }
   6999          //      else
   7000          //      {
   7001          //      }
   7002          //    }
   7003          //  }
   7004          //  //右边没有斜入的黑块，接着检测左边有没有斜入的黑块。
   7005          //  else
   7006          //  {
   7007          //  }
   7008          //  
   7009          //  
   7010          //  //常态为没检测到。
   7011          //  return 0;
   7012          //}
   7013          
   7014          
   7015          
   7016          //======================================================================
   7017          //函数名：BlackGet
   7018          //功  能：黑线提取程序
   7019          //参  数：无
   7020          //返  回：1成功 0失败
   7021          //影  响：见具体的左、右黑线算法
   7022          //说  明：1. 学长的黑线提取算法有很多输入参数，用以对不同环境下的黑线进行提取，可以效仿
   7023          //        2. 左右黑线分开提取，但右黑线提取的起始点以左黑线提取的结果为准（前提是左黑线提取成功）。
   7024          //        3. 为了防止光线的突变，左右黑线各有2次机会，第2次机会将会把3个关键值赋成原始值再试一次。
   7025          //           如果不是光线的原因，3个关键值会变回来。
   7026          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   7027          uint8 BlackGet(void)
   7028          {
   \                     BlackGet: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   7029              uint8 i;
   7030              uint8 tempBlackAngleZoneSpeCheck;       //斜入直角黑块储存位
   7031              uint8 tempBlackBigChangeFinalCheck; //最终大跳变检测储存位。
   7032              uint8 tempBlackSingleSpeCheck;      //单线错误检测储存位。
   7033              //uint8 tempLWB, tempLW, tempLB;
   7034              //uint8 tempRWB, tempRW, tempRB;
   7035          
   7036              //黑线提取预处理。决定先扫描哪条线
   7037              BlackGetPre();    
   \   00000002   0x.... 0x....      BL       BlackGetPre
   7038              
   7039              //预处理左线头成功或左右线头均失败时，从左线开始扫描。
   7040              if(BlackGetPreDir == 0 || BlackGetPreDir == 2)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable43_1
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD004             BEQ.N    ??BlackGet_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable43_1
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD12F             BNE.N    ??BlackGet_1
   7041              {
   7042                //左黑线提取，成功则返回1，失败则返回0.
   7043                if(BlackGetLeft() == 0)
   \                     ??BlackGet_0: (+1)
   \   0000001A   0x.... 0x....      BL       BlackGetLeft
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD10B             BNE.N    ??BlackGet_2
   7044                {
   7045                  BlackLeftDone = 0;                  //左黑线提取失败
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable43_2
   \   00000028   0x7008             STRB     R0,[R1, #+0]
   7046                  BlackLeftHeadLine = MaxValUint8;    //左线头置无效值。
   \   0000002A   0x20FF             MOVS     R0,#+255
   \   0000002C   0x....             LDR.N    R1,??DataTable42_6
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
   7047                  BlackLeftEndLine = MaxValUint8;    //左线尾置无效值。
   \   00000030   0x20FF             MOVS     R0,#+255
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable43_3
   \   00000036   0x7008             STRB     R0,[R1, #+0]
   \   00000038   0xE003             B.N      ??BlackGet_3
   7048                }
   7049                else
   7050                {
   7051                  //先进行左黑线连续性补线
   7052                  BlackLeftContinueAdd();
   \                     ??BlackGet_2: (+1)
   \   0000003A   0x.... 0x....      BL       BlackLeftContinueAdd
   7053                  //再进行左黑线线头线尾查找
   7054                  BlackLeftHeadEndSearch();
   \   0000003E   0x.... 0x....      BL       BlackLeftHeadEndSearch
   7055            
   7056                }    
   7057                
   7058                //右黑线提取，成功则返回1，失败则返回0.
   7059                //如果是右障碍特殊处理，则右黑线函数不用执行，直接置为失败。
   7060                if(
   7061                  (BrickSpeDealFlag == 1 && BrickSpeDealDir == 1)
   7062                ||(BlackGetRight() == 0)
   7063                  )
   \                     ??BlackGet_3: (+1)
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable43_4
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD104             BNE.N    ??BlackGet_4
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable43_5
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD003             BEQ.N    ??BlackGet_5
   \                     ??BlackGet_4: (+1)
   \   00000056   0x.... 0x....      BL       BlackGetRight
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD108             BNE.N    ??BlackGet_6
   7064                {
   7065                  BlackRightDone = 0;                  //右黑线提取失败
   \                     ??BlackGet_5: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable43_6
   \   00000064   0x7008             STRB     R0,[R1, #+0]
   7066                  BlackRightHeadLine = MaxValUint8;    //右线头置无效值。      
   \   00000066   0x20FF             MOVS     R0,#+255
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable43
   \   0000006C   0x7008             STRB     R0,[R1, #+0]
   \   0000006E   0xE033             B.N      ??BlackGet_7
   7067                }
   7068                else
   7069                {
   7070                  //先进行右黑线连续性补线
   7071                  BlackRightContinueAdd();
   \                     ??BlackGet_6: (+1)
   \   00000070   0x.... 0x....      BL       BlackRightContinueAdd
   7072                  //再进行右黑线线头线尾查找
   7073                  BlackRightHeadEndSearch();
   \   00000074   0x.... 0x....      BL       BlackRightHeadEndSearch
   \   00000078   0xE02E             B.N      ??BlackGet_7
   7074                }
   7075              }
   7076              //右线头成功，从右线开始扫描。
   7077              else
   7078              {
   7079                //右黑线提取，成功则返回1，失败则返回0.
   7080                if(BlackGetRight() == 0)
   \                     ??BlackGet_1: (+1)
   \   0000007A   0x.... 0x....      BL       BlackGetRight
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD108             BNE.N    ??BlackGet_8
   7081                {
   7082                  BlackRightDone = 0;                  //右黑线提取失败
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable43_6
   \   00000088   0x7008             STRB     R0,[R1, #+0]
   7083                  BlackRightHeadLine = MaxValUint8;    //右线头置无效值。      
   \   0000008A   0x20FF             MOVS     R0,#+255
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable43
   \   00000090   0x7008             STRB     R0,[R1, #+0]
   \   00000092   0xE003             B.N      ??BlackGet_9
   7084                }
   7085                else
   7086                {
   7087                  //先进行右黑线连续性补线
   7088                  BlackRightContinueAdd();
   \                     ??BlackGet_8: (+1)
   \   00000094   0x.... 0x....      BL       BlackRightContinueAdd
   7089                  //再进行右黑线线头线尾查找
   7090                  BlackRightHeadEndSearch();
   \   00000098   0x.... 0x....      BL       BlackRightHeadEndSearch
   7091                }
   7092                
   7093                //左黑线提取，成功则返回1，失败则返回0.
   7094                //如果是左障碍特殊处理，则左黑线函数不用执行，直接置为失败。
   7095                if(
   7096                  (BrickSpeDealFlag == 1 && BrickSpeDealDir == 0)
   7097                ||(BlackGetLeft() == 0)
   7098                  )
   \                     ??BlackGet_9: (+1)
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable43_4
   \   000000A0   0x7800             LDRB     R0,[R0, #+0]
   \   000000A2   0x2801             CMP      R0,#+1
   \   000000A4   0xD104             BNE.N    ??BlackGet_10
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable43_5
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD003             BEQ.N    ??BlackGet_11
   \                     ??BlackGet_10: (+1)
   \   000000B0   0x.... 0x....      BL       BlackGetLeft
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD10B             BNE.N    ??BlackGet_12
   7099                {
   7100                  BlackLeftDone = 0;                  //左黑线提取失败
   \                     ??BlackGet_11: (+1)
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable43_2
   \   000000BE   0x7008             STRB     R0,[R1, #+0]
   7101                  BlackLeftHeadLine = MaxValUint8;    //左线头置无效值。
   \   000000C0   0x20FF             MOVS     R0,#+255
   \   000000C2   0x....             LDR.N    R1,??DataTable42_6
   \   000000C4   0x7008             STRB     R0,[R1, #+0]
   7102                  BlackLeftEndLine = MaxValUint8;    //左线尾置无效值。
   \   000000C6   0x20FF             MOVS     R0,#+255
   \   000000C8   0x.... 0x....      LDR.W    R1,??DataTable43_3
   \   000000CC   0x7008             STRB     R0,[R1, #+0]
   \   000000CE   0xE003             B.N      ??BlackGet_7
   7103                }
   7104                else
   7105                {
   7106                  //先进行左黑线连续性补线
   7107                  BlackLeftContinueAdd();
   \                     ??BlackGet_12: (+1)
   \   000000D0   0x.... 0x....      BL       BlackLeftContinueAdd
   7108                  //再进行左黑线线头线尾查找
   7109                  BlackLeftHeadEndSearch();
   \   000000D4   0x.... 0x....      BL       BlackLeftHeadEndSearch
   7110            
   7111                }
   7112              }
   7113               
   7114              //左、右黑线均提取失败，则黑线提取失败。
   7115              if((BlackLeftDone == 0) && (BlackRightDone == 0))
   \                     ??BlackGet_7: (+1)
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable43_2
   \   000000DC   0x7800             LDRB     R0,[R0, #+0]
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD106             BNE.N    ??BlackGet_13
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable43_6
   \   000000E6   0x7800             LDRB     R0,[R0, #+0]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD101             BNE.N    ??BlackGet_13
   7116              {
   7117                return 0;
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xE0AB             B.N      ??BlackGet_14
   7118              }
   7119              else
   7120              {
   7121                //左右黑线畸变矫正
   7122                BlackUdis();
   \                     ??BlackGet_13: (+1)
   \   000000F0   0x.... 0x....      BL       BlackUdis
   7123                
   7124                //只要有一边成功就可以进来。
   7125                //由于回弯要用到斜率，所以提前计算。
   7126                //曲率、斜率求取的标志位，1成功，0失败。
   7127                CurveSlopeFlagL = 1;
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable43_7
   \   000000FA   0x7008             STRB     R0,[R1, #+0]
   7128                CurveSlopeFlagR = 1;
   \   000000FC   0x2001             MOVS     R0,#+1
   \   000000FE   0x.... 0x....      LDR.W    R1,??DataTable43_8
   \   00000102   0x7008             STRB     R0,[R1, #+0]
   7129                //左黑线的曲率、斜率的求取。  
   7130                if(CurveSlopeGetLeft() == 0)
   \   00000104   0x.... 0x....      BL       CurveSlopeGetLeft
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD103             BNE.N    ??BlackGet_15
   7131                {
   7132                  CurveSlopeFlagL = 0;
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable43_7
   \   00000112   0x7008             STRB     R0,[R1, #+0]
   7133                  //uart_sendN(UART0, (uint8 *)"\nCurveSlopeGetLeft() Failed!", 28);
   7134                }
   7135                else
   7136                {
   7137                }
   7138                
   7139                //右黑线的曲率、斜率的求取。  
   7140                if(CurveSlopeGetRight() == 0)
   \                     ??BlackGet_15: (+1)
   \   00000114   0x.... 0x....      BL       CurveSlopeGetRight
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD103             BNE.N    ??BlackGet_16
   7141                {
   7142                  CurveSlopeFlagR = 0;
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0x.... 0x....      LDR.W    R1,??DataTable43_8
   \   00000122   0x7008             STRB     R0,[R1, #+0]
   7143                  //uart_sendN(UART0, (uint8 *)"\nCurveSlopeGetRight() Failed!", 29);
   7144                }
   7145                else
   7146                {
   7147                }
   7148                
   7149                //左线提取成功则进行左回弯检测
   7150                if(BlackLeftDone == 1)
   \                     ??BlackGet_16: (+1)
   \   00000124   0x.... 0x....      LDR.W    R0,??DataTable43_2
   \   00000128   0x7800             LDRB     R0,[R0, #+0]
   \   0000012A   0x2801             CMP      R0,#+1
   \   0000012C   0xD124             BNE.N    ??BlackGet_17
   7151                {
   7152                  //左回弯特殊检测。
   7153                  if(BlackLeftRollCheck() == 0)
   \   0000012E   0x.... 0x....      BL       BlackLeftRollCheck
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD120             BNE.N    ??BlackGet_17
   7154                  {
   7155                    BlackLeftRollCheckFlag = 1;         //检测到回弯。
   \   00000136   0x2001             MOVS     R0,#+1
   \   00000138   0x.... 0x....      LDR.W    R1,??DataTable43_9
   \   0000013C   0x7008             STRB     R0,[R1, #+0]
   7156                    BlackLeftDone = 0;                  //左黑线提取失败
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0x.... 0x....      LDR.W    R1,??DataTable43_2
   \   00000144   0x7008             STRB     R0,[R1, #+0]
   7157                    //清除所有值。
   7158                    for(i = BlackLeftEndLine; ; i--)
   \   00000146   0x.... 0x....      LDR.W    R0,??DataTable43_3
   \   0000014A   0x7800             LDRB     R0,[R0, #+0]
   \   0000014C   0xE000             B.N      ??BlackGet_18
   \                     ??BlackGet_19: (+1)
   \   0000014E   0x1E40             SUBS     R0,R0,#+1
   7159                    {
   7160                      BlackLeftLoc[i][0] = MaxValUint8;
   \                     ??BlackGet_18: (+1)
   \   00000150   0x21FF             MOVS     R1,#+255
   \   00000152   0x.... 0x....      LDR.W    R2,??DataTable43_10
   \   00000156   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000158   0x2303             MOVS     R3,#+3
   \   0000015A   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000015E   0x7011             STRB     R1,[R2, #+0]
   7161                      if(i == BlackLeftHeadLine) break;
   \   00000160   0x....             LDR.N    R1,??DataTable42_6
   \   00000162   0x7809             LDRB     R1,[R1, #+0]
   \   00000164   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000166   0x4288             CMP      R0,R1
   \   00000168   0xD1F1             BNE.N    ??BlackGet_19
   7162                    }
   7163                    BlackLeftHeadLine = MaxValUint8;    //左线头置无效值。
   \   0000016A   0x20FF             MOVS     R0,#+255
   \   0000016C   0x....             LDR.N    R1,??DataTable42_6
   \   0000016E   0x7008             STRB     R0,[R1, #+0]
   7164                    BlackLeftEndLine = MaxValUint8;     //左线尾置无效值。
   \   00000170   0x20FF             MOVS     R0,#+255
   \   00000172   0x.... 0x....      LDR.W    R1,??DataTable43_3
   \   00000176   0x7008             STRB     R0,[R1, #+0]
   7165                  }
   7166                  else
   7167                  {
   7168                  }
   7169                }
   7170                //左线提取失败就不用进行左回弯检测了
   7171                else
   7172                {
   7173                }
   7174                
   7175                //右线提取成功则进行右回弯检测
   7176                if(BlackRightDone == 1)
   \                     ??BlackGet_17: (+1)
   \   00000178   0x.... 0x....      LDR.W    R0,??DataTable43_6
   \   0000017C   0x7800             LDRB     R0,[R0, #+0]
   \   0000017E   0x2801             CMP      R0,#+1
   \   00000180   0xD125             BNE.N    ??BlackGet_20
   7177                {
   7178                  //右回弯特殊检测。
   7179                  if(BlackRightRollCheck() == 0)
   \   00000182   0x.... 0x....      BL       BlackRightRollCheck
   \   00000186   0x2800             CMP      R0,#+0
   \   00000188   0xD121             BNE.N    ??BlackGet_20
   7180                  {
   7181                    BlackRightRollCheckFlag = 1;         //检测到回弯。
   \   0000018A   0x2001             MOVS     R0,#+1
   \   0000018C   0x.... 0x....      LDR.W    R1,??DataTable43_11
   \   00000190   0x7008             STRB     R0,[R1, #+0]
   7182                    BlackRightDone = 0;                  //右黑线提取失败
   \   00000192   0x2000             MOVS     R0,#+0
   \   00000194   0x.... 0x....      LDR.W    R1,??DataTable43_6
   \   00000198   0x7008             STRB     R0,[R1, #+0]
   7183                    //清除所有值。
   7184                    for(i = BlackRightEndLine; ; i--)
   \   0000019A   0x.... 0x....      LDR.W    R0,??DataTable43_12
   \   0000019E   0x7800             LDRB     R0,[R0, #+0]
   \   000001A0   0xE000             B.N      ??BlackGet_21
   \                     ??BlackGet_22: (+1)
   \   000001A2   0x1E40             SUBS     R0,R0,#+1
   7185                    {
   7186                      BlackRightLoc[i][0] = MaxValUint8;
   \                     ??BlackGet_21: (+1)
   \   000001A4   0x21FF             MOVS     R1,#+255
   \   000001A6   0x....             LDR.N    R2,??DataTable42_1
   \   000001A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001AA   0x2303             MOVS     R3,#+3
   \   000001AC   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000001B0   0x7011             STRB     R1,[R2, #+0]
   7187                      if(i == BlackRightHeadLine) break;
   \   000001B2   0x.... 0x....      LDR.W    R1,??DataTable43
   \   000001B6   0x7809             LDRB     R1,[R1, #+0]
   \   000001B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001BA   0x4288             CMP      R0,R1
   \   000001BC   0xD1F1             BNE.N    ??BlackGet_22
   7188                    }
   7189                    BlackRightHeadLine = MaxValUint8;    //右线头置无效值。
   \   000001BE   0x20FF             MOVS     R0,#+255
   \   000001C0   0x.... 0x....      LDR.W    R1,??DataTable43
   \   000001C4   0x7008             STRB     R0,[R1, #+0]
   7190                    BlackRightEndLine = MaxValUint8;     //右线尾置无效值。
   \   000001C6   0x20FF             MOVS     R0,#+255
   \   000001C8   0x.... 0x....      LDR.W    R1,??DataTable43_12
   \   000001CC   0x7008             STRB     R0,[R1, #+0]
   7191                  }
   7192                  else
   7193                  {
   7194                  }
   7195                }
   7196                //右线提取失败就不用进行右回弯检测了
   7197                else
   7198                {
   7199                }
   7200                
   7201              }
   7202              
   7203              //若处在特殊赛道锁存或者特殊控制阶段，则不用进行大跳变最终检测 和 单线错误检测
   7204              if(AngleConfirmLockFlag == 1 || AngleSpeDealFlag == 1 || BrickConfirmLockFlag == 1 || BrickSpeDealFlag == 1)
   \                     ??BlackGet_20: (+1)
   \   000001CE   0x.... 0x....      LDR.W    R0,??DataTable43_13
   \   000001D2   0x7800             LDRB     R0,[R0, #+0]
   \   000001D4   0x2801             CMP      R0,#+1
   \   000001D6   0xD036             BEQ.N    ??BlackGet_23
   \   000001D8   0x.... 0x....      LDR.W    R0,??DataTable43_14
   \   000001DC   0x7800             LDRB     R0,[R0, #+0]
   \   000001DE   0x2801             CMP      R0,#+1
   \   000001E0   0xD031             BEQ.N    ??BlackGet_23
   \   000001E2   0x.... 0x....      LDR.W    R0,??DataTable43_15
   \   000001E6   0x7800             LDRB     R0,[R0, #+0]
   \   000001E8   0x2801             CMP      R0,#+1
   \   000001EA   0xD02C             BEQ.N    ??BlackGet_23
   \   000001EC   0x.... 0x....      LDR.W    R0,??DataTable43_4
   \   000001F0   0x7800             LDRB     R0,[R0, #+0]
   \   000001F2   0x2801             CMP      R0,#+1
   \   000001F4   0xD027             BEQ.N    ??BlackGet_23
   7205              {
   7206              }
   7207              else
   7208              {
   7209                //斜入直角黑块检测
   7210                tempBlackAngleZoneSpeCheck = 0;
   \   000001F6   0x2100             MOVS     R1,#+0
   7211          //      if(BlackAngleZoneSpeCheckSwitch == 1)
   7212          //      {
   7213          //        //1表示检测到斜入直角黑块，0表示没有检测到。
   7214          //        tempBlackAngleZoneSpeCheck = BlackAngleZoneSpeCheck();
   7215          //      }
   7216          //      else
   7217          //      {
   7218          //      }
   7219          
   7220                //大跳变最终检测.
   7221                tempBlackBigChangeFinalCheck = 0;
   \   000001F8   0x2000             MOVS     R0,#+0
   7222                if(tempBlackAngleZoneSpeCheck == 0 && BlackBigChangeFinalCheckSwitch == 1)
   \   000001FA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001FC   0x2900             CMP      R1,#+0
   \   000001FE   0xD122             BNE.N    ??BlackGet_24
   7223                {
   7224                  //1表示检测到，0表示没检测到。
   7225                  tempBlackBigChangeFinalCheck = BlackBigChangeFinalCheck();
   \   00000200   0x.... 0x....      BL       BlackBigChangeFinalCheck
   7226                  //大跳变检测成功，重新找线头线尾，作畸变矫正，计算整条线的斜率、曲率，
   7227                  if(tempBlackBigChangeFinalCheck == 1)
   \   00000204   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000206   0x2801             CMP      R0,#+1
   \   00000208   0xD11D             BNE.N    ??BlackGet_24
   7228                  {
   7229                    //左黑线线头线尾查找
   7230                    BlackLeftHeadEndSearch();
   \   0000020A   0x.... 0x....      BL       BlackLeftHeadEndSearch
   7231                    //右黑线线头线尾查找
   7232                    BlackRightHeadEndSearch();
   \   0000020E   0x.... 0x....      BL       BlackRightHeadEndSearch
   7233                    
   7234                    //左右黑线畸变矫正
   7235                    BlackUdis();
   \   00000212   0x.... 0x....      BL       BlackUdis
   7236                    
   7237                    //只要有一边成功就可以进来。
   7238                    //由于回弯要用到斜率，所以提前计算。
   7239                    //曲率、斜率求取的标志位，1成功，0失败。
   7240                    CurveSlopeFlagL = 1;
   \   00000216   0x2001             MOVS     R0,#+1
   \   00000218   0x.... 0x....      LDR.W    R1,??DataTable43_7
   \   0000021C   0x7008             STRB     R0,[R1, #+0]
   7241                    CurveSlopeFlagR = 1;
   \   0000021E   0x2001             MOVS     R0,#+1
   \   00000220   0x.... 0x....      LDR.W    R1,??DataTable43_8
   \   00000224   0x7008             STRB     R0,[R1, #+0]
   7242                    //左黑线的曲率、斜率的求取。  
   7243                    if(CurveSlopeGetLeft() == 0)
   \   00000226   0x.... 0x....      BL       CurveSlopeGetLeft
   \   0000022A   0x2800             CMP      R0,#+0
   \   0000022C   0xD103             BNE.N    ??BlackGet_25
   7244                    {
   7245                      CurveSlopeFlagL = 0;
   \   0000022E   0x2000             MOVS     R0,#+0
   \   00000230   0x.... 0x....      LDR.W    R1,??DataTable43_7
   \   00000234   0x7008             STRB     R0,[R1, #+0]
   7246                      //uart_sendN(UART0, (uint8 *)"\nCurveSlopeGetLeft() Failed!", 28);
   7247                    }
   7248                    else
   7249                    {
   7250                    }
   7251                    
   7252                    //右黑线的曲率、斜率的求取。  
   7253                    if(CurveSlopeGetRight() == 0)
   \                     ??BlackGet_25: (+1)
   \   00000236   0x.... 0x....      BL       CurveSlopeGetRight
   \   0000023A   0x2800             CMP      R0,#+0
   \   0000023C   0xD103             BNE.N    ??BlackGet_24
   7254                    {
   7255                      CurveSlopeFlagR = 0;
   \   0000023E   0x2000             MOVS     R0,#+0
   \   00000240   0x.... 0x....      LDR.W    R1,??DataTable43_8
   \   00000244   0x7008             STRB     R0,[R1, #+0]
   7256                      //uart_sendN(UART0, (uint8 *)"\nCurveSlopeGetRight() Failed!", 29);
   7257                    }
   7258                    else
   7259                    {
   7260                    }          
   7261                  }
   7262                  else
   7263                  {
   7264                  }
   7265                }
   7266                else
   7267                {        
   7268                }
   7269                
   7270                if(tempBlackAngleZoneSpeCheck == 1 || tempBlackBigChangeFinalCheck == 1)
   7271                {
   7272                  //前面的斜入直角黑块或大跳变已经检测成功了，就不用检测单线错误，两种针对的情况完全不同，关键在于线头线尾、畸变矫正、斜曲率计算最好不要重复，浪费时间。
   7273                }
   7274                /*
   7275                else
   7276                {
   7277                  //黑线检测最后一步，找单线错误。
   7278                  //单线错误比较差劲，出错了，这幅图就直接判定为错图。   
   7279                  tempBlackSingleSpeCheck = BlackSingleSpeCheck();
   7280                  if(tempBlackSingleSpeCheck == 0)
   7281                  {
   7282                    BlackLeftDone = 0;
   7283                    BlackLeftHeadLine = MaxValUint8;
   7284                    BlackLeftEndLine = MaxValUint8;
   7285                    BlackRightDone = 0;
   7286                    BlackRightHeadLine = MaxValUint8;
   7287                    BlackRightEndLine = MaxValUint8;          
   7288                    
   7289                    return 0;
   7290                  }
   7291                  else
   7292                  {
   7293                    //检测到了单线错误，重新找线头线尾，作畸变矫正，计算整条线的斜率、曲率，
   7294                    if(BlackSingleFlag == 1)
   7295                    {
   7296                      //左黑线线头线尾查找
   7297                      BlackLeftHeadEndSearch();
   7298                      //右黑线线头线尾查找
   7299                      BlackRightHeadEndSearch();
   7300                      
   7301                      //左右黑线畸变矫正
   7302                      BlackUdis();
   7303                      
   7304                      //只要有一边成功就可以进来。
   7305                      //由于回弯要用到斜率，所以提前计算。
   7306                      //曲率、斜率求取的标志位，1成功，0失败。
   7307                      CurveSlopeFlagL = 1;
   7308                      CurveSlopeFlagR = 1;
   7309                      //左黑线的曲率、斜率的求取。  
   7310                      if(CurveSlopeGetLeft() == 0)
   7311                      {
   7312                        CurveSlopeFlagL = 0;
   7313                        //uart_sendN(UART0, (uint8 *)"\nCurveSlopeGetLeft() Failed!", 28);
   7314                      }
   7315                      else
   7316                      {
   7317                      }
   7318                      
   7319                      //右黑线的曲率、斜率的求取。  
   7320                      if(CurveSlopeGetRight() == 0)
   7321                      {
   7322                        CurveSlopeFlagR = 0;
   7323                        //uart_sendN(UART0, (uint8 *)"\nCurveSlopeGetRight() Failed!", 29);
   7324                      }
   7325                      else
   7326                      {
   7327                      }
   7328                    }
   7329                    //没有检测到单线错误，不用作处理。
   7330                    else
   7331                    {
   7332                    }
   7333                  }
   7334                }*/          
   7335              }
   7336          
   7337              
   7338              return 1;
   \                     ??BlackGet_24: (+1)
   \                     ??BlackGet_23: (+1)
   \   00000246   0x2001             MOVS     R0,#+1
   \                     ??BlackGet_14: (+1)
   \   00000248   0xBD02             POP      {R1,PC}          ;; return
   7339          }
   7340          
   7341          
   7342          //针对单线错误的中心线重新处理

   \                                 In section .text, align 2, keep-with-next
   7343          uint8 CenterLineGetSingleWrongAdd(void)
   7344          {
   \                     CenterLineGetSingleWrongAdd: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   7345            uint8 row, i;
   7346            uint8 temp;
   7347            uint8 flag1, flag2;
   7348            uint8 tempflag1;
   7349            uint8 tempway1;
   7350            uint8 x[CenterForwardLineNum];   //中心线向前补线计算斜率时，x坐标，表示第几行。。
   7351            int16 y[CenterForwardLineNum];   //中心线向前补线计算斜率时，y坐标，表示中心线位置。
   7352            int32 a1, a0;    //中心线向前补线时，最小二乘法的斜率和纵截距。
   7353            
   7354            float slope;
   7355            
   7356            //中心线数组的重新初始化
   7357            for(i = 0; ; i++)
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xE000             B.N      ??CenterLineGetSingleWrongAdd_0
   \                     ??CenterLineGetSingleWrongAdd_1: (+1)
   \   0000000A   0x1C40             ADDS     R0,R0,#+1
   7358            {
   7359              CenterLineLoc[i] = MaxValInt16;
   \                     ??CenterLineGetSingleWrongAdd_0: (+1)
   \   0000000C   0xF647 0x71FF      MOVW     R1,#+32767
   \   00000010   0x.... 0x....      LDR.W    R2,??DataTable43_16
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   7360              if(i == CameraHight - 1) break;
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x283B             CMP      R0,#+59
   \   0000001E   0xD1F4             BNE.N    ??CenterLineGetSingleWrongAdd_1
   7361            }
   7362            
   7363            //左线悬空，右线有效。
   7364            if(RoadHalfWidthWrongDir == 0)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable43_17
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xF040 0x816D      BNE.W    ??CenterLineGetSingleWrongAdd_2
   7365            {
   7366              //若右线的线头线尾无效，则直接返回失败。
   7367              if(BlackRightHeadLine == MaxValUint8 || BlackRightEndLine == MaxValUint8)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable43
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x28FF             CMP      R0,#+255
   \   00000034   0xD004             BEQ.N    ??CenterLineGetSingleWrongAdd_3
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable43_12
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x28FF             CMP      R0,#+255
   \   0000003E   0xD101             BNE.N    ??CenterLineGetSingleWrongAdd_4
   7368              {
   7369                return 0;
   \                     ??CenterLineGetSingleWrongAdd_3: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE2A4             B.N      ??CenterLineGetSingleWrongAdd_5
   7370              }
   7371              else
   7372              {
   7373              }
   7374                 
   7375              flag1 = 1;
   \                     ??CenterLineGetSingleWrongAdd_4: (+1)
   \   00000044   0x2001             MOVS     R0,#+1
   7376              flag2 = 1;
   \   00000046   0x2001             MOVS     R0,#+1
   7377              
   7378              //中心线的线尾取左线的线尾即可。
   7379              CenterHeadLine = BlackRightHeadLine;   //线头取左线的线头，注意这不是实际的线头。
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable43
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable43_18
   \   00000052   0x7008             STRB     R0,[R1, #+0]
   7380              //CenterHeadLine = 0;                    //线头因为要固定补到第0行，所以直接置0.
   7381              CenterEndLine = BlackRightEndLine;
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable43_12
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable43_19
   \   0000005E   0x7008             STRB     R0,[R1, #+0]
   7382              
   7383              //首先看线头是否大于BlackControlLineLow行
   7384              if(BlackRightHeadLine >= BlackControlLineLow)
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable43
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x281A             CMP      R0,#+26
   \   00000068   0xDB00             BLT.N    ??CenterLineGetSingleWrongAdd_6
   7385              {
   7386                flag1 = 0;     
   \   0000006A   0x2000             MOVS     R0,#+0
   7387              }
   7388              else
   7389              {
   7390              }
   7391              
   7392              //右线尾小于CameraHight - 1行。
   7393              if(BlackRightEndLine < CameraHight - 1)
   \                     ??CenterLineGetSingleWrongAdd_6: (+1)
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable43_12
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x283B             CMP      R0,#+59
   \   00000074   0xDA07             BGE.N    ??CenterLineGetSingleWrongAdd_7
   7394              {
   7395                //只有右线成功，而且右线尾还那么远，真心没法继续。直接返回失败。
   7396                //if(BlackRightEndLine < CameraHight - 1 - BlackRightBackLineStart)
   7397                if(BlackRightEndLine <= BlackControlLineLow)  
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable43_12
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0x281B             CMP      R0,#+27
   \   0000007E   0xDA02             BGE.N    ??CenterLineGetSingleWrongAdd_7
   7398                {
   7399                  flag2 = 0;
   \   00000080   0x2000             MOVS     R0,#+0
   7400                  return 0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xE283             B.N      ??CenterLineGetSingleWrongAdd_5
   7401                }
   7402                //右线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackRightEndLine。
   7403                else
   7404                {
   7405                }
   7406              }
   7407              //右线尾等于CameraHight - 1，直接取BlackRightEndLine
   7408              else
   7409              {
   7410              }
   7411              
   7412              //丢失另一根线的时候，先根据斜率估算出半宽，若没有上一次双线图像时的赛道半宽大，则直接用上一次双线的赛道半宽。
   7413              //求5行的斜率。
   7414              if(BlackRightEndLine - BlackRightHeadLine > 5)
   \                     ??CenterLineGetSingleWrongAdd_7: (+1)
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable43_12
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable43
   \   00000090   0x7809             LDRB     R1,[R1, #+0]
   \   00000092   0x1A40             SUBS     R0,R0,R1
   \   00000094   0x2806             CMP      R0,#+6
   \   00000096   0xDB36             BLT.N    ??CenterLineGetSingleWrongAdd_8
   7415              {
   7416                slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
   7417                              (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable43_20
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable43_12
   \   000000A0   0x7809             LDRB     R1,[R1, #+0]
   \   000000A2   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable43_20
   \   000000AA   0x.... 0x....      LDR.W    R2,??DataTable43_12
   \   000000AE   0x7812             LDRB     R2,[R2, #+0]
   \   000000B0   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   000000B4   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   000000B8   0x1A40             SUBS     R0,R0,R1
   \   000000BA   0x.... 0x....      BL       __aeabi_i2d
   \   000000BE   0x2200             MOVS     R2,#+0
   \   000000C0   0x.... 0x....      LDR.W    R3,??DataTable43_21  ;; 0x3ff00000
   \   000000C4   0x.... 0x....      BL       __aeabi_dmul
   \   000000C8   0x0004             MOVS     R4,R0
   \   000000CA   0x000D             MOVS     R5,R1
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable43_20
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable43_12
   \   000000D4   0x7809             LDRB     R1,[R1, #+0]
   \   000000D6   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   000000DA   0x6840             LDR      R0,[R0, #+4]
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable43_20
   \   000000E0   0x.... 0x....      LDR.W    R2,??DataTable43_12
   \   000000E4   0x7812             LDRB     R2,[R2, #+0]
   \   000000E6   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   000000EA   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   000000EE   0x1A40             SUBS     R0,R0,R1
   \   000000F0   0x.... 0x....      BL       __aeabi_i2d
   \   000000F4   0x0002             MOVS     R2,R0
   \   000000F6   0x000B             MOVS     R3,R1
   \   000000F8   0x0020             MOVS     R0,R4
   \   000000FA   0x0029             MOVS     R1,R5
   \   000000FC   0x.... 0x....      BL       __aeabi_ddiv
   \   00000100   0x.... 0x....      BL       __aeabi_d2f
   \   00000104   0xE000             B.N      ??CenterLineGetSingleWrongAdd_9
   7418              }
   7419              else
   7420              {
   7421                slope = 0;
   \                     ??CenterLineGetSingleWrongAdd_8: (+1)
   \   00000106   0x2000             MOVS     R0,#+0
   7422              }
   7423              //赛道半宽
   7424              temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
   \                     ??CenterLineGetSingleWrongAdd_9: (+1)
   \   00000108   0x0001             MOVS     R1,R0
   \   0000010A   0x.... 0x....      BL       __aeabi_fmul
   \   0000010E   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   00000112   0x.... 0x....      BL       __aeabi_fadd
   \   00000116   0x.... 0x....      BL       __aeabi_f2d
   \   0000011A   0x.... 0x....      BL       sqrt
   \   0000011E   0x2200             MOVS     R2,#+0
   \   00000120   0x.... 0x....      LDR.W    R3,??DataTable43_21  ;; 0x3ff00000
   \   00000124   0x.... 0x....      BL       __aeabi_dmul
   \   00000128   0x2200             MOVS     R2,#+0
   \   0000012A   0x.... 0x....      LDR.W    R3,??DataTable43_22  ;; 0x40690000
   \   0000012E   0x.... 0x....      BL       __aeabi_dmul
   \   00000132   0x2200             MOVS     R2,#+0
   \   00000134   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   00000138   0x.... 0x....      BL       __aeabi_ddiv
   \   0000013C   0x.... 0x....      BL       __aeabi_d2iz
   7425              //取最大值
   7426              RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
   \   00000140   0x.... 0x....      LDR.W    R1,??DataTable43_23
   \   00000144   0x7809             LDRB     R1,[R1, #+0]
   \   00000146   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000148   0x.... 0x....      BL       MaxRe
   \   0000014C   0x.... 0x....      LDR.W    R1,??DataTable43_23
   \   00000150   0x7008             STRB     R0,[R1, #+0]
   7427              
   7428              tempflag1 = 0;
   \   00000152   0x2400             MOVS     R4,#+0
   7429              tempway1 = 0;
   \   00000154   0x2500             MOVS     R5,#+0
   7430              //根据赛道宽度估计出中心线的线头。
   7431              CenterLineLoc[BlackRightEndLine] = BlackUdisRightLocation[BlackRightEndLine].x - RoadHalfWidth;
   \   00000156   0x.... 0x....      LDR.W    R0,??DataTable43_20
   \   0000015A   0x.... 0x....      LDR.W    R1,??DataTable43_12
   \   0000015E   0x7809             LDRB     R1,[R1, #+0]
   \   00000160   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000164   0x.... 0x....      LDR.W    R1,??DataTable43_23
   \   00000168   0x7809             LDRB     R1,[R1, #+0]
   \   0000016A   0x1A40             SUBS     R0,R0,R1
   \   0000016C   0x.... 0x....      LDR.W    R1,??DataTable43_16
   \   00000170   0x.... 0x....      LDR.W    R2,??DataTable43_12
   \   00000174   0x7812             LDRB     R2,[R2, #+0]
   \   00000176   0xF821 0x0012      STRH     R0,[R1, R2, LSL #+1]
   7432              //根据右线的走势估计出中心线。中心线是个int16型矩阵，有正负。
   7433              for(row = BlackRightEndLine - 1; ;row--)
   \   0000017A   0x.... 0x....      LDR.W    R0,??DataTable43_12
   \   0000017E   0x7800             LDRB     R0,[R0, #+0]
   \   00000180   0xF1B0 0x0801      SUBS     R8,R0,#+1
   \   00000184   0xE001             B.N      ??CenterLineGetSingleWrongAdd_10
   \                     ??CenterLineGetSingleWrongAdd_11: (+1)
   \   00000186   0xF1B8 0x0801      SUBS     R8,R8,#+1
   7434              {
   7435                //右线有效时。根据右线的趋势补线。
   7436                if(BlackRightLoc[row][0] != MaxValUint8)
   \                     ??CenterLineGetSingleWrongAdd_10: (+1)
   \   0000018A   0x.... 0x....      LDR.W    R0,??DataTable43_24
   \   0000018E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000192   0x2103             MOVS     R1,#+3
   \   00000194   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00000198   0x7800             LDRB     R0,[R0, #+0]
   \   0000019A   0x28FF             CMP      R0,#+255
   \   0000019C   0xD01D             BEQ.N    ??CenterLineGetSingleWrongAdd_12
   7437                {
   7438                  tempflag1 = 0;
   \   0000019E   0x2400             MOVS     R4,#+0
   7439                  CenterLineLoc[row] = CenterLineLoc[row+1] + BlackUdisRightLocation[row].x - BlackUdisRightLocation[row+1].x;
   \   000001A0   0x.... 0x....      LDR.W    R0,??DataTable43_16
   \   000001A4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001A8   0xEB10 0x0048      ADDS     R0,R0,R8, LSL #+1
   \   000001AC   0x8840             LDRH     R0,[R0, #+2]
   \   000001AE   0x.... 0x....      LDR.W    R1,??DataTable43_20
   \   000001B2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001B6   0xF851 0x1038      LDR      R1,[R1, R8, LSL #+3]
   \   000001BA   0x1808             ADDS     R0,R1,R0
   \   000001BC   0x.... 0x....      LDR.W    R1,??DataTable43_20
   \   000001C0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001C4   0xEB11 0x01C8      ADDS     R1,R1,R8, LSL #+3
   \   000001C8   0x6889             LDR      R1,[R1, #+8]
   \   000001CA   0x1A40             SUBS     R0,R0,R1
   \   000001CC   0x.... 0x....      LDR.W    R1,??DataTable43_16
   \   000001D0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001D4   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   000001D8   0xE077             B.N      ??CenterLineGetSingleWrongAdd_13
   7440                }
   7441                //右线无效时。根据最后两行的中心线趋势补线。
   7442                else
   7443                {
   7444                    //当右线无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
   7445                    if(tempflag1 == 0)
   \                     ??CenterLineGetSingleWrongAdd_12: (+1)
   \   000001DA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001DC   0x2C00             CMP      R4,#+0
   \   000001DE   0xD12E             BNE.N    ??CenterLineGetSingleWrongAdd_14
   7446                    {
   7447                      //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
   7448                      tempflag1 = 1;
   \   000001E0   0x2401             MOVS     R4,#+1
   7449                      //最后几行行数够多，可以采用最小二乘法的方式。
   7450                      if(row + CenterForwardLineNum <= CameraHight - 1)
   \   000001E2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001E6   0xF118 0x0004      ADDS     R0,R8,#+4
   \   000001EA   0x283C             CMP      R0,#+60
   \   000001EC   0xDA26             BGE.N    ??CenterLineGetSingleWrongAdd_15
   7451                      {
   7452                        tempway1 = 0;
   \   000001EE   0x2500             MOVS     R5,#+0
   7453                        //进行最小二乘法系数的计算。
   7454                        for(i = 0; i < CenterForwardLineNum; i++)
   \   000001F0   0x2000             MOVS     R0,#+0
   \   000001F2   0xE012             B.N      ??CenterLineGetSingleWrongAdd_16
   7455                        {
   7456                          x[i] = row + i + 1;
   \                     ??CenterLineGetSingleWrongAdd_17: (+1)
   \   000001F4   0xEB10 0x0108      ADDS     R1,R0,R8
   \   000001F8   0x1C49             ADDS     R1,R1,#+1
   \   000001FA   0xAA00             ADD      R2,SP,#+0
   \   000001FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001FE   0x5481             STRB     R1,[R0, R2]
   7457                          y[i] = CenterLineLoc[row + i + 1];
   \   00000200   0x.... 0x....      LDR.W    R1,??DataTable43_16
   \   00000204   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000206   0xFA50 0xF288      UXTAB    R2,R0,R8
   \   0000020A   0xEB11 0x0142      ADDS     R1,R1,R2, LSL #+1
   \   0000020E   0x8849             LDRH     R1,[R1, #+2]
   \   00000210   0xAA01             ADD      R2,SP,#+4
   \   00000212   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000214   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   7458                        }
   \   00000218   0x1C40             ADDS     R0,R0,#+1
   \                     ??CenterLineGetSingleWrongAdd_16: (+1)
   \   0000021A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000021C   0x2804             CMP      R0,#+4
   \   0000021E   0xDBE9             BLT.N    ??CenterLineGetSingleWrongAdd_17
   7459                        a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
   \   00000220   0x2204             MOVS     R2,#+4
   \   00000222   0xA901             ADD      R1,SP,#+4
   \   00000224   0xA800             ADD      R0,SP,#+0
   \   00000226   0x.... 0x....      BL       LeastSquareInt16a1
   \   0000022A   0x0006             MOVS     R6,R0
   7460                        a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
   \   0000022C   0x2304             MOVS     R3,#+4
   \   0000022E   0x0032             MOVS     R2,R6
   \   00000230   0xA901             ADD      R1,SP,#+4
   \   00000232   0xA800             ADD      R0,SP,#+0
   \   00000234   0x.... 0x....      BL       LeastSquareInt16a0
   \   00000238   0x0007             MOVS     R7,R0
   \   0000023A   0xE000             B.N      ??CenterLineGetSingleWrongAdd_14
   7461                      }
   7462                      //最后几行的行数不够多，采用最后两行趋势补线的方式。
   7463                      else
   7464                      {
   7465                        tempway1 = 1;
   \                     ??CenterLineGetSingleWrongAdd_15: (+1)
   \   0000023C   0x2501             MOVS     R5,#+1
   7466                      }
   7467                    }
   7468                    else
   7469                    {
   7470                    }
   7471                  
   7472                    //确认补线方式后，开始补线。
   7473                    if(tempway1 == 0)
   \                     ??CenterLineGetSingleWrongAdd_14: (+1)
   \   0000023E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000240   0x2D00             CMP      R5,#+0
   \   00000242   0xD10E             BNE.N    ??CenterLineGetSingleWrongAdd_18
   7474                    {
   7475                      //最小二乘法的方式。
   7476                      CenterLineLoc[row] = (a0 + a1 * row) / LeastSquareMulti;
   \   00000244   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000248   0xFB08 0x7006      MLA      R0,R8,R6,R7
   \   0000024C   0xF44F 0x717A      MOV      R1,#+1000
   \   00000250   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000254   0x.... 0x....      LDR.W    R1,??DataTable43_16
   \   00000258   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000025C   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   00000260   0xE033             B.N      ??CenterLineGetSingleWrongAdd_13
   7477                    }
   7478                    else
   7479                    {
   7480                      //最近2行。
   7481                      if(row == CameraHight - 1 || row == CameraHight - 2)
   \                     ??CenterLineGetSingleWrongAdd_18: (+1)
   \   00000262   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000266   0xF1B8 0x0F3B      CMP      R8,#+59
   \   0000026A   0xD004             BEQ.N    ??CenterLineGetSingleWrongAdd_19
   \   0000026C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000270   0xF1B8 0x0F3A      CMP      R8,#+58
   \   00000274   0xD110             BNE.N    ??CenterLineGetSingleWrongAdd_20
   7482                      {
   7483                        CenterLineLoc[row] = BlackUdisRightLocation[row].x - RoadHalfWidth;
   \                     ??CenterLineGetSingleWrongAdd_19: (+1)
   \   00000276   0x.... 0x....      LDR.W    R0,??DataTable43_20
   \   0000027A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000027E   0xF850 0x0038      LDR      R0,[R0, R8, LSL #+3]
   \   00000282   0x.... 0x....      LDR.W    R1,??DataTable43_23
   \   00000286   0x7809             LDRB     R1,[R1, #+0]
   \   00000288   0x1A40             SUBS     R0,R0,R1
   \   0000028A   0x.... 0x....      LDR.W    R1,??DataTable43_16
   \   0000028E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000292   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   00000296   0xE018             B.N      ??CenterLineGetSingleWrongAdd_13
   7484                      }
   7485                      //不是最近2行。
   7486                      else
   7487                      {
   7488                        //最后两行的方式。
   7489                        CenterLineLoc[row] = CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2];
   \                     ??CenterLineGetSingleWrongAdd_20: (+1)
   \   00000298   0x....             LDR.N    R0,??DataTable43_16
   \   0000029A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000029E   0xEB10 0x0048      ADDS     R0,R0,R8, LSL #+1
   \   000002A2   0x8840             LDRH     R0,[R0, #+2]
   \   000002A4   0x....             LDR.N    R1,??DataTable43_16
   \   000002A6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002AA   0xEB11 0x0148      ADDS     R1,R1,R8, LSL #+1
   \   000002AE   0x8849             LDRH     R1,[R1, #+2]
   \   000002B0   0x1808             ADDS     R0,R1,R0
   \   000002B2   0x....             LDR.N    R1,??DataTable43_16
   \   000002B4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002B8   0xEB11 0x0148      ADDS     R1,R1,R8, LSL #+1
   \   000002BC   0x8889             LDRH     R1,[R1, #+4]
   \   000002BE   0x1A40             SUBS     R0,R0,R1
   \   000002C0   0x....             LDR.N    R1,??DataTable43_16
   \   000002C2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002C6   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   7490                      }
   7491                    }
   7492                  }
   7493                
   7494                  if(row == 0) break;
   \                     ??CenterLineGetSingleWrongAdd_13: (+1)
   \   000002CA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002CE   0xF1B8 0x0F00      CMP      R8,#+0
   \   000002D2   0xF47F 0xAF58      BNE.W    ??CenterLineGetSingleWrongAdd_11
   7495                }
   7496              
   7497                
   7498              
   7499              //对未处理的行的中心线置无效值。
   7500              //底部置无效值。顶部不用处理。
   7501              if(CenterEndLine != CameraHight - 1)
   \   000002D6   0x....             LDR.N    R0,??DataTable43_19
   \   000002D8   0x7800             LDRB     R0,[R0, #+0]
   \   000002DA   0x283B             CMP      R0,#+59
   \   000002DC   0xF000 0x8156      BEQ.W    ??CenterLineGetSingleWrongAdd_21
   7502              {
   7503                for(row = CameraHight - 1; ; row--)
   \   000002E0   0xF05F 0x083B      MOVS     R8,#+59
   \   000002E4   0xE008             B.N      ??CenterLineGetSingleWrongAdd_22
   7504                {
   7505                  if(row == CenterEndLine) break;       
   7506                  CenterLineLoc[row] = MaxValInt16;
   \                     ??CenterLineGetSingleWrongAdd_23: (+1)
   \   000002E6   0xF647 0x70FF      MOVW     R0,#+32767
   \   000002EA   0x....             LDR.N    R1,??DataTable43_16
   \   000002EC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002F0   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   000002F4   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \                     ??CenterLineGetSingleWrongAdd_22: (+1)
   \   000002F8   0x....             LDR.N    R0,??DataTable43_19
   \   000002FA   0x7800             LDRB     R0,[R0, #+0]
   \   000002FC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000300   0x4580             CMP      R8,R0
   \   00000302   0xD1F0             BNE.N    ??CenterLineGetSingleWrongAdd_23
   \   00000304   0xE142             B.N      ??CenterLineGetSingleWrongAdd_21
   7507                }
   7508              }
   7509              else
   7510              {
   7511              }
   7512            }
   7513            //右线悬空，左线有效。
   7514            else
   7515            {
   7516              //若左线的线头线尾无效，则直接返回失败。
   7517              if(BlackLeftHeadLine == MaxValUint8 || BlackLeftEndLine == MaxValUint8)
   \                     ??CenterLineGetSingleWrongAdd_2: (+1)
   \   00000306   0x....             LDR.N    R0,??DataTable43_25
   \   00000308   0x7800             LDRB     R0,[R0, #+0]
   \   0000030A   0x28FF             CMP      R0,#+255
   \   0000030C   0xD003             BEQ.N    ??CenterLineGetSingleWrongAdd_24
   \   0000030E   0x....             LDR.N    R0,??DataTable43_3
   \   00000310   0x7800             LDRB     R0,[R0, #+0]
   \   00000312   0x28FF             CMP      R0,#+255
   \   00000314   0xD101             BNE.N    ??CenterLineGetSingleWrongAdd_25
   7518              {
   7519                return 0;
   \                     ??CenterLineGetSingleWrongAdd_24: (+1)
   \   00000316   0x2000             MOVS     R0,#+0
   \   00000318   0xE139             B.N      ??CenterLineGetSingleWrongAdd_5
   7520              }
   7521              else
   7522              {
   7523              }
   7524              
   7525              flag1 = 1;
   \                     ??CenterLineGetSingleWrongAdd_25: (+1)
   \   0000031A   0x2001             MOVS     R0,#+1
   7526              flag2 = 1;
   \   0000031C   0x2001             MOVS     R0,#+1
   7527              
   7528              //中心线的线尾取左线的线尾即可。
   7529              CenterHeadLine = BlackLeftHeadLine;     //线头取左线的线头，注意这不是实际的线头。
   \   0000031E   0x....             LDR.N    R0,??DataTable43_25
   \   00000320   0x7800             LDRB     R0,[R0, #+0]
   \   00000322   0x....             LDR.N    R1,??DataTable43_18
   \   00000324   0x7008             STRB     R0,[R1, #+0]
   7530              //CenterHeadLine = 0;   //线头因为要固定补到第0行，所以直接置0.
   7531              CenterEndLine = BlackLeftEndLine;
   \   00000326   0x....             LDR.N    R0,??DataTable43_3
   \   00000328   0x7800             LDRB     R0,[R0, #+0]
   \   0000032A   0x....             LDR.N    R1,??DataTable43_19
   \   0000032C   0x7008             STRB     R0,[R1, #+0]
   7532              
   7533              //首先看线头是否大于BlackControlLineLow行
   7534              if(BlackLeftHeadLine >= BlackControlLineLow)
   \   0000032E   0x....             LDR.N    R0,??DataTable43_25
   \   00000330   0x7800             LDRB     R0,[R0, #+0]
   \   00000332   0x281A             CMP      R0,#+26
   \   00000334   0xDB00             BLT.N    ??CenterLineGetSingleWrongAdd_26
   7535              {
   7536                flag1 = 0;
   \   00000336   0x2000             MOVS     R0,#+0
   7537              }
   7538              else
   7539              {
   7540              }
   7541              
   7542              //左线尾小于CameraHight - 1行。
   7543              if(BlackLeftEndLine < CameraHight - 1)
   \                     ??CenterLineGetSingleWrongAdd_26: (+1)
   \   00000338   0x....             LDR.N    R0,??DataTable43_3
   \   0000033A   0x7800             LDRB     R0,[R0, #+0]
   \   0000033C   0x283B             CMP      R0,#+59
   \   0000033E   0xDA06             BGE.N    ??CenterLineGetSingleWrongAdd_27
   7544              {
   7545                //只有左线成功，而且左线尾还那么远，真心没法继续。直接返回失败。
   7546                //if(BlackLeftEndLine < CameraHight - 1 - BlackLeftBackLineStart)
   7547                if(BlackLeftEndLine <= BlackControlLineLow)
   \   00000340   0x....             LDR.N    R0,??DataTable43_3
   \   00000342   0x7800             LDRB     R0,[R0, #+0]
   \   00000344   0x281B             CMP      R0,#+27
   \   00000346   0xDA02             BGE.N    ??CenterLineGetSingleWrongAdd_27
   7548                {
   7549                  flag2 = 0;
   \   00000348   0x2000             MOVS     R0,#+0
   7550                  return 0;       
   \   0000034A   0x2000             MOVS     R0,#+0
   \   0000034C   0xE11F             B.N      ??CenterLineGetSingleWrongAdd_5
   7551                }
   7552                //左线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackLeftEndLine。
   7553                else
   7554                {
   7555                }
   7556              }
   7557              //左线尾等于CameraHight - 1，直接取BlackLeftEndLine
   7558              else
   7559              {
   7560              }
   7561              
   7562              //丢失另一根线的时候，先根据斜率估算出半宽，若没有上一次双线图像时的赛道半宽大，则直接用上一次双线的赛道半宽。
   7563              //求5行的斜率。
   7564              if(BlackLeftEndLine - BlackLeftHeadLine > 5)
   \                     ??CenterLineGetSingleWrongAdd_27: (+1)
   \   0000034E   0x....             LDR.N    R0,??DataTable43_3
   \   00000350   0x7800             LDRB     R0,[R0, #+0]
   \   00000352   0x....             LDR.N    R1,??DataTable43_25
   \   00000354   0x7809             LDRB     R1,[R1, #+0]
   \   00000356   0x1A40             SUBS     R0,R0,R1
   \   00000358   0x2806             CMP      R0,#+6
   \   0000035A   0xDB2D             BLT.N    ??CenterLineGetSingleWrongAdd_28
   7565              {
   7566                slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
   7567                              (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
   \   0000035C   0x....             LDR.N    R0,??DataTable43_26
   \   0000035E   0x....             LDR.N    R1,??DataTable43_3
   \   00000360   0x7809             LDRB     R1,[R1, #+0]
   \   00000362   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000366   0x....             LDR.N    R1,??DataTable43_26
   \   00000368   0x....             LDR.N    R2,??DataTable43_3
   \   0000036A   0x7812             LDRB     R2,[R2, #+0]
   \   0000036C   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000370   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   00000374   0x1A40             SUBS     R0,R0,R1
   \   00000376   0x.... 0x....      BL       __aeabi_i2d
   \   0000037A   0x2200             MOVS     R2,#+0
   \   0000037C   0x....             LDR.N    R3,??DataTable43_21  ;; 0x3ff00000
   \   0000037E   0x.... 0x....      BL       __aeabi_dmul
   \   00000382   0x0004             MOVS     R4,R0
   \   00000384   0x000D             MOVS     R5,R1
   \   00000386   0x....             LDR.N    R0,??DataTable43_26
   \   00000388   0x....             LDR.N    R1,??DataTable43_3
   \   0000038A   0x7809             LDRB     R1,[R1, #+0]
   \   0000038C   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000390   0x6840             LDR      R0,[R0, #+4]
   \   00000392   0x....             LDR.N    R1,??DataTable43_26
   \   00000394   0x....             LDR.N    R2,??DataTable43_3
   \   00000396   0x7812             LDRB     R2,[R2, #+0]
   \   00000398   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   0000039C   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   000003A0   0x1A40             SUBS     R0,R0,R1
   \   000003A2   0x.... 0x....      BL       __aeabi_i2d
   \   000003A6   0x0002             MOVS     R2,R0
   \   000003A8   0x000B             MOVS     R3,R1
   \   000003AA   0x0020             MOVS     R0,R4
   \   000003AC   0x0029             MOVS     R1,R5
   \   000003AE   0x.... 0x....      BL       __aeabi_ddiv
   \   000003B2   0x.... 0x....      BL       __aeabi_d2f
   \   000003B6   0xE000             B.N      ??CenterLineGetSingleWrongAdd_29
   7568              }
   7569              else
   7570              {
   7571                slope = 0;
   \                     ??CenterLineGetSingleWrongAdd_28: (+1)
   \   000003B8   0x2000             MOVS     R0,#+0
   7572              }
   7573              //赛道半宽
   7574              temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
   \                     ??CenterLineGetSingleWrongAdd_29: (+1)
   \   000003BA   0x0001             MOVS     R1,R0
   \   000003BC   0x.... 0x....      BL       __aeabi_fmul
   \   000003C0   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   000003C4   0x.... 0x....      BL       __aeabi_fadd
   \   000003C8   0x.... 0x....      BL       __aeabi_f2d
   \   000003CC   0x.... 0x....      BL       sqrt
   \   000003D0   0x2200             MOVS     R2,#+0
   \   000003D2   0x....             LDR.N    R3,??DataTable43_21  ;; 0x3ff00000
   \   000003D4   0x.... 0x....      BL       __aeabi_dmul
   \   000003D8   0x2200             MOVS     R2,#+0
   \   000003DA   0x....             LDR.N    R3,??DataTable43_22  ;; 0x40690000
   \   000003DC   0x.... 0x....      BL       __aeabi_dmul
   \   000003E0   0x2200             MOVS     R2,#+0
   \   000003E2   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   000003E6   0x.... 0x....      BL       __aeabi_ddiv
   \   000003EA   0x.... 0x....      BL       __aeabi_d2iz
   7575              //取最大值
   7576              RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
   \   000003EE   0x....             LDR.N    R1,??DataTable43_23
   \   000003F0   0x7809             LDRB     R1,[R1, #+0]
   \   000003F2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003F4   0x.... 0x....      BL       MaxRe
   \   000003F8   0x....             LDR.N    R1,??DataTable43_23
   \   000003FA   0x7008             STRB     R0,[R1, #+0]
   7577              
   7578              //根据赛道宽度估计出中心线的线头。
   7579              CenterLineLoc[BlackLeftEndLine] = BlackUdisLeftLocation[BlackLeftEndLine].x + RoadHalfWidth;
   \   000003FC   0x....             LDR.N    R0,??DataTable43_26
   \   000003FE   0x....             LDR.N    R1,??DataTable43_3
   \   00000400   0x7809             LDRB     R1,[R1, #+0]
   \   00000402   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000406   0x....             LDR.N    R1,??DataTable43_23
   \   00000408   0x7809             LDRB     R1,[R1, #+0]
   \   0000040A   0x1840             ADDS     R0,R0,R1
   \   0000040C   0x....             LDR.N    R1,??DataTable43_16
   \   0000040E   0x....             LDR.N    R2,??DataTable43_3
   \   00000410   0x7812             LDRB     R2,[R2, #+0]
   \   00000412   0xF821 0x0012      STRH     R0,[R1, R2, LSL #+1]
   7580              
   7581              tempflag1 = 0;
   \   00000416   0x2400             MOVS     R4,#+0
   7582              tempway1 = 0;
   \   00000418   0x2500             MOVS     R5,#+0
   7583              //根据左线的走势估计出中心线。中心线是个int16型矩阵，有正负。
   7584              for(row = BlackLeftEndLine - 1; ;row--)
   \   0000041A   0x....             LDR.N    R0,??DataTable43_3
   \   0000041C   0x7800             LDRB     R0,[R0, #+0]
   \   0000041E   0xF1B0 0x0801      SUBS     R8,R0,#+1
   \   00000422   0xE001             B.N      ??CenterLineGetSingleWrongAdd_30
   \                     ??CenterLineGetSingleWrongAdd_31: (+1)
   \   00000424   0xF1B8 0x0801      SUBS     R8,R8,#+1
   7585              {
   7586                //左线有效时。根据左线的趋势补线。
   7587                if(BlackLeftLoc[row][0] != MaxValUint8)
   \                     ??CenterLineGetSingleWrongAdd_30: (+1)
   \   00000428   0x....             LDR.N    R0,??DataTable43_10
   \   0000042A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000042E   0x2103             MOVS     R1,#+3
   \   00000430   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00000434   0x7800             LDRB     R0,[R0, #+0]
   \   00000436   0x28FF             CMP      R0,#+255
   \   00000438   0xD019             BEQ.N    ??CenterLineGetSingleWrongAdd_32
   7588                {
   7589                  tempflag1 = 0;
   \   0000043A   0x2400             MOVS     R4,#+0
   7590                  CenterLineLoc[row] = CenterLineLoc[row+1] + BlackUdisLeftLocation[row].x - BlackUdisLeftLocation[row+1].x;
   \   0000043C   0x....             LDR.N    R0,??DataTable43_16
   \   0000043E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000442   0xEB10 0x0048      ADDS     R0,R0,R8, LSL #+1
   \   00000446   0x8840             LDRH     R0,[R0, #+2]
   \   00000448   0x....             LDR.N    R1,??DataTable43_26
   \   0000044A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000044E   0xF851 0x1038      LDR      R1,[R1, R8, LSL #+3]
   \   00000452   0x1808             ADDS     R0,R1,R0
   \   00000454   0x....             LDR.N    R1,??DataTable43_26
   \   00000456   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000045A   0xEB11 0x01C8      ADDS     R1,R1,R8, LSL #+3
   \   0000045E   0x6889             LDR      R1,[R1, #+8]
   \   00000460   0x1A40             SUBS     R0,R0,R1
   \   00000462   0x....             LDR.N    R1,??DataTable43_16
   \   00000464   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000468   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   0000046C   0xE072             B.N      ??CenterLineGetSingleWrongAdd_33
   7591                }
   7592                //左线无效时。根据最后两行的中心线趋势补线。
   7593                else
   7594                {
   7595                  //当左线无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
   7596                  if(tempflag1 == 0)
   \                     ??CenterLineGetSingleWrongAdd_32: (+1)
   \   0000046E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000470   0x2C00             CMP      R4,#+0
   \   00000472   0xD12D             BNE.N    ??CenterLineGetSingleWrongAdd_34
   7597                  {
   7598                    //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
   7599                    tempflag1 = 1;
   \   00000474   0x2401             MOVS     R4,#+1
   7600                    //最后几行行数够多，可以采用最小二乘法的方式。
   7601                    if(row + CenterForwardLineNum <= CameraHight - 1)
   \   00000476   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000047A   0xF118 0x0004      ADDS     R0,R8,#+4
   \   0000047E   0x283C             CMP      R0,#+60
   \   00000480   0xDA25             BGE.N    ??CenterLineGetSingleWrongAdd_35
   7602                    {
   7603                      tempway1 = 0;
   \   00000482   0x2500             MOVS     R5,#+0
   7604                      //进行最小二乘法系数的计算。
   7605                      for(i = 0; i < CenterForwardLineNum; i++)
   \   00000484   0x2000             MOVS     R0,#+0
   \   00000486   0xE011             B.N      ??CenterLineGetSingleWrongAdd_36
   7606                      {
   7607                        x[i] = row + i + 1;
   \                     ??CenterLineGetSingleWrongAdd_37: (+1)
   \   00000488   0xEB10 0x0108      ADDS     R1,R0,R8
   \   0000048C   0x1C49             ADDS     R1,R1,#+1
   \   0000048E   0xAA00             ADD      R2,SP,#+0
   \   00000490   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000492   0x5481             STRB     R1,[R0, R2]
   7608                        y[i] = CenterLineLoc[row + i + 1];
   \   00000494   0x....             LDR.N    R1,??DataTable43_16
   \   00000496   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000498   0xFA50 0xF288      UXTAB    R2,R0,R8
   \   0000049C   0xEB11 0x0142      ADDS     R1,R1,R2, LSL #+1
   \   000004A0   0x8849             LDRH     R1,[R1, #+2]
   \   000004A2   0xAA01             ADD      R2,SP,#+4
   \   000004A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004A6   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   7609                      }
   \   000004AA   0x1C40             ADDS     R0,R0,#+1
   \                     ??CenterLineGetSingleWrongAdd_36: (+1)
   \   000004AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004AE   0x2804             CMP      R0,#+4
   \   000004B0   0xDBEA             BLT.N    ??CenterLineGetSingleWrongAdd_37
   7610                      a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
   \   000004B2   0x2204             MOVS     R2,#+4
   \   000004B4   0xA901             ADD      R1,SP,#+4
   \   000004B6   0xA800             ADD      R0,SP,#+0
   \   000004B8   0x.... 0x....      BL       LeastSquareInt16a1
   \   000004BC   0x0006             MOVS     R6,R0
   7611                      a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
   \   000004BE   0x2304             MOVS     R3,#+4
   \   000004C0   0x0032             MOVS     R2,R6
   \   000004C2   0xA901             ADD      R1,SP,#+4
   \   000004C4   0xA800             ADD      R0,SP,#+0
   \   000004C6   0x.... 0x....      BL       LeastSquareInt16a0
   \   000004CA   0x0007             MOVS     R7,R0
   \   000004CC   0xE000             B.N      ??CenterLineGetSingleWrongAdd_34
   7612                    }
   7613                    //最后几行的行数不够多，采用最后两行趋势补线的方式。
   7614                    else
   7615                    {
   7616                      tempway1 = 1;
   \                     ??CenterLineGetSingleWrongAdd_35: (+1)
   \   000004CE   0x2501             MOVS     R5,#+1
   7617                    }
   7618                  }
   7619                  else
   7620                  {
   7621                  }
   7622                  
   7623                  //确认补线方式后，开始补线。
   7624                  if(tempway1 == 0)
   \                     ??CenterLineGetSingleWrongAdd_34: (+1)
   \   000004D0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004D2   0x2D00             CMP      R5,#+0
   \   000004D4   0xD10D             BNE.N    ??CenterLineGetSingleWrongAdd_38
   7625                  {
   7626                    //最小二乘法的方式。
   7627                    CenterLineLoc[row] = (a0 + a1 * row) / LeastSquareMulti;
   \   000004D6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000004DA   0xFB08 0x7006      MLA      R0,R8,R6,R7
   \   000004DE   0xF44F 0x717A      MOV      R1,#+1000
   \   000004E2   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000004E6   0x....             LDR.N    R1,??DataTable43_16
   \   000004E8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000004EC   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   000004F0   0xE030             B.N      ??CenterLineGetSingleWrongAdd_33
   7628                  }
   7629                  else
   7630                  {
   7631                    //如果是最近2行。
   7632                    if(row == CameraHight -1  || row == CameraHight - 2)
   \                     ??CenterLineGetSingleWrongAdd_38: (+1)
   \   000004F2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000004F6   0xF1B8 0x0F3B      CMP      R8,#+59
   \   000004FA   0xD004             BEQ.N    ??CenterLineGetSingleWrongAdd_39
   \   000004FC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000500   0xF1B8 0x0F3A      CMP      R8,#+58
   \   00000504   0xD10D             BNE.N    ??CenterLineGetSingleWrongAdd_40
   7633                    {
   7634                      CenterLineLoc[row] = BlackUdisLeftLocation[row].x + RoadHalfWidth;
   \                     ??CenterLineGetSingleWrongAdd_39: (+1)
   \   00000506   0x....             LDR.N    R0,??DataTable43_26
   \   00000508   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000050C   0xF850 0x0038      LDR      R0,[R0, R8, LSL #+3]
   \   00000510   0x....             LDR.N    R1,??DataTable43_23
   \   00000512   0x7809             LDRB     R1,[R1, #+0]
   \   00000514   0x1840             ADDS     R0,R0,R1
   \   00000516   0x....             LDR.N    R1,??DataTable43_16
   \   00000518   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000051C   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   00000520   0xE018             B.N      ??CenterLineGetSingleWrongAdd_33
   7635                    }
   7636                    //不是最近2行。
   7637                    else
   7638                    {
   7639                      //最后两行的方式。
   7640                      CenterLineLoc[row] = CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2];            
   \                     ??CenterLineGetSingleWrongAdd_40: (+1)
   \   00000522   0x....             LDR.N    R0,??DataTable43_16
   \   00000524   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000528   0xEB10 0x0048      ADDS     R0,R0,R8, LSL #+1
   \   0000052C   0x8840             LDRH     R0,[R0, #+2]
   \   0000052E   0x....             LDR.N    R1,??DataTable43_16
   \   00000530   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000534   0xEB11 0x0148      ADDS     R1,R1,R8, LSL #+1
   \   00000538   0x8849             LDRH     R1,[R1, #+2]
   \   0000053A   0x1808             ADDS     R0,R1,R0
   \   0000053C   0x....             LDR.N    R1,??DataTable43_16
   \   0000053E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000542   0xEB11 0x0148      ADDS     R1,R1,R8, LSL #+1
   \   00000546   0x8889             LDRH     R1,[R1, #+4]
   \   00000548   0x1A40             SUBS     R0,R0,R1
   \   0000054A   0x....             LDR.N    R1,??DataTable43_16
   \   0000054C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000550   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   7641                    }
   7642                  }
   7643                }
   7644                
   7645                //一直补到最高行。
   7646                if(row == 0) break;
   \                     ??CenterLineGetSingleWrongAdd_33: (+1)
   \   00000554   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000558   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000055C   0xF47F 0xAF62      BNE.W    ??CenterLineGetSingleWrongAdd_31
   7647              }
   7648              
   7649              //对未处理的行的中心线置无效值。
   7650              //底部置无效值。顶部不用处理。
   7651              if(CenterEndLine != CameraHight - 1)
   \   00000560   0x....             LDR.N    R0,??DataTable43_19
   \   00000562   0x7800             LDRB     R0,[R0, #+0]
   \   00000564   0x283B             CMP      R0,#+59
   \   00000566   0xD011             BEQ.N    ??CenterLineGetSingleWrongAdd_21
   7652              {
   7653                for(row = CameraHight - 1; ; row--)
   \   00000568   0xF05F 0x083B      MOVS     R8,#+59
   \   0000056C   0xE008             B.N      ??CenterLineGetSingleWrongAdd_41
   7654                {
   7655                  if(row == CenterEndLine) break;       
   7656                  CenterLineLoc[row] = MaxValInt16;
   \                     ??CenterLineGetSingleWrongAdd_42: (+1)
   \   0000056E   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000572   0x....             LDR.N    R1,??DataTable43_16
   \   00000574   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000578   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   0000057C   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \                     ??CenterLineGetSingleWrongAdd_41: (+1)
   \   00000580   0x....             LDR.N    R0,??DataTable43_19
   \   00000582   0x7800             LDRB     R0,[R0, #+0]
   \   00000584   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000588   0x4580             CMP      R8,R0
   \   0000058A   0xD1F0             BNE.N    ??CenterLineGetSingleWrongAdd_42
   7657                }
   7658              }
   7659              else
   7660              {
   7661              }
   7662            }
   7663            
   7664            return 1;
   \                     ??CenterLineGetSingleWrongAdd_21: (+1)
   \   0000058C   0x2001             MOVS     R0,#+1
   \                     ??CenterLineGetSingleWrongAdd_5: (+1)
   \   0000058E   0xB004             ADD      SP,SP,#+16
   \   00000590   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   7665          }
   7666          
   7667          
   7668          
   7669          //非特殊赛道的中心线提取程序
   7670          //中心线提取，进来前左右黑线均连续。
   7671          //采用原始的左右黑线，不使用矫正后的左右黑线。

   \                                 In section .text, align 4, keep-with-next
   7672          uint8 CenterLineGetNormal(void)
   7673          {
   \                     CenterLineGetNormal: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   7674              int black_row, i, j;
   7675                      uint8 temp;
   7676                      uint8 flag1, //左线头标志（远处）
   7677                          flag2, //左线尾标志（近处）
   7678                          flag3, //右线头标志
   7679                          flag4;  //右线尾标志
   7680                      uint8 tempflag1=1;
   \   00000006   0xF05F 0x0801      MOVS     R8,#+1
   7681                      uint8 tempway1=1;
   \   0000000A   0xF05F 0x0901      MOVS     R9,#+1
   7682                      uint8 x[CenterForwardLineNum];   //中心线向前补线计算斜率时，x坐标，表示第几行。。
   7683                      int16 y[CenterForwardLineNum];   //中心线向前补线计算斜率时，y坐标，表示中心线位置。
   7684                      int32 a1 = 0, a0 = 0;    //中心线向前补线时，最小二乘法的斜率和纵截距。
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0x2500             MOVS     R5,#+0
   7685                      uint8 index;
   7686                      uint8 a[BlackBackLineNum];   //取多少个点在一开始有定义。
   7687                      uint8 b[BlackBackLineNum];
   7688          
   7689          
   7690                      float slope;
   7691          
   7692          
   7693                      //左线提取成功，右线提取失败。
   7694                      if (BlackLeftDone == 1 && BlackRightDone == 0)
   \   00000012   0xF8DF 0x0DD4      LDR.W    R0,??CenterLineGetNormal_0
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xF040 0x8150      BNE.W    ??CenterLineGetNormal_1
   \   0000001E   0xF8DF 0x0DCC      LDR.W    R0,??CenterLineGetNormal_0+0x4
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xF040 0x814A      BNE.W    ??CenterLineGetNormal_1
   7695                      {
   7696                          //若右线的线头线尾无效，则直接返回失败。
   7697                          if (BlackLeftHeadLine == MaxValUint8 || BlackLeftEndLine == MaxValUint8)
   \   0000002A   0xF8DF 0x0DC4      LDR.W    R0,??CenterLineGetNormal_0+0x8
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x28FF             CMP      R0,#+255
   \   00000032   0xD004             BEQ.N    ??CenterLineGetNormal_2
   \   00000034   0xF8DF 0x0DBC      LDR.W    R0,??CenterLineGetNormal_0+0xC
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x28FF             CMP      R0,#+255
   \   0000003C   0xD101             BNE.N    ??CenterLineGetNormal_3
   7698                          {
   7699                              return 0;
   \                     ??CenterLineGetNormal_2: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE13A             B.N      ??CenterLineGetNormal_4
   7700                          }
   7701                          else
   7702                          {
   7703                          }
   7704          
   7705                          flag1 = 1;
   \                     ??CenterLineGetNormal_3: (+1)
   \   00000042   0x2001             MOVS     R0,#+1
   7706                          flag2 = 1;
   \   00000044   0x2101             MOVS     R1,#+1
   7707          
   7708                          //中心线的线尾取左线的线尾即可。
   7709                          CenterHeadLine = BlackLeftHeadLine;   //线头取左线的线头，注意这不是实际的线头。
   \   00000046   0xF8DF 0x0DA8      LDR.W    R0,??CenterLineGetNormal_0+0x8
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0xF8DF 0x1DA8      LDR.W    R1,??CenterLineGetNormal_0+0x10
   \   00000050   0x7008             STRB     R0,[R1, #+0]
   7710                                                                 //CenterHeadLine = 0;                    //线头因为要固定补到第0行，所以直接置0.
   7711                          CenterEndLine = BlackLeftEndLine;
   \   00000052   0xF8DF 0x0DA0      LDR.W    R0,??CenterLineGetNormal_0+0xC
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0xF8DF 0x1DA0      LDR.W    R1,??CenterLineGetNormal_0+0x14
   \   0000005C   0x7008             STRB     R0,[R1, #+0]
   7712          
   7713                          //首先看线头是否大于BlackControlLineLow行
   7714                          if (BlackLeftHeadLine >= 55)
   \   0000005E   0xF8DF 0x0D90      LDR.W    R0,??CenterLineGetNormal_0+0x8
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0x2837             CMP      R0,#+55
   \   00000066   0xDB00             BLT.N    ??CenterLineGetNormal_5
   7715                          {
   7716                              flag1 = 0;
   \   00000068   0x2000             MOVS     R0,#+0
   7717                          }
   7718                          else
   7719                          {
   7720                          }
   7721          
   7722                          //右线尾小于CameraHight - 1行。
   7723                          if (BlackLeftEndLine < CameraHight - 1)
   \                     ??CenterLineGetNormal_5: (+1)
   \   0000006A   0xF8DF 0x0D88      LDR.W    R0,??CenterLineGetNormal_0+0xC
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0x283B             CMP      R0,#+59
   \   00000072   0xDA07             BGE.N    ??CenterLineGetNormal_6
   7724                          {
   7725                              //只有右线成功，而且右线尾还那么远，真心没法继续。直接返回失败。
   7726                              //if(BlackRightEndLine < CameraHight - 1 - BlackRightBackLineStart)
   7727                              if (BlackLeftEndLine <= 5)
   \   00000074   0xF8DF 0x0D7C      LDR.W    R0,??CenterLineGetNormal_0+0xC
   \   00000078   0x7800             LDRB     R0,[R0, #+0]
   \   0000007A   0x2806             CMP      R0,#+6
   \   0000007C   0xDA02             BGE.N    ??CenterLineGetNormal_6
   7728                              {
   7729                                  flag2 = 0;
   \   0000007E   0x2100             MOVS     R1,#+0
   7730                                  return 0;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xE119             B.N      ??CenterLineGetNormal_4
   7731                              }
   7732                              //右线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackRightEndLine。
   7733                              else
   7734                              {
   7735                              }
   7736                          }
   7737                          //右线尾等于CameraHight - 1，直接取BlackRightEndLine
   7738                          else
   7739                          {
   7740                          }
   7741          
   7742                          //丢失另一根线的时候，先根据斜率估算出半宽，若没有上一次双线图像时的赛道半宽大，则直接用上一次双线的赛道半宽。
   7743                          //求5行的斜率。
   7744                          for (black_row = BlackLeftHeadLine; ; black_row++)
   \                     ??CenterLineGetNormal_6: (+1)
   \   00000084   0xF8DF 0x0D68      LDR.W    R0,??CenterLineGetNormal_0+0x8
   \   00000088   0x7806             LDRB     R6,[R0, #+0]
   \   0000008A   0xE000             B.N      ??CenterLineGetNormal_7
   \                     ??CenterLineGetNormal_8: (+1)
   \   0000008C   0x1C76             ADDS     R6,R6,#+1
   7745                          {
   7746                              if (BlackLeftEndLine - BlackLeftHeadLine > 5)
   \                     ??CenterLineGetNormal_7: (+1)
   \   0000008E   0xF8DF 0x0D64      LDR.W    R0,??CenterLineGetNormal_0+0xC
   \   00000092   0x7800             LDRB     R0,[R0, #+0]
   \   00000094   0xF8DF 0x1D58      LDR.W    R1,??CenterLineGetNormal_0+0x8
   \   00000098   0x7809             LDRB     R1,[R1, #+0]
   \   0000009A   0x1A40             SUBS     R0,R0,R1
   \   0000009C   0x2806             CMP      R0,#+6
   \   0000009E   0xF2C0 0x80D8      BLT.W    ??CenterLineGetNormal_9
   7747                              {
   7748                                  if (BlackLeftLoc[black_row][ 0] != MaxValUint8)
   \   000000A2   0xF8DF 0x0D5C      LDR.W    R0,??CenterLineGetNormal_0+0x18
   \   000000A6   0x2103             MOVS     R1,#+3
   \   000000A8   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   000000AC   0x7800             LDRB     R0,[R0, #+0]
   \   000000AE   0x28FF             CMP      R0,#+255
   \   000000B0   0xD044             BEQ.N    ??CenterLineGetNormal_10
   7749                                  {
   7750                                      slope = 1.0 * (BlackUdisLeftLocation[black_row + 4].x - BlackUdisLeftLocation[black_row].x) /
   7751                                            (BlackUdisLeftLocation[black_row + 4].y - BlackUdisLeftLocation[black_row].y);
   \   000000B2   0xF8DF 0x0D50      LDR.W    R0,??CenterLineGetNormal_0+0x1C
   \   000000B6   0xEB10 0x00C6      ADDS     R0,R0,R6, LSL #+3
   \   000000BA   0x6A00             LDR      R0,[R0, #+32]
   \   000000BC   0xF8DF 0x1D44      LDR.W    R1,??CenterLineGetNormal_0+0x1C
   \   000000C0   0xF851 0x1036      LDR      R1,[R1, R6, LSL #+3]
   \   000000C4   0x1A40             SUBS     R0,R0,R1
   \   000000C6   0x.... 0x....      BL       __aeabi_i2d
   \   000000CA   0x2200             MOVS     R2,#+0
   \   000000CC   0xF8DF 0x3D38      LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   000000D0   0x.... 0x....      BL       __aeabi_dmul
   \   000000D4   0x4680             MOV      R8,R0
   \   000000D6   0x4689             MOV      R9,R1
   \   000000D8   0xF8DF 0x0D28      LDR.W    R0,??CenterLineGetNormal_0+0x1C
   \   000000DC   0xEB10 0x00C6      ADDS     R0,R0,R6, LSL #+3
   \   000000E0   0x6A40             LDR      R0,[R0, #+36]
   \   000000E2   0xF8DF 0x1D20      LDR.W    R1,??CenterLineGetNormal_0+0x1C
   \   000000E6   0xEB11 0x01C6      ADDS     R1,R1,R6, LSL #+3
   \   000000EA   0x6849             LDR      R1,[R1, #+4]
   \   000000EC   0x1A40             SUBS     R0,R0,R1
   \   000000EE   0x.... 0x....      BL       __aeabi_i2d
   \   000000F2   0x0002             MOVS     R2,R0
   \   000000F4   0x000B             MOVS     R3,R1
   \   000000F6   0x4640             MOV      R0,R8
   \   000000F8   0x4649             MOV      R1,R9
   \   000000FA   0x.... 0x....      BL       __aeabi_ddiv
   \   000000FE   0x.... 0x....      BL       __aeabi_d2f
   7752                                      /* else
   7753                                       {
   7754                                         slope = 0;
   7755                                       }*/
   7756                                      //赛道半宽
   7757                                      temp = CenterLineHalfWidth[black_row];// (int)(1.0 * Math.Sqrt(slope * slope + 1) * CenterLineHalfWidth[black_row] / 2);
   \   00000102   0xF8DF 0x0D08      LDR.W    R0,??CenterLineGetNormal_0+0x24
   \   00000106   0x5C37             LDRB     R7,[R6, R0]
   7758                                      //取最大值
   7759          
   7760                                      RoadHalfWidth = temp;// MaxRe(temp, RoadHalfWidth);
   \   00000108   0xF8DF 0x0D04      LDR.W    R0,??CenterLineGetNormal_0+0x28
   \   0000010C   0x7007             STRB     R7,[R0, #+0]
   7761          
   7762                                      tempflag1 = 0;
   \   0000010E   0xF05F 0x0800      MOVS     R8,#+0
   7763                                      tempway1 = 0;
   \   00000112   0xF05F 0x0900      MOVS     R9,#+0
   7764                                      buXianCount = 0;
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xF8DF 0x1CF8      LDR.W    R1,??CenterLineGetNormal_0+0x2C
   \   0000011C   0x8008             STRH     R0,[R1, #+0]
   7765                                      //根据赛道宽度估计出中心线的线头。
   7766                                      CenterLineLoc[black_row] = BlackLeftLoc[black_row][ 0] + RoadHalfWidth;
   \   0000011E   0xF8DF 0x0CE0      LDR.W    R0,??CenterLineGetNormal_0+0x18
   \   00000122   0x2103             MOVS     R1,#+3
   \   00000124   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000128   0x7800             LDRB     R0,[R0, #+0]
   \   0000012A   0xF8DF 0x1CE4      LDR.W    R1,??CenterLineGetNormal_0+0x28
   \   0000012E   0x7809             LDRB     R1,[R1, #+0]
   \   00000130   0x1808             ADDS     R0,R1,R0
   \   00000132   0xF8DF 0x1CE4      LDR.W    R1,??CenterLineGetNormal_0+0x30
   \   00000136   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
   \   0000013A   0xE0A2             B.N      ??CenterLineGetNormal_11
   7767                                  }
   7768                                  //根据右线的走势估计出中心线。中心线是个int16型矩阵，有正负。
   7769          
   7770                                  // CenterLineLoc[black_row] = CenterLineLoc[black_row + 1] + BlackRightLoc[black_row, 0] - BlackRightLoc[black_row + 1, 0];
   7771                                  //右线无效时。根据最后两行的中心线趋势补线。
   7772                                  else
   7773                                  {
   7774                                      //当右线无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
   7775                                      if (tempflag1 == 0)
   \                     ??CenterLineGetNormal_10: (+1)
   \   0000013C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000140   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000144   0xD175             BNE.N    ??CenterLineGetNormal_12
   7776                                      {
   7777                                          //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
   7778                                          tempflag1 = 1;
   \   00000146   0xF05F 0x0801      MOVS     R8,#+1
   7779                                          //最后几行行数够多，可以采用最小二乘法的方式。
   7780                                          //最后一行或两行尽量不用，因为有可能是拐点。但也不能太往后取，斜率就不对了。
   7781                                          if (black_row + CenterForwardLineNum + 2 <= CameraHight - 1)
   \   0000014A   0x1DB0             ADDS     R0,R6,#+6
   \   0000014C   0x283C             CMP      R0,#+60
   \   0000014E   0xDA22             BGE.N    ??CenterLineGetNormal_13
   7782                                          {
   7783                                              tempway1 = 0;
   \   00000150   0xF05F 0x0900      MOVS     R9,#+0
   7784                                              //进行最小二乘法系数的计算。
   7785                                              for (i = 0; i < CenterForwardLineNum; i++)
   \   00000154   0x2000             MOVS     R0,#+0
   \   00000156   0xE00E             B.N      ??CenterLineGetNormal_14
   7786                                              {
   7787                                                  x[i] = black_row - i - 3;
   \                     ??CenterLineGetNormal_15: (+1)
   \   00000158   0x1A31             SUBS     R1,R6,R0
   \   0000015A   0x1EC9             SUBS     R1,R1,#+3
   \   0000015C   0xAA00             ADD      R2,SP,#+0
   \   0000015E   0x5481             STRB     R1,[R0, R2]
   7788                                                  y[i] = CenterLineLoc[black_row - i - 3];
   \   00000160   0xF8DF 0x1CB4      LDR.W    R1,??CenterLineGetNormal_0+0x30
   \   00000164   0x1A32             SUBS     R2,R6,R0
   \   00000166   0xEB11 0x0142      ADDS     R1,R1,R2, LSL #+1
   \   0000016A   0xF831 0x1C06      LDRH     R1,[R1, #-6]
   \   0000016E   0xAA01             ADD      R2,SP,#+4
   \   00000170   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   7789                                              }
   \   00000174   0x1C40             ADDS     R0,R0,#+1
   \                     ??CenterLineGetNormal_14: (+1)
   \   00000176   0x2804             CMP      R0,#+4
   \   00000178   0xDBEE             BLT.N    ??CenterLineGetNormal_15
   7790                                              a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
   \   0000017A   0x2204             MOVS     R2,#+4
   \   0000017C   0xA901             ADD      R1,SP,#+4
   \   0000017E   0xA800             ADD      R0,SP,#+0
   \   00000180   0x.... 0x....      BL       LeastSquareInt16a1
   \   00000184   0x0004             MOVS     R4,R0
   7791                                              a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。            
   \   00000186   0x2304             MOVS     R3,#+4
   \   00000188   0x0022             MOVS     R2,R4
   \   0000018A   0xA901             ADD      R1,SP,#+4
   \   0000018C   0xA800             ADD      R0,SP,#+0
   \   0000018E   0x.... 0x....      BL       LeastSquareInt16a0
   \   00000192   0x0005             MOVS     R5,R0
   \   00000194   0xE04D             B.N      ??CenterLineGetNormal_12
   7792                                          }
   7793                                          else if (black_row + CenterForwardLineNum + 1 <= CameraHight - 1)
   \                     ??CenterLineGetNormal_13: (+1)
   \   00000196   0x1D70             ADDS     R0,R6,#+5
   \   00000198   0x283C             CMP      R0,#+60
   \   0000019A   0xDA22             BGE.N    ??CenterLineGetNormal_16
   7794                                          {
   7795                                              tempway1 = 0;
   \   0000019C   0xF05F 0x0900      MOVS     R9,#+0
   7796                                              //进行最小二乘法系数的计算。
   7797                                              for (i = 0; i < CenterForwardLineNum; i++)
   \   000001A0   0x2000             MOVS     R0,#+0
   \   000001A2   0xE00E             B.N      ??CenterLineGetNormal_17
   7798                                              {
   7799                                                  x[i] = black_row - i - 2;
   \                     ??CenterLineGetNormal_18: (+1)
   \   000001A4   0x1A31             SUBS     R1,R6,R0
   \   000001A6   0x1E89             SUBS     R1,R1,#+2
   \   000001A8   0xAA00             ADD      R2,SP,#+0
   \   000001AA   0x5481             STRB     R1,[R0, R2]
   7800                                                  y[i] = CenterLineLoc[black_row - i - 2];
   \   000001AC   0xF8DF 0x1C68      LDR.W    R1,??CenterLineGetNormal_0+0x30
   \   000001B0   0x1A32             SUBS     R2,R6,R0
   \   000001B2   0xEB11 0x0142      ADDS     R1,R1,R2, LSL #+1
   \   000001B6   0xF831 0x1C04      LDRH     R1,[R1, #-4]
   \   000001BA   0xAA01             ADD      R2,SP,#+4
   \   000001BC   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   7801                                              }
   \   000001C0   0x1C40             ADDS     R0,R0,#+1
   \                     ??CenterLineGetNormal_17: (+1)
   \   000001C2   0x2804             CMP      R0,#+4
   \   000001C4   0xDBEE             BLT.N    ??CenterLineGetNormal_18
   7802                                              a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
   \   000001C6   0x2204             MOVS     R2,#+4
   \   000001C8   0xA901             ADD      R1,SP,#+4
   \   000001CA   0xA800             ADD      R0,SP,#+0
   \   000001CC   0x.... 0x....      BL       LeastSquareInt16a1
   \   000001D0   0x0004             MOVS     R4,R0
   7803                                              a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。                        
   \   000001D2   0x2304             MOVS     R3,#+4
   \   000001D4   0x0022             MOVS     R2,R4
   \   000001D6   0xA901             ADD      R1,SP,#+4
   \   000001D8   0xA800             ADD      R0,SP,#+0
   \   000001DA   0x.... 0x....      BL       LeastSquareInt16a0
   \   000001DE   0x0005             MOVS     R5,R0
   \   000001E0   0xE027             B.N      ??CenterLineGetNormal_12
   7804                                          }
   7805                                          else if (black_row + CenterForwardLineNum <= CameraHight - 1)
   \                     ??CenterLineGetNormal_16: (+1)
   \   000001E2   0x1D30             ADDS     R0,R6,#+4
   \   000001E4   0x283C             CMP      R0,#+60
   \   000001E6   0xDA22             BGE.N    ??CenterLineGetNormal_19
   7806                                          {
   7807                                              tempway1 = 0;
   \   000001E8   0xF05F 0x0900      MOVS     R9,#+0
   7808                                              //进行最小二乘法系数的计算。
   7809                                              for (i = 0; i < CenterForwardLineNum; i++)
   \   000001EC   0x2000             MOVS     R0,#+0
   \   000001EE   0xE00E             B.N      ??CenterLineGetNormal_20
   7810                                              {
   7811                                                  x[i] = black_row - i - 1;
   \                     ??CenterLineGetNormal_21: (+1)
   \   000001F0   0x1A31             SUBS     R1,R6,R0
   \   000001F2   0x1E49             SUBS     R1,R1,#+1
   \   000001F4   0xAA00             ADD      R2,SP,#+0
   \   000001F6   0x5481             STRB     R1,[R0, R2]
   7812                                                  y[i] = CenterLineLoc[black_row - i - 1];
   \   000001F8   0xF8DF 0x1C1C      LDR.W    R1,??CenterLineGetNormal_0+0x30
   \   000001FC   0x1A32             SUBS     R2,R6,R0
   \   000001FE   0xEB11 0x0142      ADDS     R1,R1,R2, LSL #+1
   \   00000202   0xF831 0x1C02      LDRH     R1,[R1, #-2]
   \   00000206   0xAA01             ADD      R2,SP,#+4
   \   00000208   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   7813                                              }
   \   0000020C   0x1C40             ADDS     R0,R0,#+1
   \                     ??CenterLineGetNormal_20: (+1)
   \   0000020E   0x2804             CMP      R0,#+4
   \   00000210   0xDBEE             BLT.N    ??CenterLineGetNormal_21
   7814                                              a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
   \   00000212   0x2204             MOVS     R2,#+4
   \   00000214   0xA901             ADD      R1,SP,#+4
   \   00000216   0xA800             ADD      R0,SP,#+0
   \   00000218   0x.... 0x....      BL       LeastSquareInt16a1
   \   0000021C   0x0004             MOVS     R4,R0
   7815                                              a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
   \   0000021E   0x2304             MOVS     R3,#+4
   \   00000220   0x0022             MOVS     R2,R4
   \   00000222   0xA901             ADD      R1,SP,#+4
   \   00000224   0xA800             ADD      R0,SP,#+0
   \   00000226   0x.... 0x....      BL       LeastSquareInt16a0
   \   0000022A   0x0005             MOVS     R5,R0
   \   0000022C   0xE001             B.N      ??CenterLineGetNormal_12
   7816                                          }
   7817                                          //最后几行的行数不够多，采用最后两行趋势补线的方式。
   7818                                          else
   7819                                          {
   7820                                              tempway1 = 1;
   \                     ??CenterLineGetNormal_19: (+1)
   \   0000022E   0xF05F 0x0901      MOVS     R9,#+1
   7821                                          }
   7822                                      }
   7823                                      else
   7824                                      {
   7825                                      }
   7826          
   7827                                      //确认补线方式后，开始补线。
   7828                                      if (tempway1 == 0)
   \                     ??CenterLineGetNormal_12: (+1)
   \   00000232   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000236   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000023A   0xD122             BNE.N    ??CenterLineGetNormal_11
   7829                                      {
   7830                                          //最小二乘法的方式。
   7831                                          CenterLineLoc[black_row] = (a0 + a1 * black_row) / LeastSquareMulti;
   \   0000023C   0xFB06 0x5004      MLA      R0,R6,R4,R5
   \   00000240   0xF44F 0x717A      MOV      R1,#+1000
   \   00000244   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000248   0xF8DF 0x1BCC      LDR.W    R1,??CenterLineGetNormal_0+0x30
   \   0000024C   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
   \   00000250   0xE017             B.N      ??CenterLineGetNormal_11
   7832                                      }
   7833                                      else
   7834                                      {
   7835                                          /*//最近2行。
   7836                                          if(black_row == CameraHight - 1 || black_row == CameraHight - 2)
   7837                                          {
   7838                                            CenterLineLoc[black_row] = BlackRightLoc[black_row,0] - RoadHalfWidth;
   7839                                          }
   7840                                          //不是最近2行。
   7841                                          else
   7842                                          {
   7843                                            //最后两行的方式。
   7844                                            CenterLineLoc[black_row] = CenterLineLoc[black_row+1] + CenterLineLoc[black_row+1] - CenterLineLoc[black_row+2];
   7845                                          }
   7846                                          */
   7847                                      }
   7848                                  }
   7849                              }
   7850                              else
   7851                              {
   7852                                  tempflag1 = 1;
   \                     ??CenterLineGetNormal_9: (+1)
   \   00000252   0xF05F 0x0801      MOVS     R8,#+1
   7853                                  tempway1 = 1;
   \   00000256   0xF05F 0x0901      MOVS     R9,#+1
   7854                                  temp = CenterLineHalfWidth[black_row];// (int)(1.0 * CenterLineHalfWidth[black_row] / 2);
   \   0000025A   0xF8DF 0x0BB0      LDR.W    R0,??CenterLineGetNormal_0+0x24
   \   0000025E   0x5C37             LDRB     R7,[R6, R0]
   7855                                  RoadHalfWidth = temp;// MaxRe(temp, RoadHalfWidth);
   \   00000260   0xF8DF 0x0BAC      LDR.W    R0,??CenterLineGetNormal_0+0x28
   \   00000264   0x7007             STRB     R7,[R0, #+0]
   7856                                  CenterLineLoc[black_row] = BlackLeftLoc[black_row][ 0] + RoadHalfWidth;
   \   00000266   0xF8DF 0x0B98      LDR.W    R0,??CenterLineGetNormal_0+0x18
   \   0000026A   0x2103             MOVS     R1,#+3
   \   0000026C   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000270   0x7800             LDRB     R0,[R0, #+0]
   \   00000272   0xF8DF 0x1B9C      LDR.W    R1,??CenterLineGetNormal_0+0x28
   \   00000276   0x7809             LDRB     R1,[R1, #+0]
   \   00000278   0x1808             ADDS     R0,R1,R0
   \   0000027A   0xF8DF 0x1B9C      LDR.W    R1,??CenterLineGetNormal_0+0x30
   \   0000027E   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
   7857          
   7858                              }
   7859                              if (CenterLineLoc[black_row] >= MaxValUint8)
   \                     ??CenterLineGetNormal_11: (+1)
   \   00000282   0xF8DF 0x0B94      LDR.W    R0,??CenterLineGetNormal_0+0x30
   \   00000286   0xF930 0x0016      LDRSH    R0,[R0, R6, LSL #+1]
   \   0000028A   0x28FF             CMP      R0,#+255
   \   0000028C   0xDB05             BLT.N    ??CenterLineGetNormal_22
   7860                                  CenterLineLoc[black_row] = MaxValUint8;
   \   0000028E   0x20FF             MOVS     R0,#+255
   \   00000290   0xF8DF 0x1B84      LDR.W    R1,??CenterLineGetNormal_0+0x30
   \   00000294   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
   \   00000298   0xE00A             B.N      ??CenterLineGetNormal_23
   7861                              else if (CenterLineLoc[black_row] <= 0)
   \                     ??CenterLineGetNormal_22: (+1)
   \   0000029A   0xF8DF 0x0B7C      LDR.W    R0,??CenterLineGetNormal_0+0x30
   \   0000029E   0xF930 0x0016      LDRSH    R0,[R0, R6, LSL #+1]
   \   000002A2   0x2801             CMP      R0,#+1
   \   000002A4   0xDA04             BGE.N    ??CenterLineGetNormal_23
   7862                                  CenterLineLoc[black_row] = 0;
   \   000002A6   0x2000             MOVS     R0,#+0
   \   000002A8   0xF8DF 0x1B6C      LDR.W    R1,??CenterLineGetNormal_0+0x30
   \   000002AC   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
   7863                              else
   7864                              {
   7865                              }
   7866                              if (black_row >= 59) break;
   \                     ??CenterLineGetNormal_23: (+1)
   \   000002B0   0x2E3B             CMP      R6,#+59
   \   000002B2   0xF6FF 0xAEEB      BLT.W    ??CenterLineGetNormal_8
   7867                          }
   7868          
   7869          
   7870          
   7871                      }
   7872                      //右线提取成功，左线提取失败。
   7873                      else if (BlackLeftDone == 0 && BlackRightDone == 1)
   7874                      {
   7875                          //若右线的线头线尾无效，则直接返回失败。
   7876                          if (BlackRightHeadLine == MaxValUint8 || BlackRightEndLine == MaxValUint8)
   7877                          {
   7878                              return 0;
   7879                          }
   7880                          else
   7881                          {
   7882                          }
   7883          
   7884                          flag1 = 1;
   7885                          flag2 = 1;
   7886          
   7887                          //中心线的线尾取左线的线尾即可。
   7888                          CenterHeadLine = BlackRightHeadLine;   //线头取左线的线头，注意这不是实际的线头。
   7889                                                                 //CenterHeadLine = 0;                    //线头因为要固定补到第0行，所以直接置0.
   7890                          CenterEndLine = BlackRightEndLine;
   7891          
   7892                          //首先看线头是否大于BlackControlLineLow行
   7893                          if (BlackRightHeadLine >= 55)
   7894                          {
   7895                              flag1 = 0;
   7896                          }
   7897                          else
   7898                          {
   7899                          }
   7900          
   7901                          //右线尾小于CameraHight - 1行。
   7902                          if (BlackRightEndLine < CameraHight - 1)
   7903                          {
   7904                              //只有右线成功，而且右线尾还那么远，真心没法继续。直接返回失败。
   7905                              //if(BlackRightEndLine < CameraHight - 1 - BlackRightBackLineStart)
   7906                              if (BlackRightEndLine <= 5)
   7907                              {
   7908                                  flag2 = 0;
   7909                                  return 0;
   7910                              }
   7911                              //右线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackRightEndLine。
   7912                              else
   7913                              {
   7914                              }
   7915                          }
   7916                          //右线尾等于CameraHight - 1，直接取BlackRightEndLine
   7917                          else
   7918                          {
   7919                          }
   7920          
   7921                          //丢失另一根线的时候，先根据斜率估算出半宽，若没有上一次双线图像时的赛道半宽大，则直接用上一次双线的赛道半宽。
   7922                          //求5行的斜率。
   7923                          for (black_row = BlackRightHeadLine; ; black_row++)
   7924                          {
   7925                              if (BlackRightEndLine - BlackRightHeadLine > 5)
   7926                              {
   7927                                  if (BlackRightLoc[black_row][ 0] != MaxValUint8)
   7928                                  {
   7929                                      slope = 1.0 * (BlackUdisRightLocation[black_row + 4].x - BlackUdisRightLocation[black_row].x) /
   7930                                            (BlackUdisRightLocation[black_row + 4].y - BlackUdisRightLocation[black_row].y);
   7931                                      /* else
   7932                                       {
   7933                                         slope = 0;
   7934                                       }*/
   7935                                      //赛道半宽
   7936                                      temp = CenterLineHalfWidth[black_row];// (int)(1.0 * Math.Sqrt(slope * slope + 1) * CenterLineHalfWidth[black_row] / 2);
   7937                                      //取最大值
   7938          
   7939                                      RoadHalfWidth = temp;// MaxRe(temp, RoadHalfWidth);
   7940          
   7941                                      tempflag1 = 0;
   7942                                      tempway1 = 0;
   7943                                      buXianCount = 0;
   7944                                      //根据赛道宽度估计出中心线的线头。
   7945                                      CenterLineLoc[black_row] = BlackRightLoc[black_row][ 0] - RoadHalfWidth;
   7946                                  }
   7947                                  //根据右线的走势估计出中心线。中心线是个int16型矩阵，有正负。
   7948          
   7949                                  // CenterLineLoc[black_row] = CenterLineLoc[black_row + 1] + BlackRightLoc[black_row, 0] - BlackRightLoc[black_row + 1, 0];
   7950                                  //右线无效时。根据最后两行的中心线趋势补线。
   7951                                  else
   7952                                  {
   7953                                      //当右线无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
   7954                                      if (tempflag1 == 0)
   7955                                      {
   7956                                          //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
   7957                                          tempflag1 = 1;
   7958                                          //最后几行行数够多，可以采用最小二乘法的方式。
   7959                                          //最后一行或两行尽量不用，因为有可能是拐点。但也不能太往后取，斜率就不对了。
   7960                                          if (black_row + CenterForwardLineNum + 2 <= CameraHight - 1)
   7961                                          {
   7962                                              tempway1 = 0;
   7963                                              //进行最小二乘法系数的计算。
   7964                                              for (i = 0; i < CenterForwardLineNum; i++)
   7965                                              {
   7966                                                  x[i] = black_row - i - 3;
   7967                                                  y[i] = CenterLineLoc[black_row - i - 3];
   7968                                              }
   7969                                              a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
   7970                                              a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。            
   7971                                          }
   7972                                          else if (black_row + CenterForwardLineNum + 1 <= CameraHight - 1)
   7973                                          {
   7974                                              tempway1 = 0;
   7975                                              //进行最小二乘法系数的计算。
   7976                                              for (i = 0; i < CenterForwardLineNum; i++)
   7977                                              {
   7978                                                  x[i] = black_row - i - 2;
   7979                                                  y[i] = CenterLineLoc[black_row - i - 2];
   7980                                              }
   7981                                              a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
   7982                                              a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。                        
   7983                                          }
   7984                                          else if (black_row + CenterForwardLineNum <= CameraHight - 1)
   7985                                          {
   7986                                              tempway1 = 0;
   7987                                              //进行最小二乘法系数的计算。
   7988                                              for (i = 0; i < CenterForwardLineNum; i++)
   7989                                              {
   7990                                                  x[i] = black_row - i - 1;
   7991                                                  y[i] = CenterLineLoc[black_row - i - 1];
   7992                                              }
   7993                                              a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
   7994                                              a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
   7995                                          }
   7996                                          //最后几行的行数不够多，采用最后两行趋势补线的方式。
   7997                                          else
   7998                                          {
   7999                                              tempway1 = 1;
   8000                                          }
   8001                                      }
   8002                                      else
   8003                                      {
   8004                                      }
   8005          
   8006                                      //确认补线方式后，开始补线。
   8007                                      if (tempway1 == 0)
   8008                                      {
   8009                                          //最小二乘法的方式。
   8010                                          CenterLineLoc[black_row] = (a0 + a1 * black_row) / LeastSquareMulti;
   8011                                      }
   8012                                      else
   8013                                      {
   8014                                          /*//最近2行。
   8015                                          if(black_row == CameraHight - 1 || black_row == CameraHight - 2)
   8016                                          {
   8017                                            CenterLineLoc[black_row] = BlackRightLoc[black_row,0] - RoadHalfWidth;
   8018                                          }
   8019                                          //不是最近2行。
   8020                                          else
   8021                                          {
   8022                                            //最后两行的方式。
   8023                                            CenterLineLoc[black_row] = CenterLineLoc[black_row+1] + CenterLineLoc[black_row+1] - CenterLineLoc[black_row+2];
   8024                                          }
   8025                                          */
   8026                                      }
   8027                                  }
   8028                              }
   8029                              else
   8030                              {
   8031                                  tempflag1 = 1;
   8032                                  tempway1 = 1;
   8033                                  temp = CenterLineHalfWidth[black_row];// (int)(1.0 * CenterLineHalfWidth[black_row] / 2);
   8034                                  RoadHalfWidth = temp;// MaxRe(temp, RoadHalfWidth);
   8035                                  CenterLineLoc[black_row] = BlackRightLoc[black_row][ 0] - RoadHalfWidth;
   8036          
   8037                              }
   8038                              if (CenterLineLoc[black_row] >= MaxValUint8)
   8039                                  CenterLineLoc[black_row] = MaxValUint8;
   8040                              else if (CenterLineLoc[black_row] <= 0)
   8041                                  CenterLineLoc[black_row] = 0;
   8042                              else
   8043                              {
   8044                              }
   8045                              if (black_row >= 59) break;
   8046                          }
   8047          
   8048          
   8049                      }
   8050          
   8051          
   8052          
   8053                      //对未处理的行的中心线置无效值。
   8054                      //底部置无效值。顶部不用处理。
   8055                      /* if(CenterEndLine != CameraHight - 1)
   8056                       {
   8057                         for(black_row = CameraHight - 1; ; black_row--)
   8058                         {
   8059                           if(black_row == CenterEndLine) break;       
   8060                           CenterLineLoc[black_row] = MaxValInt16;
   8061                         }
   8062                       }
   8063                       else
   8064                       {
   8065                       }*/
   8066          
   8067                 
   8068          
   8069            //左右线均提取成功。
   8070           else if(BlackLeftDone == 1 && BlackRightDone == 1)
   8071            {
   8072              CenterHeadLine = MinRe(BlackLeftHeadLine, BlackRightHeadLine);    //线头取两者较小者。     
   8073              //CenterHeadLine = 0;    //因为固定要补到第0行，所以固定取0.
   8074              //线尾取两者较大者。
   8075              CenterEndLine = MinRe(BlackLeftEndLine, BlackRightEndLine);             
   8076              
   8077              //不是单线的情况。
   8078              if(SingleBlackAllFlag == 0)
   8079              {
   8080              
   8081                //左右线均提取成功，首选根据两线得中心线，实在不行再根据赛道宽度估计。
   8082                //不根据趋势来预测，因为畸变矫正基本上已经把左右线差搞成定值了，所以不用那么麻烦。    
   8083                
   8084                //先检查左线，左线不满足条件再检测右线。右线不满足再返回失败。
   8085                flag1 = 1;
   8086                flag2 = 1;
   8087                flag3 = 1;
   8088                flag4 = 1;
   8089                //取左右两线的第39到第59行的差，取最大值。
   8090                //首先看线头是否大于39行，大于39行就直接返回失败。
   8091                if(BlackLeftHeadLine >= 55)
   8092                {
   8093                  flag1 = 0;
   8094                }
   8095                else
   8096                {
   8097                }
   8098                //左线尾小于CameraHight - 1行。
   8099                if(BlackLeftEndLine < CameraHight - 1)
   8100                {
   8101                  //只有左线成功，而且左线尾还那么远，真心没法继续。看右线是不是一样的情况。
   8102                  //if(BlackLeftEndLine < CameraHight - 1 - BlackLeftBackLineStart)
   8103                  if(BlackLeftEndLine <= CameraHight - BlackStep1Size - 1)
   8104                  {
   8105                    flag2 = 0;
   8106                  }
   8107                  //左线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackLeftEndLine。
   8108                  else
   8109                  {
   8110                  }
   8111                }
   8112                //左线尾等于CameraHight - 1，直接取BlackLeftEndLine
   8113                else
   8114                {
   8115                }
   8116            
   8117                //处理右线，右线不满足条件，则直接返回失败。
   8118                //首先看线头是否大于39行，大于39行就直接返回失败。
   8119                if(BlackRightHeadLine >= 55)
   8120                {
   8121                  flag3 = 0;
   8122                }
   8123                else
   8124                {
   8125                }    
   8126                //右线尾小于CameraHight - 1行。
   8127                if(BlackRightEndLine < CameraHight - 1)
   8128                {
   8129                  //只有右线成功，而且右线尾还那么远，真心没法继续。直接返回失败。
   8130                  //if(BlackRightEndLine < CameraHight - 1 - BlackRightBackLineStart)
   8131                  if(BlackRightEndLine <= CameraHight - BlackStep1Size - 1)
   8132                  {
   8133                    flag4 = 0;
   8134                    //两次都线尾很远，直接返回失败。
   8135                    if(flag2 == 0) 
   8136                    {
   8137                      return 0;
   8138                    }
   8139                    else
   8140                    {
   8141                    }
   8142                  }
   8143                  //右线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackRightEndLine。
   8144                  else
   8145                  {
   8146                  }
   8147                }
   8148                //右线尾等于CameraHight - 1，直接取BlackRightEndLine
   8149                else
   8150                {
   8151                }
   8152                
   8153                //只有右线满足要求，则直接取右线的列差值绝对值。
   8154                if(
   8155                  (flag3 == 1 && flag4 == 1)
   8156                &&((flag1 == 0 && flag2 == 0) || (flag1 == 1 && flag2 == 0) || (flag1 == 0 && flag2 == 1))
   8157                  )
   8158                {
   8159                  //斜率的方式估算出赛道半宽。
   8160                  //求5行的斜率。
   8161                  if(BlackRightEndLine - BlackRightHeadLine > 5)
   8162                  {
   8163                    slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
   8164                              (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
   8165                  }
   8166                  else
   8167                  {
   8168                    slope = 0;
   8169                  }
   8170                  //赛道半宽
   8171                  temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
   8172                  RoadHalfWidthCompen = RoadHalfWidth / temp;
   8173                  if(RoadHalfWidthSwitch == 1)
   8174                  {
   8175                    RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
   8176                  }
   8177                  else
   8178                  {
   8179                  }
   8180                }
   8181                //只有左线满足要求，则直接取左线的列差值绝对值。
   8182                else if(
   8183                       (flag1 == 1 && flag2 == 1)
   8184                     &&((flag3 == 0 && flag4 == 0) || (flag3 == 1 && flag4 == 0) || (flag3 == 0 && flag4 == 1))
   8185                       )
   8186                {
   8187                  //斜率的方式估算出赛道半宽。
   8188                  //求5行的斜率。
   8189                  if(BlackLeftEndLine - BlackLeftHeadLine > 5)
   8190                  {
   8191                    slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x- BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
   8192                              (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
   8193                  }
   8194                  else
   8195                  {
   8196                    slope = 0;
   8197                  }
   8198                  //赛道半宽
   8199                  temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
   8200                  RoadHalfWidthCompen = RoadHalfWidth / temp;
   8201                  if(RoadHalfWidthSwitch == 1)
   8202                  {
   8203                    RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
   8204                  }
   8205                  else
   8206                  {
   8207                  }
   8208                }
   8209                //左右线均满足条件。则取列差值绝对值较大的。
   8210                else if(flag1 == 1 && flag2 == 1 && flag3 == 1 && flag4 == 1)
   8211                {
   8212                  //斜率的方式估算出赛道半宽。
   8213                  //求5行的斜率。
   8214                  if(BlackLeftEndLine - BlackLeftHeadLine > 5)
   8215                  {
   8216                    slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
   8217                              (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
   8218                  }
   8219                  else
   8220                  {
   8221                    slope = 0;
   8222                  }
   8223                  //赛道半宽
   8224                  temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
   8225                  
   8226                  //求5行的斜率。
   8227                  if(BlackRightEndLine - BlackRightHeadLine > 5)
   8228                  {
   8229                    slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
   8230                              (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
   8231                  }
   8232                  else
   8233                  {
   8234                    slope = 0;
   8235                  }
   8236                  //赛道半宽
   8237                  temp = MaxRe((uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2), temp);
   8238                  RoadHalfWidthCompen = RoadHalfWidth / temp;
   8239                  if(RoadHalfWidthSwitch == 1)
   8240                  {
   8241                    RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
   8242                  }
   8243                  else
   8244                  {
   8245                  }
   8246                }
   8247                //左右线均不满足要求。
   8248                else
   8249                {
   8250                  //左右线都在第BlackControlLineLow行的远方。直接返回失败。
   8251                  if(flag2 == 0 && flag4 == 0)
   8252                  {
   8253                    return 0;
   8254                  }
   8255                  else
   8256                  {
   8257                    //左线在第BlackControlLineLow行的近方，右线在第BlackControlLineLow行的远方，则用左线来求。
   8258                    if(flag1 == 1 && flag3 == 0)
   8259                    {
   8260                      //斜率的方式估算出赛道半宽。
   8261                      //求5行的斜率。
   8262                      if(BlackLeftEndLine - BlackLeftHeadLine > 5)
   8263                      {
   8264                        slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
   8265                              (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
   8266                      }
   8267                      else
   8268                      {
   8269                        slope = 0;
   8270                      }
   8271                      //赛道半宽
   8272                      temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
   8273                      RoadHalfWidthCompen = RoadHalfWidth / temp;
   8274                      if(RoadHalfWidthSwitch == 1)
   8275                      {
   8276                        RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
   8277                      }
   8278                      else
   8279                      {
   8280                      }
   8281                    }
   8282                    //右线在第BlackControlLineLow行的近方，左线在第BlackControlLineLow行的远方，则用右线来求。
   8283                    else if(flag1 == 0 && flag3 == 1)
   8284                    {
   8285                      //斜率的方式估算出赛道半宽。
   8286                      //求5行的斜率。
   8287                      if(BlackRightEndLine - BlackRightHeadLine > 5)
   8288                      {
   8289                        slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
   8290                              (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
   8291                      }
   8292                      else
   8293                      {
   8294                        slope = 0;
   8295                      }
   8296                      //赛道半宽
   8297                      temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
   8298                      RoadHalfWidthCompen = RoadHalfWidth / temp;
   8299                      if(RoadHalfWidthSwitch == 1)
   8300                      {
   8301                        RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
   8302                      }
   8303                      else
   8304                      {
   8305                      }
   8306                    }
   8307                    //左右线都在第行的近方，则取较大值。
   8308                    else if(flag1 == 0 && flag3 == 0)
   8309                    {
   8310                      //斜率的方式估算出赛道半宽。
   8311                      //求5行的斜率。
   8312                      if(BlackLeftEndLine - BlackLeftHeadLine > 5)
   8313                      {
   8314                        slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
   8315                              (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
   8316                      }
   8317                      else
   8318                      {
   8319                        slope = 0;
   8320                      }
   8321                      //赛道半宽
   8322                      temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
   8323                      
   8324                      //求5行的斜率。
   8325                      if(BlackRightEndLine - BlackRightHeadLine > 5)
   8326                      {
   8327                        slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
   8328                              (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
   8329                      }
   8330                      else
   8331                      {
   8332                        slope = 0;
   8333                      }
   8334                      //赛道半宽
   8335                      temp = MaxRe((uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2), temp);
   8336                      RoadHalfWidthCompen = RoadHalfWidth / temp;
   8337                      if(RoadHalfWidthSwitch == 1)
   8338                      {
   8339                        RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
   8340                      }
   8341                      else
   8342                      {
   8343                      }
   8344                    }
   8345                    //理论上不可能走到这里。
   8346                    else
   8347                    {
   8348                      return 0;
   8349                    }
   8350                  }
   8351                }
   8352                
   8353                int temproad;  //本幅图的最后一个双线有效路宽。给本幅图的单线部分用。
   8354                temproad = RoadHalfWidth;
   8355                
   8356                tempflag1 = 0;
   8357                tempway1 = 0;
   8358              buXianCount = 0;
   8359          
   8360                              //赛道宽度已经求得，现在开始从高到低求中心线。
   8361                                  for (black_row = CenterHeadLine; black_row <= CameraHight - 1; black_row++)
   8362                                  {
   8363                                      //当前行左右黑线均有效。检测有无效不能用Udis数组，只能用原始的黑线储存数组。
   8364                                      if (BlackLeftLoc[black_row][ 0] != MaxValUint8 && BlackRightLoc[black_row][ 0] != MaxValUint8)
   8365                                      {
   8366                                          tempflag1 = 0;
   8367                                          //取左右黑线的平均值。
   8368                                          CenterLineLoc[black_row] = (BlackLeftLoc[black_row][ 0] + BlackRightLoc[black_row][ 0]) / 2;
   8369                                          //取最后一行两行有效的行的赛道半宽，作为最新的赛道半宽。
   8370                                          /*  
   8371          
   8372                                            //本幅图的最后一个双线有效路宽。给本幅图的单线部分用。
   8373                                            temproad = RoadHalfWidthRecord[black_row];*/
   8374                                          //赛道半宽记录.存第CameraHight - 1行的赛道半宽，给下一幅图用。
   8375                                          //怕出意外，限个幅。
   8376                                          /* if(black_row == CameraHight - 1) 
   8377                                           {  
   8378                                             if(RoadHalfWidthRecord[black_row] > RoadHalfWidthLimitMax)
   8379                                             {
   8380                                               RoadHalfWidth = RoadHalfWidthLimitMax;
   8381                                             }
   8382                                             else if(RoadHalfWidthRecord[black_row] < RoadHalfWidthLimitMin)
   8383                                             {
   8384                                               RoadHalfWidth = RoadHalfWidthLimitMin;
   8385                                             }
   8386                                             else
   8387                                             {
   8388                                               RoadHalfWidth = RoadHalfWidthRecord[black_row];
   8389                                             }            
   8390                                           }
   8391                                           else
   8392                                           {
   8393                                           } */
   8394                                      }
   8395                                      //左行或右行无效。则用上半段的中心线向后补线。
   8396                                      else if (BlackLeftLoc[black_row][ 0] == MaxValUint8 || BlackRightLoc[black_row][ 0] == MaxValUint8)
   8397                                      {
   8398          
   8399                                          if (BlackLeftCrossDone == 2 || BlackRightCrossDone == 2)
   8400                                          {
   8401                                              buXianCount--;
   8402                                          }
   8403                                          else if (BlackRightHeadLine >= 25 && BlackLeftHeadLine >= 25) { buXianCount = 0; }
   8404                                          else if (BlackLeftHeadLine <= 20 && BlackRightHeadLine >= 50) { buXianCount = 0; }
   8405                                          else if ((CURVEL < 0 && CURVER > 0) || (CURVEL > 0 && CURVER < 0)) { buXianCount = 0; }
   8406                                          else if (BlackLeftHeadLine <= 5) { buXianCount = 0; }
   8407                                          else if (BlackLeftHeadLine <= 20 && BlackRightHeadLine >= 45) { buXianCount = 0; }
   8408                                          else if (((AbsInt(CURVEL) >= 20) && (AbsInt(CURVEL) <= 50)) || ((AbsInt(CURVER) >= 20) && (AbsInt(CURVER) <= 50)))
   8409                                          {
   8410                                              buXianCount = 0;
   8411                                          }
   8412                                          else if (((AbsInt(CURVEL) > 50) && (AbsInt(CURVEL) <= 2000)) || ((AbsInt(CURVER) > 50) && (AbsInt(CURVER) <= 2000)))
   8413                                          {
   8414                                              buXianCount = 0;
   8415                                          }
   8416                                          else if ((AbsInt(CURVEL) > 2000) || (AbsInt(CURVER) > 2000))
   8417                                          {
   8418                                              buXianCount = 0;
   8419                                          }
   8420          
   8421          
   8422                                          tempflag1 = 0;
   8423                                          index = 0;
   8424                                          for (i = black_row - 1;i>=0 ; i--)
   8425                                          {
   8426                                              if (CenterLineLoc[i] != MaxValUint8)
   8427                                              {
   8428                                                  b[index] = CenterLineLoc[i];
   8429                                                  a[index] = i;
   8430                                                  index++;
   8431                                              }
   8432                                              if (index == BlackBackLineNum)
   8433                                              {
   8434          
   8435                                                  break;
   8436                                              }
   8437          
   8438                                          }
   8439          
   8440                                          //最小二乘法
   8441                                          //y = a0 + a1 * x
   8442                                          a1 = LeastSquarea1(a, b, BlackBackLineNum);
   8443          
   8444                                          a0 = LeastSquarea0(a, b, a1, BlackBackLineNum);
   8445          
   8446          
   8447                                          //补线也有个度，向左向右都不能补出范围。
   8448                                          temp = (a0 + a1 * black_row) / LeastSquareMulti;
   8449                                          if (temp >= CameraRealWidth - 1)
   8450                                          {
   8451                                              //BlackLeftLoc[black_row,0] = CameraRealWidth - 1;
   8452                                              //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。
   8453          
   8454                                              temp = CameraRealWidth - 1;
   8455                                          }
   8456                                          else if (temp <= 0)
   8457                                          {
   8458                                              //BlackLeftLoc[black_row,0] = 0;
   8459                                              //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。
   8460                                              temp = 0;
   8461                                          }
   8462                                          CenterLineLoc[black_row] = (int)(temp);
   8463                                          //  CenterLineLoc[black_row] = BlackLeftLoc[black_row,0] + temproad + buXianCount;
   8464                                      }
   8465                                      //左行无效，右行有效。则用右行减去一个赛道半宽。
   8466                                      /*else if(BlackLeftLoc[black_row,0] == MaxValUint8 && BlackRightLoc[black_row,0] != MaxValUint8)
   8467                                      {
   8468                                          if (BlackLeftCrossDone == 2 || BlackRightCrossDone == 2)
   8469                                          {
   8470                                              buXianCount--;
   8471                                          }
   8472                                          else if (BlackRightHeadLine >= 25 && BlackLeftHeadLine >= 25) { buXianCount = 0; }
   8473                                          else if (BlackRightHeadLine <= 20 && BlackLeftHeadLine >= 50) { buXianCount = 0; }
   8474                                          else if ((CURVEL < 0 && CURVER > 0) || (CURVEL > 0 && CURVER < 0)) { buXianCount = 0; }
   8475                                          else if (BlackRightHeadLine <= 5) { buXianCount = 0; }
   8476                                          else if (BlackRightHeadLine <= 20 && BlackLeftHeadLine >= 45) { buXianCount = 0; }
   8477                                          else if (((AbsInt(CURVEL) >= 20) && (AbsInt(CURVEL) <= 50)) || ((AbsInt(CURVER) >= 20) && (AbsInt(CURVER) <= 50)))
   8478                                          {
   8479                                              buXianCount=0;
   8480                                          }
   8481                                          else if (((AbsInt(CURVEL) > 50) && (AbsInt(CURVEL) <= 2000)) || ((AbsInt(CURVER) > 50) && (AbsInt(CURVER) <= 2000)))
   8482                                          {
   8483                                              buXianCount =0;
   8484                                          }
   8485                                          else if ((AbsInt(CURVEL) > 2000) ||(AbsInt(CURVER) > 2000))
   8486                                          {
   8487                                              buXianCount =0;
   8488                                          }
   8489          
   8490          
   8491                                          tempflag1 = 0;
   8492                                        CenterLineLoc[black_row] = BlackRightLoc[black_row,0] - temproad - buXianCount;
   8493                                      }
   8494                                      //左右行均无效。则用最后的中心线均势往前走。
   8495                                      else if(BlackLeftLoc[black_row,0] == MaxValUint8 && BlackRightLoc[black_row,0] == MaxValUint8)
   8496                                      {
   8497                                        //当左右线均无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
   8498                                        if(tempflag1 == 0)
   8499                                        {
   8500                                          //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
   8501                                          //除非又出现左或右黑线有效的情况，则再次刷新斜率。
   8502                                          tempflag1 = 1;
   8503                                          //最后几行行数够多，可以采用最小二乘法的方式。
   8504                                          //最后一行或两行尽量不用，因为有可能是拐点。但也不能太往后取，斜率就不对了。
   8505                                          if(black_row + CenterForwardLineNum + 2 <= CameraHight - 1)
   8506                                          {
   8507                                            tempway1 = 0;
   8508                                            //进行最小二乘法系数的计算。
   8509                                            for(i = 0; i < CenterForwardLineNum; i++)
   8510                                            {
   8511                                              x[i] = black_row + i + 3;
   8512                                              y[i] = CenterLineLoc[black_row + i + 3];
   8513                                            }
   8514                                            a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
   8515                                            a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。            
   8516                                          }
   8517                                          else if(black_row + CenterForwardLineNum + 1 <= CameraHight - 1)
   8518                                          {
   8519                                            tempway1 = 0;
   8520                                            //进行最小二乘法系数的计算。
   8521                                            for(i = 0; i < CenterForwardLineNum; i++)
   8522                                            {
   8523                                              x[i] = black_row + i + 2;
   8524                                              y[i] = CenterLineLoc[black_row + i + 2];
   8525                                            }
   8526                                            a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
   8527                                            a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。                        
   8528                                          }
   8529                                          else if(black_row + CenterForwardLineNum <= CameraHight - 1)
   8530                                          {
   8531                                            tempway1 = 0;
   8532                                            //进行最小二乘法系数的计算。
   8533                                            for(i = 0; i < CenterForwardLineNum; i++)
   8534                                            {
   8535                                              x[i] = black_row + i + 1;
   8536                                              y[i] = CenterLineLoc[black_row + i + 1];
   8537                                            }
   8538                                            a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
   8539                                            a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
   8540                                          }
   8541                                          //最后几行的行数不够多，采用最后两行趋势补线的方式。
   8542                                          else
   8543                                          {
   8544                                            tempway1 = 1;
   8545                                          }
   8546                                        }
   8547                                        else
   8548                                        {
   8549                                        }
   8550          
   8551                                        //确认补线方式后，开始补线。
   8552                                        if(tempway1 == 0)
   8553                                        {
   8554                                          //最小二乘法的方式。
   8555                                          CenterLineLoc[black_row] = (a0 + a1 * black_row) / LeastSquareMulti;
   8556                                        }
   8557                                        else
   8558                                        {
   8559                                          //最后两行的方式。
   8560                                          CenterLineLoc[black_row] = CenterLineLoc[black_row+1] + CenterLineLoc[black_row+1] - CenterLineLoc[black_row+2];
   8561                                        }
   8562          
   8563                                      }*/
   8564                                      //理论上不会走到这里。
   8565                                      else
   8566                                      {
   8567                                      }
   8568          
   8569                                  }
   8570                              
   8571                //对未处理的行的中心线置无效值。对顶部的不作处理。
   8572                //底部置无效值。
   8573                /* if(CenterEndLine != CameraHight - 1)
   8574                 {
   8575                   for(black_row = CameraHight - 1; ; black_row--)
   8576                   {
   8577                     if(black_row == CenterEndLine) break;       
   8578                     CenterLineLoc[black_row] = MaxValInt16;
   8579                   }
   8580                 }
   8581                 else
   8582                 {
   8583                 }      */
   8584              }
   8585              //单线的情况，也就是SingleBlackAllFlag==1的情况。
   8586              else
   8587              {
   8588                tempflag1 = 0;
   8589                tempway1 = 0;
   8590                
   8591                //赛道宽度已经求得，现在开始从低到高求中心线。
   8592                for(black_row = CenterEndLine; ; black_row--)
   8593                {
   8594                  //当前行左右黑线均有效。检测有无效不能用Udis数组，只能用原始的黑线储存数组。
   8595                  if(BlackLeftLoc[black_row][0] != MaxValUint8 && BlackRightLoc[black_row][0] != MaxValUint8)
   8596                  {
   8597                    tempflag1 = 0;
   8598                    //取左右黑线的平均值。
   8599                    CenterLineLoc[black_row] = (BlackLeftLoc[black_row][0] + BlackRightLoc[black_row][0]) / 2;
   8600                    //取最后一行两行有效的行的赛道半宽，作为最新的赛道半宽。
   8601                    if(BlackLeftLoc[black_row,0] > BlackRightLoc[black_row,0])
   8602                    {
   8603                      RoadHalfWidthSingle = (BlackLeftLoc[black_row,0] - BlackRightLoc[black_row,0]) / 2;
   8604                    }
   8605                    else
   8606                    {
   8607                      RoadHalfWidthSingle = (BlackRightLoc[black_row,0] - BlackLeftLoc[black_row,0]) / 2;
   8608                    }        
   8609                  }
   8610                  //左行有效，右行无效。则用左行加上一个赛道半宽。
   8611                  else if(BlackLeftLoc[black_row][0] != MaxValUint8 && BlackRightLoc[black_row][0] == MaxValUint8)
   8612                  {
   8613                    tempflag1 = 0;
   8614                    CenterLineLoc[black_row] = BlackLeftLoc[black_row][0] - RoadHalfWidthSingle;    //因为是单线，所以是减号。
   8615                  }
   8616                  //左行无效，右行有效。则用右行减去一个赛道半宽。
   8617                  else if(BlackLeftLoc[black_row][0] == MaxValUint8 && BlackRightLoc[black_row][0] != MaxValUint8)
   8618                  {
   8619                    tempflag1 = 0;
   8620                    CenterLineLoc[black_row] = BlackRightLoc[black_row][0] + RoadHalfWidthSingle;   //因为是单线，所以是加号。
   8621                  }
   8622                  //左右行均无效。则用最后的中心线均势往前走。
   8623                  else if(BlackLeftLoc[black_row][0] == MaxValUint8 && BlackRightLoc[black_row][0] == MaxValUint8)
   8624                  {
   8625                    //当左右线均无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
   8626                    if(tempflag1 == 0)
   8627                    {
   8628                      //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
   8629                      //除非又出现左或右黑线有效的情况，则再次刷新斜率。
   8630                      tempflag1 = 1;
   8631                      //最后几行行数够多，可以采用最小二乘法的方式。
   8632                      //最后一行或两行尽量不用，因为有可能是拐点。但也不能太往后取，斜率就不对了。
   8633                      if(black_row + CenterForwardLineNum + 2 <= CameraHight - 1)
   8634                      {
   8635                        tempway1 = 0;
   8636                        //进行最小二乘法系数的计算。
   8637                        for(i = 0; i < CenterForwardLineNum; i++)
   8638                        {
   8639                          x[i] = black_row + i + 3;
   8640                          y[i] = CenterLineLoc[black_row + i + 3];
   8641                        }
   8642                        a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
   8643                        a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。            
   8644                      }
   8645                      else if(black_row + CenterForwardLineNum + 1 <= CameraHight - 1)
   8646                      {
   8647                        tempway1 = 0;
   8648                        //进行最小二乘法系数的计算。
   8649                        for(i = 0; i < CenterForwardLineNum; i++)
   8650                        {
   8651                          x[i] = black_row + i + 2;
   8652                          y[i] = CenterLineLoc[black_row + i + 2];
   8653                        }
   8654                        a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
   8655                        a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。                        
   8656                      }
   8657                      else if(black_row + CenterForwardLineNum <= CameraHight - 1)
   8658                      {
   8659                        tempway1 = 0;
   8660                        //进行最小二乘法系数的计算。
   8661                        for(i = 0; i < CenterForwardLineNum; i++)
   8662                        {
   8663                          x[i] = black_row + i + 1;
   8664                          y[i] = CenterLineLoc[black_row + i + 1];
   8665                        }
   8666                        a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
   8667                        a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
   8668                      }
   8669                      //最后几行的行数不够多，采用最后两行趋势补线的方式。
   8670                      else
   8671                      {
   8672                        tempway1 = 1;
   8673                      }
   8674                    }
   8675                    else
   8676                    {
   8677                    }
   8678                    
   8679                    //确认补线方式后，开始补线。
   8680                    if(tempway1 == 0)
   8681                    {
   8682                      //最小二乘法的方式。
   8683                      CenterLineLoc[black_row] = (a0 + a1 * black_row) / LeastSquareMulti;
   8684                    }
   8685                    else
   8686                    {
   8687                      //最后两行的方式。
   8688                      CenterLineLoc[black_row] = CenterLineLoc[black_row+1] + CenterLineLoc[black_row+1] - CenterLineLoc[black_row+2];
   8689                    }
   8690                    
   8691                  }
   8692                  //理论上不会走到这里。
   8693                  else
   8694                  {
   8695                  }
   8696                  
   8697                  if(black_row == 0) break;
   8698                }
   8699                   
   8700                //对未处理的行的中心线置无效值。对顶部的不作处理。
   8701                //底部置无效值。
   8702                if(CenterEndLine != CameraHight - 1)
   8703                {
   8704                  for(black_row = CameraHight - 1; ; black_row--)
   8705                  {
   8706                    if(black_row == CenterEndLine) break;       
   8707                    CenterLineLoc[black_row] = MaxValInt16;
   8708                  }
   8709                }
   8710                else
   8711                {
   8712                }
   8713              }
   8714            }
   8715            //理论上不会走到这里。
   8716            else
   8717            {
   8718              //左右黑线均提取失败，返回0.
   8719              return 0;
   8720            }
   8721                 /*     if (BlackLeftLoc[CenterEndLine, 0] > BlackRightLoc[CenterEndLine, 0])
   8722                      {
   8723                          RoadHalfWidth = (BlackLeftLoc[CenterEndLine, 0] - BlackRightLoc[CenterEndLine, 0]) / 2;
   8724                      }
   8725                      else
   8726                      {
   8727                          RoadHalfWidth = (BlackRightLoc[CenterEndLine, 0] - BlackLeftLoc[CenterEndLine, 0]) / 2;
   8728                      }
   8729                      if (RoadHalfWidth > RoadHalfWidthLimitMax)
   8730                      {
   8731                          RoadHalfWidth = RoadHalfWidthLimitMax;
   8732                      }
   8733                      else if (RoadHalfWidth < RoadHalfWidthLimitMin)
   8734                      {
   8735                          RoadHalfWidth = RoadHalfWidthLimitMin;
   8736                      }
   8737                      else
   8738                      {
   8739                      }*/
   8740                      return 1;
   \                     ??CenterLineGetNormal_24: (+1)
   \   000002B6   0x2001             MOVS     R0,#+1
   \                     ??CenterLineGetNormal_4: (+1)
   \   000002B8   0xB005             ADD      SP,SP,#+20
   \   000002BA   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   \                     ??CenterLineGetNormal_1: (+1)
   \   000002BE   0xF8DF 0x0B28      LDR.W    R0,??CenterLineGetNormal_0
   \   000002C2   0x7800             LDRB     R0,[R0, #+0]
   \   000002C4   0x2800             CMP      R0,#+0
   \   000002C6   0xF040 0x814D      BNE.W    ??CenterLineGetNormal_25
   \   000002CA   0xF8DF 0x0B20      LDR.W    R0,??CenterLineGetNormal_0+0x4
   \   000002CE   0x7800             LDRB     R0,[R0, #+0]
   \   000002D0   0x2801             CMP      R0,#+1
   \   000002D2   0xF040 0x8147      BNE.W    ??CenterLineGetNormal_25
   \   000002D6   0xF8DF 0x0D60      LDR.W    R0,??CenterLineGetNormal_26
   \   000002DA   0x7800             LDRB     R0,[R0, #+0]
   \   000002DC   0x28FF             CMP      R0,#+255
   \   000002DE   0xD004             BEQ.N    ??CenterLineGetNormal_27
   \   000002E0   0xF8DF 0x0D58      LDR.W    R0,??CenterLineGetNormal_26+0x4
   \   000002E4   0x7800             LDRB     R0,[R0, #+0]
   \   000002E6   0x28FF             CMP      R0,#+255
   \   000002E8   0xD101             BNE.N    ??CenterLineGetNormal_28
   \                     ??CenterLineGetNormal_27: (+1)
   \   000002EA   0x2000             MOVS     R0,#+0
   \   000002EC   0xE7E4             B.N      ??CenterLineGetNormal_4
   \                     ??CenterLineGetNormal_28: (+1)
   \   000002EE   0x2001             MOVS     R0,#+1
   \   000002F0   0x2101             MOVS     R1,#+1
   \   000002F2   0xF8DF 0x0D44      LDR.W    R0,??CenterLineGetNormal_26
   \   000002F6   0x7800             LDRB     R0,[R0, #+0]
   \   000002F8   0xF8DF 0x1AFC      LDR.W    R1,??CenterLineGetNormal_0+0x10
   \   000002FC   0x7008             STRB     R0,[R1, #+0]
   \   000002FE   0xF8DF 0x0D3C      LDR.W    R0,??CenterLineGetNormal_26+0x4
   \   00000302   0x7800             LDRB     R0,[R0, #+0]
   \   00000304   0xF8DF 0x1AF4      LDR.W    R1,??CenterLineGetNormal_0+0x14
   \   00000308   0x7008             STRB     R0,[R1, #+0]
   \   0000030A   0xF8DF 0x0D2C      LDR.W    R0,??CenterLineGetNormal_26
   \   0000030E   0x7800             LDRB     R0,[R0, #+0]
   \   00000310   0x2837             CMP      R0,#+55
   \   00000312   0xDB00             BLT.N    ??CenterLineGetNormal_29
   \   00000314   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGetNormal_29: (+1)
   \   00000316   0xF8DF 0x0D24      LDR.W    R0,??CenterLineGetNormal_26+0x4
   \   0000031A   0x7800             LDRB     R0,[R0, #+0]
   \   0000031C   0x283B             CMP      R0,#+59
   \   0000031E   0xDA07             BGE.N    ??CenterLineGetNormal_30
   \   00000320   0xF8DF 0x0D18      LDR.W    R0,??CenterLineGetNormal_26+0x4
   \   00000324   0x7800             LDRB     R0,[R0, #+0]
   \   00000326   0x2806             CMP      R0,#+6
   \   00000328   0xDA02             BGE.N    ??CenterLineGetNormal_30
   \   0000032A   0x2100             MOVS     R1,#+0
   \   0000032C   0x2000             MOVS     R0,#+0
   \   0000032E   0xE7C3             B.N      ??CenterLineGetNormal_4
   \                     ??CenterLineGetNormal_30: (+1)
   \   00000330   0xF8DF 0x0D04      LDR.W    R0,??CenterLineGetNormal_26
   \   00000334   0x7806             LDRB     R6,[R0, #+0]
   \   00000336   0xE000             B.N      ??CenterLineGetNormal_31
   \                     ??CenterLineGetNormal_32: (+1)
   \   00000338   0x1C76             ADDS     R6,R6,#+1
   \                     ??CenterLineGetNormal_31: (+1)
   \   0000033A   0xF8DF 0x0D00      LDR.W    R0,??CenterLineGetNormal_26+0x4
   \   0000033E   0x7800             LDRB     R0,[R0, #+0]
   \   00000340   0xF8DF 0x1CF4      LDR.W    R1,??CenterLineGetNormal_26
   \   00000344   0x7809             LDRB     R1,[R1, #+0]
   \   00000346   0x1A40             SUBS     R0,R0,R1
   \   00000348   0x2806             CMP      R0,#+6
   \   0000034A   0xF2C0 0x80D8      BLT.W    ??CenterLineGetNormal_33
   \   0000034E   0xF8DF 0x0DE0      LDR.W    R0,??CenterLineGetNormal_34
   \   00000352   0x2103             MOVS     R1,#+3
   \   00000354   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000358   0x7800             LDRB     R0,[R0, #+0]
   \   0000035A   0x28FF             CMP      R0,#+255
   \   0000035C   0xD044             BEQ.N    ??CenterLineGetNormal_35
   \   0000035E   0xF8DF 0x0DD4      LDR.W    R0,??CenterLineGetNormal_34+0x4
   \   00000362   0xEB10 0x00C6      ADDS     R0,R0,R6, LSL #+3
   \   00000366   0x6A00             LDR      R0,[R0, #+32]
   \   00000368   0xF8DF 0x1DC8      LDR.W    R1,??CenterLineGetNormal_34+0x4
   \   0000036C   0xF851 0x1036      LDR      R1,[R1, R6, LSL #+3]
   \   00000370   0x1A40             SUBS     R0,R0,R1
   \   00000372   0x.... 0x....      BL       __aeabi_i2d
   \   00000376   0x2200             MOVS     R2,#+0
   \   00000378   0xF8DF 0x3A8C      LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   0000037C   0x.... 0x....      BL       __aeabi_dmul
   \   00000380   0x4680             MOV      R8,R0
   \   00000382   0x4689             MOV      R9,R1
   \   00000384   0xF8DF 0x0DAC      LDR.W    R0,??CenterLineGetNormal_34+0x4
   \   00000388   0xEB10 0x00C6      ADDS     R0,R0,R6, LSL #+3
   \   0000038C   0x6A40             LDR      R0,[R0, #+36]
   \   0000038E   0xF8DF 0x1DA4      LDR.W    R1,??CenterLineGetNormal_34+0x4
   \   00000392   0xEB11 0x01C6      ADDS     R1,R1,R6, LSL #+3
   \   00000396   0x6849             LDR      R1,[R1, #+4]
   \   00000398   0x1A40             SUBS     R0,R0,R1
   \   0000039A   0x.... 0x....      BL       __aeabi_i2d
   \   0000039E   0x0002             MOVS     R2,R0
   \   000003A0   0x000B             MOVS     R3,R1
   \   000003A2   0x4640             MOV      R0,R8
   \   000003A4   0x4649             MOV      R1,R9
   \   000003A6   0x.... 0x....      BL       __aeabi_ddiv
   \   000003AA   0x.... 0x....      BL       __aeabi_d2f
   \   000003AE   0xF8DF 0x0A5C      LDR.W    R0,??CenterLineGetNormal_0+0x24
   \   000003B2   0x5C37             LDRB     R7,[R6, R0]
   \   000003B4   0xF8DF 0x0A58      LDR.W    R0,??CenterLineGetNormal_0+0x28
   \   000003B8   0x7007             STRB     R7,[R0, #+0]
   \   000003BA   0xF05F 0x0800      MOVS     R8,#+0
   \   000003BE   0xF05F 0x0900      MOVS     R9,#+0
   \   000003C2   0x2000             MOVS     R0,#+0
   \   000003C4   0xF8DF 0x1A4C      LDR.W    R1,??CenterLineGetNormal_0+0x2C
   \   000003C8   0x8008             STRH     R0,[R1, #+0]
   \   000003CA   0xF8DF 0x0D64      LDR.W    R0,??CenterLineGetNormal_34
   \   000003CE   0x2103             MOVS     R1,#+3
   \   000003D0   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   000003D4   0x7800             LDRB     R0,[R0, #+0]
   \   000003D6   0xF8DF 0x1A38      LDR.W    R1,??CenterLineGetNormal_0+0x28
   \   000003DA   0x7809             LDRB     R1,[R1, #+0]
   \   000003DC   0x1A40             SUBS     R0,R0,R1
   \   000003DE   0xF8DF 0x1A38      LDR.W    R1,??CenterLineGetNormal_0+0x30
   \   000003E2   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
   \   000003E6   0xE0A2             B.N      ??CenterLineGetNormal_36
   \                     ??CenterLineGetNormal_35: (+1)
   \   000003E8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000003EC   0xF1B8 0x0F00      CMP      R8,#+0
   \   000003F0   0xD175             BNE.N    ??CenterLineGetNormal_37
   \   000003F2   0xF05F 0x0801      MOVS     R8,#+1
   \   000003F6   0x1DB0             ADDS     R0,R6,#+6
   \   000003F8   0x283C             CMP      R0,#+60
   \   000003FA   0xDA22             BGE.N    ??CenterLineGetNormal_38
   \   000003FC   0xF05F 0x0900      MOVS     R9,#+0
   \   00000400   0x2000             MOVS     R0,#+0
   \   00000402   0xE00E             B.N      ??CenterLineGetNormal_39
   \                     ??CenterLineGetNormal_40: (+1)
   \   00000404   0x1A31             SUBS     R1,R6,R0
   \   00000406   0x1EC9             SUBS     R1,R1,#+3
   \   00000408   0xAA00             ADD      R2,SP,#+0
   \   0000040A   0x5481             STRB     R1,[R0, R2]
   \   0000040C   0xF8DF 0x1A08      LDR.W    R1,??CenterLineGetNormal_0+0x30
   \   00000410   0x1A32             SUBS     R2,R6,R0
   \   00000412   0xEB11 0x0142      ADDS     R1,R1,R2, LSL #+1
   \   00000416   0xF831 0x1C06      LDRH     R1,[R1, #-6]
   \   0000041A   0xAA01             ADD      R2,SP,#+4
   \   0000041C   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   \   00000420   0x1C40             ADDS     R0,R0,#+1
   \                     ??CenterLineGetNormal_39: (+1)
   \   00000422   0x2804             CMP      R0,#+4
   \   00000424   0xDBEE             BLT.N    ??CenterLineGetNormal_40
   \   00000426   0x2204             MOVS     R2,#+4
   \   00000428   0xA901             ADD      R1,SP,#+4
   \   0000042A   0xA800             ADD      R0,SP,#+0
   \   0000042C   0x.... 0x....      BL       LeastSquareInt16a1
   \   00000430   0x0004             MOVS     R4,R0
   \   00000432   0x2304             MOVS     R3,#+4
   \   00000434   0x0022             MOVS     R2,R4
   \   00000436   0xA901             ADD      R1,SP,#+4
   \   00000438   0xA800             ADD      R0,SP,#+0
   \   0000043A   0x.... 0x....      BL       LeastSquareInt16a0
   \   0000043E   0x0005             MOVS     R5,R0
   \   00000440   0xE04D             B.N      ??CenterLineGetNormal_37
   \                     ??CenterLineGetNormal_38: (+1)
   \   00000442   0x1D70             ADDS     R0,R6,#+5
   \   00000444   0x283C             CMP      R0,#+60
   \   00000446   0xDA22             BGE.N    ??CenterLineGetNormal_41
   \   00000448   0xF05F 0x0900      MOVS     R9,#+0
   \   0000044C   0x2000             MOVS     R0,#+0
   \   0000044E   0xE00E             B.N      ??CenterLineGetNormal_42
   \                     ??CenterLineGetNormal_43: (+1)
   \   00000450   0x1A31             SUBS     R1,R6,R0
   \   00000452   0x1E89             SUBS     R1,R1,#+2
   \   00000454   0xAA00             ADD      R2,SP,#+0
   \   00000456   0x5481             STRB     R1,[R0, R2]
   \   00000458   0xF8DF 0x19BC      LDR.W    R1,??CenterLineGetNormal_0+0x30
   \   0000045C   0x1A32             SUBS     R2,R6,R0
   \   0000045E   0xEB11 0x0142      ADDS     R1,R1,R2, LSL #+1
   \   00000462   0xF831 0x1C04      LDRH     R1,[R1, #-4]
   \   00000466   0xAA01             ADD      R2,SP,#+4
   \   00000468   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   \   0000046C   0x1C40             ADDS     R0,R0,#+1
   \                     ??CenterLineGetNormal_42: (+1)
   \   0000046E   0x2804             CMP      R0,#+4
   \   00000470   0xDBEE             BLT.N    ??CenterLineGetNormal_43
   \   00000472   0x2204             MOVS     R2,#+4
   \   00000474   0xA901             ADD      R1,SP,#+4
   \   00000476   0xA800             ADD      R0,SP,#+0
   \   00000478   0x.... 0x....      BL       LeastSquareInt16a1
   \   0000047C   0x0004             MOVS     R4,R0
   \   0000047E   0x2304             MOVS     R3,#+4
   \   00000480   0x0022             MOVS     R2,R4
   \   00000482   0xA901             ADD      R1,SP,#+4
   \   00000484   0xA800             ADD      R0,SP,#+0
   \   00000486   0x.... 0x....      BL       LeastSquareInt16a0
   \   0000048A   0x0005             MOVS     R5,R0
   \   0000048C   0xE027             B.N      ??CenterLineGetNormal_37
   \                     ??CenterLineGetNormal_41: (+1)
   \   0000048E   0x1D30             ADDS     R0,R6,#+4
   \   00000490   0x283C             CMP      R0,#+60
   \   00000492   0xDA22             BGE.N    ??CenterLineGetNormal_44
   \   00000494   0xF05F 0x0900      MOVS     R9,#+0
   \   00000498   0x2000             MOVS     R0,#+0
   \   0000049A   0xE00E             B.N      ??CenterLineGetNormal_45
   \                     ??CenterLineGetNormal_46: (+1)
   \   0000049C   0x1A31             SUBS     R1,R6,R0
   \   0000049E   0x1E49             SUBS     R1,R1,#+1
   \   000004A0   0xAA00             ADD      R2,SP,#+0
   \   000004A2   0x5481             STRB     R1,[R0, R2]
   \   000004A4   0xF8DF 0x1970      LDR.W    R1,??CenterLineGetNormal_0+0x30
   \   000004A8   0x1A32             SUBS     R2,R6,R0
   \   000004AA   0xEB11 0x0142      ADDS     R1,R1,R2, LSL #+1
   \   000004AE   0xF831 0x1C02      LDRH     R1,[R1, #-2]
   \   000004B2   0xAA01             ADD      R2,SP,#+4
   \   000004B4   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   \   000004B8   0x1C40             ADDS     R0,R0,#+1
   \                     ??CenterLineGetNormal_45: (+1)
   \   000004BA   0x2804             CMP      R0,#+4
   \   000004BC   0xDBEE             BLT.N    ??CenterLineGetNormal_46
   \   000004BE   0x2204             MOVS     R2,#+4
   \   000004C0   0xA901             ADD      R1,SP,#+4
   \   000004C2   0xA800             ADD      R0,SP,#+0
   \   000004C4   0x.... 0x....      BL       LeastSquareInt16a1
   \   000004C8   0x0004             MOVS     R4,R0
   \   000004CA   0x2304             MOVS     R3,#+4
   \   000004CC   0x0022             MOVS     R2,R4
   \   000004CE   0xA901             ADD      R1,SP,#+4
   \   000004D0   0xA800             ADD      R0,SP,#+0
   \   000004D2   0x.... 0x....      BL       LeastSquareInt16a0
   \   000004D6   0x0005             MOVS     R5,R0
   \   000004D8   0xE001             B.N      ??CenterLineGetNormal_37
   \                     ??CenterLineGetNormal_44: (+1)
   \   000004DA   0xF05F 0x0901      MOVS     R9,#+1
   \                     ??CenterLineGetNormal_37: (+1)
   \   000004DE   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000004E2   0xF1B9 0x0F00      CMP      R9,#+0
   \   000004E6   0xD122             BNE.N    ??CenterLineGetNormal_36
   \   000004E8   0xFB06 0x5004      MLA      R0,R6,R4,R5
   \   000004EC   0xF44F 0x717A      MOV      R1,#+1000
   \   000004F0   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000004F4   0xF8DF 0x1920      LDR.W    R1,??CenterLineGetNormal_0+0x30
   \   000004F8   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
   \   000004FC   0xE017             B.N      ??CenterLineGetNormal_36
   \                     ??CenterLineGetNormal_33: (+1)
   \   000004FE   0xF05F 0x0801      MOVS     R8,#+1
   \   00000502   0xF05F 0x0901      MOVS     R9,#+1
   \   00000506   0xF8DF 0x0904      LDR.W    R0,??CenterLineGetNormal_0+0x24
   \   0000050A   0x5C37             LDRB     R7,[R6, R0]
   \   0000050C   0xF8DF 0x0900      LDR.W    R0,??CenterLineGetNormal_0+0x28
   \   00000510   0x7007             STRB     R7,[R0, #+0]
   \   00000512   0xF8DF 0x0C1C      LDR.W    R0,??CenterLineGetNormal_34
   \   00000516   0x2103             MOVS     R1,#+3
   \   00000518   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   0000051C   0x7800             LDRB     R0,[R0, #+0]
   \   0000051E   0xF8DF 0x18F0      LDR.W    R1,??CenterLineGetNormal_0+0x28
   \   00000522   0x7809             LDRB     R1,[R1, #+0]
   \   00000524   0x1A40             SUBS     R0,R0,R1
   \   00000526   0xF8DF 0x18F0      LDR.W    R1,??CenterLineGetNormal_0+0x30
   \   0000052A   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
   \                     ??CenterLineGetNormal_36: (+1)
   \   0000052E   0xF8DF 0x08E8      LDR.W    R0,??CenterLineGetNormal_0+0x30
   \   00000532   0xF930 0x0016      LDRSH    R0,[R0, R6, LSL #+1]
   \   00000536   0x28FF             CMP      R0,#+255
   \   00000538   0xDB05             BLT.N    ??CenterLineGetNormal_47
   \   0000053A   0x20FF             MOVS     R0,#+255
   \   0000053C   0xF8DF 0x18D8      LDR.W    R1,??CenterLineGetNormal_0+0x30
   \   00000540   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
   \   00000544   0xE00A             B.N      ??CenterLineGetNormal_48
   \                     ??CenterLineGetNormal_47: (+1)
   \   00000546   0xF8DF 0x08D0      LDR.W    R0,??CenterLineGetNormal_0+0x30
   \   0000054A   0xF930 0x0016      LDRSH    R0,[R0, R6, LSL #+1]
   \   0000054E   0x2801             CMP      R0,#+1
   \   00000550   0xDA04             BGE.N    ??CenterLineGetNormal_48
   \   00000552   0x2000             MOVS     R0,#+0
   \   00000554   0xF8DF 0x18C0      LDR.W    R1,??CenterLineGetNormal_0+0x30
   \   00000558   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
   \                     ??CenterLineGetNormal_48: (+1)
   \   0000055C   0x2E3B             CMP      R6,#+59
   \   0000055E   0xF6FF 0xAEEB      BLT.W    ??CenterLineGetNormal_32
   \   00000562   0xE6A8             B.N      ??CenterLineGetNormal_24
   \                     ??CenterLineGetNormal_25: (+1)
   \   00000564   0xF8DF 0x0880      LDR.W    R0,??CenterLineGetNormal_0
   \   00000568   0x7800             LDRB     R0,[R0, #+0]
   \   0000056A   0x2801             CMP      R0,#+1
   \   0000056C   0xF040 0x86EE      BNE.W    ??CenterLineGetNormal_49
   \   00000570   0xF8DF 0x0878      LDR.W    R0,??CenterLineGetNormal_0+0x4
   \   00000574   0x7800             LDRB     R0,[R0, #+0]
   \   00000576   0x2801             CMP      R0,#+1
   \   00000578   0xF040 0x86E8      BNE.W    ??CenterLineGetNormal_49
   \   0000057C   0xF8DF 0x0AB8      LDR.W    R0,??CenterLineGetNormal_26
   \   00000580   0x7801             LDRB     R1,[R0, #+0]
   \   00000582   0xF8DF 0x086C      LDR.W    R0,??CenterLineGetNormal_0+0x8
   \   00000586   0x7800             LDRB     R0,[R0, #+0]
   \   00000588   0x.... 0x....      BL       MinRe
   \   0000058C   0xF8DF 0x1868      LDR.W    R1,??CenterLineGetNormal_0+0x10
   \   00000590   0x7008             STRB     R0,[R1, #+0]
   \   00000592   0xF8DF 0x0AA8      LDR.W    R0,??CenterLineGetNormal_26+0x4
   \   00000596   0x7801             LDRB     R1,[R0, #+0]
   \   00000598   0xF8DF 0x0858      LDR.W    R0,??CenterLineGetNormal_0+0xC
   \   0000059C   0x7800             LDRB     R0,[R0, #+0]
   \   0000059E   0x.... 0x....      BL       MinRe
   \   000005A2   0xF8DF 0x1858      LDR.W    R1,??CenterLineGetNormal_0+0x14
   \   000005A6   0x7008             STRB     R0,[R1, #+0]
   \   000005A8   0x.... 0x....      LDR.W    R0,??DataTable44
   \   000005AC   0x7800             LDRB     R0,[R0, #+0]
   \   000005AE   0x2800             CMP      R0,#+0
   \   000005B0   0xF040 0x8576      BNE.W    ??CenterLineGetNormal_50
   \   000005B4   0x2001             MOVS     R0,#+1
   \   000005B6   0x2101             MOVS     R1,#+1
   \   000005B8   0x2301             MOVS     R3,#+1
   \   000005BA   0x2201             MOVS     R2,#+1
   \   000005BC   0xF8DF 0x4830      LDR.W    R4,??CenterLineGetNormal_0+0x8
   \   000005C0   0x7824             LDRB     R4,[R4, #+0]
   \   000005C2   0x2C37             CMP      R4,#+55
   \   000005C4   0xDB00             BLT.N    ??CenterLineGetNormal_51
   \   000005C6   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGetNormal_51: (+1)
   \   000005C8   0xF8DF 0x4828      LDR.W    R4,??CenterLineGetNormal_0+0xC
   \   000005CC   0x7824             LDRB     R4,[R4, #+0]
   \   000005CE   0x2C3B             CMP      R4,#+59
   \   000005D0   0xDA05             BGE.N    ??CenterLineGetNormal_52
   \   000005D2   0xF8DF 0x4820      LDR.W    R4,??CenterLineGetNormal_0+0xC
   \   000005D6   0x7824             LDRB     R4,[R4, #+0]
   \   000005D8   0x2C0C             CMP      R4,#+12
   \   000005DA   0xDA00             BGE.N    ??CenterLineGetNormal_52
   \   000005DC   0x2100             MOVS     R1,#+0
   \                     ??CenterLineGetNormal_52: (+1)
   \   000005DE   0xF8DF 0x4A58      LDR.W    R4,??CenterLineGetNormal_26
   \   000005E2   0x7824             LDRB     R4,[R4, #+0]
   \   000005E4   0x2C37             CMP      R4,#+55
   \   000005E6   0xDB00             BLT.N    ??CenterLineGetNormal_53
   \   000005E8   0x2300             MOVS     R3,#+0
   \                     ??CenterLineGetNormal_53: (+1)
   \   000005EA   0xF8DF 0x4A50      LDR.W    R4,??CenterLineGetNormal_26+0x4
   \   000005EE   0x7824             LDRB     R4,[R4, #+0]
   \   000005F0   0x2C3B             CMP      R4,#+59
   \   000005F2   0xDA0A             BGE.N    ??CenterLineGetNormal_54
   \   000005F4   0xF8DF 0x4A44      LDR.W    R4,??CenterLineGetNormal_26+0x4
   \   000005F8   0x7824             LDRB     R4,[R4, #+0]
   \   000005FA   0x2C0C             CMP      R4,#+12
   \   000005FC   0xDA05             BGE.N    ??CenterLineGetNormal_54
   \   000005FE   0x2200             MOVS     R2,#+0
   \   00000600   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000602   0x2900             CMP      R1,#+0
   \   00000604   0xD101             BNE.N    ??CenterLineGetNormal_54
   \   00000606   0x2000             MOVS     R0,#+0
   \   00000608   0xE656             B.N      ??CenterLineGetNormal_4
   \                     ??CenterLineGetNormal_54: (+1)
   \   0000060A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000060C   0x2B01             CMP      R3,#+1
   \   0000060E   0xF040 0x809F      BNE.W    ??CenterLineGetNormal_55
   \   00000612   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000614   0x2A01             CMP      R2,#+1
   \   00000616   0xF040 0x809B      BNE.W    ??CenterLineGetNormal_55
   \   0000061A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000061C   0x2800             CMP      R0,#+0
   \   0000061E   0xD102             BNE.N    ??CenterLineGetNormal_56
   \   00000620   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000622   0x2900             CMP      R1,#+0
   \   00000624   0xD00D             BEQ.N    ??CenterLineGetNormal_57
   \                     ??CenterLineGetNormal_56: (+1)
   \   00000626   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000628   0x2801             CMP      R0,#+1
   \   0000062A   0xD102             BNE.N    ??CenterLineGetNormal_58
   \   0000062C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000062E   0x2900             CMP      R1,#+0
   \   00000630   0xD007             BEQ.N    ??CenterLineGetNormal_57
   \                     ??CenterLineGetNormal_58: (+1)
   \   00000632   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000634   0x2800             CMP      R0,#+0
   \   00000636   0xF040 0x808B      BNE.W    ??CenterLineGetNormal_55
   \   0000063A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000063C   0x2901             CMP      R1,#+1
   \   0000063E   0xF040 0x8087      BNE.W    ??CenterLineGetNormal_55
   \                     ??CenterLineGetNormal_57: (+1)
   \   00000642   0xF8DF 0x09F8      LDR.W    R0,??CenterLineGetNormal_26+0x4
   \   00000646   0x7800             LDRB     R0,[R0, #+0]
   \   00000648   0xF8DF 0x19EC      LDR.W    R1,??CenterLineGetNormal_26
   \   0000064C   0x7809             LDRB     R1,[R1, #+0]
   \   0000064E   0x1A40             SUBS     R0,R0,R1
   \   00000650   0x2806             CMP      R0,#+6
   \   00000652   0xDB36             BLT.N    ??CenterLineGetNormal_59
   \   00000654   0xF8DF 0x0ADC      LDR.W    R0,??CenterLineGetNormal_34+0x4
   \   00000658   0xF8DF 0x19E0      LDR.W    R1,??CenterLineGetNormal_26+0x4
   \   0000065C   0x7809             LDRB     R1,[R1, #+0]
   \   0000065E   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000662   0xF8DF 0x1AD0      LDR.W    R1,??CenterLineGetNormal_34+0x4
   \   00000666   0xF8DF 0x29D4      LDR.W    R2,??CenterLineGetNormal_26+0x4
   \   0000066A   0x7812             LDRB     R2,[R2, #+0]
   \   0000066C   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000670   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   00000674   0x1A40             SUBS     R0,R0,R1
   \   00000676   0x.... 0x....      BL       __aeabi_i2d
   \   0000067A   0x2200             MOVS     R2,#+0
   \   0000067C   0xF8DF 0x3788      LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   00000680   0x.... 0x....      BL       __aeabi_dmul
   \   00000684   0x0004             MOVS     R4,R0
   \   00000686   0x000D             MOVS     R5,R1
   \   00000688   0xF8DF 0x0AA8      LDR.W    R0,??CenterLineGetNormal_34+0x4
   \   0000068C   0xF8DF 0x19AC      LDR.W    R1,??CenterLineGetNormal_26+0x4
   \   00000690   0x7809             LDRB     R1,[R1, #+0]
   \   00000692   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000696   0x6840             LDR      R0,[R0, #+4]
   \   00000698   0xF8DF 0x1A98      LDR.W    R1,??CenterLineGetNormal_34+0x4
   \   0000069C   0xF8DF 0x299C      LDR.W    R2,??CenterLineGetNormal_26+0x4
   \   000006A0   0x7812             LDRB     R2,[R2, #+0]
   \   000006A2   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   000006A6   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   000006AA   0x1A40             SUBS     R0,R0,R1
   \   000006AC   0x.... 0x....      BL       __aeabi_i2d
   \   000006B0   0x0002             MOVS     R2,R0
   \   000006B2   0x000B             MOVS     R3,R1
   \   000006B4   0x0020             MOVS     R0,R4
   \   000006B6   0x0029             MOVS     R1,R5
   \   000006B8   0x.... 0x....      BL       __aeabi_ddiv
   \   000006BC   0x.... 0x....      BL       __aeabi_d2f
   \   000006C0   0xE000             B.N      ??CenterLineGetNormal_60
   \                     ??CenterLineGetNormal_59: (+1)
   \   000006C2   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGetNormal_60: (+1)
   \   000006C4   0x0001             MOVS     R1,R0
   \   000006C6   0x.... 0x....      BL       __aeabi_fmul
   \   000006CA   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   000006CE   0x.... 0x....      BL       __aeabi_fadd
   \   000006D2   0x.... 0x....      BL       __aeabi_f2d
   \   000006D6   0x.... 0x....      BL       sqrt
   \   000006DA   0x2200             MOVS     R2,#+0
   \   000006DC   0xF8DF 0x3728      LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   000006E0   0x.... 0x....      BL       __aeabi_dmul
   \   000006E4   0x2200             MOVS     R2,#+0
   \   000006E6   0x.... 0x....      LDR.W    R3,??DataTable45  ;; 0x40690000
   \   000006EA   0x.... 0x....      BL       __aeabi_dmul
   \   000006EE   0x2200             MOVS     R2,#+0
   \   000006F0   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   000006F4   0x.... 0x....      BL       __aeabi_ddiv
   \   000006F8   0x.... 0x....      BL       __aeabi_d2iz
   \   000006FC   0x0007             MOVS     R7,R0
   \   000006FE   0xF8DF 0x0710      LDR.W    R0,??CenterLineGetNormal_0+0x28
   \   00000702   0x7800             LDRB     R0,[R0, #+0]
   \   00000704   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000706   0xFB90 0xF0F7      SDIV     R0,R0,R7
   \   0000070A   0x.... 0x....      BL       __aeabi_i2f
   \   0000070E   0x.... 0x....      LDR.W    R1,??DataTable45_1
   \   00000712   0x6008             STR      R0,[R1, #+0]
   \   00000714   0x.... 0x....      LDR.W    R0,??DataTable45_2
   \   00000718   0x7800             LDRB     R0,[R0, #+0]
   \   0000071A   0x2801             CMP      R0,#+1
   \   0000071C   0xD109             BNE.N    ??CenterLineGetNormal_61
   \   0000071E   0xF8DF 0x06F0      LDR.W    R0,??CenterLineGetNormal_0+0x28
   \   00000722   0x7801             LDRB     R1,[R0, #+0]
   \   00000724   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000726   0x0038             MOVS     R0,R7
   \   00000728   0x.... 0x....      BL       MaxRe
   \   0000072C   0xF8DF 0x16E0      LDR.W    R1,??CenterLineGetNormal_0+0x28
   \   00000730   0x7008             STRB     R0,[R1, #+0]
   \                     ??CenterLineGetNormal_61: (+1)
   \   00000732   0xF8DF 0x06DC      LDR.W    R0,??CenterLineGetNormal_0+0x28
   \   00000736   0x7800             LDRB     R0,[R0, #+0]
   \   00000738   0xF05F 0x0800      MOVS     R8,#+0
   \   0000073C   0xF05F 0x0900      MOVS     R9,#+0
   \   00000740   0x2000             MOVS     R0,#+0
   \   00000742   0xF8DF 0x16D0      LDR.W    R1,??CenterLineGetNormal_0+0x2C
   \   00000746   0x8008             STRH     R0,[R1, #+0]
   \   00000748   0xF8DF 0x06AC      LDR.W    R0,??CenterLineGetNormal_0+0x10
   \   0000074C   0x7806             LDRB     R6,[R0, #+0]
   \   0000074E   0xE372             B.N      ??CenterLineGetNormal_62
   \                     ??CenterLineGetNormal_55: (+1)
   \   00000750   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000752   0x2801             CMP      R0,#+1
   \   00000754   0xF040 0x8090      BNE.W    ??CenterLineGetNormal_63
   \   00000758   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000075A   0x2901             CMP      R1,#+1
   \   0000075C   0xF040 0x808C      BNE.W    ??CenterLineGetNormal_63
   \   00000760   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000762   0x2B00             CMP      R3,#+0
   \   00000764   0xD102             BNE.N    ??CenterLineGetNormal_64
   \   00000766   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000768   0x2A00             CMP      R2,#+0
   \   0000076A   0xD00B             BEQ.N    ??CenterLineGetNormal_65
   \                     ??CenterLineGetNormal_64: (+1)
   \   0000076C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000076E   0x2B01             CMP      R3,#+1
   \   00000770   0xD102             BNE.N    ??CenterLineGetNormal_66
   \   00000772   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000774   0x2A00             CMP      R2,#+0
   \   00000776   0xD005             BEQ.N    ??CenterLineGetNormal_65
   \                     ??CenterLineGetNormal_66: (+1)
   \   00000778   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000077A   0x2B00             CMP      R3,#+0
   \   0000077C   0xD17C             BNE.N    ??CenterLineGetNormal_63
   \   0000077E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000780   0x2A01             CMP      R2,#+1
   \   00000782   0xD179             BNE.N    ??CenterLineGetNormal_63
   \                     ??CenterLineGetNormal_65: (+1)
   \   00000784   0xF8DF 0x066C      LDR.W    R0,??CenterLineGetNormal_0+0xC
   \   00000788   0x7800             LDRB     R0,[R0, #+0]
   \   0000078A   0xF8DF 0x1664      LDR.W    R1,??CenterLineGetNormal_0+0x8
   \   0000078E   0x7809             LDRB     R1,[R1, #+0]
   \   00000790   0x1A40             SUBS     R0,R0,R1
   \   00000792   0x2806             CMP      R0,#+6
   \   00000794   0xDB36             BLT.N    ??CenterLineGetNormal_67
   \   00000796   0xF8DF 0x066C      LDR.W    R0,??CenterLineGetNormal_0+0x1C
   \   0000079A   0xF8DF 0x1658      LDR.W    R1,??CenterLineGetNormal_0+0xC
   \   0000079E   0x7809             LDRB     R1,[R1, #+0]
   \   000007A0   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   000007A4   0xF8DF 0x165C      LDR.W    R1,??CenterLineGetNormal_0+0x1C
   \   000007A8   0xF8DF 0x2648      LDR.W    R2,??CenterLineGetNormal_0+0xC
   \   000007AC   0x7812             LDRB     R2,[R2, #+0]
   \   000007AE   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   000007B2   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   000007B6   0x1A40             SUBS     R0,R0,R1
   \   000007B8   0x.... 0x....      BL       __aeabi_i2d
   \   000007BC   0x2200             MOVS     R2,#+0
   \   000007BE   0xF8DF 0x3648      LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   000007C2   0x.... 0x....      BL       __aeabi_dmul
   \   000007C6   0x0004             MOVS     R4,R0
   \   000007C8   0x000D             MOVS     R5,R1
   \   000007CA   0xF8DF 0x0638      LDR.W    R0,??CenterLineGetNormal_0+0x1C
   \   000007CE   0xF8DF 0x1624      LDR.W    R1,??CenterLineGetNormal_0+0xC
   \   000007D2   0x7809             LDRB     R1,[R1, #+0]
   \   000007D4   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   000007D8   0x6840             LDR      R0,[R0, #+4]
   \   000007DA   0xF8DF 0x1628      LDR.W    R1,??CenterLineGetNormal_0+0x1C
   \   000007DE   0xF8DF 0x2614      LDR.W    R2,??CenterLineGetNormal_0+0xC
   \   000007E2   0x7812             LDRB     R2,[R2, #+0]
   \   000007E4   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   000007E8   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   000007EC   0x1A40             SUBS     R0,R0,R1
   \   000007EE   0x.... 0x....      BL       __aeabi_i2d
   \   000007F2   0x0002             MOVS     R2,R0
   \   000007F4   0x000B             MOVS     R3,R1
   \   000007F6   0x0020             MOVS     R0,R4
   \   000007F8   0x0029             MOVS     R1,R5
   \   000007FA   0x.... 0x....      BL       __aeabi_ddiv
   \   000007FE   0x.... 0x....      BL       __aeabi_d2f
   \   00000802   0xE000             B.N      ??CenterLineGetNormal_68
   \                     ??CenterLineGetNormal_67: (+1)
   \   00000804   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGetNormal_68: (+1)
   \   00000806   0x0001             MOVS     R1,R0
   \   00000808   0x.... 0x....      BL       __aeabi_fmul
   \   0000080C   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   00000810   0x.... 0x....      BL       __aeabi_fadd
   \   00000814   0x.... 0x....      BL       __aeabi_f2d
   \   00000818   0x.... 0x....      BL       sqrt
   \   0000081C   0x2200             MOVS     R2,#+0
   \   0000081E   0xF8DF 0x35E8      LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   00000822   0x.... 0x....      BL       __aeabi_dmul
   \   00000826   0x2200             MOVS     R2,#+0
   \   00000828   0x.... 0x....      LDR.W    R3,??DataTable45  ;; 0x40690000
   \   0000082C   0x.... 0x....      BL       __aeabi_dmul
   \   00000830   0x2200             MOVS     R2,#+0
   \   00000832   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   00000836   0x.... 0x....      BL       __aeabi_ddiv
   \   0000083A   0x.... 0x....      BL       __aeabi_d2iz
   \   0000083E   0x0007             MOVS     R7,R0
   \   00000840   0xF8DF 0x05CC      LDR.W    R0,??CenterLineGetNormal_0+0x28
   \   00000844   0x7800             LDRB     R0,[R0, #+0]
   \   00000846   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000848   0xFB90 0xF0F7      SDIV     R0,R0,R7
   \   0000084C   0x.... 0x....      BL       __aeabi_i2f
   \   00000850   0x.... 0x....      LDR.W    R1,??DataTable45_1
   \   00000854   0x6008             STR      R0,[R1, #+0]
   \   00000856   0x.... 0x....      LDR.W    R0,??DataTable45_2
   \   0000085A   0x7800             LDRB     R0,[R0, #+0]
   \   0000085C   0x2801             CMP      R0,#+1
   \   0000085E   0xF47F 0xAF68      BNE.W    ??CenterLineGetNormal_61
   \   00000862   0xF8DF 0x05AC      LDR.W    R0,??CenterLineGetNormal_0+0x28
   \   00000866   0x7801             LDRB     R1,[R0, #+0]
   \   00000868   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000086A   0x0038             MOVS     R0,R7
   \   0000086C   0x.... 0x....      BL       MaxRe
   \   00000870   0xF8DF 0x159C      LDR.W    R1,??CenterLineGetNormal_0+0x28
   \   00000874   0x7008             STRB     R0,[R1, #+0]
   \   00000876   0xE75C             B.N      ??CenterLineGetNormal_61
   \                     ??CenterLineGetNormal_63: (+1)
   \   00000878   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000087A   0x2801             CMP      R0,#+1
   \   0000087C   0xF040 0x80ED      BNE.W    ??CenterLineGetNormal_69
   \   00000880   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000882   0x2901             CMP      R1,#+1
   \   00000884   0xF040 0x80E9      BNE.W    ??CenterLineGetNormal_69
   \   00000888   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000088A   0x2B01             CMP      R3,#+1
   \   0000088C   0xF040 0x80E5      BNE.W    ??CenterLineGetNormal_69
   \   00000890   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000892   0x2A01             CMP      R2,#+1
   \   00000894   0xF040 0x80E1      BNE.W    ??CenterLineGetNormal_69
   \   00000898   0xF8DF 0x0558      LDR.W    R0,??CenterLineGetNormal_0+0xC
   \   0000089C   0x7800             LDRB     R0,[R0, #+0]
   \   0000089E   0xF8DF 0x1550      LDR.W    R1,??CenterLineGetNormal_0+0x8
   \   000008A2   0x7809             LDRB     R1,[R1, #+0]
   \   000008A4   0x1A40             SUBS     R0,R0,R1
   \   000008A6   0x2806             CMP      R0,#+6
   \   000008A8   0xDB36             BLT.N    ??CenterLineGetNormal_70
   \   000008AA   0xF8DF 0x0558      LDR.W    R0,??CenterLineGetNormal_0+0x1C
   \   000008AE   0xF8DF 0x1544      LDR.W    R1,??CenterLineGetNormal_0+0xC
   \   000008B2   0x7809             LDRB     R1,[R1, #+0]
   \   000008B4   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   000008B8   0xF8DF 0x1548      LDR.W    R1,??CenterLineGetNormal_0+0x1C
   \   000008BC   0xF8DF 0x2534      LDR.W    R2,??CenterLineGetNormal_0+0xC
   \   000008C0   0x7812             LDRB     R2,[R2, #+0]
   \   000008C2   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   000008C6   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   000008CA   0x1A40             SUBS     R0,R0,R1
   \   000008CC   0x.... 0x....      BL       __aeabi_i2d
   \   000008D0   0x2200             MOVS     R2,#+0
   \   000008D2   0xF8DF 0x3534      LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   000008D6   0x.... 0x....      BL       __aeabi_dmul
   \   000008DA   0x0004             MOVS     R4,R0
   \   000008DC   0x000D             MOVS     R5,R1
   \   000008DE   0xF8DF 0x0524      LDR.W    R0,??CenterLineGetNormal_0+0x1C
   \   000008E2   0xF8DF 0x1510      LDR.W    R1,??CenterLineGetNormal_0+0xC
   \   000008E6   0x7809             LDRB     R1,[R1, #+0]
   \   000008E8   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   000008EC   0x6840             LDR      R0,[R0, #+4]
   \   000008EE   0xF8DF 0x1514      LDR.W    R1,??CenterLineGetNormal_0+0x1C
   \   000008F2   0xF8DF 0x2500      LDR.W    R2,??CenterLineGetNormal_0+0xC
   \   000008F6   0x7812             LDRB     R2,[R2, #+0]
   \   000008F8   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   000008FC   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   00000900   0x1A40             SUBS     R0,R0,R1
   \   00000902   0x.... 0x....      BL       __aeabi_i2d
   \   00000906   0x0002             MOVS     R2,R0
   \   00000908   0x000B             MOVS     R3,R1
   \   0000090A   0x0020             MOVS     R0,R4
   \   0000090C   0x0029             MOVS     R1,R5
   \   0000090E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000912   0x.... 0x....      BL       __aeabi_d2f
   \   00000916   0xE000             B.N      ??CenterLineGetNormal_71
   \                     ??CenterLineGetNormal_70: (+1)
   \   00000918   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGetNormal_71: (+1)
   \   0000091A   0x0001             MOVS     R1,R0
   \   0000091C   0x.... 0x....      BL       __aeabi_fmul
   \   00000920   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   00000924   0x.... 0x....      BL       __aeabi_fadd
   \   00000928   0x.... 0x....      BL       __aeabi_f2d
   \   0000092C   0x.... 0x....      BL       sqrt
   \   00000930   0x2200             MOVS     R2,#+0
   \   00000932   0xF8DF 0x34D4      LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   00000936   0x.... 0x....      BL       __aeabi_dmul
   \   0000093A   0x2200             MOVS     R2,#+0
   \   0000093C   0x.... 0x....      LDR.W    R3,??DataTable45  ;; 0x40690000
   \   00000940   0x.... 0x....      BL       __aeabi_dmul
   \   00000944   0x2200             MOVS     R2,#+0
   \   00000946   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   0000094A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000094E   0x.... 0x....      BL       __aeabi_d2iz
   \   00000952   0x0007             MOVS     R7,R0
   \   00000954   0xF8DF 0x06E4      LDR.W    R0,??CenterLineGetNormal_26+0x4
   \   00000958   0x7800             LDRB     R0,[R0, #+0]
   \   0000095A   0xF8DF 0x16DC      LDR.W    R1,??CenterLineGetNormal_26
   \   0000095E   0x7809             LDRB     R1,[R1, #+0]
   \   00000960   0x1A40             SUBS     R0,R0,R1
   \   00000962   0x2806             CMP      R0,#+6
   \   00000964   0xDB36             BLT.N    ??CenterLineGetNormal_72
   \   00000966   0xF8DF 0x07CC      LDR.W    R0,??CenterLineGetNormal_34+0x4
   \   0000096A   0xF8DF 0x16D0      LDR.W    R1,??CenterLineGetNormal_26+0x4
   \   0000096E   0x7809             LDRB     R1,[R1, #+0]
   \   00000970   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000974   0xF8DF 0x17BC      LDR.W    R1,??CenterLineGetNormal_34+0x4
   \   00000978   0xF8DF 0x26C0      LDR.W    R2,??CenterLineGetNormal_26+0x4
   \   0000097C   0x7812             LDRB     R2,[R2, #+0]
   \   0000097E   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000982   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   00000986   0x1A40             SUBS     R0,R0,R1
   \   00000988   0x.... 0x....      BL       __aeabi_i2d
   \   0000098C   0x2200             MOVS     R2,#+0
   \   0000098E   0xF8DF 0x3478      LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   00000992   0x.... 0x....      BL       __aeabi_dmul
   \   00000996   0x0004             MOVS     R4,R0
   \   00000998   0x000D             MOVS     R5,R1
   \   0000099A   0xF8DF 0x0798      LDR.W    R0,??CenterLineGetNormal_34+0x4
   \   0000099E   0xF8DF 0x169C      LDR.W    R1,??CenterLineGetNormal_26+0x4
   \   000009A2   0x7809             LDRB     R1,[R1, #+0]
   \   000009A4   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   000009A8   0x6840             LDR      R0,[R0, #+4]
   \   000009AA   0xF8DF 0x1788      LDR.W    R1,??CenterLineGetNormal_34+0x4
   \   000009AE   0xF8DF 0x268C      LDR.W    R2,??CenterLineGetNormal_26+0x4
   \   000009B2   0x7812             LDRB     R2,[R2, #+0]
   \   000009B4   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   000009B8   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   000009BC   0x1A40             SUBS     R0,R0,R1
   \   000009BE   0x.... 0x....      BL       __aeabi_i2d
   \   000009C2   0x0002             MOVS     R2,R0
   \   000009C4   0x000B             MOVS     R3,R1
   \   000009C6   0x0020             MOVS     R0,R4
   \   000009C8   0x0029             MOVS     R1,R5
   \   000009CA   0x.... 0x....      BL       __aeabi_ddiv
   \   000009CE   0x.... 0x....      BL       __aeabi_d2f
   \   000009D2   0xE000             B.N      ??CenterLineGetNormal_73
   \                     ??CenterLineGetNormal_72: (+1)
   \   000009D4   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGetNormal_73: (+1)
   \   000009D6   0x0001             MOVS     R1,R0
   \   000009D8   0x.... 0x....      BL       __aeabi_fmul
   \   000009DC   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   000009E0   0x.... 0x....      BL       __aeabi_fadd
   \   000009E4   0x.... 0x....      BL       __aeabi_f2d
   \   000009E8   0x.... 0x....      BL       sqrt
   \   000009EC   0x0002             MOVS     R2,R0
   \   000009EE   0x000B             MOVS     R3,R1
   \   000009F0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000009F2   0x0039             MOVS     R1,R7
   \   000009F4   0x000C             MOVS     R4,R1
   \   000009F6   0x2000             MOVS     R0,#+0
   \   000009F8   0xF8DF 0x140C      LDR.W    R1,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   000009FC   0x.... 0x....      BL       __aeabi_dmul
   \   00000A00   0x2200             MOVS     R2,#+0
   \   00000A02   0x.... 0x....      LDR.W    R3,??DataTable45  ;; 0x40690000
   \   00000A06   0x.... 0x....      BL       __aeabi_dmul
   \   00000A0A   0x2200             MOVS     R2,#+0
   \   00000A0C   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   00000A10   0x.... 0x....      BL       __aeabi_ddiv
   \   00000A14   0x.... 0x....      BL       __aeabi_d2iz
   \   00000A18   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000A1A   0x0021             MOVS     R1,R4
   \   00000A1C   0x.... 0x....      BL       MaxRe
   \   00000A20   0x0007             MOVS     R7,R0
   \   00000A22   0xF8DF 0x03EC      LDR.W    R0,??CenterLineGetNormal_0+0x28
   \   00000A26   0x7800             LDRB     R0,[R0, #+0]
   \   00000A28   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000A2A   0xFB90 0xF0F7      SDIV     R0,R0,R7
   \   00000A2E   0x.... 0x....      BL       __aeabi_i2f
   \   00000A32   0x.... 0x....      LDR.W    R1,??DataTable45_1
   \   00000A36   0x6008             STR      R0,[R1, #+0]
   \   00000A38   0x.... 0x....      LDR.W    R0,??DataTable45_2
   \   00000A3C   0x7800             LDRB     R0,[R0, #+0]
   \   00000A3E   0x2801             CMP      R0,#+1
   \   00000A40   0xF47F 0xAE77      BNE.W    ??CenterLineGetNormal_61
   \   00000A44   0xF8DF 0x03C8      LDR.W    R0,??CenterLineGetNormal_0+0x28
   \   00000A48   0x7801             LDRB     R1,[R0, #+0]
   \   00000A4A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000A4C   0x0038             MOVS     R0,R7
   \   00000A4E   0x.... 0x....      BL       MaxRe
   \   00000A52   0xF8DF 0x13BC      LDR.W    R1,??CenterLineGetNormal_0+0x28
   \   00000A56   0x7008             STRB     R0,[R1, #+0]
   \   00000A58   0xE66B             B.N      ??CenterLineGetNormal_61
   \                     ??CenterLineGetNormal_69: (+1)
   \   00000A5A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000A5C   0x2900             CMP      R1,#+0
   \   00000A5E   0xD104             BNE.N    ??CenterLineGetNormal_74
   \   00000A60   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000A62   0x2A00             CMP      R2,#+0
   \   00000A64   0xD101             BNE.N    ??CenterLineGetNormal_74
   \   00000A66   0x2000             MOVS     R0,#+0
   \   00000A68   0xE426             B.N      ??CenterLineGetNormal_4
   \                     ??CenterLineGetNormal_74: (+1)
   \   00000A6A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000A6C   0x2801             CMP      R0,#+1
   \   00000A6E   0xD16E             BNE.N    ??CenterLineGetNormal_75
   \   00000A70   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000A72   0x2B00             CMP      R3,#+0
   \   00000A74   0xD16B             BNE.N    ??CenterLineGetNormal_75
   \   00000A76   0xF8DF 0x037C      LDR.W    R0,??CenterLineGetNormal_0+0xC
   \   00000A7A   0x7800             LDRB     R0,[R0, #+0]
   \   00000A7C   0x49DC             LDR.N    R1,??CenterLineGetNormal_0+0x8
   \   00000A7E   0x7809             LDRB     R1,[R1, #+0]
   \   00000A80   0x1A40             SUBS     R0,R0,R1
   \   00000A82   0x2806             CMP      R0,#+6
   \   00000A84   0xDB2D             BLT.N    ??CenterLineGetNormal_76
   \   00000A86   0x48DF             LDR.N    R0,??CenterLineGetNormal_0+0x1C
   \   00000A88   0x49DA             LDR.N    R1,??CenterLineGetNormal_0+0xC
   \   00000A8A   0x7809             LDRB     R1,[R1, #+0]
   \   00000A8C   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000A90   0x49DC             LDR.N    R1,??CenterLineGetNormal_0+0x1C
   \   00000A92   0x4AD8             LDR.N    R2,??CenterLineGetNormal_0+0xC
   \   00000A94   0x7812             LDRB     R2,[R2, #+0]
   \   00000A96   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000A9A   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   00000A9E   0x1A40             SUBS     R0,R0,R1
   \   00000AA0   0x.... 0x....      BL       __aeabi_i2d
   \   00000AA4   0x2200             MOVS     R2,#+0
   \   00000AA6   0x4BD8             LDR.N    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   00000AA8   0x.... 0x....      BL       __aeabi_dmul
   \   00000AAC   0x0004             MOVS     R4,R0
   \   00000AAE   0x000D             MOVS     R5,R1
   \   00000AB0   0x48D4             LDR.N    R0,??CenterLineGetNormal_0+0x1C
   \   00000AB2   0x49D0             LDR.N    R1,??CenterLineGetNormal_0+0xC
   \   00000AB4   0x7809             LDRB     R1,[R1, #+0]
   \   00000AB6   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000ABA   0x6840             LDR      R0,[R0, #+4]
   \   00000ABC   0x49D1             LDR.N    R1,??CenterLineGetNormal_0+0x1C
   \   00000ABE   0x4ACD             LDR.N    R2,??CenterLineGetNormal_0+0xC
   \   00000AC0   0x7812             LDRB     R2,[R2, #+0]
   \   00000AC2   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000AC6   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   00000ACA   0x1A40             SUBS     R0,R0,R1
   \   00000ACC   0x.... 0x....      BL       __aeabi_i2d
   \   00000AD0   0x0002             MOVS     R2,R0
   \   00000AD2   0x000B             MOVS     R3,R1
   \   00000AD4   0x0020             MOVS     R0,R4
   \   00000AD6   0x0029             MOVS     R1,R5
   \   00000AD8   0x.... 0x....      BL       __aeabi_ddiv
   \   00000ADC   0x.... 0x....      BL       __aeabi_d2f
   \   00000AE0   0xE000             B.N      ??CenterLineGetNormal_77
   \                     ??CenterLineGetNormal_76: (+1)
   \   00000AE2   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGetNormal_77: (+1)
   \   00000AE4   0x0001             MOVS     R1,R0
   \   00000AE6   0x.... 0x....      BL       __aeabi_fmul
   \   00000AEA   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   00000AEE   0x.... 0x....      BL       __aeabi_fadd
   \   00000AF2   0x.... 0x....      BL       __aeabi_f2d
   \   00000AF6   0x.... 0x....      BL       sqrt
   \   00000AFA   0x2200             MOVS     R2,#+0
   \   00000AFC   0x4BC2             LDR.N    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   00000AFE   0x.... 0x....      BL       __aeabi_dmul
   \   00000B02   0x2200             MOVS     R2,#+0
   \   00000B04   0x.... 0x....      LDR.W    R3,??DataTable45  ;; 0x40690000
   \   00000B08   0x.... 0x....      BL       __aeabi_dmul
   \   00000B0C   0x2200             MOVS     R2,#+0
   \   00000B0E   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   00000B12   0x.... 0x....      BL       __aeabi_ddiv
   \   00000B16   0x.... 0x....      BL       __aeabi_d2iz
   \   00000B1A   0x0007             MOVS     R7,R0
   \   00000B1C   0x48BC             LDR.N    R0,??CenterLineGetNormal_0+0x28
   \   00000B1E   0x7800             LDRB     R0,[R0, #+0]
   \   00000B20   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000B22   0xFB90 0xF0F7      SDIV     R0,R0,R7
   \   00000B26   0x.... 0x....      BL       __aeabi_i2f
   \   00000B2A   0x.... 0x....      LDR.W    R1,??DataTable45_1
   \   00000B2E   0x6008             STR      R0,[R1, #+0]
   \   00000B30   0x.... 0x....      LDR.W    R0,??DataTable45_2
   \   00000B34   0x7800             LDRB     R0,[R0, #+0]
   \   00000B36   0x2801             CMP      R0,#+1
   \   00000B38   0xF47F 0xADFB      BNE.W    ??CenterLineGetNormal_61
   \   00000B3C   0x48B4             LDR.N    R0,??CenterLineGetNormal_0+0x28
   \   00000B3E   0x7801             LDRB     R1,[R0, #+0]
   \   00000B40   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000B42   0x0038             MOVS     R0,R7
   \   00000B44   0x.... 0x....      BL       MaxRe
   \   00000B48   0x49B1             LDR.N    R1,??CenterLineGetNormal_0+0x28
   \   00000B4A   0x7008             STRB     R0,[R1, #+0]
   \   00000B4C   0xE5F1             B.N      ??CenterLineGetNormal_61
   \                     ??CenterLineGetNormal_75: (+1)
   \   00000B4E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000B50   0x2800             CMP      R0,#+0
   \   00000B52   0xD177             BNE.N    ??CenterLineGetNormal_78
   \   00000B54   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000B56   0x2B01             CMP      R3,#+1
   \   00000B58   0xD174             BNE.N    ??CenterLineGetNormal_78
   \   00000B5A   0xF8DF 0x04E0      LDR.W    R0,??CenterLineGetNormal_26+0x4
   \   00000B5E   0x7800             LDRB     R0,[R0, #+0]
   \   00000B60   0xF8DF 0x14D4      LDR.W    R1,??CenterLineGetNormal_26
   \   00000B64   0x7809             LDRB     R1,[R1, #+0]
   \   00000B66   0x1A40             SUBS     R0,R0,R1
   \   00000B68   0x2806             CMP      R0,#+6
   \   00000B6A   0xDB35             BLT.N    ??CenterLineGetNormal_79
   \   00000B6C   0xF8DF 0x05C4      LDR.W    R0,??CenterLineGetNormal_34+0x4
   \   00000B70   0xF8DF 0x14C8      LDR.W    R1,??CenterLineGetNormal_26+0x4
   \   00000B74   0x7809             LDRB     R1,[R1, #+0]
   \   00000B76   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000B7A   0xF8DF 0x15B8      LDR.W    R1,??CenterLineGetNormal_34+0x4
   \   00000B7E   0xF8DF 0x24BC      LDR.W    R2,??CenterLineGetNormal_26+0x4
   \   00000B82   0x7812             LDRB     R2,[R2, #+0]
   \   00000B84   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000B88   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   00000B8C   0x1A40             SUBS     R0,R0,R1
   \   00000B8E   0x.... 0x....      BL       __aeabi_i2d
   \   00000B92   0x2200             MOVS     R2,#+0
   \   00000B94   0x4B9C             LDR.N    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   00000B96   0x.... 0x....      BL       __aeabi_dmul
   \   00000B9A   0x0004             MOVS     R4,R0
   \   00000B9C   0x000D             MOVS     R5,R1
   \   00000B9E   0xF8DF 0x0594      LDR.W    R0,??CenterLineGetNormal_34+0x4
   \   00000BA2   0xF8DF 0x1498      LDR.W    R1,??CenterLineGetNormal_26+0x4
   \   00000BA6   0x7809             LDRB     R1,[R1, #+0]
   \   00000BA8   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000BAC   0x6840             LDR      R0,[R0, #+4]
   \   00000BAE   0xF8DF 0x1584      LDR.W    R1,??CenterLineGetNormal_34+0x4
   \   00000BB2   0xF8DF 0x2488      LDR.W    R2,??CenterLineGetNormal_26+0x4
   \   00000BB6   0x7812             LDRB     R2,[R2, #+0]
   \   00000BB8   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000BBC   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   00000BC0   0x1A40             SUBS     R0,R0,R1
   \   00000BC2   0x.... 0x....      BL       __aeabi_i2d
   \   00000BC6   0x0002             MOVS     R2,R0
   \   00000BC8   0x000B             MOVS     R3,R1
   \   00000BCA   0x0020             MOVS     R0,R4
   \   00000BCC   0x0029             MOVS     R1,R5
   \   00000BCE   0x.... 0x....      BL       __aeabi_ddiv
   \   00000BD2   0x.... 0x....      BL       __aeabi_d2f
   \   00000BD6   0xE000             B.N      ??CenterLineGetNormal_80
   \                     ??CenterLineGetNormal_79: (+1)
   \   00000BD8   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGetNormal_80: (+1)
   \   00000BDA   0x0001             MOVS     R1,R0
   \   00000BDC   0x.... 0x....      BL       __aeabi_fmul
   \   00000BE0   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   00000BE4   0x.... 0x....      BL       __aeabi_fadd
   \   00000BE8   0x.... 0x....      BL       __aeabi_f2d
   \   00000BEC   0x.... 0x....      BL       sqrt
   \   00000BF0   0x2200             MOVS     R2,#+0
   \   00000BF2   0x4B85             LDR.N    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   00000BF4   0x.... 0x....      BL       __aeabi_dmul
   \   00000BF8   0x2200             MOVS     R2,#+0
   \   00000BFA   0x.... 0x....      LDR.W    R3,??DataTable45  ;; 0x40690000
   \   00000BFE   0x.... 0x....      BL       __aeabi_dmul
   \   00000C02   0x2200             MOVS     R2,#+0
   \   00000C04   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   00000C08   0x.... 0x....      BL       __aeabi_ddiv
   \   00000C0C   0x.... 0x....      BL       __aeabi_d2iz
   \   00000C10   0x0007             MOVS     R7,R0
   \   00000C12   0x487F             LDR.N    R0,??CenterLineGetNormal_0+0x28
   \   00000C14   0x7800             LDRB     R0,[R0, #+0]
   \   00000C16   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000C18   0xFB90 0xF0F7      SDIV     R0,R0,R7
   \   00000C1C   0x.... 0x....      BL       __aeabi_i2f
   \   00000C20   0x.... 0x....      LDR.W    R1,??DataTable45_1
   \   00000C24   0x6008             STR      R0,[R1, #+0]
   \   00000C26   0x.... 0x....      LDR.W    R0,??DataTable45_2
   \   00000C2A   0x7800             LDRB     R0,[R0, #+0]
   \   00000C2C   0x2801             CMP      R0,#+1
   \   00000C2E   0xF47F 0xAD80      BNE.W    ??CenterLineGetNormal_61
   \   00000C32   0x4877             LDR.N    R0,??CenterLineGetNormal_0+0x28
   \   00000C34   0x7801             LDRB     R1,[R0, #+0]
   \   00000C36   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000C38   0x0038             MOVS     R0,R7
   \   00000C3A   0x.... 0x....      BL       MaxRe
   \   00000C3E   0x4974             LDR.N    R1,??CenterLineGetNormal_0+0x28
   \   00000C40   0x7008             STRB     R0,[R1, #+0]
   \   00000C42   0xE576             B.N      ??CenterLineGetNormal_61
   \                     ??CenterLineGetNormal_78: (+1)
   \   00000C44   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000C46   0x2800             CMP      R0,#+0
   \   00000C48   0xF040 0x80E8      BNE.W    ??CenterLineGetNormal_81
   \   00000C4C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000C4E   0x2B00             CMP      R3,#+0
   \   00000C50   0xF040 0x80E4      BNE.W    ??CenterLineGetNormal_81
   \   00000C54   0x4867             LDR.N    R0,??CenterLineGetNormal_0+0xC
   \   00000C56   0x7800             LDRB     R0,[R0, #+0]
   \   00000C58   0x4965             LDR.N    R1,??CenterLineGetNormal_0+0x8
   \   00000C5A   0x7809             LDRB     R1,[R1, #+0]
   \   00000C5C   0x1A40             SUBS     R0,R0,R1
   \   00000C5E   0x2806             CMP      R0,#+6
   \   00000C60   0xDB2D             BLT.N    ??CenterLineGetNormal_82
   \   00000C62   0x4868             LDR.N    R0,??CenterLineGetNormal_0+0x1C
   \   00000C64   0x4963             LDR.N    R1,??CenterLineGetNormal_0+0xC
   \   00000C66   0x7809             LDRB     R1,[R1, #+0]
   \   00000C68   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000C6C   0x4965             LDR.N    R1,??CenterLineGetNormal_0+0x1C
   \   00000C6E   0x4A61             LDR.N    R2,??CenterLineGetNormal_0+0xC
   \   00000C70   0x7812             LDRB     R2,[R2, #+0]
   \   00000C72   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000C76   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   00000C7A   0x1A40             SUBS     R0,R0,R1
   \   00000C7C   0x.... 0x....      BL       __aeabi_i2d
   \   00000C80   0x2200             MOVS     R2,#+0
   \   00000C82   0x4B61             LDR.N    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   00000C84   0x.... 0x....      BL       __aeabi_dmul
   \   00000C88   0x0004             MOVS     R4,R0
   \   00000C8A   0x000D             MOVS     R5,R1
   \   00000C8C   0x485D             LDR.N    R0,??CenterLineGetNormal_0+0x1C
   \   00000C8E   0x4959             LDR.N    R1,??CenterLineGetNormal_0+0xC
   \   00000C90   0x7809             LDRB     R1,[R1, #+0]
   \   00000C92   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000C96   0x6840             LDR      R0,[R0, #+4]
   \   00000C98   0x495A             LDR.N    R1,??CenterLineGetNormal_0+0x1C
   \   00000C9A   0x4A56             LDR.N    R2,??CenterLineGetNormal_0+0xC
   \   00000C9C   0x7812             LDRB     R2,[R2, #+0]
   \   00000C9E   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000CA2   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   00000CA6   0x1A40             SUBS     R0,R0,R1
   \   00000CA8   0x.... 0x....      BL       __aeabi_i2d
   \   00000CAC   0x0002             MOVS     R2,R0
   \   00000CAE   0x000B             MOVS     R3,R1
   \   00000CB0   0x0020             MOVS     R0,R4
   \   00000CB2   0x0029             MOVS     R1,R5
   \   00000CB4   0x.... 0x....      BL       __aeabi_ddiv
   \   00000CB8   0x.... 0x....      BL       __aeabi_d2f
   \   00000CBC   0xE000             B.N      ??CenterLineGetNormal_83
   \                     ??CenterLineGetNormal_82: (+1)
   \   00000CBE   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGetNormal_83: (+1)
   \   00000CC0   0x0001             MOVS     R1,R0
   \   00000CC2   0x.... 0x....      BL       __aeabi_fmul
   \   00000CC6   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   00000CCA   0x.... 0x....      BL       __aeabi_fadd
   \   00000CCE   0x.... 0x....      BL       __aeabi_f2d
   \   00000CD2   0x.... 0x....      BL       sqrt
   \   00000CD6   0x2200             MOVS     R2,#+0
   \   00000CD8   0x4B4B             LDR.N    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   00000CDA   0x.... 0x....      BL       __aeabi_dmul
   \   00000CDE   0x2200             MOVS     R2,#+0
   \   00000CE0   0x.... 0x....      LDR.W    R3,??DataTable45  ;; 0x40690000
   \   00000CE4   0x.... 0x....      BL       __aeabi_dmul
   \   00000CE8   0x2200             MOVS     R2,#+0
   \   00000CEA   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   00000CEE   0x.... 0x....      BL       __aeabi_ddiv
   \   00000CF2   0x.... 0x....      BL       __aeabi_d2iz
   \   00000CF6   0x0007             MOVS     R7,R0
   \   00000CF8   0x48D0             LDR.N    R0,??CenterLineGetNormal_26+0x4
   \   00000CFA   0x7800             LDRB     R0,[R0, #+0]
   \   00000CFC   0x49CE             LDR.N    R1,??CenterLineGetNormal_26
   \   00000CFE   0x7809             LDRB     R1,[R1, #+0]
   \   00000D00   0x1A40             SUBS     R0,R0,R1
   \   00000D02   0x2806             CMP      R0,#+6
   \   00000D04   0xDB31             BLT.N    ??CenterLineGetNormal_84
   \   00000D06   0xF8DF 0x042C      LDR.W    R0,??CenterLineGetNormal_34+0x4
   \   00000D0A   0x49CC             LDR.N    R1,??CenterLineGetNormal_26+0x4
   \   00000D0C   0x7809             LDRB     R1,[R1, #+0]
   \   00000D0E   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000D12   0xF8DF 0x1420      LDR.W    R1,??CenterLineGetNormal_34+0x4
   \   00000D16   0x4AC9             LDR.N    R2,??CenterLineGetNormal_26+0x4
   \   00000D18   0x7812             LDRB     R2,[R2, #+0]
   \   00000D1A   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000D1E   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   00000D22   0x1A40             SUBS     R0,R0,R1
   \   00000D24   0x.... 0x....      BL       __aeabi_i2d
   \   00000D28   0x2200             MOVS     R2,#+0
   \   00000D2A   0x4B37             LDR.N    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   00000D2C   0x.... 0x....      BL       __aeabi_dmul
   \   00000D30   0x0004             MOVS     R4,R0
   \   00000D32   0x000D             MOVS     R5,R1
   \   00000D34   0xF8DF 0x03FC      LDR.W    R0,??CenterLineGetNormal_34+0x4
   \   00000D38   0x49C0             LDR.N    R1,??CenterLineGetNormal_26+0x4
   \   00000D3A   0x7809             LDRB     R1,[R1, #+0]
   \   00000D3C   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000D40   0x6840             LDR      R0,[R0, #+4]
   \   00000D42   0xF8DF 0x13F0      LDR.W    R1,??CenterLineGetNormal_34+0x4
   \   00000D46   0x4ABD             LDR.N    R2,??CenterLineGetNormal_26+0x4
   \   00000D48   0x7812             LDRB     R2,[R2, #+0]
   \   00000D4A   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000D4E   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   00000D52   0x1A40             SUBS     R0,R0,R1
   \   00000D54   0x.... 0x....      BL       __aeabi_i2d
   \   00000D58   0x0002             MOVS     R2,R0
   \   00000D5A   0x000B             MOVS     R3,R1
   \   00000D5C   0x0020             MOVS     R0,R4
   \   00000D5E   0x0029             MOVS     R1,R5
   \   00000D60   0x.... 0x....      BL       __aeabi_ddiv
   \   00000D64   0x.... 0x....      BL       __aeabi_d2f
   \   00000D68   0xE000             B.N      ??CenterLineGetNormal_85
   \                     ??CenterLineGetNormal_84: (+1)
   \   00000D6A   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGetNormal_85: (+1)
   \   00000D6C   0x0001             MOVS     R1,R0
   \   00000D6E   0x.... 0x....      BL       __aeabi_fmul
   \   00000D72   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   00000D76   0x.... 0x....      BL       __aeabi_fadd
   \   00000D7A   0x.... 0x....      BL       __aeabi_f2d
   \   00000D7E   0x.... 0x....      BL       sqrt
   \   00000D82   0x0002             MOVS     R2,R0
   \   00000D84   0x000B             MOVS     R3,R1
   \   00000D86   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000D88   0x0039             MOVS     R1,R7
   \   00000D8A   0x000C             MOVS     R4,R1
   \   00000D8C   0x2000             MOVS     R0,#+0
   \   00000D8E   0x491E             LDR.N    R1,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
   \   00000D90   0x.... 0x....      BL       __aeabi_dmul
   \   00000D94   0x2200             MOVS     R2,#+0
   \   00000D96   0x.... 0x....      LDR.W    R3,??DataTable45  ;; 0x40690000
   \   00000D9A   0x.... 0x....      BL       __aeabi_dmul
   \   00000D9E   0x2200             MOVS     R2,#+0
   \   00000DA0   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   00000DA4   0x.... 0x....      BL       __aeabi_ddiv
   \   00000DA8   0x.... 0x....      BL       __aeabi_d2iz
   \   00000DAC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000DAE   0x0021             MOVS     R1,R4
   \   00000DB0   0x.... 0x....      BL       MaxRe
   \   00000DB4   0x0007             MOVS     R7,R0
   \   00000DB6   0x4816             LDR.N    R0,??CenterLineGetNormal_0+0x28
   \   00000DB8   0x7800             LDRB     R0,[R0, #+0]
   \   00000DBA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000DBC   0xFB90 0xF0F7      SDIV     R0,R0,R7
   \   00000DC0   0x.... 0x....      BL       __aeabi_i2f
   \   00000DC4   0x.... 0x....      LDR.W    R1,??DataTable45_1
   \   00000DC8   0x6008             STR      R0,[R1, #+0]
   \   00000DCA   0x.... 0x....      LDR.W    R0,??DataTable45_2
   \   00000DCE   0x7800             LDRB     R0,[R0, #+0]
   \   00000DD0   0x2801             CMP      R0,#+1
   \   00000DD2   0xF47F 0xACAE      BNE.W    ??CenterLineGetNormal_61
   \   00000DD6   0x480E             LDR.N    R0,??CenterLineGetNormal_0+0x28
   \   00000DD8   0x7801             LDRB     R1,[R0, #+0]
   \   00000DDA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000DDC   0x0038             MOVS     R0,R7
   \   00000DDE   0x.... 0x....      BL       MaxRe
   \   00000DE2   0x490B             LDR.N    R1,??CenterLineGetNormal_0+0x28
   \   00000DE4   0x7008             STRB     R0,[R1, #+0]
   \   00000DE6   0xE4A4             B.N      ??CenterLineGetNormal_61
   \                     ??CenterLineGetNormal_0:
   \   00000DE8   0x........         DC32     BlackLeftDone
   \   00000DEC   0x........         DC32     BlackRightDone
   \   00000DF0   0x........         DC32     BlackLeftHeadLine
   \   00000DF4   0x........         DC32     BlackLeftEndLine
   \   00000DF8   0x........         DC32     CenterHeadLine
   \   00000DFC   0x........         DC32     CenterEndLine
   \   00000E00   0x........         DC32     BlackLeftLoc
   \   00000E04   0x........         DC32     BlackUdisLeftLocation
   \   00000E08   0x3FF00000         DC32     0x3ff00000
   \   00000E0C   0x........         DC32     CenterLineHalfWidth
   \   00000E10   0x........         DC32     RoadHalfWidth
   \   00000E14   0x........         DC32     buXianCount
   \   00000E18   0x........         DC32     CenterLineLoc
   \                     ??CenterLineGetNormal_81: (+1)
   \   00000E1C   0x2000             MOVS     R0,#+0
   \   00000E1E   0xF7FF 0xBA4B      B.W      ??CenterLineGetNormal_4
   \                     ??CenterLineGetNormal_86: (+1)
   \   00000E22   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000E24   0x2F00             CMP      R7,#+0
   \   00000E26   0xD100             BNE.N    ??CenterLineGetNormal_87
   \   00000E28   0x2700             MOVS     R7,#+0
   \                     ??CenterLineGetNormal_87: (+1)
   \   00000E2A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000E2C   0x.... 0x....      LDR.W    R0,??DataTable48
   \   00000E30   0xF820 0x7016      STRH     R7,[R0, R6, LSL #+1]
   \                     ??CenterLineGetNormal_88: (+1)
   \   00000E34   0x1C76             ADDS     R6,R6,#+1
   \                     ??CenterLineGetNormal_62: (+1)
   \   00000E36   0x2E3C             CMP      R6,#+60
   \   00000E38   0xF6BF 0xAA3D      BGE.W    ??CenterLineGetNormal_24
   \   00000E3C   0x.... 0x....      LDR.W    R0,??DataTable48_1
   \   00000E40   0x2103             MOVS     R1,#+3
   \   00000E42   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000E46   0x7800             LDRB     R0,[R0, #+0]
   \   00000E48   0x28FF             CMP      R0,#+255
   \   00000E4A   0xD01C             BEQ.N    ??CenterLineGetNormal_89
   \   00000E4C   0x48B8             LDR.N    R0,??CenterLineGetNormal_34
   \   00000E4E   0x2103             MOVS     R1,#+3
   \   00000E50   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000E54   0x7800             LDRB     R0,[R0, #+0]
   \   00000E56   0x28FF             CMP      R0,#+255
   \   00000E58   0xD015             BEQ.N    ??CenterLineGetNormal_89
   \   00000E5A   0xF05F 0x0800      MOVS     R8,#+0
   \   00000E5E   0x.... 0x....      LDR.W    R0,??DataTable48_1
   \   00000E62   0x2103             MOVS     R1,#+3
   \   00000E64   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000E68   0x7800             LDRB     R0,[R0, #+0]
   \   00000E6A   0x49B1             LDR.N    R1,??CenterLineGetNormal_34
   \   00000E6C   0x2203             MOVS     R2,#+3
   \   00000E6E   0xFB02 0x1106      MLA      R1,R2,R6,R1
   \   00000E72   0x7809             LDRB     R1,[R1, #+0]
   \   00000E74   0x1808             ADDS     R0,R1,R0
   \   00000E76   0x2102             MOVS     R1,#+2
   \   00000E78   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000E7C   0x.... 0x....      LDR.W    R1,??DataTable48
   \   00000E80   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
   \   00000E84   0xE7D6             B.N      ??CenterLineGetNormal_88
   \                     ??CenterLineGetNormal_89: (+1)
   \   00000E86   0x.... 0x....      LDR.W    R0,??DataTable48_1
   \   00000E8A   0x2103             MOVS     R1,#+3
   \   00000E8C   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000E90   0x7800             LDRB     R0,[R0, #+0]
   \   00000E92   0x28FF             CMP      R0,#+255
   \   00000E94   0xD006             BEQ.N    ??CenterLineGetNormal_90
   \   00000E96   0x48A6             LDR.N    R0,??CenterLineGetNormal_34
   \   00000E98   0x2103             MOVS     R1,#+3
   \   00000E9A   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000E9E   0x7800             LDRB     R0,[R0, #+0]
   \   00000EA0   0x28FF             CMP      R0,#+255
   \   00000EA2   0xD1C7             BNE.N    ??CenterLineGetNormal_88
   \                     ??CenterLineGetNormal_90: (+1)
   \   00000EA4   0x.... 0x....      LDR.W    R0,??DataTable48_2
   \   00000EA8   0x7800             LDRB     R0,[R0, #+0]
   \   00000EAA   0x2802             CMP      R0,#+2
   \   00000EAC   0xD004             BEQ.N    ??CenterLineGetNormal_91
   \   00000EAE   0x.... 0x....      LDR.W    R0,??DataTable48_3
   \   00000EB2   0x7800             LDRB     R0,[R0, #+0]
   \   00000EB4   0x2802             CMP      R0,#+2
   \   00000EB6   0xD107             BNE.N    ??CenterLineGetNormal_92
   \                     ??CenterLineGetNormal_91: (+1)
   \   00000EB8   0x.... 0x....      LDR.W    R0,??DataTable48_4
   \   00000EBC   0x8800             LDRH     R0,[R0, #+0]
   \   00000EBE   0x1E40             SUBS     R0,R0,#+1
   \   00000EC0   0x.... 0x....      LDR.W    R1,??DataTable48_4
   \   00000EC4   0x8008             STRH     R0,[R1, #+0]
   \   00000EC6   0xE0B2             B.N      ??CenterLineGetNormal_93
   \                     ??CenterLineGetNormal_92: (+1)
   \   00000EC8   0x485B             LDR.N    R0,??CenterLineGetNormal_26
   \   00000ECA   0x7800             LDRB     R0,[R0, #+0]
   \   00000ECC   0x2819             CMP      R0,#+25
   \   00000ECE   0xDB09             BLT.N    ??CenterLineGetNormal_94
   \   00000ED0   0x.... 0x....      LDR.W    R0,??DataTable48_5
   \   00000ED4   0x7800             LDRB     R0,[R0, #+0]
   \   00000ED6   0x2819             CMP      R0,#+25
   \   00000ED8   0xDB04             BLT.N    ??CenterLineGetNormal_94
   \   00000EDA   0x2000             MOVS     R0,#+0
   \   00000EDC   0x.... 0x....      LDR.W    R1,??DataTable48_4
   \   00000EE0   0x8008             STRH     R0,[R1, #+0]
   \   00000EE2   0xE0A4             B.N      ??CenterLineGetNormal_93
   \                     ??CenterLineGetNormal_94: (+1)
   \   00000EE4   0x.... 0x....      LDR.W    R0,??DataTable48_5
   \   00000EE8   0x7800             LDRB     R0,[R0, #+0]
   \   00000EEA   0x2815             CMP      R0,#+21
   \   00000EEC   0xDA08             BGE.N    ??CenterLineGetNormal_95
   \   00000EEE   0x4852             LDR.N    R0,??CenterLineGetNormal_26
   \   00000EF0   0x7800             LDRB     R0,[R0, #+0]
   \   00000EF2   0x2832             CMP      R0,#+50
   \   00000EF4   0xDB04             BLT.N    ??CenterLineGetNormal_95
   \   00000EF6   0x2000             MOVS     R0,#+0
   \   00000EF8   0x.... 0x....      LDR.W    R1,??DataTable48_4
   \   00000EFC   0x8008             STRH     R0,[R1, #+0]
   \   00000EFE   0xE096             B.N      ??CenterLineGetNormal_93
   \                     ??CenterLineGetNormal_95: (+1)
   \   00000F00   0x.... 0x....      LDR.W    R0,??DataTable48_6
   \   00000F04   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000F08   0x2800             CMP      R0,#+0
   \   00000F0A   0xD505             BPL.N    ??CenterLineGetNormal_96
   \   00000F0C   0x.... 0x....      LDR.W    R0,??DataTable48_7
   \   00000F10   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000F14   0x2801             CMP      R0,#+1
   \   00000F16   0xDA0B             BGE.N    ??CenterLineGetNormal_97
   \                     ??CenterLineGetNormal_96: (+1)
   \   00000F18   0x.... 0x....      LDR.W    R0,??DataTable48_6
   \   00000F1C   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000F20   0x2801             CMP      R0,#+1
   \   00000F22   0xDB0A             BLT.N    ??CenterLineGetNormal_98
   \   00000F24   0x.... 0x....      LDR.W    R0,??DataTable48_7
   \   00000F28   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000F2C   0x2800             CMP      R0,#+0
   \   00000F2E   0xD504             BPL.N    ??CenterLineGetNormal_98
   \                     ??CenterLineGetNormal_97: (+1)
   \   00000F30   0x2000             MOVS     R0,#+0
   \   00000F32   0x.... 0x....      LDR.W    R1,??DataTable48_4
   \   00000F36   0x8008             STRH     R0,[R1, #+0]
   \   00000F38   0xE079             B.N      ??CenterLineGetNormal_93
   \                     ??CenterLineGetNormal_98: (+1)
   \   00000F3A   0x.... 0x....      LDR.W    R0,??DataTable48_5
   \   00000F3E   0x7800             LDRB     R0,[R0, #+0]
   \   00000F40   0x2806             CMP      R0,#+6
   \   00000F42   0xDA04             BGE.N    ??CenterLineGetNormal_99
   \   00000F44   0x2000             MOVS     R0,#+0
   \   00000F46   0x.... 0x....      LDR.W    R1,??DataTable48_4
   \   00000F4A   0x8008             STRH     R0,[R1, #+0]
   \   00000F4C   0xE06F             B.N      ??CenterLineGetNormal_93
   \                     ??CenterLineGetNormal_99: (+1)
   \   00000F4E   0x.... 0x....      LDR.W    R0,??DataTable48_5
   \   00000F52   0x7800             LDRB     R0,[R0, #+0]
   \   00000F54   0x2815             CMP      R0,#+21
   \   00000F56   0xDA08             BGE.N    ??CenterLineGetNormal_100
   \   00000F58   0x4837             LDR.N    R0,??CenterLineGetNormal_26
   \   00000F5A   0x7800             LDRB     R0,[R0, #+0]
   \   00000F5C   0x282D             CMP      R0,#+45
   \   00000F5E   0xDB04             BLT.N    ??CenterLineGetNormal_100
   \   00000F60   0x2000             MOVS     R0,#+0
   \   00000F62   0x.... 0x....      LDR.W    R1,??DataTable48_4
   \   00000F66   0x8008             STRH     R0,[R1, #+0]
   \   00000F68   0xE061             B.N      ??CenterLineGetNormal_93
   \                     ??CenterLineGetNormal_100: (+1)
   \   00000F6A   0x.... 0x....      LDR.W    R0,??DataTable48_6
   \   00000F6E   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000F72   0x.... 0x....      BL       AbsInt
   \   00000F76   0x2814             CMP      R0,#+20
   \   00000F78   0xDB07             BLT.N    ??CenterLineGetNormal_101
   \   00000F7A   0x.... 0x....      LDR.W    R0,??DataTable48_6
   \   00000F7E   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000F82   0x.... 0x....      BL       AbsInt
   \   00000F86   0x2833             CMP      R0,#+51
   \   00000F88   0xDB0F             BLT.N    ??CenterLineGetNormal_102
   \                     ??CenterLineGetNormal_101: (+1)
   \   00000F8A   0x.... 0x....      LDR.W    R0,??DataTable48_7
   \   00000F8E   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000F92   0x.... 0x....      BL       AbsInt
   \   00000F96   0x2814             CMP      R0,#+20
   \   00000F98   0xDB0C             BLT.N    ??CenterLineGetNormal_103
   \   00000F9A   0x.... 0x....      LDR.W    R0,??DataTable48_7
   \   00000F9E   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000FA2   0x.... 0x....      BL       AbsInt
   \   00000FA6   0x2833             CMP      R0,#+51
   \   00000FA8   0xDA04             BGE.N    ??CenterLineGetNormal_103
   \                     ??CenterLineGetNormal_102: (+1)
   \   00000FAA   0x2000             MOVS     R0,#+0
   \   00000FAC   0x.... 0x....      LDR.W    R1,??DataTable48_4
   \   00000FB0   0x8008             STRH     R0,[R1, #+0]
   \   00000FB2   0xE03C             B.N      ??CenterLineGetNormal_93
   \                     ??CenterLineGetNormal_103: (+1)
   \   00000FB4   0x.... 0x....      LDR.W    R0,??DataTable48_6
   \   00000FB8   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000FBC   0x.... 0x....      BL       AbsInt
   \   00000FC0   0x2833             CMP      R0,#+51
   \   00000FC2   0xDB08             BLT.N    ??CenterLineGetNormal_104
   \   00000FC4   0x.... 0x....      LDR.W    R0,??DataTable48_6
   \   00000FC8   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000FCC   0x.... 0x....      BL       AbsInt
   \   00000FD0   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   00000FD4   0xDD10             BLE.N    ??CenterLineGetNormal_105
   \                     ??CenterLineGetNormal_104: (+1)
   \   00000FD6   0x.... 0x....      LDR.W    R0,??DataTable48_7
   \   00000FDA   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000FDE   0x.... 0x....      BL       AbsInt
   \   00000FE2   0x2833             CMP      R0,#+51
   \   00000FE4   0xDB0D             BLT.N    ??CenterLineGetNormal_106
   \   00000FE6   0x.... 0x....      LDR.W    R0,??DataTable48_7
   \   00000FEA   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000FEE   0x.... 0x....      BL       AbsInt
   \   00000FF2   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   00000FF6   0xDC04             BGT.N    ??CenterLineGetNormal_106
   \                     ??CenterLineGetNormal_105: (+1)
   \   00000FF8   0x2000             MOVS     R0,#+0
   \   00000FFA   0x.... 0x....      LDR.W    R1,??DataTable48_4
   \   00000FFE   0x8008             STRH     R0,[R1, #+0]
   \   00001000   0xE015             B.N      ??CenterLineGetNormal_93
   \                     ??CenterLineGetNormal_106: (+1)
   \   00001002   0x.... 0x....      LDR.W    R0,??DataTable48_6
   \   00001006   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000100A   0x.... 0x....      BL       AbsInt
   \   0000100E   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   00001012   0xDC08             BGT.N    ??CenterLineGetNormal_107
   \   00001014   0x.... 0x....      LDR.W    R0,??DataTable48_7
   \   00001018   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000101C   0x.... 0x....      BL       AbsInt
   \   00001020   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   00001024   0xDD03             BLE.N    ??CenterLineGetNormal_93
   \                     ??CenterLineGetNormal_107: (+1)
   \   00001026   0x2000             MOVS     R0,#+0
   \   00001028   0x.... 0x....      LDR.W    R1,??DataTable48_4
   \   0000102C   0x8008             STRH     R0,[R1, #+0]
   \                     ??CenterLineGetNormal_93: (+1)
   \   0000102E   0xF05F 0x0800      MOVS     R8,#+0
   \   00001032   0x2100             MOVS     R1,#+0
   \   00001034   0x1E70             SUBS     R0,R6,#+1
   \   00001036   0xE004             B.N      ??CenterLineGetNormal_108
   \                     ??CenterLineGetNormal_26:
   \   00001038   0x........         DC32     BlackRightHeadLine
   \   0000103C   0x........         DC32     BlackRightEndLine
   \                     ??CenterLineGetNormal_109: (+1)
   \   00001040   0x1E40             SUBS     R0,R0,#+1
   \                     ??CenterLineGetNormal_108: (+1)
   \   00001042   0x2800             CMP      R0,#+0
   \   00001044   0xD413             BMI.N    ??CenterLineGetNormal_110
   \   00001046   0x.... 0x....      LDR.W    R2,??DataTable48
   \   0000104A   0xF932 0x2010      LDRSH    R2,[R2, R0, LSL #+1]
   \   0000104E   0x2AFF             CMP      R2,#+255
   \   00001050   0xD00A             BEQ.N    ??CenterLineGetNormal_111
   \   00001052   0x.... 0x....      LDR.W    R2,??DataTable48
   \   00001056   0xF832 0x2010      LDRH     R2,[R2, R0, LSL #+1]
   \   0000105A   0xAB03             ADD      R3,SP,#+12
   \   0000105C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000105E   0x54CA             STRB     R2,[R1, R3]
   \   00001060   0xAA04             ADD      R2,SP,#+16
   \   00001062   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00001064   0x5488             STRB     R0,[R1, R2]
   \   00001066   0x1C49             ADDS     R1,R1,#+1
   \                     ??CenterLineGetNormal_111: (+1)
   \   00001068   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000106A   0x2904             CMP      R1,#+4
   \   0000106C   0xD1E8             BNE.N    ??CenterLineGetNormal_109
   \                     ??CenterLineGetNormal_110: (+1)
   \   0000106E   0x2204             MOVS     R2,#+4
   \   00001070   0xA903             ADD      R1,SP,#+12
   \   00001072   0xA804             ADD      R0,SP,#+16
   \   00001074   0x.... 0x....      BL       LeastSquarea1
   \   00001078   0x0004             MOVS     R4,R0
   \   0000107A   0x2304             MOVS     R3,#+4
   \   0000107C   0x0022             MOVS     R2,R4
   \   0000107E   0xA903             ADD      R1,SP,#+12
   \   00001080   0xA804             ADD      R0,SP,#+16
   \   00001082   0x.... 0x....      BL       LeastSquarea0
   \   00001086   0x0005             MOVS     R5,R0
   \   00001088   0xFB06 0x5004      MLA      R0,R6,R4,R5
   \   0000108C   0xF44F 0x717A      MOV      R1,#+1000
   \   00001090   0xFB90 0xF7F1      SDIV     R7,R0,R1
   \   00001094   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00001096   0x2FF9             CMP      R7,#+249
   \   00001098   0xF6FF 0xAEC3      BLT.W    ??CenterLineGetNormal_86
   \   0000109C   0x27F9             MOVS     R7,#+249
   \   0000109E   0xE6C4             B.N      ??CenterLineGetNormal_87
   \                     ??CenterLineGetNormal_50: (+1)
   \   000010A0   0xF05F 0x0800      MOVS     R8,#+0
   \   000010A4   0xF05F 0x0900      MOVS     R9,#+0
   \   000010A8   0x.... 0x....      LDR.W    R0,??DataTable48_8
   \   000010AC   0x7806             LDRB     R6,[R0, #+0]
   \   000010AE   0xE000             B.N      ??CenterLineGetNormal_112
   \                     ??CenterLineGetNormal_113: (+1)
   \   000010B0   0x1E76             SUBS     R6,R6,#+1
   \                     ??CenterLineGetNormal_112: (+1)
   \   000010B2   0x.... 0x....      LDR.W    R0,??DataTable48_1
   \   000010B6   0x2103             MOVS     R1,#+3
   \   000010B8   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   000010BC   0x7800             LDRB     R0,[R0, #+0]
   \   000010BE   0x28FF             CMP      R0,#+255
   \   000010C0   0xD03A             BEQ.N    ??CenterLineGetNormal_114
   \   000010C2   0x481B             LDR.N    R0,??CenterLineGetNormal_34
   \   000010C4   0x2103             MOVS     R1,#+3
   \   000010C6   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   000010CA   0x7800             LDRB     R0,[R0, #+0]
   \   000010CC   0x28FF             CMP      R0,#+255
   \   000010CE   0xD033             BEQ.N    ??CenterLineGetNormal_114
   \   000010D0   0xF05F 0x0800      MOVS     R8,#+0
   \   000010D4   0x.... 0x....      LDR.W    R0,??DataTable48_1
   \   000010D8   0x2103             MOVS     R1,#+3
   \   000010DA   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   000010DE   0x7800             LDRB     R0,[R0, #+0]
   \   000010E0   0x4913             LDR.N    R1,??CenterLineGetNormal_34
   \   000010E2   0x2203             MOVS     R2,#+3
   \   000010E4   0xFB02 0x1106      MLA      R1,R2,R6,R1
   \   000010E8   0x7809             LDRB     R1,[R1, #+0]
   \   000010EA   0x1808             ADDS     R0,R1,R0
   \   000010EC   0x2102             MOVS     R1,#+2
   \   000010EE   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000010F2   0x.... 0x....      LDR.W    R1,??DataTable48
   \   000010F6   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
   \   000010FA   0x480D             LDR.N    R0,??CenterLineGetNormal_34
   \   000010FC   0x.... 0x....      LDR.W    R1,??DataTable48_1
   \   00001100   0x4288             CMP      R0,R1
   \   00001102   0xD30A             BCC.N    ??CenterLineGetNormal_115
   \   00001104   0x480A             LDR.N    R0,??CenterLineGetNormal_34
   \   00001106   0x.... 0x....      LDR.W    R1,??DataTable48_1
   \   0000110A   0x1A40             SUBS     R0,R0,R1
   \   0000110C   0x2102             MOVS     R1,#+2
   \   0000110E   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00001112   0x.... 0x....      LDR.W    R1,??DataTable48_9
   \   00001116   0x7008             STRB     R0,[R1, #+0]
   \   00001118   0xE0FF             B.N      ??CenterLineGetNormal_116
   \                     ??CenterLineGetNormal_115: (+1)
   \   0000111A   0x.... 0x....      LDR.W    R0,??DataTable48_1
   \   0000111E   0x4904             LDR.N    R1,??CenterLineGetNormal_34
   \   00001120   0x1A40             SUBS     R0,R0,R1
   \   00001122   0x2102             MOVS     R1,#+2
   \   00001124   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00001128   0x.... 0x....      LDR.W    R1,??DataTable48_9
   \   0000112C   0x7008             STRB     R0,[R1, #+0]
   \   0000112E   0xE0F4             B.N      ??CenterLineGetNormal_116
   \                     ??CenterLineGetNormal_34:
   \   00001130   0x........         DC32     BlackRightLoc
   \   00001134   0x........         DC32     BlackUdisRightLocation
   \                     ??CenterLineGetNormal_114: (+1)
   \   00001138   0x.... 0x....      LDR.W    R0,??DataTable48_1
   \   0000113C   0x2103             MOVS     R1,#+3
   \   0000113E   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00001142   0x7800             LDRB     R0,[R0, #+0]
   \   00001144   0x28FF             CMP      R0,#+255
   \   00001146   0xD018             BEQ.N    ??CenterLineGetNormal_117
   \   00001148   0x.... 0x....      LDR.W    R0,??DataTable48_10
   \   0000114C   0x2103             MOVS     R1,#+3
   \   0000114E   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00001152   0x7800             LDRB     R0,[R0, #+0]
   \   00001154   0x28FF             CMP      R0,#+255
   \   00001156   0xD110             BNE.N    ??CenterLineGetNormal_117
   \   00001158   0xF05F 0x0800      MOVS     R8,#+0
   \   0000115C   0x.... 0x....      LDR.W    R0,??DataTable48_1
   \   00001160   0x2103             MOVS     R1,#+3
   \   00001162   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00001166   0x7800             LDRB     R0,[R0, #+0]
   \   00001168   0x.... 0x....      LDR.W    R1,??DataTable48_9
   \   0000116C   0x7809             LDRB     R1,[R1, #+0]
   \   0000116E   0x1A40             SUBS     R0,R0,R1
   \   00001170   0x.... 0x....      LDR.W    R1,??DataTable48
   \   00001174   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
   \   00001178   0xE0CF             B.N      ??CenterLineGetNormal_116
   \                     ??CenterLineGetNormal_117: (+1)
   \   0000117A   0x.... 0x....      LDR.W    R0,??DataTable48_1
   \   0000117E   0x2103             MOVS     R1,#+3
   \   00001180   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00001184   0x7800             LDRB     R0,[R0, #+0]
   \   00001186   0x28FF             CMP      R0,#+255
   \   00001188   0xD118             BNE.N    ??CenterLineGetNormal_118
   \   0000118A   0x.... 0x....      LDR.W    R0,??DataTable48_10
   \   0000118E   0x2103             MOVS     R1,#+3
   \   00001190   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00001194   0x7800             LDRB     R0,[R0, #+0]
   \   00001196   0x28FF             CMP      R0,#+255
   \   00001198   0xD010             BEQ.N    ??CenterLineGetNormal_118
   \   0000119A   0xF05F 0x0800      MOVS     R8,#+0
   \   0000119E   0x.... 0x....      LDR.W    R0,??DataTable48_10
   \   000011A2   0x2103             MOVS     R1,#+3
   \   000011A4   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   000011A8   0x7800             LDRB     R0,[R0, #+0]
   \   000011AA   0x.... 0x....      LDR.W    R1,??DataTable48_9
   \   000011AE   0x7809             LDRB     R1,[R1, #+0]
   \   000011B0   0x1808             ADDS     R0,R1,R0
   \   000011B2   0x.... 0x....      LDR.W    R1,??DataTable48
   \   000011B6   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
   \   000011BA   0xE0AE             B.N      ??CenterLineGetNormal_116
   \                     ??CenterLineGetNormal_118: (+1)
   \   000011BC   0x.... 0x....      LDR.W    R0,??DataTable48_1
   \   000011C0   0x2103             MOVS     R1,#+3
   \   000011C2   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   000011C6   0x7800             LDRB     R0,[R0, #+0]
   \   000011C8   0x28FF             CMP      R0,#+255
   \   000011CA   0xF040 0x80A6      BNE.W    ??CenterLineGetNormal_116
   \   000011CE   0x.... 0x....      LDR.W    R0,??DataTable48_10
   \   000011D2   0x2103             MOVS     R1,#+3
   \   000011D4   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   000011D8   0x7800             LDRB     R0,[R0, #+0]
   \   000011DA   0x28FF             CMP      R0,#+255
   \   000011DC   0xF040 0x809D      BNE.W    ??CenterLineGetNormal_116
   \   000011E0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000011E4   0xF1B8 0x0F00      CMP      R8,#+0
   \   000011E8   0xD172             BNE.N    ??CenterLineGetNormal_119
   \   000011EA   0xF05F 0x0801      MOVS     R8,#+1
   \   000011EE   0x1DB0             ADDS     R0,R6,#+6
   \   000011F0   0x283C             CMP      R0,#+60
   \   000011F2   0xDA21             BGE.N    ??CenterLineGetNormal_120
   \   000011F4   0xF05F 0x0900      MOVS     R9,#+0
   \   000011F8   0x2000             MOVS     R0,#+0
   \   000011FA   0xE00D             B.N      ??CenterLineGetNormal_121
   \                     ??CenterLineGetNormal_122: (+1)
   \   000011FC   0x1981             ADDS     R1,R0,R6
   \   000011FE   0x1CC9             ADDS     R1,R1,#+3
   \   00001200   0xAA00             ADD      R2,SP,#+0
   \   00001202   0x5481             STRB     R1,[R0, R2]
   \   00001204   0x.... 0x....      LDR.W    R1,??DataTable48
   \   00001208   0x1982             ADDS     R2,R0,R6
   \   0000120A   0xEB11 0x0142      ADDS     R1,R1,R2, LSL #+1
   \   0000120E   0x88C9             LDRH     R1,[R1, #+6]
   \   00001210   0xAA01             ADD      R2,SP,#+4
   \   00001212   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   \   00001216   0x1C40             ADDS     R0,R0,#+1
   \                     ??CenterLineGetNormal_121: (+1)
   \   00001218   0x2804             CMP      R0,#+4
   \   0000121A   0xDBEF             BLT.N    ??CenterLineGetNormal_122
   \   0000121C   0x2204             MOVS     R2,#+4
   \   0000121E   0xA901             ADD      R1,SP,#+4
   \   00001220   0xA800             ADD      R0,SP,#+0
   \   00001222   0x.... 0x....      BL       LeastSquareInt16a1
   \   00001226   0x0004             MOVS     R4,R0
   \   00001228   0x2304             MOVS     R3,#+4
   \   0000122A   0x0022             MOVS     R2,R4
   \   0000122C   0xA901             ADD      R1,SP,#+4
   \   0000122E   0xA800             ADD      R0,SP,#+0
   \   00001230   0x.... 0x....      BL       LeastSquareInt16a0
   \   00001234   0x0005             MOVS     R5,R0
   \   00001236   0xE04B             B.N      ??CenterLineGetNormal_119
   \                     ??CenterLineGetNormal_120: (+1)
   \   00001238   0x1D70             ADDS     R0,R6,#+5
   \   0000123A   0x283C             CMP      R0,#+60
   \   0000123C   0xDA21             BGE.N    ??CenterLineGetNormal_123
   \   0000123E   0xF05F 0x0900      MOVS     R9,#+0
   \   00001242   0x2000             MOVS     R0,#+0
   \   00001244   0xE00D             B.N      ??CenterLineGetNormal_124
   \                     ??CenterLineGetNormal_125: (+1)
   \   00001246   0x1981             ADDS     R1,R0,R6
   \   00001248   0x1C89             ADDS     R1,R1,#+2
   \   0000124A   0xAA00             ADD      R2,SP,#+0
   \   0000124C   0x5481             STRB     R1,[R0, R2]
   \   0000124E   0x.... 0x....      LDR.W    R1,??DataTable48
   \   00001252   0x1982             ADDS     R2,R0,R6
   \   00001254   0xEB11 0x0142      ADDS     R1,R1,R2, LSL #+1
   \   00001258   0x8889             LDRH     R1,[R1, #+4]
   \   0000125A   0xAA01             ADD      R2,SP,#+4
   \   0000125C   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   \   00001260   0x1C40             ADDS     R0,R0,#+1
   \                     ??CenterLineGetNormal_124: (+1)
   \   00001262   0x2804             CMP      R0,#+4
   \   00001264   0xDBEF             BLT.N    ??CenterLineGetNormal_125
   \   00001266   0x2204             MOVS     R2,#+4
   \   00001268   0xA901             ADD      R1,SP,#+4
   \   0000126A   0xA800             ADD      R0,SP,#+0
   \   0000126C   0x.... 0x....      BL       LeastSquareInt16a1
   \   00001270   0x0004             MOVS     R4,R0
   \   00001272   0x2304             MOVS     R3,#+4
   \   00001274   0x0022             MOVS     R2,R4
   \   00001276   0xA901             ADD      R1,SP,#+4
   \   00001278   0xA800             ADD      R0,SP,#+0
   \   0000127A   0x.... 0x....      BL       LeastSquareInt16a0
   \   0000127E   0x0005             MOVS     R5,R0
   \   00001280   0xE026             B.N      ??CenterLineGetNormal_119
   \                     ??CenterLineGetNormal_123: (+1)
   \   00001282   0x1D30             ADDS     R0,R6,#+4
   \   00001284   0x283C             CMP      R0,#+60
   \   00001286   0xDA21             BGE.N    ??CenterLineGetNormal_126
   \   00001288   0xF05F 0x0900      MOVS     R9,#+0
   \   0000128C   0x2000             MOVS     R0,#+0
   \   0000128E   0xE00D             B.N      ??CenterLineGetNormal_127
   \                     ??CenterLineGetNormal_128: (+1)
   \   00001290   0x1981             ADDS     R1,R0,R6
   \   00001292   0x1C49             ADDS     R1,R1,#+1
   \   00001294   0xAA00             ADD      R2,SP,#+0
   \   00001296   0x5481             STRB     R1,[R0, R2]
   \   00001298   0x.... 0x....      LDR.W    R1,??DataTable48
   \   0000129C   0x1982             ADDS     R2,R0,R6
   \   0000129E   0xEB11 0x0142      ADDS     R1,R1,R2, LSL #+1
   \   000012A2   0x8849             LDRH     R1,[R1, #+2]
   \   000012A4   0xAA01             ADD      R2,SP,#+4
   \   000012A6   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   \   000012AA   0x1C40             ADDS     R0,R0,#+1
   \                     ??CenterLineGetNormal_127: (+1)
   \   000012AC   0x2804             CMP      R0,#+4
   \   000012AE   0xDBEF             BLT.N    ??CenterLineGetNormal_128
   \   000012B0   0x2204             MOVS     R2,#+4
   \   000012B2   0xA901             ADD      R1,SP,#+4
   \   000012B4   0xA800             ADD      R0,SP,#+0
   \   000012B6   0x.... 0x....      BL       LeastSquareInt16a1
   \   000012BA   0x0004             MOVS     R4,R0
   \   000012BC   0x2304             MOVS     R3,#+4
   \   000012BE   0x0022             MOVS     R2,R4
   \   000012C0   0xA901             ADD      R1,SP,#+4
   \   000012C2   0xA800             ADD      R0,SP,#+0
   \   000012C4   0x.... 0x....      BL       LeastSquareInt16a0
   \   000012C8   0x0005             MOVS     R5,R0
   \   000012CA   0xE001             B.N      ??CenterLineGetNormal_119
   \                     ??CenterLineGetNormal_126: (+1)
   \   000012CC   0xF05F 0x0901      MOVS     R9,#+1
   \                     ??CenterLineGetNormal_119: (+1)
   \   000012D0   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000012D4   0xF1B9 0x0F00      CMP      R9,#+0
   \   000012D8   0xD10A             BNE.N    ??CenterLineGetNormal_129
   \   000012DA   0xFB06 0x5004      MLA      R0,R6,R4,R5
   \   000012DE   0xF44F 0x717A      MOV      R1,#+1000
   \   000012E2   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000012E6   0x.... 0x....      LDR.W    R1,??DataTable48
   \   000012EA   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
   \   000012EE   0xE014             B.N      ??CenterLineGetNormal_116
   \                     ??CenterLineGetNormal_129: (+1)
   \   000012F0   0x.... 0x....      LDR.W    R0,??DataTable48
   \   000012F4   0xEB10 0x0046      ADDS     R0,R0,R6, LSL #+1
   \   000012F8   0x8840             LDRH     R0,[R0, #+2]
   \   000012FA   0x.... 0x....      LDR.W    R1,??DataTable48
   \   000012FE   0xEB11 0x0146      ADDS     R1,R1,R6, LSL #+1
   \   00001302   0x8849             LDRH     R1,[R1, #+2]
   \   00001304   0x1808             ADDS     R0,R1,R0
   \   00001306   0x.... 0x....      LDR.W    R1,??DataTable48
   \   0000130A   0xEB11 0x0146      ADDS     R1,R1,R6, LSL #+1
   \   0000130E   0x8889             LDRH     R1,[R1, #+4]
   \   00001310   0x1A40             SUBS     R0,R0,R1
   \   00001312   0x.... 0x....      LDR.W    R1,??DataTable48
   \   00001316   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
   \                     ??CenterLineGetNormal_116: (+1)
   \   0000131A   0x2E00             CMP      R6,#+0
   \   0000131C   0xF47F 0xAEC8      BNE.W    ??CenterLineGetNormal_113
   \   00001320   0x.... 0x....      LDR.W    R0,??DataTable48_8
   \   00001324   0x7800             LDRB     R0,[R0, #+0]
   \   00001326   0x283B             CMP      R0,#+59
   \   00001328   0xF43E 0xAFC5      BEQ.W    ??CenterLineGetNormal_24
   \   0000132C   0x263B             MOVS     R6,#+59
   \   0000132E   0xE006             B.N      ??CenterLineGetNormal_130
   \                     ??CenterLineGetNormal_131: (+1)
   \   00001330   0xF647 0x70FF      MOVW     R0,#+32767
   \   00001334   0x.... 0x....      LDR.W    R1,??DataTable48
   \   00001338   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
   \   0000133C   0x1E76             SUBS     R6,R6,#+1
   \                     ??CenterLineGetNormal_130: (+1)
   \   0000133E   0x.... 0x....      LDR.W    R0,??DataTable48_8
   \   00001342   0x7800             LDRB     R0,[R0, #+0]
   \   00001344   0x4286             CMP      R6,R0
   \   00001346   0xD1F3             BNE.N    ??CenterLineGetNormal_131
   \   00001348   0xF7FE 0xBFB5      B.W      ??CenterLineGetNormal_24
   \                     ??CenterLineGetNormal_49: (+1)
   \   0000134C   0x2000             MOVS     R0,#+0
   \   0000134E   0xF7FE 0xBFB3      B.W      ??CenterLineGetNormal_4
   8741          }
   8742          
   8743          
   8744          
   8745          //障碍，锁存后，用以确定是否开始特殊控制。返回1开始，0再等等

   \                                 In section .text, align 2, keep-with-next
   8746          uint8 BrickSpeDealStartJudge(void)
   8747          {
   8748            uint8 col, count1, i, index;
   8749            int32 a0, a1;
   8750            uint8 x[BrickSlopeRowNum];   //取多少个点在一开始有定义。
   8751            uint8 y[BrickSlopeRowNum];
   8752            
   8753            return 1;   ///////////////不等待，直接特殊控制。
   \                     BrickSpeDealStartJudge: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
   8754            
   8755            //通过判断障碍是不是向近处越过了某一行，从而判断是否开始特殊控制。
   8756            
   8757            //左障碍
   8758            if(BrickSpeDealDir == 0)
   8759            {
   8760              //最小二乘法计算扫描起始行和结束行的黑点所在列。
   8761              //取BrickSlopeRowNum个点作为最小二乘法的基准点。
   8762              //以左上角为原点，向下为x轴正方向，向右为y轴正方向
   8763              index = 0;
   8764              for(i = CameraHight - 1; ; i--)
   8765              {
   8766                if(BlackLeftLoc[i][0] != MaxValUint8)
   8767                {
   8768                  y[index] = BlackLeftLoc[i][0];
   8769                  x[index] = i;
   8770                  index++;
   8771                }
   8772                if(index == BrickSlopeRowNum)
   8773                {
   8774                  break;
   8775                }
   8776                if(i == BrickSpeDealStartJudgeRow) //CameraHight-BrickSpeDealStartJudgeRow必须比BrickSlopeRowNum大
   8777                {
   8778                  return 0;
   8779                }
   8780              }
   8781              //最小二乘法
   8782              //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
   8783              a1 = LeastSquarea1(x, y, BrickSlopeRowNum);
   8784              a0 = LeastSquarea0(x, y, a1, BrickSlopeRowNum);
   8785             
   8786              //对特定一行的处理。
   8787              //该行黑点计数，左障碍从右往左扫描。
   8788              count1 = 0;
   8789              //当前行的扫描左边界。
   8790              BrickSpeDealStartJudgeCol = (a0 + a1 * BrickSpeDealStartJudgeRow) / LeastSquareMulti;
   8791              //向右BrickScanColNum列为右边界
   8792              for(col = BrickSpeDealStartJudgeCol + BrickScanColNum; ; col--)
   8793              {
   8794                if(ImgNew[BrickSpeDealStartJudgeRow][col] < LimitLeftB)  //够黑
   8795                {
   8796                  count1++;
   8797                }
   8798                else
   8799                {
   8800                }
   8801                //向左扫描至左边界。
   8802                if(col <= BrickSpeDealStartJudgeCol || col == 0) break;
   8803              }
   8804              
   8805              //该行黑点个数大于BrickLineBlackCountNum个时，则行计数加1.
   8806              if(count1 > BrickLineBlackCountNum) 
   8807              {
   8808                return 1;
   8809              }
   8810              else
   8811              {
   8812              }
   8813            }
   8814            //右障碍
   8815            else
   8816            {
   8817              //最小二乘法计算扫描起始行和结束行的黑点所在列。
   8818              //取BrickSlopeRowNum个点作为最小二乘法的基准点。
   8819              //以左上角为原点，向下为x轴正方向，向右为y轴正方向
   8820              index = 0;
   8821              for(i = CameraHight - 1; ; i--)
   8822              {
   8823                if(BlackRightLoc[i][0] != MaxValUint8)
   8824                {
   8825                  y[index] = BlackRightLoc[i][0];
   8826                  x[index] = i;
   8827                  index++;
   8828                }
   8829                if(index == BrickSlopeRowNum)
   8830                {
   8831                  break;
   8832                }
   8833                if(i == BrickSpeDealStartJudgeRow) //CameraHight-BrickSpeDealStartJudgeRow必须比BrickSlopeRowNum大
   8834                {
   8835                  return 0;
   8836                }
   8837              }
   8838              //最小二乘法
   8839              //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
   8840              a1 = LeastSquarea1(x, y, BrickSlopeRowNum);
   8841              a0 = LeastSquarea0(x, y, a1, BrickSlopeRowNum);
   8842             
   8843              //对特定一行的处理。
   8844              //该行黑点计数，右障碍从左往右扫描。
   8845              count1 = 0;
   8846              //当前行的扫描左边界。
   8847              BrickSpeDealStartJudgeCol = (a0 + a1 * BrickSpeDealStartJudgeRow) / LeastSquareMulti;
   8848              //向左BrickScanColNum列为左边界
   8849              for(col = BrickSpeDealStartJudgeCol - BrickScanColNum; ; col++)
   8850              {
   8851                if(ImgNew[BrickSpeDealStartJudgeRow][col] < LimitRightB)  //够黑
   8852                {
   8853                  count1++;
   8854                }
   8855                else
   8856                {
   8857                }
   8858                //向右扫描至右边界。
   8859                if(col >= BrickSpeDealStartJudgeCol || col >= CameraRealWidth - 1) break;
   8860              }
   8861              
   8862              //该行黑点个数大于BrickLineBlackCountNum个时，则行计数加1.
   8863              if(count1 > BrickLineBlackCountNum) 
   8864              {
   8865                return 1;
   8866              }
   8867              else
   8868              {
   8869              }
   8870            }
   8871            
   8872            //常态为再等等。
   8873            return 0;
   8874          }
   8875          
   8876          
   8877          
   8878          //障碍，特殊控制时，用以确定是否退出特殊控制。
   8879          //改变BrickSpeDealExitJudgeFlag，1~2继续特殊控制，其中1表示初始态，2表示当前已经与障碍平行，0退出特殊控制，把控制权交还给普通控制。

   \                                 In section .text, align 2, keep-with-next
   8880          uint8 BrickSpeDealExitJudge(void)
   8881          {
   8882            return 1;   //////////////不改变退出标志位，只通过倒计时来控制特殊控制的次数。
   \                     BrickSpeDealExitJudge: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
   8883            
   8884            
   8885            //根据第CameraHight - 1行的赛道半宽来，先必须检测到小于65的样子，然后必须检测到大于75（不是65，有返回系数的意思）的样子。
   8886            //左右障碍不用区分，没有必要。
   8887          
   8888            //当前为初始态，需要判断是不是已经跟障碍物平行了。
   8889            if(BrickSpeDealExitJudgeFlag == 1)
   8890            {
   8891              if(
   8892                 (BlackLeftLoc[CameraHight - 1][0] != MaxValUint8)
   8893              && (BlackRightLoc[CameraHight - 1][0] != MaxValUint8)
   8894              && (BlackRightLoc[CameraHight - 1][0] > BlackLeftLoc[CameraHight - 1][0]) //两线有效
   8895              && (BlackRightLoc[CameraHight - 1][0] - BlackLeftLoc[CameraHight - 1][0] < BrickSpeDealExitState1Val * 2) //赛道半宽小于一定值
   8896                )
   8897              {
   8898                //符合所有条件，过渡到状态2，表示已经与障碍物平行。
   8899                BrickSpeDealExitJudgeFlag = 2;
   8900              }
   8901              else
   8902              {
   8903              }
   8904            }
   8905            //当前已经与障碍物平行了，需要判断是不是车前端已经越过了障碍物从而退出特殊控制。
   8906            else if(BrickSpeDealExitJudgeFlag == 2)
   8907            {
   8908              if(
   8909                 (BlackLeftLoc[CameraHight - 1][0] != MaxValUint8)
   8910              && (BlackRightLoc[CameraHight - 1][0] != MaxValUint8)
   8911              && (BlackRightLoc[CameraHight - 1][0] > BlackLeftLoc[CameraHight - 1][0]) //两线有效
   8912              && (BlackRightLoc[CameraHight - 1][0] - BlackLeftLoc[CameraHight - 1][0] > BrickSpeDealExitState2Val * 2) //赛道半宽大于一定值
   8913                )
   8914              {
   8915                //符合所有条件，过渡到状态0，表示车前端已经一定程序越过障碍物，退出特殊控制。
   8916                BrickSpeDealExitJudgeFlag = 0;
   8917              }
   8918              else
   8919              {
   8920              }
   8921            }
   8922            //理论上不会到这里。
   8923            else
   8924            {
   8925            }
   8926          
   8927            return 1;
   8928          }
   8929          
   8930          
   8931          
   8932          //障碍物对舵机的特殊处理。///////////////////////////不知道是不是鸡肋

   \                                 In section .text, align 2, keep-with-next
   8933          uint8 BrickSpeDealServor(void)
   8934          {  
   8935            //舵机打角限幅。
   8936            //左障碍，不能往右打太多。
   8937            if(BrickSpeDealFlag == 1 && BrickSpeDealCenFlag == 0 && BrickSpeDealDir == 0)
   \                     BrickSpeDealServor: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable48_11
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD10F             BNE.N    ??BrickSpeDealServor_0
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable48_12
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD10A             BNE.N    ??BrickSpeDealServor_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable48_13
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD105             BNE.N    ??BrickSpeDealServor_0
   8938            {
   8939              //强制左转，侧撞总比出线好。
   8940              ServoPIDInputVal = ServoPIDCen - 100;
   \   0000001E   0xF240 0x605E      MOVW     R0,#+1630
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable48_14
   \   00000026   0x6008             STR      R0,[R1, #+0]
   \   00000028   0xE013             B.N      ??BrickSpeDealServor_1
   8941              //ServoPIDInputVal = ServoPIDCen - 0;
   8942              //StopFlag = 1;
   8943            }
   8944            //右障碍，不能往左打太多。
   8945            else if(BrickSpeDealFlag == 1 && BrickSpeDealCenFlag == 0 && BrickSpeDealDir == 1)
   \                     ??BrickSpeDealServor_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable48_11
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD10E             BNE.N    ??BrickSpeDealServor_1
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable48_12
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD109             BNE.N    ??BrickSpeDealServor_1
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable48_13
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD104             BNE.N    ??BrickSpeDealServor_1
   8946            {
   8947              //强制右转，侧撞总比出线好。
   8948              ServoPIDInputVal = ServoPIDCen + 100;  
   \   00000048   0xF240 0x7026      MOVW     R0,#+1830
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable48_14
   \   00000050   0x6008             STR      R0,[R1, #+0]
   8949              //ServoPIDInputVal = ServoPIDCen + 0;
   8950              
   8951              //StopFlag = 1;
   8952            }
   8953            //不是障碍，不用限制
   8954            else
   8955            {    
   8956            }
   8957          
   8958            return 1;
   \                     ??BrickSpeDealServor_1: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x4770             BX       LR               ;; return
   8959          }
   8960          
   8961          
   8962          
   8963          
   8964          //障碍，对中心线的特殊处理。不直接修改DeviFuse，而是某一条黑线给出一条修正后的中心线。然后交由ImgProSucceedDeal()函数里的DeviFuse更新函数去弄。
   8965          //会对CenterLineLoc[]数组产生影响。
   8966          //进来之前，黑线一定是连续的。所以直接从线尾补到线头即可。
   8967          //如果直接用BlackLoc数组不太理想，可以尝试使用畸变矫正后的数组，会更直。/////////////////////////

   \                                 In section .text, align 2, keep-with-next
   8968          uint8 BrickSpeDealCen(void)
   8969          {
   8970            uint8 row;
   8971            
   8972            //左障碍，按右线往左一小段来补线。
   8973            if(BrickSpeDealDir == 0)
   \                     BrickSpeDealCen: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable48_13
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD15B             BNE.N    ??BrickSpeDealCen_0
   8974            {
   8975              //图像失败或非障碍边失败时，不允许补线，返回失败。之后会根据上一幅图的DeviFuse来强制给。
   8976              if(ImgBlackSucceedFlag == 0 || BlackRightDone == 0)
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable48_15
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??BrickSpeDealCen_1
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable48_16
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD101             BNE.N    ??BrickSpeDealCen_2
   8977              {
   8978                return 0;
   \                     ??BrickSpeDealCen_1: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE09F             B.N      ??BrickSpeDealCen_3
   8979              }
   8980              else
   8981              {
   8982              }
   8983              
   8984              //线头线尾
   8985              //CenterHeadLine = BlackRightHeadLine;
   8986              CenterHeadLine = 0;
   \                     ??BrickSpeDealCen_2: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable48_17
   \   00000028   0x7008             STRB     R0,[R1, #+0]
   8987              CenterEndLine = BlackRightEndLine;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable48_18
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable48_8
   \   00000034   0x7008             STRB     R0,[R1, #+0]
   8988              
   8989              //采用未矫正的数组构造中心线数组，来避障
   8990              if(BrickSpeDealCenChoose == 0)
   8991              {
   8992                //逐行补线
   8993                for(row = BlackRightEndLine; ; row--)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable48_18
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0xE000             B.N      ??BrickSpeDealCen_4
   \                     ??BrickSpeDealCen_5: (+1)
   \   0000003E   0x1E40             SUBS     R0,R0,#+1
   8994                {
   8995                  CenterLineLoc[row] = BlackRightLoc[row][0] - BrickSpeDealBias[BrickSpeDealBackCount] + (BrickConfirmFinalColCom - 50); //BrickConfirmFinalColCom用于OLED修正
   \                     ??BrickSpeDealCen_4: (+1)
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable48_10
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x2203             MOVS     R2,#+3
   \   00000048   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   0000004C   0x7809             LDRB     R1,[R1, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R2,??DataTable48_19
   \   00000052   0x.... 0x....      LDR.W    R3,??DataTable48_20
   \   00000056   0x781B             LDRB     R3,[R3, #+0]
   \   00000058   0xF852 0x2023      LDR      R2,[R2, R3, LSL #+2]
   \   0000005C   0x1A89             SUBS     R1,R1,R2
   \   0000005E   0x.... 0x....      LDR.W    R2,??DataTable48_21
   \   00000062   0x7812             LDRB     R2,[R2, #+0]
   \   00000064   0x1889             ADDS     R1,R1,R2
   \   00000066   0x3932             SUBS     R1,R1,#+50
   \   00000068   0x....             LDR.N    R2,??DataTable48
   \   0000006A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006C   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   8996                  
   8997                  if(row == BlackRightHeadLine) break;
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable48_22
   \   00000074   0x7809             LDRB     R1,[R1, #+0]
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xD1E0             BNE.N    ??BrickSpeDealCen_5
   8998                }
   8999              }
   9000              //采用矫正后的数组构造中心线数组，来避障
   9001              else
   9002              {
   9003                //逐行补线
   9004                for(row = BlackRightEndLine; ; row--)
   9005                {
   9006                  CenterLineLoc[row] = BlackUdisRightLocation[row].x - BrickSpeDealBias[BrickSpeDealBackCount] + (BrickConfirmFinalColCom - 50); //BrickConfirmFinalColCom用于OLED修正
   9007                  
   9008                  if(row == BlackRightHeadLine) break;
   9009                }      
   9010              }
   9011              
   9012              //一直补到最顶行。
   9013              if(BlackRightHeadLine != 0)
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable48_22
   \   00000080   0x7800             LDRB     R0,[R0, #+0]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD06C             BEQ.N    ??BrickSpeDealCen_6
   9014              {
   9015                for(row = BlackRightHeadLine - 1; ; row--)
   \   00000086   0x....             LDR.N    R0,??DataTable48_22
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0x1E40             SUBS     R0,R0,#+1
   \   0000008C   0xE000             B.N      ??BrickSpeDealCen_7
   \                     ??BrickSpeDealCen_8: (+1)
   \   0000008E   0x1E40             SUBS     R0,R0,#+1
   9016                {
   9017                  CenterLineLoc[row] = CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2];
   \                     ??BrickSpeDealCen_7: (+1)
   \   00000090   0x....             LDR.N    R1,??DataTable48
   \   00000092   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000094   0xEB11 0x0140      ADDS     R1,R1,R0, LSL #+1
   \   00000098   0x8849             LDRH     R1,[R1, #+2]
   \   0000009A   0x....             LDR.N    R2,??DataTable48
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0xEB12 0x0240      ADDS     R2,R2,R0, LSL #+1
   \   000000A2   0x8852             LDRH     R2,[R2, #+2]
   \   000000A4   0x1851             ADDS     R1,R2,R1
   \   000000A6   0x....             LDR.N    R2,??DataTable48
   \   000000A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AA   0xEB12 0x0240      ADDS     R2,R2,R0, LSL #+1
   \   000000AE   0x8892             LDRH     R2,[R2, #+4]
   \   000000B0   0x1A89             SUBS     R1,R1,R2
   \   000000B2   0x....             LDR.N    R2,??DataTable48
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   9018                  
   9019                  if(row == 0) break;
   \   000000BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD1E6             BNE.N    ??BrickSpeDealCen_8
   \   000000C0   0xE04E             B.N      ??BrickSpeDealCen_6
   9020                }
   9021              }
   9022              else
   9023              {     
   9024              }
   9025              
   9026            }
   9027            //右障碍，按左线往右一小段来补线。
   9028            else
   9029            {
   9030              //图像失败或非障碍边失败时，不允许补线，返回失败。之后会根据上一幅图的DeviFuse来强制给。
   9031              if(ImgBlackSucceedFlag == 0 || BlackLeftDone == 0)
   \                     ??BrickSpeDealCen_0: (+1)
   \   000000C2   0x....             LDR.N    R0,??DataTable48_15
   \   000000C4   0x7800             LDRB     R0,[R0, #+0]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD003             BEQ.N    ??BrickSpeDealCen_9
   \   000000CA   0x....             LDR.N    R0,??DataTable48_23
   \   000000CC   0x7800             LDRB     R0,[R0, #+0]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD101             BNE.N    ??BrickSpeDealCen_10
   9032              {
   9033                return 0;
   \                     ??BrickSpeDealCen_9: (+1)
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xE045             B.N      ??BrickSpeDealCen_3
   9034              }
   9035              else
   9036              {
   9037              }
   9038              
   9039              //线头线尾
   9040              //CenterHeadLine = BlackLeftHeadLine;
   9041              CenterHeadLine = 0;
   \                     ??BrickSpeDealCen_10: (+1)
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0x....             LDR.N    R1,??DataTable48_17
   \   000000DA   0x7008             STRB     R0,[R1, #+0]
   9042              CenterEndLine = BlackLeftEndLine;
   \   000000DC   0x....             LDR.N    R0,??DataTable48_24
   \   000000DE   0x7800             LDRB     R0,[R0, #+0]
   \   000000E0   0x....             LDR.N    R1,??DataTable48_8
   \   000000E2   0x7008             STRB     R0,[R1, #+0]
   9043              
   9044              //采用未矫正的数组构造中心线数组，来避障
   9045              if(BrickSpeDealCenChoose == 0)
   9046              {
   9047                //逐行补线
   9048                for(row = BlackLeftEndLine; ; row--)
   \   000000E4   0x....             LDR.N    R0,??DataTable48_24
   \   000000E6   0x7800             LDRB     R0,[R0, #+0]
   \   000000E8   0xE000             B.N      ??BrickSpeDealCen_11
   \                     ??BrickSpeDealCen_12: (+1)
   \   000000EA   0x1E40             SUBS     R0,R0,#+1
   9049                {
   9050                  CenterLineLoc[row] = BlackLeftLoc[row][0] + BrickSpeDealBias[BrickSpeDealBackCount] - (BrickConfirmFinalColCom - 50); //BrickConfirmFinalColCom用于OLED修正
   \                     ??BrickSpeDealCen_11: (+1)
   \   000000EC   0x....             LDR.N    R1,??DataTable48_1
   \   000000EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F0   0x2203             MOVS     R2,#+3
   \   000000F2   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   000000F6   0x7809             LDRB     R1,[R1, #+0]
   \   000000F8   0x....             LDR.N    R2,??DataTable48_19
   \   000000FA   0x....             LDR.N    R3,??DataTable48_20
   \   000000FC   0x781B             LDRB     R3,[R3, #+0]
   \   000000FE   0xF852 0x2023      LDR      R2,[R2, R3, LSL #+2]
   \   00000102   0x1851             ADDS     R1,R2,R1
   \   00000104   0x....             LDR.N    R2,??DataTable48_21
   \   00000106   0x7812             LDRB     R2,[R2, #+0]
   \   00000108   0x1A89             SUBS     R1,R1,R2
   \   0000010A   0x3132             ADDS     R1,R1,#+50
   \   0000010C   0x....             LDR.N    R2,??DataTable48
   \   0000010E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000110   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   9051                  
   9052                  if(row == BlackLeftHeadLine) break;
   \   00000114   0x....             LDR.N    R1,??DataTable48_5
   \   00000116   0x7809             LDRB     R1,[R1, #+0]
   \   00000118   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011A   0x4288             CMP      R0,R1
   \   0000011C   0xD1E5             BNE.N    ??BrickSpeDealCen_12
   9053                }
   9054              }
   9055              //采用矫正后的数组构造中心线数组，来避障
   9056              else
   9057              {
   9058                //逐行补线
   9059                for(row = BlackLeftEndLine; ; row--)
   9060                {
   9061                  CenterLineLoc[row] = BlackUdisLeftLocation[row].x + BrickSpeDealBias[BrickSpeDealBackCount] - (BrickConfirmFinalColCom - 50); //BrickConfirmFinalColCom用于OLED修正
   9062                  
   9063                  if(row == BlackLeftHeadLine) break;
   9064                }      
   9065              }
   9066              
   9067              //一直补到最顶行。
   9068              if(BlackLeftHeadLine != 0)
   \   0000011E   0x....             LDR.N    R0,??DataTable48_5
   \   00000120   0x7800             LDRB     R0,[R0, #+0]
   \   00000122   0x2800             CMP      R0,#+0
   \   00000124   0xD01C             BEQ.N    ??BrickSpeDealCen_6
   9069              {
   9070                for(row = BlackLeftHeadLine - 1; ; row--)
   \   00000126   0x....             LDR.N    R0,??DataTable48_5
   \   00000128   0x7800             LDRB     R0,[R0, #+0]
   \   0000012A   0x1E40             SUBS     R0,R0,#+1
   \   0000012C   0xE000             B.N      ??BrickSpeDealCen_13
   \                     ??BrickSpeDealCen_14: (+1)
   \   0000012E   0x1E40             SUBS     R0,R0,#+1
   9071                {
   9072                  CenterLineLoc[row] = CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2];
   \                     ??BrickSpeDealCen_13: (+1)
   \   00000130   0x....             LDR.N    R1,??DataTable48
   \   00000132   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000134   0xEB11 0x0140      ADDS     R1,R1,R0, LSL #+1
   \   00000138   0x8849             LDRH     R1,[R1, #+2]
   \   0000013A   0x....             LDR.N    R2,??DataTable48
   \   0000013C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013E   0xEB12 0x0240      ADDS     R2,R2,R0, LSL #+1
   \   00000142   0x8852             LDRH     R2,[R2, #+2]
   \   00000144   0x1851             ADDS     R1,R2,R1
   \   00000146   0x....             LDR.N    R2,??DataTable48
   \   00000148   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014A   0xEB12 0x0240      ADDS     R2,R2,R0, LSL #+1
   \   0000014E   0x8892             LDRH     R2,[R2, #+4]
   \   00000150   0x1A89             SUBS     R1,R1,R2
   \   00000152   0x....             LDR.N    R2,??DataTable48
   \   00000154   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000156   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   9073                  
   9074                  if(row == 0) break;
   \   0000015A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015C   0x2800             CMP      R0,#+0
   \   0000015E   0xD1E6             BNE.N    ??BrickSpeDealCen_14
   9075                }
   9076              }
   9077              else
   9078              {     
   9079              }
   9080              
   9081            }
   9082            
   9083            return 1;
   \                     ??BrickSpeDealCen_6: (+1)
   \   00000160   0x2001             MOVS     R0,#+1
   \                     ??BrickSpeDealCen_3: (+1)
   \   00000162   0x4770             BX       LR               ;; return
   9084          }
   9085          
   9086          
   9087          
   9088          //避障程序

   \                                 In section .text, align 2, keep-with-next
   9089          uint8 BrickAvoid(void)
   9090          {
   \                     BrickAvoid: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9091            uint8 i;
   9092            
   9093            ////障碍锁存标志没有被置位的时候才进行障碍计数，若已被置位，则不用进行障碍计数。
   9094            if(BrickConfirmLockFlag == 0)
   \   00000002   0x....             LDR.N    R0,??DataTable48_25
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xF040 0x808B      BNE.W    ??BrickAvoid_0
   9095            {
   9096              //A次计数内有B次障碍成功，则判断为障碍。先入先出队列。
   9097              for(i = 0; ; i++)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE000             B.N      ??BrickAvoid_1
   \                     ??BrickAvoid_2: (+1)
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   9098              {
   9099                BrickConfirmMat0[i] = BrickConfirmMat0[i + 1];
   \                     ??BrickAvoid_1: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable48_26
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x1841             ADDS     R1,R0,R1
   \   00000018   0x7849             LDRB     R1,[R1, #+1]
   \   0000001A   0x....             LDR.N    R2,??DataTable48_26
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x5481             STRB     R1,[R0, R2]
   9100                BrickConfirmMat1[i] = BrickConfirmMat1[i + 1];
   \   00000020   0x....             LDR.N    R1,??DataTable48_27
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x1841             ADDS     R1,R0,R1
   \   00000026   0x7849             LDRB     R1,[R1, #+1]
   \   00000028   0x....             LDR.N    R2,??DataTable48_27
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x5481             STRB     R1,[R0, R2]
   9101                if(i == BrickConfirmMatNum - 2) break;
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0x2804             CMP      R0,#+4
   \   00000032   0xD1ED             BNE.N    ??BrickAvoid_2
   9102              }
   9103              //左障碍成功
   9104              if(PathType == PathBrickLeft)
   \   00000034   0x....             LDR.N    R0,??DataTable48_28
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x2808             CMP      R0,#+8
   \   0000003A   0xD106             BNE.N    ??BrickAvoid_3
   9105              {
   9106                //左障碍储存数组置1.
   9107                BrickConfirmMat0[BrickConfirmMatNum - 1] = 1;
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x....             LDR.N    R1,??DataTable48_26
   \   00000040   0x7148             STRB     R0,[R1, #+5]
   9108                //右障碍储存数组置0。
   9109                BrickConfirmMat1[BrickConfirmMatNum - 1] = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x....             LDR.N    R1,??DataTable48_27
   \   00000046   0x7148             STRB     R0,[R1, #+5]
   \   00000048   0xE010             B.N      ??BrickAvoid_4
   9110              }
   9111              else if(PathType == PathBrickRight)
   \                     ??BrickAvoid_3: (+1)
   \   0000004A   0x....             LDR.N    R0,??DataTable48_28
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x2809             CMP      R0,#+9
   \   00000050   0xD106             BNE.N    ??BrickAvoid_5
   9112              {
   9113                //右障碍储存数组置1.
   9114                BrickConfirmMat1[BrickConfirmMatNum - 1] = 1;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x....             LDR.N    R1,??DataTable48_27
   \   00000056   0x7148             STRB     R0,[R1, #+5]
   9115                //左障碍储存数组置0。
   9116                BrickConfirmMat0[BrickConfirmMatNum - 1] = 0;   
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x....             LDR.N    R1,??DataTable48_26
   \   0000005C   0x7148             STRB     R0,[R1, #+5]
   \   0000005E   0xE005             B.N      ??BrickAvoid_4
   9117              }
   9118              else
   9119              {
   9120                //判定为非障碍则新来的值置0.
   9121                BrickConfirmMat0[BrickConfirmMatNum - 1] = 0;
   \                     ??BrickAvoid_5: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x....             LDR.N    R1,??DataTable48_26
   \   00000064   0x7148             STRB     R0,[R1, #+5]
   9122                BrickConfirmMat1[BrickConfirmMatNum - 1] = 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x....             LDR.N    R1,??DataTable48_27
   \   0000006A   0x7148             STRB     R0,[R1, #+5]
   9123              }
   9124              
   9125              //收集BrickConfirmMat数组里1的个数。
   9126              BrickConfirmMatCollect0 = 0;
   \                     ??BrickAvoid_4: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x....             LDR.N    R1,??DataTable48_29
   \   00000070   0x7008             STRB     R0,[R1, #+0]
   9127              for(i = 0; ; i++)
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xE000             B.N      ??BrickAvoid_6
   \                     ??BrickAvoid_7: (+1)
   \   00000076   0x1C40             ADDS     R0,R0,#+1
   9128              {
   9129                if(BrickConfirmMat0[i] == 1) BrickConfirmMatCollect0++;
   \                     ??BrickAvoid_6: (+1)
   \   00000078   0x....             LDR.N    R1,??DataTable48_26
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0x5C41             LDRB     R1,[R0, R1]
   \   0000007E   0x2901             CMP      R1,#+1
   \   00000080   0xD104             BNE.N    ??BrickAvoid_8
   \   00000082   0x....             LDR.N    R1,??DataTable48_29
   \   00000084   0x7809             LDRB     R1,[R1, #+0]
   \   00000086   0x1C49             ADDS     R1,R1,#+1
   \   00000088   0x....             LDR.N    R2,??DataTable48_29
   \   0000008A   0x7011             STRB     R1,[R2, #+0]
   9130                
   9131                if(i == BrickConfirmMatNum - 1) break;
   \                     ??BrickAvoid_8: (+1)
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0x2805             CMP      R0,#+5
   \   00000090   0xD1F1             BNE.N    ??BrickAvoid_7
   9132              }
   9133              
   9134              //收集BrickConfirmMat数组里1的个数。
   9135              BrickConfirmMatCollect1 = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x....             LDR.N    R1,??DataTable48_30
   \   00000096   0x7008             STRB     R0,[R1, #+0]
   9136              for(i = 0; ; i++)
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xE000             B.N      ??BrickAvoid_9
   \                     ??BrickAvoid_10: (+1)
   \   0000009C   0x1C40             ADDS     R0,R0,#+1
   9137              {
   9138                if(BrickConfirmMat1[i] == 1) BrickConfirmMatCollect1++;
   \                     ??BrickAvoid_9: (+1)
   \   0000009E   0x....             LDR.N    R1,??DataTable48_27
   \   000000A0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A2   0x5C41             LDRB     R1,[R0, R1]
   \   000000A4   0x2901             CMP      R1,#+1
   \   000000A6   0xD104             BNE.N    ??BrickAvoid_11
   \   000000A8   0x....             LDR.N    R1,??DataTable48_30
   \   000000AA   0x7809             LDRB     R1,[R1, #+0]
   \   000000AC   0x1C49             ADDS     R1,R1,#+1
   \   000000AE   0x....             LDR.N    R2,??DataTable48_30
   \   000000B0   0x7011             STRB     R1,[R2, #+0]
   9139                
   9140                if(i == BrickConfirmMatNum - 1) break;
   \                     ??BrickAvoid_11: (+1)
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0x2805             CMP      R0,#+5
   \   000000B6   0xD1F1             BNE.N    ??BrickAvoid_10
   9141              }
   9142              
   9143              //大于若干次，则锁存为左障碍。
   9144              if(BrickConfirmMatCollect0 >= BrickConfirmMatLimit)
   \   000000B8   0x....             LDR.N    R0,??DataTable48_29
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0x....             LDR.N    R1,??DataTable48_31
   \   000000BE   0x7809             LDRB     R1,[R1, #+0]
   \   000000C0   0x4288             CMP      R0,R1
   \   000000C2   0xD314             BCC.N    ??BrickAvoid_12
   9145              {
   9146                //锁存标志位置位。
   9147                BrickConfirmLockFlag = 1;
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0x....             LDR.N    R1,??DataTable48_25
   \   000000C8   0x7008             STRB     R0,[R1, #+0]
   9148                //数组清空，防止重复锁存。
   9149                for(i = 0; ; i++)
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xE000             B.N      ??BrickAvoid_13
   \                     ??BrickAvoid_14: (+1)
   \   000000CE   0x1C40             ADDS     R0,R0,#+1
   9150                {
   9151                  BrickConfirmMat0[i] = 0;
   \                     ??BrickAvoid_13: (+1)
   \   000000D0   0x2100             MOVS     R1,#+0
   \   000000D2   0x....             LDR.N    R2,??DataTable48_26
   \   000000D4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D6   0x5481             STRB     R1,[R0, R2]
   9152                  BrickConfirmMat1[i] = 0;
   \   000000D8   0x2100             MOVS     R1,#+0
   \   000000DA   0x....             LDR.N    R2,??DataTable48_27
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0x5481             STRB     R1,[R0, R2]
   9153                  if(i == BrickConfirmMatNum - 1) break;
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0x2805             CMP      R0,#+5
   \   000000E4   0xD1F3             BNE.N    ??BrickAvoid_14
   9154                }
   9155                //确认障碍的方向。
   9156                BrickSpeDealDir = 0;             //左障碍
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0x....             LDR.N    R1,??DataTable48_13
   \   000000EA   0x7008             STRB     R0,[R1, #+0]
   \   000000EC   0xE019             B.N      ??BrickAvoid_0
   9157              }
   9158              else if(BrickConfirmMatCollect1 >= BrickConfirmMatLimit)
   \                     ??BrickAvoid_12: (+1)
   \   000000EE   0x....             LDR.N    R0,??DataTable48_30
   \   000000F0   0x7800             LDRB     R0,[R0, #+0]
   \   000000F2   0x....             LDR.N    R1,??DataTable48_31
   \   000000F4   0x7809             LDRB     R1,[R1, #+0]
   \   000000F6   0x4288             CMP      R0,R1
   \   000000F8   0xD313             BCC.N    ??BrickAvoid_0
   9159              {
   9160                //锁存标志位置位。
   9161                BrickConfirmLockFlag = 1;
   \   000000FA   0x2001             MOVS     R0,#+1
   \   000000FC   0x....             LDR.N    R1,??DataTable48_25
   \   000000FE   0x7008             STRB     R0,[R1, #+0]
   9162                //数组清空，防止重复锁存。
   9163                for(i = 0; ; i++)
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0xE000             B.N      ??BrickAvoid_15
   \                     ??BrickAvoid_16: (+1)
   \   00000104   0x1C40             ADDS     R0,R0,#+1
   9164                {
   9165                  BrickConfirmMat0[i] = 0;
   \                     ??BrickAvoid_15: (+1)
   \   00000106   0x2100             MOVS     R1,#+0
   \   00000108   0x....             LDR.N    R2,??DataTable48_26
   \   0000010A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010C   0x5481             STRB     R1,[R0, R2]
   9166                  BrickConfirmMat1[i] = 0;
   \   0000010E   0x2100             MOVS     R1,#+0
   \   00000110   0x....             LDR.N    R2,??DataTable48_27
   \   00000112   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000114   0x5481             STRB     R1,[R0, R2]
   9167                  if(i == BrickConfirmMatNum - 1) break;
   \   00000116   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000118   0x2805             CMP      R0,#+5
   \   0000011A   0xD1F3             BNE.N    ??BrickAvoid_16
   9168                }
   9169                //确认障碍的方向。
   9170                BrickSpeDealDir = 1;             //右障碍      
   \   0000011C   0x2001             MOVS     R0,#+1
   \   0000011E   0x....             LDR.N    R1,??DataTable48_13
   \   00000120   0x7008             STRB     R0,[R1, #+0]
   9171              }
   9172              else
   9173              {
   9174              }
   9175            }
   9176            //障碍锁存已被置位，则不用进行障碍计数。
   9177            else
   9178            {
   9179            }
   9180            
   9181            //若障碍锁存标志位置位，则等待矮线的线头够低后开始障碍处理。
   9182            if(BrickConfirmLockFlag == 1)
   \                     ??BrickAvoid_0: (+1)
   \   00000122   0x....             LDR.N    R0,??DataTable48_25
   \   00000124   0x7800             LDRB     R0,[R0, #+0]
   \   00000126   0x2801             CMP      R0,#+1
   \   00000128   0xD10B             BNE.N    ??BrickAvoid_17
   9183            {
   9184              light_control(PORTD, 15, Light_ON);
   \   0000012A   0x2200             MOVS     R2,#+0
   \   0000012C   0x210F             MOVS     R1,#+15
   \   0000012E   0x....             LDR.N    R0,??DataTable48_32  ;; 0x400ff0c0
   \   00000130   0x.... 0x....      BL       light_control
   9185              //判断可否开始特殊处理。
   9186              if(BrickSpeDealStartJudge() == 1)
   \   00000134   0x.... 0x....      BL       BrickSpeDealStartJudge
   \   00000138   0x2801             CMP      R0,#+1
   \   0000013A   0xD102             BNE.N    ??BrickAvoid_17
   9187              {
   9188                BrickSpeDealBackCount = BrickSpeDealBackCountNum;
   \   0000013C   0x2014             MOVS     R0,#+20
   \   0000013E   0x....             LDR.N    R1,??DataTable48_20
   \   00000140   0x7008             STRB     R0,[R1, #+0]
   9189              }
   9190              else
   9191              {
   9192                //还没满足条件，再等等。
   9193              }
   9194            }
   9195            else
   9196            {
   9197            }
   9198          
   9199            //退出障碍特殊处理的判断。BrickSpeDealExitJudgeFlag会更新。
   9200            BrickSpeDealExitJudge();
   \                     ??BrickAvoid_17: (+1)
   \   00000142   0x.... 0x....      BL       BrickSpeDealExitJudge
   9201            
   9202            //有了倒数次数后，就开始每次倒数，直到为0或判断已经出了障碍.
   9203            if(BrickSpeDealBackCount != 0 && BrickSpeDealExitJudgeFlag != 0)
   \   00000146   0x....             LDR.N    R0,??DataTable48_20
   \   00000148   0x7800             LDRB     R0,[R0, #+0]
   \   0000014A   0x2800             CMP      R0,#+0
   \   0000014C   0xD020             BEQ.N    ??BrickAvoid_18
   \   0000014E   0x....             LDR.N    R0,??DataTable48_33
   \   00000150   0x7800             LDRB     R0,[R0, #+0]
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD01C             BEQ.N    ??BrickAvoid_18
   9204            {
   9205              BrickConfirmLockFlag = 0;    //障碍特殊控制开启成功，则锁存标志位清零。
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0x....             LDR.N    R1,??DataTable48_25
   \   0000015A   0x7008             STRB     R0,[R1, #+0]
   9206              
   9207              //倒数值减1。
   9208              BrickSpeDealBackCount--;
   \   0000015C   0x....             LDR.N    R0,??DataTable48_20
   \   0000015E   0x7800             LDRB     R0,[R0, #+0]
   \   00000160   0x1E40             SUBS     R0,R0,#+1
   \   00000162   0x....             LDR.N    R1,??DataTable48_20
   \   00000164   0x7008             STRB     R0,[R1, #+0]
   9209              //标志位说明进行了障碍的特殊处理。
   9210              BrickSpeDealFlag = 1;
   \   00000166   0x2001             MOVS     R0,#+1
   \   00000168   0x....             LDR.N    R1,??DataTable48_11
   \   0000016A   0x7008             STRB     R0,[R1, #+0]
   9211              
   9212              //对中心线的特殊处理函数，还剩BrickSpeDealBackCount次。
   9213              BrickSpeDealCenFlag = BrickSpeDealCen();
   \   0000016C   0x.... 0x....      BL       BrickSpeDealCen
   \   00000170   0x....             LDR.N    R1,??DataTable48_12
   \   00000172   0x7008             STRB     R0,[R1, #+0]
   9214              //若处理已经出错了，则立即停止特殊控制，后面会将舵机强制打回来。
   9215              if(BrickSpeDealCenFlag == 0)
   \   00000174   0x....             LDR.N    R0,??DataTable48_12
   \   00000176   0x7800             LDRB     R0,[R0, #+0]
   \   00000178   0x2800             CMP      R0,#+0
   \   0000017A   0xD102             BNE.N    ??BrickAvoid_19
   9216              {
   9217                BrickSpeDealBackCount = 0;
   \   0000017C   0x2000             MOVS     R0,#+0
   \   0000017E   0x....             LDR.N    R1,??DataTable48_20
   \   00000180   0x7008             STRB     R0,[R1, #+0]
   9218              }
   9219              else
   9220              {
   9221              }
   9222              //特殊控制期间，为了防止撞障碍引起的上下坡误判，将坡道禁止赛道类型判断标志复位，并将倒计数置0（不允许置下坡标志，会引起减速），保证复位。
   9223              //会持续多个周期，所以应该是保险的。
   9224              GyroResultForbidFlag = 0;
   \                     ??BrickAvoid_19: (+1)
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0x....             LDR.N    R1,??DataTable48_34
   \   00000186   0x7008             STRB     R0,[R1, #+0]
   9225              GyroResultForbidBackCount = 0;
   \   00000188   0x2000             MOVS     R0,#+0
   \   0000018A   0x....             LDR.N    R1,??DataTable48_35
   \   0000018C   0x7008             STRB     R0,[R1, #+0]
   \   0000018E   0xE008             B.N      ??BrickAvoid_20
   9226              
   9227            }
   9228            else
   9229            {    
   9230              //倒数次数清零，防止再次启动障碍特殊处理。
   9231              BrickSpeDealBackCount = 0;
   \                     ??BrickAvoid_18: (+1)
   \   00000190   0x2000             MOVS     R0,#+0
   \   00000192   0x....             LDR.N    R1,??DataTable48_20
   \   00000194   0x7008             STRB     R0,[R1, #+0]
   9232              
   9233              //标志位说明没有进行障碍的特殊处理。
   9234              BrickSpeDealFlag = 0;
   \   00000196   0x2000             MOVS     R0,#+0
   \   00000198   0x....             LDR.N    R1,??DataTable48_11
   \   0000019A   0x7008             STRB     R0,[R1, #+0]
   9235              
   9236              //判出标志置初始状态1.
   9237              BrickSpeDealExitJudgeFlag = 1;
   \   0000019C   0x2001             MOVS     R0,#+1
   \   0000019E   0x....             LDR.N    R1,??DataTable48_33
   \   000001A0   0x7008             STRB     R0,[R1, #+0]
   9238            }
   9239            
   9240            return 1;
   \                     ??BrickAvoid_20: (+1)
   \   000001A2   0x2001             MOVS     R0,#+1
   \   000001A4   0xBD02             POP      {R1,PC}          ;; return
   9241          }
   9242          
   9243          
   9244          //中心线处理函数，包括特殊和非特殊赛道

   \                                 In section .text, align 2, keep-with-next
   9245          uint8 CenterLineGetRaw(void)
   9246          {
   \                     CenterLineGetRaw: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9247            uint8 flag;
   9248            
   9249            flag = 1;
   \   00000002   0x2001             MOVS     R0,#+1
   9250            //直角弯 锁存 或 强制控制期间，就不用进行正常的中心线提取。
   9251            //ImgProSucceedDeal()里面的DeviFuse更新函数是没有用的，因为AngleStep2Confirm()在ImgProSucceedDeal()的后面执行，会强制更改DeviFuse.
   9252            if(AngleConfirmLockFlag == 1 || AngleSpeDealFlag == 1)
   \   00000004   0x....             LDR.N    R1,??DataTable48_36
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD009             BEQ.N    ??CenterLineGetRaw_0
   \   0000000C   0x....             LDR.N    R1,??DataTable48_37
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x2901             CMP      R1,#+1
   \   00000012   0xD005             BEQ.N    ??CenterLineGetRaw_0
   9253            {   
   9254              //直角弯锁存或特殊控制时，CenterLineLoc[]数组一直是无效值。
   9255            }
   9256            //障碍物强制控制期间，不执行正常的中心线提取，而是采用单边线的特殊中心线提取函数。
   9257            //这里只是给出一条修正后的中心线，用来给ImgProSucceedDeal()里面的DeviFuse更新函数去用。
   9258            //但是障碍物锁存期间，仍然靠正常提取中心线。
   9259            else if(BrickSpeDealFlag == 1)
   \   00000014   0x....             LDR.N    R1,??DataTable48_11
   \   00000016   0x7809             LDRB     R1,[R1, #+0]
   \   00000018   0x2901             CMP      R1,#+1
   \   0000001A   0xD001             BEQ.N    ??CenterLineGetRaw_0
   9260            {
   9261              //在BrickAvoid()中已经执行了中心线提取函数。
   9262            }
   9263            //不是特殊赛道，进行正常的中心线提取。有可能返回失败。
   9264            else
   9265            {
   9266              flag = CenterLineGetNormal();
   \   0000001C   0x.... 0x....      BL       CenterLineGetNormal
   9267            }
   9268            
   9269            return flag;
   \                     ??CenterLineGetRaw_0: (+1)
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0xBD02             POP      {R1,PC}          ;; return
   9270          }
   9271          
   9272          
   9273          
   9274          
   9275          //中心线提取，进来前左右黑线均连续。

   \                                 In section .text, align 4, keep-with-next
   9276          uint8 CenterLineGet(void)
   9277          {
   \                     CenterLineGet: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   9278            uint8 row, i;
   9279            uint8 temp;
   9280            uint8 flag1, flag2, flag3, flag4;  
   9281            uint8 tempflag1;
   9282            uint8 tempway1;
   9283            uint8 x[CenterForwardLineNum];   //中心线向前补线计算斜率时，x坐标，表示第几行。。
   9284            int16 y[CenterForwardLineNum];   //中心线向前补线计算斜率时，y坐标，表示中心线位置。
   9285            int32 a1, a0;    //中心线向前补线时，最小二乘法的斜率和纵截距。
   9286            
   9287            float slope;
   9288            
   9289            
   9290            //左线提取成功，右线提取失败。
   9291            if(BlackLeftDone == 1 && BlackRightDone == 0)
   \   00000004   0xF8DF 0x0DBC      LDR.W    R0,??CenterLineGet_0
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xF040 0x817D      BNE.W    ??CenterLineGet_1
   \   00000010   0xF8DF 0x0DB4      LDR.W    R0,??CenterLineGet_0+0x4
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xF040 0x8177      BNE.W    ??CenterLineGet_1
   9292            {
   9293              //若左线的线头线尾无效，则直接返回失败。
   9294              if(BlackLeftHeadLine == MaxValUint8 || BlackLeftEndLine == MaxValUint8)
   \   0000001C   0xF8DF 0x0DAC      LDR.W    R0,??CenterLineGet_0+0x8
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x28FF             CMP      R0,#+255
   \   00000024   0xD004             BEQ.N    ??CenterLineGet_2
   \   00000026   0xF8DF 0x0DA8      LDR.W    R0,??CenterLineGet_0+0xC
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x28FF             CMP      R0,#+255
   \   0000002E   0xD101             BNE.N    ??CenterLineGet_3
   9295              {
   9296                return 0;
   \                     ??CenterLineGet_2: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE168             B.N      ??CenterLineGet_4
   9297              }
   9298              else
   9299              {
   9300              }
   9301              
   9302              flag1 = 1;
   \                     ??CenterLineGet_3: (+1)
   \   00000034   0x2101             MOVS     R1,#+1
   9303              flag2 = 1;
   \   00000036   0x2201             MOVS     R2,#+1
   9304              
   9305              //中心线的线尾取左线的线尾即可。
   9306              CenterHeadLine = BlackLeftHeadLine;     //线头取左线的线头，注意这不是实际的线头。
   \   00000038   0xF8DF 0x0D90      LDR.W    R0,??CenterLineGet_0+0x8
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0xF8DF 0x1D94      LDR.W    R1,??CenterLineGet_0+0x10
   \   00000042   0x7008             STRB     R0,[R1, #+0]
   9307              //CenterHeadLine = 0;   //线头因为要固定补到第0行，所以直接置0.
   9308              CenterEndLine = BlackLeftEndLine;
   \   00000044   0xF8DF 0x0D88      LDR.W    R0,??CenterLineGet_0+0xC
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0xF8DF 0x1D8C      LDR.W    R1,??CenterLineGet_0+0x14
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
   9309              
   9310              //首先看线头是否大于BlackControlLineLow行
   9311              if(BlackLeftHeadLine >= BlackControlLineLow)
   \   00000050   0xF8DF 0x0D78      LDR.W    R0,??CenterLineGet_0+0x8
   \   00000054   0x7800             LDRB     R0,[R0, #+0]
   \   00000056   0x281A             CMP      R0,#+26
   \   00000058   0xDB00             BLT.N    ??CenterLineGet_5
   9312              {
   9313                flag1 = 0;
   \   0000005A   0x2100             MOVS     R1,#+0
   9314              }
   9315              else
   9316              {
   9317              }
   9318              
   9319              //左线尾小于CameraHight - 1行。
   9320              if(BlackLeftEndLine < CameraHight - 1)
   \                     ??CenterLineGet_5: (+1)
   \   0000005C   0xF8DF 0x0D70      LDR.W    R0,??CenterLineGet_0+0xC
   \   00000060   0x7800             LDRB     R0,[R0, #+0]
   \   00000062   0x283B             CMP      R0,#+59
   \   00000064   0xDA07             BGE.N    ??CenterLineGet_6
   9321              {
   9322                //只有左线成功，而且左线尾还那么远，真心没法继续。直接返回失败。
   9323                //if(BlackLeftEndLine < CameraHight - 1 - BlackLeftBackLineStart)
   9324                if(BlackLeftEndLine <= BlackControlLineLow)
   \   00000066   0xF8DF 0x0D68      LDR.W    R0,??CenterLineGet_0+0xC
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0x281B             CMP      R0,#+27
   \   0000006E   0xDA02             BGE.N    ??CenterLineGet_6
   9325                {
   9326                  flag2 = 0;
   \   00000070   0x2200             MOVS     R2,#+0
   9327                  return 0;       
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xE147             B.N      ??CenterLineGet_4
   9328                }
   9329                //左线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackLeftEndLine。
   9330                else
   9331                {
   9332                }
   9333              }
   9334              //左线尾等于CameraHight - 1，直接取BlackLeftEndLine
   9335              else
   9336              {
   9337              }
   9338              
   9339              //丢失另一根线的时候，先根据斜率估算出半宽，若没有上一次双线图像时的赛道半宽大，则直接用上一次双线的赛道半宽。
   9340              //求5行的斜率。
   9341              if(BlackLeftEndLine - BlackLeftHeadLine > 5)
   \                     ??CenterLineGet_6: (+1)
   \   00000076   0xF8DF 0x0D58      LDR.W    R0,??CenterLineGet_0+0xC
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0xF8DF 0x1D4C      LDR.W    R1,??CenterLineGet_0+0x8
   \   00000080   0x7809             LDRB     R1,[R1, #+0]
   \   00000082   0x1A40             SUBS     R0,R0,R1
   \   00000084   0x2806             CMP      R0,#+6
   \   00000086   0xDB36             BLT.N    ??CenterLineGet_7
   9342              {
   9343                slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
   9344                              (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
   \   00000088   0xF8DF 0x0D50      LDR.W    R0,??CenterLineGet_0+0x18
   \   0000008C   0xF8DF 0x1D40      LDR.W    R1,??CenterLineGet_0+0xC
   \   00000090   0x7809             LDRB     R1,[R1, #+0]
   \   00000092   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000096   0xF8DF 0x1D44      LDR.W    R1,??CenterLineGet_0+0x18
   \   0000009A   0xF8DF 0x2D34      LDR.W    R2,??CenterLineGet_0+0xC
   \   0000009E   0x7812             LDRB     R2,[R2, #+0]
   \   000000A0   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   000000A4   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   000000A8   0x1A40             SUBS     R0,R0,R1
   \   000000AA   0x.... 0x....      BL       __aeabi_i2d
   \   000000AE   0x2200             MOVS     R2,#+0
   \   000000B0   0xF8DF 0x3E40      LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   000000B4   0x.... 0x....      BL       __aeabi_dmul
   \   000000B8   0x0004             MOVS     R4,R0
   \   000000BA   0x000D             MOVS     R5,R1
   \   000000BC   0xF8DF 0x0D1C      LDR.W    R0,??CenterLineGet_0+0x18
   \   000000C0   0xF8DF 0x1D0C      LDR.W    R1,??CenterLineGet_0+0xC
   \   000000C4   0x7809             LDRB     R1,[R1, #+0]
   \   000000C6   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   000000CA   0x6840             LDR      R0,[R0, #+4]
   \   000000CC   0xF8DF 0x1D0C      LDR.W    R1,??CenterLineGet_0+0x18
   \   000000D0   0xF8DF 0x2CFC      LDR.W    R2,??CenterLineGet_0+0xC
   \   000000D4   0x7812             LDRB     R2,[R2, #+0]
   \   000000D6   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   000000DA   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   000000DE   0x1A40             SUBS     R0,R0,R1
   \   000000E0   0x.... 0x....      BL       __aeabi_i2d
   \   000000E4   0x0002             MOVS     R2,R0
   \   000000E6   0x000B             MOVS     R3,R1
   \   000000E8   0x0020             MOVS     R0,R4
   \   000000EA   0x0029             MOVS     R1,R5
   \   000000EC   0x.... 0x....      BL       __aeabi_ddiv
   \   000000F0   0x.... 0x....      BL       __aeabi_d2f
   \   000000F4   0xE000             B.N      ??CenterLineGet_9
   9345              }
   9346              else
   9347              {
   9348                slope = 0;
   \                     ??CenterLineGet_7: (+1)
   \   000000F6   0x2000             MOVS     R0,#+0
   9349              }
   9350              //赛道半宽
   9351              temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
   \                     ??CenterLineGet_9: (+1)
   \   000000F8   0x0001             MOVS     R1,R0
   \   000000FA   0x.... 0x....      BL       __aeabi_fmul
   \   000000FE   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   00000102   0x.... 0x....      BL       __aeabi_fadd
   \   00000106   0x.... 0x....      BL       __aeabi_f2d
   \   0000010A   0x.... 0x....      BL       sqrt
   \   0000010E   0x2200             MOVS     R2,#+0
   \   00000110   0xF8DF 0x3DE0      LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   00000114   0x.... 0x....      BL       __aeabi_dmul
   \   00000118   0x2200             MOVS     R2,#+0
   \   0000011A   0xF8DF 0x3DDC      LDR.W    R3,??CenterLineGet_8+0x4  ;; 0x40690000
   \   0000011E   0x.... 0x....      BL       __aeabi_dmul
   \   00000122   0x2200             MOVS     R2,#+0
   \   00000124   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   00000128   0x.... 0x....      BL       __aeabi_ddiv
   \   0000012C   0x.... 0x....      BL       __aeabi_d2iz
   \   00000130   0x0004             MOVS     R4,R0
   9352              //取最大值
   9353              RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
   \   00000132   0xF8DF 0x0DC8      LDR.W    R0,??CenterLineGet_8+0x8
   \   00000136   0x7801             LDRB     R1,[R0, #+0]
   \   00000138   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000013A   0x0020             MOVS     R0,R4
   \   0000013C   0x.... 0x....      BL       MaxRe
   \   00000140   0xF8DF 0x1DB8      LDR.W    R1,??CenterLineGet_8+0x8
   \   00000144   0x7008             STRB     R0,[R1, #+0]
   9354              
   9355              //根据赛道宽度估计出中心线的线头。
   9356              CenterLineLoc[BlackLeftEndLine] = BlackUdisLeftLocation[BlackLeftEndLine].x + RoadHalfWidth;
   \   00000146   0xF8DF 0x0C94      LDR.W    R0,??CenterLineGet_0+0x18
   \   0000014A   0xF8DF 0x1C84      LDR.W    R1,??CenterLineGet_0+0xC
   \   0000014E   0x7809             LDRB     R1,[R1, #+0]
   \   00000150   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000154   0xF8DF 0x1DA4      LDR.W    R1,??CenterLineGet_8+0x8
   \   00000158   0x7809             LDRB     R1,[R1, #+0]
   \   0000015A   0x1840             ADDS     R0,R0,R1
   \   0000015C   0xF8DF 0x1E2C      LDR.W    R1,??CenterLineGet_10
   \   00000160   0xF8DF 0x2C6C      LDR.W    R2,??CenterLineGet_0+0xC
   \   00000164   0x7812             LDRB     R2,[R2, #+0]
   \   00000166   0xF821 0x0012      STRH     R0,[R1, R2, LSL #+1]
   9357              
   9358              tempflag1 = 0;
   \   0000016A   0x2400             MOVS     R4,#+0
   9359              tempway1 = 0;
   \   0000016C   0x2500             MOVS     R5,#+0
   9360              //根据左线的走势估计出中心线。中心线是个int16型矩阵，有正负。
   9361              for(row = BlackLeftEndLine - 1; ;row--)
   \   0000016E   0xF8DF 0x0C60      LDR.W    R0,??CenterLineGet_0+0xC
   \   00000172   0x7800             LDRB     R0,[R0, #+0]
   \   00000174   0xF1B0 0x0801      SUBS     R8,R0,#+1
   \   00000178   0xE001             B.N      ??CenterLineGet_11
   \                     ??CenterLineGet_12: (+1)
   \   0000017A   0xF1B8 0x0801      SUBS     R8,R8,#+1
   9362              {
   9363                //左线有效时。根据左线的趋势补线。
   9364                if(BlackLeftLoc[row][0] != MaxValUint8)
   \                     ??CenterLineGet_11: (+1)
   \   0000017E   0xF8DF 0x0E10      LDR.W    R0,??CenterLineGet_10+0x4
   \   00000182   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000186   0x2103             MOVS     R1,#+3
   \   00000188   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   0000018C   0x7800             LDRB     R0,[R0, #+0]
   \   0000018E   0x28FF             CMP      R0,#+255
   \   00000190   0xD01D             BEQ.N    ??CenterLineGet_13
   9365                {
   9366                  tempflag1 = 0;
   \   00000192   0x2400             MOVS     R4,#+0
   9367                  CenterLineLoc[row] = CenterLineLoc[row+1] + BlackUdisLeftLocation[row].x - BlackUdisLeftLocation[row+1].x;
   \   00000194   0xF8DF 0x0DF4      LDR.W    R0,??CenterLineGet_10
   \   00000198   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000019C   0xEB10 0x0048      ADDS     R0,R0,R8, LSL #+1
   \   000001A0   0x8840             LDRH     R0,[R0, #+2]
   \   000001A2   0xF8DF 0x1C38      LDR.W    R1,??CenterLineGet_0+0x18
   \   000001A6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001AA   0xF851 0x1038      LDR      R1,[R1, R8, LSL #+3]
   \   000001AE   0x1808             ADDS     R0,R1,R0
   \   000001B0   0xF8DF 0x1C28      LDR.W    R1,??CenterLineGet_0+0x18
   \   000001B4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001B8   0xEB11 0x01C8      ADDS     R1,R1,R8, LSL #+3
   \   000001BC   0x6889             LDR      R1,[R1, #+8]
   \   000001BE   0x1A40             SUBS     R0,R0,R1
   \   000001C0   0xF8DF 0x1DC8      LDR.W    R1,??CenterLineGet_10
   \   000001C4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001C8   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   000001CC   0xE07B             B.N      ??CenterLineGet_14
   9368                }
   9369                //左线无效时。根据最后两行的中心线趋势补线。
   9370                else
   9371                {
   9372                  //当左线无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
   9373                  if(tempflag1 == 0)
   \                     ??CenterLineGet_13: (+1)
   \   000001CE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001D0   0x2C00             CMP      R4,#+0
   \   000001D2   0xD12E             BNE.N    ??CenterLineGet_15
   9374                  {
   9375                    //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
   9376                    tempflag1 = 1;
   \   000001D4   0x2401             MOVS     R4,#+1
   9377                    //最后几行行数够多，可以采用最小二乘法的方式。
   9378                    if(row + CenterForwardLineNum <= CameraHight - 1)
   \   000001D6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001DA   0xF118 0x0004      ADDS     R0,R8,#+4
   \   000001DE   0x283C             CMP      R0,#+60
   \   000001E0   0xDA26             BGE.N    ??CenterLineGet_16
   9379                    {
   9380                      tempway1 = 0;
   \   000001E2   0x2500             MOVS     R5,#+0
   9381                      //进行最小二乘法系数的计算。
   9382                      for(i = 0; i < CenterForwardLineNum; i++)
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0xE012             B.N      ??CenterLineGet_17
   9383                      {
   9384                        x[i] = row + i + 1;
   \                     ??CenterLineGet_18: (+1)
   \   000001E8   0xEB10 0x0108      ADDS     R1,R0,R8
   \   000001EC   0x1C49             ADDS     R1,R1,#+1
   \   000001EE   0xAA00             ADD      R2,SP,#+0
   \   000001F0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001F2   0x5481             STRB     R1,[R0, R2]
   9385                        y[i] = CenterLineLoc[row + i + 1];
   \   000001F4   0xF8DF 0x1D94      LDR.W    R1,??CenterLineGet_10
   \   000001F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001FA   0xFA50 0xF288      UXTAB    R2,R0,R8
   \   000001FE   0xEB11 0x0142      ADDS     R1,R1,R2, LSL #+1
   \   00000202   0x8849             LDRH     R1,[R1, #+2]
   \   00000204   0xAA01             ADD      R2,SP,#+4
   \   00000206   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000208   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   9386                      }
   \   0000020C   0x1C40             ADDS     R0,R0,#+1
   \                     ??CenterLineGet_17: (+1)
   \   0000020E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000210   0x2804             CMP      R0,#+4
   \   00000212   0xDBE9             BLT.N    ??CenterLineGet_18
   9387                      a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
   \   00000214   0x2204             MOVS     R2,#+4
   \   00000216   0xA901             ADD      R1,SP,#+4
   \   00000218   0xA800             ADD      R0,SP,#+0
   \   0000021A   0x.... 0x....      BL       LeastSquareInt16a1
   \   0000021E   0x0006             MOVS     R6,R0
   9388                      a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
   \   00000220   0x2304             MOVS     R3,#+4
   \   00000222   0x0032             MOVS     R2,R6
   \   00000224   0xA901             ADD      R1,SP,#+4
   \   00000226   0xA800             ADD      R0,SP,#+0
   \   00000228   0x.... 0x....      BL       LeastSquareInt16a0
   \   0000022C   0x0007             MOVS     R7,R0
   \   0000022E   0xE000             B.N      ??CenterLineGet_15
   9389                    }
   9390                    //最后几行的行数不够多，采用最后两行趋势补线的方式。
   9391                    else
   9392                    {
   9393                      tempway1 = 1;
   \                     ??CenterLineGet_16: (+1)
   \   00000230   0x2501             MOVS     R5,#+1
   9394                    }
   9395                  }
   9396                  else
   9397                  {
   9398                  }
   9399                  
   9400                  //确认补线方式后，开始补线。
   9401                  if(tempway1 == 0)
   \                     ??CenterLineGet_15: (+1)
   \   00000232   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000234   0x2D00             CMP      R5,#+0
   \   00000236   0xD10E             BNE.N    ??CenterLineGet_19
   9402                  {
   9403                    //最小二乘法的方式。
   9404                    CenterLineLoc[row] = (a0 + a1 * row) / LeastSquareMulti;
   \   00000238   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000023C   0xFB08 0x7006      MLA      R0,R8,R6,R7
   \   00000240   0xF44F 0x717A      MOV      R1,#+1000
   \   00000244   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000248   0xF8DF 0x1D40      LDR.W    R1,??CenterLineGet_10
   \   0000024C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000250   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   00000254   0xE037             B.N      ??CenterLineGet_14
   9405                  }
   9406                  else
   9407                  {
   9408                    //如果是最近2行。
   9409                    if(row == CameraHight -1  || row == CameraHight - 2)
   \                     ??CenterLineGet_19: (+1)
   \   00000256   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000025A   0xF1B8 0x0F3B      CMP      R8,#+59
   \   0000025E   0xD004             BEQ.N    ??CenterLineGet_20
   \   00000260   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000264   0xF1B8 0x0F3A      CMP      R8,#+58
   \   00000268   0xD110             BNE.N    ??CenterLineGet_21
   9410                    {
   9411                      CenterLineLoc[row] = BlackUdisLeftLocation[row].x + RoadHalfWidth;
   \                     ??CenterLineGet_20: (+1)
   \   0000026A   0xF8DF 0x0B70      LDR.W    R0,??CenterLineGet_0+0x18
   \   0000026E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000272   0xF850 0x0038      LDR      R0,[R0, R8, LSL #+3]
   \   00000276   0xF8DF 0x1C84      LDR.W    R1,??CenterLineGet_8+0x8
   \   0000027A   0x7809             LDRB     R1,[R1, #+0]
   \   0000027C   0x1840             ADDS     R0,R0,R1
   \   0000027E   0xF8DF 0x1D0C      LDR.W    R1,??CenterLineGet_10
   \   00000282   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000286   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   0000028A   0xE01C             B.N      ??CenterLineGet_14
   9412                    }
   9413                    //不是最近2行。
   9414                    else
   9415                    {
   9416                      //最后两行的方式。
   9417                      CenterLineLoc[row] = CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2];            
   \                     ??CenterLineGet_21: (+1)
   \   0000028C   0xF8DF 0x0CFC      LDR.W    R0,??CenterLineGet_10
   \   00000290   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000294   0xEB10 0x0048      ADDS     R0,R0,R8, LSL #+1
   \   00000298   0x8840             LDRH     R0,[R0, #+2]
   \   0000029A   0xF8DF 0x1CF0      LDR.W    R1,??CenterLineGet_10
   \   0000029E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002A2   0xEB11 0x0148      ADDS     R1,R1,R8, LSL #+1
   \   000002A6   0x8849             LDRH     R1,[R1, #+2]
   \   000002A8   0x1808             ADDS     R0,R1,R0
   \   000002AA   0xF8DF 0x1CE0      LDR.W    R1,??CenterLineGet_10
   \   000002AE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002B2   0xEB11 0x0148      ADDS     R1,R1,R8, LSL #+1
   \   000002B6   0x8889             LDRH     R1,[R1, #+4]
   \   000002B8   0x1A40             SUBS     R0,R0,R1
   \   000002BA   0xF8DF 0x1CD0      LDR.W    R1,??CenterLineGet_10
   \   000002BE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002C2   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   9418                    }
   9419                  }
   9420                }
   9421                
   9422                //一直补到最高行。
   9423                if(row == 0) break;
   \                     ??CenterLineGet_14: (+1)
   \   000002C6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002CA   0xF1B8 0x0F00      CMP      R8,#+0
   \   000002CE   0xF47F 0xAF54      BNE.W    ??CenterLineGet_12
   9424              }
   9425              
   9426              //对未处理的行的中心线置无效值。
   9427              //底部置无效值。顶部不用处理。
   9428              if(CenterEndLine != CameraHight - 1)
   \   000002D2   0xF8DF 0x0B04      LDR.W    R0,??CenterLineGet_0+0x14
   \   000002D6   0x7800             LDRB     R0,[R0, #+0]
   \   000002D8   0x283B             CMP      R0,#+59
   \   000002DA   0xD013             BEQ.N    ??CenterLineGet_22
   9429              {
   9430                for(row = CameraHight - 1; ; row--)
   \   000002DC   0xF05F 0x083B      MOVS     R8,#+59
   \   000002E0   0xE009             B.N      ??CenterLineGet_23
   9431                {
   9432                  if(row == CenterEndLine) break;       
   9433                  CenterLineLoc[row] = MaxValInt16;
   \                     ??CenterLineGet_24: (+1)
   \   000002E2   0xF647 0x70FF      MOVW     R0,#+32767
   \   000002E6   0xF8DF 0x1CA4      LDR.W    R1,??CenterLineGet_10
   \   000002EA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002EE   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   000002F2   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \                     ??CenterLineGet_23: (+1)
   \   000002F6   0xF8DF 0x0AE0      LDR.W    R0,??CenterLineGet_0+0x14
   \   000002FA   0x7800             LDRB     R0,[R0, #+0]
   \   000002FC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000300   0x4580             CMP      R8,R0
   \   00000302   0xD1EE             BNE.N    ??CenterLineGet_24
   9434                }
   9435              }
   9436              else
   9437              {
   9438              }
   9439          
   9440              
   9441            }
   9442            //右线提取成功，左线提取失败。
   9443            else if(BlackLeftDone == 0 && BlackRightDone == 1)
   9444            {
   9445              //若右线的线头线尾无效，则直接返回失败。
   9446              if(BlackRightHeadLine == MaxValUint8 || BlackRightEndLine == MaxValUint8)
   9447              {
   9448                return 0;
   9449              }
   9450              else
   9451              {
   9452              }
   9453                 
   9454              flag1 = 1;
   9455              flag2 = 1;
   9456              
   9457              //中心线的线尾取左线的线尾即可。
   9458              CenterHeadLine = BlackRightHeadLine;   //线头取左线的线头，注意这不是实际的线头。
   9459              //CenterHeadLine = 0;                    //线头因为要固定补到第0行，所以直接置0.
   9460              CenterEndLine = BlackRightEndLine;
   9461              
   9462              //首先看线头是否大于BlackControlLineLow行
   9463              if(BlackRightHeadLine >= BlackControlLineLow)
   9464              {
   9465                flag1 = 0;     
   9466              }
   9467              else
   9468              {
   9469              }
   9470              
   9471              //右线尾小于CameraHight - 1行。
   9472              if(BlackRightEndLine < CameraHight - 1)
   9473              {
   9474                //只有右线成功，而且右线尾还那么远，真心没法继续。直接返回失败。
   9475                //if(BlackRightEndLine < CameraHight - 1 - BlackRightBackLineStart)
   9476                if(BlackRightEndLine <= BlackControlLineLow)  
   9477                {
   9478                  flag2 = 0;
   9479                  return 0;
   9480                }
   9481                //右线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackRightEndLine。
   9482                else
   9483                {
   9484                }
   9485              }
   9486              //右线尾等于CameraHight - 1，直接取BlackRightEndLine
   9487              else
   9488              {
   9489              }
   9490              
   9491              //丢失另一根线的时候，先根据斜率估算出半宽，若没有上一次双线图像时的赛道半宽大，则直接用上一次双线的赛道半宽。
   9492              //求5行的斜率。
   9493              if(BlackRightEndLine - BlackRightHeadLine > 5)
   9494              {
   9495                slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
   9496                              (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
   9497              }
   9498              else
   9499              {
   9500                slope = 0;
   9501              }
   9502              //赛道半宽
   9503              temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
   9504              //取最大值
   9505              RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
   9506              
   9507              tempflag1 = 0;
   9508              tempway1 = 0;
   9509              //根据赛道宽度估计出中心线的线头。
   9510              CenterLineLoc[BlackRightEndLine] = BlackUdisRightLocation[BlackRightEndLine].x - RoadHalfWidth;
   9511              //根据右线的走势估计出中心线。中心线是个int16型矩阵，有正负。
   9512              for(row = BlackRightEndLine - 1; ;row--)
   9513              {
   9514                //右线有效时。根据右线的趋势补线。
   9515                if(BlackRightLoc[row][0] != MaxValUint8)
   9516                {
   9517                  tempflag1 = 0;
   9518                  CenterLineLoc[row] = CenterLineLoc[row+1] + BlackUdisRightLocation[row].x - BlackUdisRightLocation[row+1].x;
   9519                }
   9520                //右线无效时。根据最后两行的中心线趋势补线。
   9521                else
   9522                {
   9523                    //当右线无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
   9524                    if(tempflag1 == 0)
   9525                    {
   9526                      //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
   9527                      tempflag1 = 1;
   9528                      //最后几行行数够多，可以采用最小二乘法的方式。
   9529                      if(row + CenterForwardLineNum <= CameraHight - 1)
   9530                      {
   9531                        tempway1 = 0;
   9532                        //进行最小二乘法系数的计算。
   9533                        for(i = 0; i < CenterForwardLineNum; i++)
   9534                        {
   9535                          x[i] = row + i + 1;
   9536                          y[i] = CenterLineLoc[row + i + 1];
   9537                        }
   9538                        a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
   9539                        a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
   9540                      }
   9541                      //最后几行的行数不够多，采用最后两行趋势补线的方式。
   9542                      else
   9543                      {
   9544                        tempway1 = 1;
   9545                      }
   9546                    }
   9547                    else
   9548                    {
   9549                    }
   9550                  
   9551                    //确认补线方式后，开始补线。
   9552                    if(tempway1 == 0)
   9553                    {
   9554                      //最小二乘法的方式。
   9555                      CenterLineLoc[row] = (a0 + a1 * row) / LeastSquareMulti;
   9556                    }
   9557                    else
   9558                    {
   9559                      //最近2行。
   9560                      if(row == CameraHight - 1 || row == CameraHight - 2)
   9561                      {
   9562                        CenterLineLoc[row] = BlackUdisRightLocation[row].x - RoadHalfWidth;
   9563                      }
   9564                      //不是最近2行。
   9565                      else
   9566                      {
   9567                        //最后两行的方式。
   9568                        CenterLineLoc[row] = CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2];
   9569                      }
   9570                    }
   9571                  }
   9572                
   9573                  if(row == 0) break;
   9574                }
   9575              
   9576                
   9577              
   9578              //对未处理的行的中心线置无效值。
   9579              //底部置无效值。顶部不用处理。
   9580              if(CenterEndLine != CameraHight - 1)
   9581              {
   9582                for(row = CameraHight - 1; ; row--)
   9583                {
   9584                  if(row == CenterEndLine) break;       
   9585                  CenterLineLoc[row] = MaxValInt16;
   9586                }
   9587              }
   9588              else
   9589              {
   9590              }
   9591             
   9592            }
   9593            //左右线均提取成功。
   9594            else if(BlackLeftDone == 1 && BlackRightDone == 1)
   9595            {
   9596              CenterHeadLine = MinRe(BlackLeftHeadLine, BlackRightHeadLine);    //线头取两者较小者。     
   9597              //CenterHeadLine = 0;    //因为固定要补到第0行，所以固定取0.
   9598              //线尾取两者较大者。
   9599              CenterEndLine = MaxRe(BlackLeftEndLine, BlackRightEndLine);             
   9600              
   9601              //不是单线的情况。
   9602              if(SingleBlackAllFlag == 0)
   9603              {
   9604              
   9605                //左右线均提取成功，首选根据两线得中心线，实在不行再根据赛道宽度估计。
   9606                //不根据趋势来预测，因为畸变矫正基本上已经把左右线差搞成定值了，所以不用那么麻烦。    
   9607                
   9608                //先检查左线，左线不满足条件再检测右线。右线不满足再返回失败。
   9609                flag1 = 1;
   9610                flag2 = 1;
   9611                flag3 = 1;
   9612                flag4 = 1;
   9613                //取左右两线的第39到第59行的差，取最大值。
   9614                //首先看线头是否大于39行，大于39行就直接返回失败。
   9615                if(BlackLeftHeadLine >= BlackControlLineLow)
   9616                {
   9617                  flag1 = 0;
   9618                }
   9619                else
   9620                {
   9621                }
   9622                //左线尾小于CameraHight - 1行。
   9623                if(BlackLeftEndLine < CameraHight - 1)
   9624                {
   9625                  //只有左线成功，而且左线尾还那么远，真心没法继续。看右线是不是一样的情况。
   9626                  //if(BlackLeftEndLine < CameraHight - 1 - BlackLeftBackLineStart)
   9627                  if(BlackLeftEndLine <= BlackControlLineLow)
   9628                  {
   9629                    flag2 = 0;
   9630                  }
   9631                  //左线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackLeftEndLine。
   9632                  else
   9633                  {
   9634                  }
   9635                }
   9636                //左线尾等于CameraHight - 1，直接取BlackLeftEndLine
   9637                else
   9638                {
   9639                }
   9640            
   9641                //处理右线，右线不满足条件，则直接返回失败。
   9642                //首先看线头是否大于39行，大于39行就直接返回失败。
   9643                if(BlackRightHeadLine >= BlackControlLineLow)
   9644                {
   9645                  flag3 = 0;
   9646                }
   9647                else
   9648                {
   9649                }    
   9650                //右线尾小于CameraHight - 1行。
   9651                if(BlackRightEndLine < CameraHight - 1)
   9652                {
   9653                  //只有右线成功，而且右线尾还那么远，真心没法继续。直接返回失败。
   9654                  //if(BlackRightEndLine < CameraHight - 1 - BlackRightBackLineStart)
   9655                  if(BlackRightEndLine <= BlackControlLineLow)
   9656                  {
   9657                    flag4 = 0;
   9658                    //两次都线尾很远，直接返回失败。
   9659                    if(flag2 == 0) 
   9660                    {
   9661                      return 0;
   9662                    }
   9663                    else
   9664                    {
   9665                    }
   9666                  }
   9667                  //右线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackRightEndLine。
   9668                  else
   9669                  {
   9670                  }
   9671                }
   9672                //右线尾等于CameraHight - 1，直接取BlackRightEndLine
   9673                else
   9674                {
   9675                }
   9676                
   9677                //只有右线满足要求，则直接取右线的列差值绝对值。
   9678                if(
   9679                  (flag3 == 1 && flag4 == 1)
   9680                &&((flag1 == 0 && flag2 == 0) || (flag1 == 1 && flag2 == 0) || (flag1 == 0 && flag2 == 1))
   9681                  )
   9682                {
   9683                  //斜率的方式估算出赛道半宽。
   9684                  //求5行的斜率。
   9685                  if(BlackRightEndLine - BlackRightHeadLine > 5)
   9686                  {
   9687                    slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
   9688                                  (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
   9689                  }
   9690                  else
   9691                  {
   9692                    slope = 0;
   9693                  }
   9694                  //赛道半宽
   9695                  temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
   9696                  RoadHalfWidthCompen = RoadHalfWidth / temp;
   9697                  RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
   9698                }
   9699                //只有左线满足要求，则直接取左线的列差值绝对值。
   9700                else if(
   9701                       (flag1 == 1 && flag2 == 1)
   9702                     &&((flag3 == 0 && flag4 == 0) || (flag3 == 1 && flag4 == 0) || (flag3 == 0 && flag4 == 1))
   9703                       )
   9704                {
   9705                  //斜率的方式估算出赛道半宽。
   9706                  //求5行的斜率。
   9707                  if(BlackLeftEndLine - BlackLeftHeadLine > 5)
   9708                  {
   9709                    slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
   9710                                  (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
   9711                  }
   9712                  else
   9713                  {
   9714                    slope = 0;
   9715                  }
   9716                  //赛道半宽
   9717                  temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
   9718                  RoadHalfWidthCompen = RoadHalfWidth / temp;
   9719                  RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
   9720                }
   9721                //左右线均满足条件。则取列差值绝对值较大的。
   9722                else if(flag1 == 1 && flag2 == 1 && flag3 == 1 && flag4 == 1)
   9723                {
   9724                  //斜率的方式估算出赛道半宽。
   9725                  //求5行的斜率。
   9726                  if(BlackLeftEndLine - BlackLeftHeadLine > 5)
   9727                  {
   9728                    slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
   9729                                  (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
   9730                  }
   9731                  else
   9732                  {
   9733                    slope = 0;
   9734                  }
   9735                  //赛道半宽
   9736                  temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
   9737                  
   9738                  //求5行的斜率。
   9739                  if(BlackRightEndLine - BlackRightHeadLine > 5)
   9740                  {
   9741                    slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
   9742                                  (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
   9743                  }
   9744                  else
   9745                  {
   9746                    slope = 0;
   9747                  }
   9748                  //赛道半宽
   9749                  temp = MaxRe((uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2), temp);
   9750                  RoadHalfWidthCompen = RoadHalfWidth / temp;
   9751                  RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
   9752                }
   9753                //左右线均不满足要求。
   9754                else
   9755                {
   9756                  //左右线都在第BlackControlLineLow行的远方。直接返回失败。
   9757                  if(flag2 == 0 && flag4 == 0)
   9758                  {
   9759                    return 0;
   9760                  }
   9761                  else
   9762                  {
   9763                    //左线在第BlackControlLineLow行的近方，右线在第BlackControlLineLow行的远方，则用左线来求。
   9764                    if(flag1 == 1 && flag3 == 0)
   9765                    {
   9766                      //斜率的方式估算出赛道半宽。
   9767                      //求5行的斜率。
   9768                      if(BlackLeftEndLine - BlackLeftHeadLine > 5)
   9769                      {
   9770                        slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
   9771                                      (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
   9772                      }
   9773                      else
   9774                      {
   9775                        slope = 0;
   9776                      }
   9777                      //赛道半宽
   9778                      temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
   9779                      RoadHalfWidthCompen = RoadHalfWidth / temp;
   9780                      RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
   9781                    }
   9782                    //右线在第BlackControlLineLow行的近方，左线在第BlackControlLineLow行的远方，则用右线来求。
   9783                    else if(flag1 == 0 && flag3 == 1)
   9784                    {
   9785                      //斜率的方式估算出赛道半宽。
   9786                      //求5行的斜率。
   9787                      if(BlackRightEndLine - BlackRightHeadLine > 5)
   9788                      {
   9789                        slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
   9790                                      (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
   9791                      }
   9792                      else
   9793                      {
   9794                        slope = 0;
   9795                      }
   9796                      //赛道半宽
   9797                      temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
   9798                      RoadHalfWidthCompen = RoadHalfWidth / temp;
   9799                      RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
   9800                    }
   9801                    //左右线都在第行的近方，则取较大值。
   9802                    else if(flag1 == 0 && flag3 == 0)
   9803                    {
   9804                      //斜率的方式估算出赛道半宽。
   9805                      //求5行的斜率。
   9806                      if(BlackLeftEndLine - BlackLeftHeadLine > 5)
   9807                      {
   9808                        slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
   9809                                      (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
   9810                      }
   9811                      else
   9812                      {
   9813                        slope = 0;
   9814                      }
   9815                      //赛道半宽
   9816                      temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
   9817                      
   9818                      //求5行的斜率。
   9819                      if(BlackRightEndLine - BlackRightHeadLine > 5)
   9820                      {
   9821                        slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
   9822                                      (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
   9823                      }
   9824                      else
   9825                      {
   9826                        slope = 0;
   9827                      }
   9828                      //赛道半宽
   9829                      temp = MaxRe((uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2), temp);
   9830                      RoadHalfWidthCompen = RoadHalfWidth / temp;
   9831                      RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
   9832                    }
   9833                    //理论上不可能走到这里。
   9834                    else
   9835                    {
   9836                      return 0;
   9837                    }
   9838                  }
   9839                }
   9840                
   9841                uint8 temproad;  //本幅图的最后一个双线有效路宽。给本幅图的单线部分用。
   9842                temproad = RoadHalfWidth;
   9843                
   9844                tempflag1 = 0;
   9845                tempway1 = 0;      
   9846                //赛道宽度已经求得，现在开始从低到高求中心线。
   9847                for(row = CenterEndLine; ; row--)
   9848                {
   9849                  //当前行左右黑线均有效。检测有无效不能用Udis数组，只能用原始的黑线储存数组。
   9850                  if(BlackLeftLoc[row][0] != MaxValUint8 && BlackRightLoc[row][0] != MaxValUint8)
   9851                  {
   9852                    tempflag1 = 0;
   9853                    //取左右黑线的平均值。
   9854                    CenterLineLoc[row] = (BlackUdisLeftLocation[row].x + BlackUdisRightLocation[row].x) / 2;
   9855                    //取最后一行两行有效的行的赛道半宽，作为最新的赛道半宽。
   9856                    if(BlackUdisLeftLocation[row].x > BlackUdisRightLocation[row].x)
   9857                    {
   9858                      RoadHalfWidthRecord[row] = (BlackUdisLeftLocation[row].x - BlackUdisRightLocation[row].x) / 2;           
   9859                    }
   9860                    else
   9861                    {
   9862                      RoadHalfWidthRecord[row] = (BlackUdisRightLocation[row].x - BlackUdisLeftLocation[row].x) / 2;
   9863                    }
   9864                    
   9865                    //本幅图的最后一个双线有效路宽。给本幅图的单线部分用。
   9866                    temproad = RoadHalfWidthRecord[row];
   9867                    //赛道半宽记录.存第CameraHight - 1行的赛道半宽，给下一幅图用。
   9868                    //怕出意外，限个幅。
   9869                    if(row == CameraHight - 1) 
   9870                    {  
   9871                      if(RoadHalfWidthRecord[row] > RoadHalfWidthLimitMax)
   9872                      {
   9873                        RoadHalfWidth = RoadHalfWidthLimitMax;
   9874                      }
   9875                      else if(RoadHalfWidthRecord[row] < RoadHalfWidthLimitMin)
   9876                      {
   9877                        RoadHalfWidth = RoadHalfWidthLimitMin;
   9878                      }
   9879                      else
   9880                      {
   9881                        RoadHalfWidth = RoadHalfWidthRecord[row];
   9882                      }            
   9883                    }
   9884                    else
   9885                    {
   9886                    }
   9887                  }
   9888                  //左行有效，右行无效。则用左行加上一个赛道半宽。
   9889                  else if(BlackLeftLoc[row][0] != MaxValUint8 && BlackRightLoc[row][0] == MaxValUint8)
   9890                  {
   9891                    tempflag1 = 0;
   9892                    CenterLineLoc[row] = BlackUdisLeftLocation[row].x + temproad;
   9893                  }
   9894                  //左行无效，右行有效。则用右行减去一个赛道半宽。
   9895                  else if(BlackLeftLoc[row][0] == MaxValUint8 && BlackRightLoc[row][0] != MaxValUint8)
   9896                  {
   9897                    tempflag1 = 0;
   9898                    CenterLineLoc[row] = BlackUdisRightLocation[row].x - temproad;
   9899                  }
   9900                  //左右行均无效。则用最后的中心线均势往前走。
   9901                  else if(BlackLeftLoc[row][0] == MaxValUint8 && BlackRightLoc[row][0] == MaxValUint8)
   9902                  {
   9903                    //当左右线均无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
   9904                    if(tempflag1 == 0)
   9905                    {
   9906                      //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
   9907                      //除非又出现左或右黑线有效的情况，则再次刷新斜率。
   9908                      tempflag1 = 1;
   9909                      //最后几行行数够多，可以采用最小二乘法的方式。
   9910                      if(row + CenterForwardLineNum <= CameraHight - 1)
   9911                      {
   9912                        tempway1 = 0;
   9913                        //进行最小二乘法系数的计算。
   9914                        for(i = 0; i < CenterForwardLineNum; i++)
   9915                        {
   9916                          x[i] = row + i + 1;
   9917                          y[i] = CenterLineLoc[row + i + 1];
   9918                        }
   9919                        a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
   9920                        a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
   9921                      }
   9922                      //最后几行的行数不够多，采用最后两行趋势补线的方式。
   9923                      else
   9924                      {
   9925                        tempway1 = 1;
   9926                      }
   9927                    }
   9928                    else
   9929                    {
   9930                    }
   9931                    
   9932                    //确认补线方式后，开始补线。
   9933                    if(tempway1 == 0)
   9934                    {
   9935                      //最小二乘法的方式。
   9936                      CenterLineLoc[row] = (a0 + a1 * row) / LeastSquareMulti;
   9937                    }
   9938                    else
   9939                    {
   9940                      //最后两行的方式。
   9941                      CenterLineLoc[row] = CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2];
   9942                    }
   9943                    
   9944                  }
   9945                  //理论上不会走到这里。
   9946                  else
   9947                  {
   9948                  }
   9949                  
   9950                  if(row == 0) break;
   9951                }
   9952                   
   9953                //对未处理的行的中心线置无效值。对顶部的不作处理。
   9954                //底部置无效值。
   9955                if(CenterEndLine != CameraHight - 1)
   9956                {
   9957                  for(row = CameraHight - 1; ; row--)
   9958                  {
   9959                    if(row == CenterEndLine) break;       
   9960                    CenterLineLoc[row] = MaxValInt16;
   9961                  }
   9962                }
   9963                else
   9964                {
   9965                }
   9966                
   9967                //单线错误暂时不检查
   9968                /*
   9969                uint8 temphead;
   9970                
   9971                //检查单线错误，先判断是不是一线初始行够高，一线初始行够低，若不是，直接跳过节省时间。
   9972                if(BlackLeftStep1ScanRow <= CameraHight - 3 && BlackRightStep1ScanRow >= CameraHight - 3)
   9973                {
   9974                  //双线都采集到的时候，最终需要检查一下赛道半宽是不是正确。
   9975                  //第一种情况，有效双行很短，而且范围内存在赛道半宽很小的点。
   9976                  for(i = 0; ; i++)
   9977                  {
   9978                    if(RoadHalfWidthRecord[i] != MaxValUint8)
   9979                    {
   9980                      temphead = i;
   9981                      break;
   9982                    }
   9983                    
   9984                    //理论上不可能走到这里
   9985                    if(i == CameraHight - 1) return 1;  //无法检测单线错误，返回1.
   9986                  }
   9987                  
   9988                  //长度是不是够小。
   9989                  if(BlackLeftStep1ScanRow > temphead && BlackLeftStep1ScanRow - temphead < RoadHalfWidthSingleGapLine)
   9990                  {
   9991                    for(i = BlackLeftStep1ScanRow; ; i--)
   9992                    {
   9993                      if(RoadHalfWidthRecord[i] < RoadHalfWidthSingleLimit)
   9994                      {
   9995                        //存在半宽很小的行，直接置单线错误标志位。 
   9996                        RoadHalfWidthWrongDir = 0;          //单线错误时左线悬空。
   9997                        RoadHalfWidthWrongFlag = 1;
   9998                        break;
   9999                      }            
  10000                      //不存在半宽很小的行，跳出，进行第二种情况的检测。
  10001                      if(i == temphead)
  10002                      {
  10003                        break;
  10004                      }
  10005                    }
  10006                    
  10007                  }
  10008                  
  10009                  //第一种情况没有检测出来的话，就检测第二种情况。
  10010                  if(RoadHalfWidthWrongFlag == 2)
  10011                  {
  10012                    for(i = CameraHight - 1; ; i--)
  10013                    {
  10014                      //只要有效的双行里有任何一个赛道半宽大于阈值，就判断为不是单线错误。
  10015                      if(RoadHalfWidthRecord[i] != MaxValUint8 && RoadHalfWidthRecord[i] > RoadHalfWidthSingleLimit)
  10016                      {
  10017                        RoadHalfWidthWrongFlag = 0;
  10018                        break;
  10019                      }
  10020                      else
  10021                      {
  10022                      }
  10023                      
  10024                      //直到最后一行仍然不满足条件，则判断为单线错误。
  10025                      if(i == 0)
  10026                      {
  10027                        RoadHalfWidthWrongDir = 0;          //单线错误时左线悬空。
  10028                        RoadHalfWidthWrongFlag = 1;
  10029                        break;
  10030                      }
  10031                      else
  10032                      {          
  10033                      }
  10034                    }
  10035                  }
  10036                  else
  10037                  {
  10038                  }        
  10039                }
  10040                else if(BlackRightStep1ScanRow <= CameraHight - 3 && BlackLeftStep1ScanRow >= CameraHight - 3)
  10041                {
  10042                  //双线都采集到的时候，最终需要检查一下赛道半宽是不是正确。
  10043                  //第一种情况，有效双行很短，而且范围内存在赛道半宽很小的点。
  10044                  for(i = 0; ; i++)
  10045                  {
  10046                    if(RoadHalfWidthRecord[i] != MaxValUint8)
  10047                    {
  10048                      temphead = i;
  10049                      break;
  10050                    }
  10051                    
  10052                    //理论上不可能走到这里
  10053                    if(i == CameraHight - 1) return 1;  //无法检测单线错误，返回1.
  10054                  }
  10055                  
  10056                  //长度是不是够小。
  10057                  if(BlackRightStep1ScanRow > temphead && BlackRightStep1ScanRow - temphead < RoadHalfWidthSingleGapLine)
  10058                  {
  10059                    for(i = BlackRightStep1ScanRow; ; i--)
  10060                    {
  10061                      if(RoadHalfWidthRecord[i] < RoadHalfWidthSingleLimit)
  10062                      {
  10063                        //存在半宽很小的行，直接置单线错误标志位。 
  10064                        RoadHalfWidthWrongDir = 1;          //单线错误时右线悬空。
  10065                        RoadHalfWidthWrongFlag = 1;
  10066                        break;
  10067                      }            
  10068                      //不存在半宽很小的行，跳出，进行第二种情况的检测。
  10069                      if(i == temphead)
  10070                      {
  10071                        break;
  10072                      }
  10073                    }
  10074                    
  10075                  }
  10076                  
  10077                  //第一种情况没有检测出来的话，就检测第二种情况。
  10078                  if(RoadHalfWidthWrongFlag == 2)
  10079                  {
  10080                    for(i = CameraHight - 1; ; i--)
  10081                    {
  10082                      //只要有效的双行里有任何一个赛道半宽大于阈值，就判断为不是单线错误。
  10083                      if(RoadHalfWidthRecord[i] != MaxValUint8 && RoadHalfWidthRecord[i] > RoadHalfWidthSingleLimit)
  10084                      {
  10085                        RoadHalfWidthWrongFlag = 0;
  10086                        break;
  10087                      }
  10088                      else
  10089                      {
  10090                      }
  10091                      
  10092                      //直到最后一行仍然不满足条件，则判断为单线错误。
  10093                      if(i == 0)
  10094                      {
  10095                        RoadHalfWidthWrongDir = 1;          //单线错误时右线悬空。
  10096                        RoadHalfWidthWrongFlag = 1;
  10097                        break;
  10098                      }
  10099                      else
  10100                      {          
  10101                      }
  10102                    }
  10103                  }
  10104                  else
  10105                  {
  10106                  }
  10107                  
  10108                }
  10109                //初始行不满足条件，则不需要检测单线错误。
  10110                else
  10111                {      
  10112                }
  10113                
  10114                //单线错误的处理，暂时简单处理为中心线错误，也就是图像错误。为了让扫描起点保持原状。
  10115                if(RoadHalfWidthWrongFlag == 1)
  10116                {        
  10117                  RoadHalfWidth = RoadHalfWidthLast;  //这次的赛道半宽无效，还原为上幅图像最终的赛道半宽。
  10118                  //一边的线是错误的。
  10119                  if(RoadHalfWidthWrongDir == 0)
  10120                  {
  10121                    BlackLeftDone = 0;
  10122                  }
  10123                  else
  10124                  {
  10125                    BlackRightDone = 0;
  10126                  }
  10127                  CenterLineGetSingleWrongAdd();      //针对单线错误的中心线重新处理。
  10128                }
  10129                else
  10130                {        
  10131                }
  10132                */
  10133                
  10134              }
  10135              //单线的情况，也就是SingleBlackAllFlag==1的情况。
  10136              else
  10137              {
  10138                tempflag1 = 0;
  10139                tempway1 = 0;
  10140                
  10141                //赛道宽度已经求得，现在开始从低到高求中心线。
  10142                for(row = CenterEndLine; ; row--)
  10143                {
  10144                  //当前行左右黑线均有效。检测有无效不能用Udis数组，只能用原始的黑线储存数组。
  10145                  if(BlackLeftLoc[row][0] != MaxValUint8 && BlackRightLoc[row][0] != MaxValUint8)
  10146                  {
  10147                    tempflag1 = 0;
  10148                    //取左右黑线的平均值。
  10149                    CenterLineLoc[row] = (BlackUdisLeftLocation[row].x + BlackUdisRightLocation[row].x) / 2;
  10150                    //取最后一行两行有效的行的赛道半宽，作为最新的赛道半宽。
  10151                    if(BlackUdisLeftLocation[row].x > BlackUdisRightLocation[row].x)
  10152                    {
  10153                      RoadHalfWidthSingle = (BlackUdisLeftLocation[row].x - BlackUdisRightLocation[row].x) / 2;
  10154                    }
  10155                    else
  10156                    {
  10157                      RoadHalfWidthSingle = (BlackUdisRightLocation[row].x - BlackUdisLeftLocation[row].x) / 2;
  10158                    }        
  10159                  }
  10160                  //左行有效，右行无效。则用左行加上一个赛道半宽。
  10161                  else if(BlackLeftLoc[row][0] != MaxValUint8 && BlackRightLoc[row][0] == MaxValUint8)
  10162                  {
  10163                    tempflag1 = 0;
  10164                    CenterLineLoc[row] = BlackUdisLeftLocation[row].x - RoadHalfWidthSingle;    //因为是单线，所以是减号。
  10165                  }
  10166                  //左行无效，右行有效。则用右行减去一个赛道半宽。
  10167                  else if(BlackLeftLoc[row][0] == MaxValUint8 && BlackRightLoc[row][0] != MaxValUint8)
  10168                  {
  10169                    tempflag1 = 0;
  10170                    CenterLineLoc[row] = BlackUdisRightLocation[row].x + RoadHalfWidthSingle;   //因为是单线，所以是加号。
  10171                  }
  10172                  //左右行均无效。则用最后的中心线均势往前走。
  10173                  else if(BlackLeftLoc[row][0] == MaxValUint8 && BlackRightLoc[row][0] == MaxValUint8)
  10174                  {
  10175                    //当左右线均无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
  10176                    if(tempflag1 == 0)
  10177                    {
  10178                      //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
  10179                      //除非又出现左或右黑线有效的情况，则再次刷新斜率。
  10180                      tempflag1 = 1;
  10181                      //最后几行行数够多，可以采用最小二乘法的方式。
  10182                      if(row + CenterForwardLineNum <= CameraHight - 1)
  10183                      {
  10184                        tempway1 = 0;
  10185                        //进行最小二乘法系数的计算。
  10186                        for(i = 0; i < CenterForwardLineNum; i++)
  10187                        {
  10188                          x[i] = row + i + 1;
  10189                          y[i] = CenterLineLoc[row + i + 1];
  10190                        }
  10191                        a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
  10192                        a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
  10193                      }
  10194                      //最后几行的行数不够多，采用最后两行趋势补线的方式。
  10195                      else
  10196                      {
  10197                        tempway1 = 1;
  10198                      }
  10199                    }
  10200                    else
  10201                    {
  10202                    }
  10203                    
  10204                    //确认补线方式后，开始补线。
  10205                    if(tempway1 == 0)
  10206                    {
  10207                      //最小二乘法的方式。
  10208                      CenterLineLoc[row] = (a0 + a1 * row) / LeastSquareMulti;
  10209                    }
  10210                    else
  10211                    {
  10212                      //最后两行的方式。
  10213                      CenterLineLoc[row] = CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2];
  10214                    }
  10215                    
  10216                  }
  10217                  //理论上不会走到这里。
  10218                  else
  10219                  {
  10220                  }
  10221                  
  10222                  if(row == 0) break;
  10223                }
  10224                   
  10225                //对未处理的行的中心线置无效值。对顶部的不作处理。
  10226                //底部置无效值。
  10227                if(CenterEndLine != CameraHight - 1)
  10228                {
  10229                  for(row = CameraHight - 1; ; row--)
  10230                  {
  10231                    if(row == CenterEndLine) break;       
  10232                    CenterLineLoc[row] = MaxValInt16;
  10233                  }
  10234                }
  10235                else
  10236                {
  10237                }
  10238              }
  10239            }
  10240            //理论上不会走到这里。
  10241            else
  10242            {
  10243              //左右黑线均提取失败，返回0.
  10244              return 0;
  10245            }
  10246            
  10247            return 1;
   \                     ??CenterLineGet_22: (+1)
   \   00000304   0x2001             MOVS     R0,#+1
   \                     ??CenterLineGet_4: (+1)
   \   00000306   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
   \                     ??CenterLineGet_1: (+1)
   \   0000030A   0xF8DF 0x0AB8      LDR.W    R0,??CenterLineGet_0
   \   0000030E   0x7800             LDRB     R0,[R0, #+0]
   \   00000310   0x2800             CMP      R0,#+0
   \   00000312   0xF040 0x817C      BNE.W    ??CenterLineGet_25
   \   00000316   0xF8DF 0x0AB0      LDR.W    R0,??CenterLineGet_0+0x4
   \   0000031A   0x7800             LDRB     R0,[R0, #+0]
   \   0000031C   0x2801             CMP      R0,#+1
   \   0000031E   0xF040 0x8176      BNE.W    ??CenterLineGet_25
   \   00000322   0xF8DF 0x0C70      LDR.W    R0,??CenterLineGet_10+0x8
   \   00000326   0x7800             LDRB     R0,[R0, #+0]
   \   00000328   0x28FF             CMP      R0,#+255
   \   0000032A   0xD004             BEQ.N    ??CenterLineGet_26
   \   0000032C   0xF8DF 0x0C68      LDR.W    R0,??CenterLineGet_10+0xC
   \   00000330   0x7800             LDRB     R0,[R0, #+0]
   \   00000332   0x28FF             CMP      R0,#+255
   \   00000334   0xD101             BNE.N    ??CenterLineGet_27
   \                     ??CenterLineGet_26: (+1)
   \   00000336   0x2000             MOVS     R0,#+0
   \   00000338   0xE7E5             B.N      ??CenterLineGet_4
   \                     ??CenterLineGet_27: (+1)
   \   0000033A   0x2101             MOVS     R1,#+1
   \   0000033C   0x2201             MOVS     R2,#+1
   \   0000033E   0xF8DF 0x0C54      LDR.W    R0,??CenterLineGet_10+0x8
   \   00000342   0x7800             LDRB     R0,[R0, #+0]
   \   00000344   0xF8DF 0x1A8C      LDR.W    R1,??CenterLineGet_0+0x10
   \   00000348   0x7008             STRB     R0,[R1, #+0]
   \   0000034A   0xF8DF 0x0C4C      LDR.W    R0,??CenterLineGet_10+0xC
   \   0000034E   0x7800             LDRB     R0,[R0, #+0]
   \   00000350   0xF8DF 0x1A84      LDR.W    R1,??CenterLineGet_0+0x14
   \   00000354   0x7008             STRB     R0,[R1, #+0]
   \   00000356   0xF8DF 0x0C3C      LDR.W    R0,??CenterLineGet_10+0x8
   \   0000035A   0x7800             LDRB     R0,[R0, #+0]
   \   0000035C   0x281A             CMP      R0,#+26
   \   0000035E   0xDB00             BLT.N    ??CenterLineGet_28
   \   00000360   0x2100             MOVS     R1,#+0
   \                     ??CenterLineGet_28: (+1)
   \   00000362   0xF8DF 0x0C34      LDR.W    R0,??CenterLineGet_10+0xC
   \   00000366   0x7800             LDRB     R0,[R0, #+0]
   \   00000368   0x283B             CMP      R0,#+59
   \   0000036A   0xDA07             BGE.N    ??CenterLineGet_29
   \   0000036C   0xF8DF 0x0C28      LDR.W    R0,??CenterLineGet_10+0xC
   \   00000370   0x7800             LDRB     R0,[R0, #+0]
   \   00000372   0x281B             CMP      R0,#+27
   \   00000374   0xDA02             BGE.N    ??CenterLineGet_29
   \   00000376   0x2200             MOVS     R2,#+0
   \   00000378   0x2000             MOVS     R0,#+0
   \   0000037A   0xE7C4             B.N      ??CenterLineGet_4
   \                     ??CenterLineGet_29: (+1)
   \   0000037C   0xF8DF 0x0C18      LDR.W    R0,??CenterLineGet_10+0xC
   \   00000380   0x7800             LDRB     R0,[R0, #+0]
   \   00000382   0xF8DF 0x1C10      LDR.W    R1,??CenterLineGet_10+0x8
   \   00000386   0x7809             LDRB     R1,[R1, #+0]
   \   00000388   0x1A40             SUBS     R0,R0,R1
   \   0000038A   0x2806             CMP      R0,#+6
   \   0000038C   0xDB36             BLT.N    ??CenterLineGet_30
   \   0000038E   0xF8DF 0x0C0C      LDR.W    R0,??CenterLineGet_10+0x10
   \   00000392   0xF8DF 0x1C04      LDR.W    R1,??CenterLineGet_10+0xC
   \   00000396   0x7809             LDRB     R1,[R1, #+0]
   \   00000398   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   0000039C   0xF8DF 0x1BFC      LDR.W    R1,??CenterLineGet_10+0x10
   \   000003A0   0xF8DF 0x2BF4      LDR.W    R2,??CenterLineGet_10+0xC
   \   000003A4   0x7812             LDRB     R2,[R2, #+0]
   \   000003A6   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   000003AA   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   000003AE   0x1A40             SUBS     R0,R0,R1
   \   000003B0   0x.... 0x....      BL       __aeabi_i2d
   \   000003B4   0x2200             MOVS     R2,#+0
   \   000003B6   0xF8DF 0x3B3C      LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   000003BA   0x.... 0x....      BL       __aeabi_dmul
   \   000003BE   0x0004             MOVS     R4,R0
   \   000003C0   0x000D             MOVS     R5,R1
   \   000003C2   0xF8DF 0x0BD8      LDR.W    R0,??CenterLineGet_10+0x10
   \   000003C6   0xF8DF 0x1BD0      LDR.W    R1,??CenterLineGet_10+0xC
   \   000003CA   0x7809             LDRB     R1,[R1, #+0]
   \   000003CC   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   000003D0   0x6840             LDR      R0,[R0, #+4]
   \   000003D2   0xF8DF 0x1BC8      LDR.W    R1,??CenterLineGet_10+0x10
   \   000003D6   0xF8DF 0x2BC0      LDR.W    R2,??CenterLineGet_10+0xC
   \   000003DA   0x7812             LDRB     R2,[R2, #+0]
   \   000003DC   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   000003E0   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   000003E4   0x1A40             SUBS     R0,R0,R1
   \   000003E6   0x.... 0x....      BL       __aeabi_i2d
   \   000003EA   0x0002             MOVS     R2,R0
   \   000003EC   0x000B             MOVS     R3,R1
   \   000003EE   0x0020             MOVS     R0,R4
   \   000003F0   0x0029             MOVS     R1,R5
   \   000003F2   0x.... 0x....      BL       __aeabi_ddiv
   \   000003F6   0x.... 0x....      BL       __aeabi_d2f
   \   000003FA   0xE000             B.N      ??CenterLineGet_31
   \                     ??CenterLineGet_30: (+1)
   \   000003FC   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGet_31: (+1)
   \   000003FE   0x0001             MOVS     R1,R0
   \   00000400   0x.... 0x....      BL       __aeabi_fmul
   \   00000404   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   00000408   0x.... 0x....      BL       __aeabi_fadd
   \   0000040C   0x.... 0x....      BL       __aeabi_f2d
   \   00000410   0x.... 0x....      BL       sqrt
   \   00000414   0x2200             MOVS     R2,#+0
   \   00000416   0xF8DF 0x3ADC      LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   0000041A   0x.... 0x....      BL       __aeabi_dmul
   \   0000041E   0x2200             MOVS     R2,#+0
   \   00000420   0xF8DF 0x3AD4      LDR.W    R3,??CenterLineGet_8+0x4  ;; 0x40690000
   \   00000424   0x.... 0x....      BL       __aeabi_dmul
   \   00000428   0x2200             MOVS     R2,#+0
   \   0000042A   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   0000042E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000432   0x.... 0x....      BL       __aeabi_d2iz
   \   00000436   0x0004             MOVS     R4,R0
   \   00000438   0xF8DF 0x0AC0      LDR.W    R0,??CenterLineGet_8+0x8
   \   0000043C   0x7801             LDRB     R1,[R0, #+0]
   \   0000043E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000440   0x0020             MOVS     R0,R4
   \   00000442   0x.... 0x....      BL       MaxRe
   \   00000446   0xF8DF 0x1AB4      LDR.W    R1,??CenterLineGet_8+0x8
   \   0000044A   0x7008             STRB     R0,[R1, #+0]
   \   0000044C   0x2400             MOVS     R4,#+0
   \   0000044E   0x2500             MOVS     R5,#+0
   \   00000450   0xF8DF 0x0B48      LDR.W    R0,??CenterLineGet_10+0x10
   \   00000454   0xF8DF 0x1B40      LDR.W    R1,??CenterLineGet_10+0xC
   \   00000458   0x7809             LDRB     R1,[R1, #+0]
   \   0000045A   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   0000045E   0xF8DF 0x1A9C      LDR.W    R1,??CenterLineGet_8+0x8
   \   00000462   0x7809             LDRB     R1,[R1, #+0]
   \   00000464   0x1A40             SUBS     R0,R0,R1
   \   00000466   0xF8DF 0x1B24      LDR.W    R1,??CenterLineGet_10
   \   0000046A   0xF8DF 0x2B2C      LDR.W    R2,??CenterLineGet_10+0xC
   \   0000046E   0x7812             LDRB     R2,[R2, #+0]
   \   00000470   0xF821 0x0012      STRH     R0,[R1, R2, LSL #+1]
   \   00000474   0xF8DF 0x0B20      LDR.W    R0,??CenterLineGet_10+0xC
   \   00000478   0x7800             LDRB     R0,[R0, #+0]
   \   0000047A   0xF1B0 0x0801      SUBS     R8,R0,#+1
   \   0000047E   0xE001             B.N      ??CenterLineGet_32
   \                     ??CenterLineGet_33: (+1)
   \   00000480   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \                     ??CenterLineGet_32: (+1)
   \   00000484   0xF8DF 0x0DA8      LDR.W    R0,??CenterLineGet_34
   \   00000488   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000048C   0x2103             MOVS     R1,#+3
   \   0000048E   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00000492   0x7800             LDRB     R0,[R0, #+0]
   \   00000494   0x28FF             CMP      R0,#+255
   \   00000496   0xD01D             BEQ.N    ??CenterLineGet_35
   \   00000498   0x2400             MOVS     R4,#+0
   \   0000049A   0xF8DF 0x0AF0      LDR.W    R0,??CenterLineGet_10
   \   0000049E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000004A2   0xEB10 0x0048      ADDS     R0,R0,R8, LSL #+1
   \   000004A6   0x8840             LDRH     R0,[R0, #+2]
   \   000004A8   0xF8DF 0x1AF0      LDR.W    R1,??CenterLineGet_10+0x10
   \   000004AC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000004B0   0xF851 0x1038      LDR      R1,[R1, R8, LSL #+3]
   \   000004B4   0x1808             ADDS     R0,R1,R0
   \   000004B6   0xF8DF 0x1AE4      LDR.W    R1,??CenterLineGet_10+0x10
   \   000004BA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000004BE   0xEB11 0x01C8      ADDS     R1,R1,R8, LSL #+3
   \   000004C2   0x6889             LDR      R1,[R1, #+8]
   \   000004C4   0x1A40             SUBS     R0,R0,R1
   \   000004C6   0xF8DF 0x1AC4      LDR.W    R1,??CenterLineGet_10
   \   000004CA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000004CE   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   000004D2   0xE07B             B.N      ??CenterLineGet_36
   \                     ??CenterLineGet_35: (+1)
   \   000004D4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000004D6   0x2C00             CMP      R4,#+0
   \   000004D8   0xD12E             BNE.N    ??CenterLineGet_37
   \   000004DA   0x2401             MOVS     R4,#+1
   \   000004DC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000004E0   0xF118 0x0004      ADDS     R0,R8,#+4
   \   000004E4   0x283C             CMP      R0,#+60
   \   000004E6   0xDA26             BGE.N    ??CenterLineGet_38
   \   000004E8   0x2500             MOVS     R5,#+0
   \   000004EA   0x2000             MOVS     R0,#+0
   \   000004EC   0xE012             B.N      ??CenterLineGet_39
   \                     ??CenterLineGet_40: (+1)
   \   000004EE   0xEB10 0x0108      ADDS     R1,R0,R8
   \   000004F2   0x1C49             ADDS     R1,R1,#+1
   \   000004F4   0xAA00             ADD      R2,SP,#+0
   \   000004F6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004F8   0x5481             STRB     R1,[R0, R2]
   \   000004FA   0xF8DF 0x1A90      LDR.W    R1,??CenterLineGet_10
   \   000004FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000500   0xFA50 0xF288      UXTAB    R2,R0,R8
   \   00000504   0xEB11 0x0142      ADDS     R1,R1,R2, LSL #+1
   \   00000508   0x8849             LDRH     R1,[R1, #+2]
   \   0000050A   0xAA01             ADD      R2,SP,#+4
   \   0000050C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000050E   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   \   00000512   0x1C40             ADDS     R0,R0,#+1
   \                     ??CenterLineGet_39: (+1)
   \   00000514   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000516   0x2804             CMP      R0,#+4
   \   00000518   0xDBE9             BLT.N    ??CenterLineGet_40
   \   0000051A   0x2204             MOVS     R2,#+4
   \   0000051C   0xA901             ADD      R1,SP,#+4
   \   0000051E   0xA800             ADD      R0,SP,#+0
   \   00000520   0x.... 0x....      BL       LeastSquareInt16a1
   \   00000524   0x0006             MOVS     R6,R0
   \   00000526   0x2304             MOVS     R3,#+4
   \   00000528   0x0032             MOVS     R2,R6
   \   0000052A   0xA901             ADD      R1,SP,#+4
   \   0000052C   0xA800             ADD      R0,SP,#+0
   \   0000052E   0x.... 0x....      BL       LeastSquareInt16a0
   \   00000532   0x0007             MOVS     R7,R0
   \   00000534   0xE000             B.N      ??CenterLineGet_37
   \                     ??CenterLineGet_38: (+1)
   \   00000536   0x2501             MOVS     R5,#+1
   \                     ??CenterLineGet_37: (+1)
   \   00000538   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000053A   0x2D00             CMP      R5,#+0
   \   0000053C   0xD10E             BNE.N    ??CenterLineGet_41
   \   0000053E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000542   0xFB08 0x7006      MLA      R0,R8,R6,R7
   \   00000546   0xF44F 0x717A      MOV      R1,#+1000
   \   0000054A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000054E   0xF8DF 0x1A3C      LDR.W    R1,??CenterLineGet_10
   \   00000552   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000556   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   0000055A   0xE037             B.N      ??CenterLineGet_36
   \                     ??CenterLineGet_41: (+1)
   \   0000055C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000560   0xF1B8 0x0F3B      CMP      R8,#+59
   \   00000564   0xD004             BEQ.N    ??CenterLineGet_42
   \   00000566   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000056A   0xF1B8 0x0F3A      CMP      R8,#+58
   \   0000056E   0xD110             BNE.N    ??CenterLineGet_43
   \                     ??CenterLineGet_42: (+1)
   \   00000570   0xF8DF 0x0A28      LDR.W    R0,??CenterLineGet_10+0x10
   \   00000574   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000578   0xF850 0x0038      LDR      R0,[R0, R8, LSL #+3]
   \   0000057C   0xF8DF 0x197C      LDR.W    R1,??CenterLineGet_8+0x8
   \   00000580   0x7809             LDRB     R1,[R1, #+0]
   \   00000582   0x1A40             SUBS     R0,R0,R1
   \   00000584   0xF8DF 0x1A04      LDR.W    R1,??CenterLineGet_10
   \   00000588   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000058C   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   00000590   0xE01C             B.N      ??CenterLineGet_36
   \                     ??CenterLineGet_43: (+1)
   \   00000592   0xF8DF 0x09F8      LDR.W    R0,??CenterLineGet_10
   \   00000596   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000059A   0xEB10 0x0048      ADDS     R0,R0,R8, LSL #+1
   \   0000059E   0x8840             LDRH     R0,[R0, #+2]
   \   000005A0   0xF8DF 0x19E8      LDR.W    R1,??CenterLineGet_10
   \   000005A4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000005A8   0xEB11 0x0148      ADDS     R1,R1,R8, LSL #+1
   \   000005AC   0x8849             LDRH     R1,[R1, #+2]
   \   000005AE   0x1808             ADDS     R0,R1,R0
   \   000005B0   0xF8DF 0x19D8      LDR.W    R1,??CenterLineGet_10
   \   000005B4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000005B8   0xEB11 0x0148      ADDS     R1,R1,R8, LSL #+1
   \   000005BC   0x8889             LDRH     R1,[R1, #+4]
   \   000005BE   0x1A40             SUBS     R0,R0,R1
   \   000005C0   0xF8DF 0x19C8      LDR.W    R1,??CenterLineGet_10
   \   000005C4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000005C8   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \                     ??CenterLineGet_36: (+1)
   \   000005CC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000005D0   0xF1B8 0x0F00      CMP      R8,#+0
   \   000005D4   0xF47F 0xAF54      BNE.W    ??CenterLineGet_33
   \   000005D8   0xF8DF 0x07FC      LDR.W    R0,??CenterLineGet_0+0x14
   \   000005DC   0x7800             LDRB     R0,[R0, #+0]
   \   000005DE   0x283B             CMP      R0,#+59
   \   000005E0   0xF43F 0xAE90      BEQ.W    ??CenterLineGet_22
   \   000005E4   0xF05F 0x083B      MOVS     R8,#+59
   \   000005E8   0xE009             B.N      ??CenterLineGet_44
   \                     ??CenterLineGet_45: (+1)
   \   000005EA   0xF647 0x70FF      MOVW     R0,#+32767
   \   000005EE   0xF8DF 0x199C      LDR.W    R1,??CenterLineGet_10
   \   000005F2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000005F6   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   000005FA   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \                     ??CenterLineGet_44: (+1)
   \   000005FE   0xF8DF 0x07D8      LDR.W    R0,??CenterLineGet_0+0x14
   \   00000602   0x7800             LDRB     R0,[R0, #+0]
   \   00000604   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000608   0x4580             CMP      R8,R0
   \   0000060A   0xD1EE             BNE.N    ??CenterLineGet_45
   \   0000060C   0xE67A             B.N      ??CenterLineGet_22
   \                     ??CenterLineGet_25: (+1)
   \   0000060E   0xF8DF 0x07B4      LDR.W    R0,??CenterLineGet_0
   \   00000612   0x7800             LDRB     R0,[R0, #+0]
   \   00000614   0x2801             CMP      R0,#+1
   \   00000616   0xF040 0x86F0      BNE.W    ??CenterLineGet_46
   \   0000061A   0xF8DF 0x07AC      LDR.W    R0,??CenterLineGet_0+0x4
   \   0000061E   0x7800             LDRB     R0,[R0, #+0]
   \   00000620   0x2801             CMP      R0,#+1
   \   00000622   0xF040 0x86EA      BNE.W    ??CenterLineGet_46
   \   00000626   0xF8DF 0x096C      LDR.W    R0,??CenterLineGet_10+0x8
   \   0000062A   0x7801             LDRB     R1,[R0, #+0]
   \   0000062C   0xF8DF 0x079C      LDR.W    R0,??CenterLineGet_0+0x8
   \   00000630   0x7800             LDRB     R0,[R0, #+0]
   \   00000632   0x.... 0x....      BL       MinRe
   \   00000636   0xF8DF 0x179C      LDR.W    R1,??CenterLineGet_0+0x10
   \   0000063A   0x7008             STRB     R0,[R1, #+0]
   \   0000063C   0xF8DF 0x0958      LDR.W    R0,??CenterLineGet_10+0xC
   \   00000640   0x7801             LDRB     R1,[R0, #+0]
   \   00000642   0xF8DF 0x078C      LDR.W    R0,??CenterLineGet_0+0xC
   \   00000646   0x7800             LDRB     R0,[R0, #+0]
   \   00000648   0x.... 0x....      BL       MaxRe
   \   0000064C   0xF8DF 0x1788      LDR.W    R1,??CenterLineGet_0+0x14
   \   00000650   0x7008             STRB     R0,[R1, #+0]
   \   00000652   0x.... 0x....      LDR.W    R0,??DataTable49
   \   00000656   0x7800             LDRB     R0,[R0, #+0]
   \   00000658   0x2800             CMP      R0,#+0
   \   0000065A   0xF040 0x857F      BNE.W    ??CenterLineGet_47
   \   0000065E   0x2101             MOVS     R1,#+1
   \   00000660   0x2201             MOVS     R2,#+1
   \   00000662   0x2301             MOVS     R3,#+1
   \   00000664   0x2001             MOVS     R0,#+1
   \   00000666   0xF8DF 0x4764      LDR.W    R4,??CenterLineGet_0+0x8
   \   0000066A   0x7824             LDRB     R4,[R4, #+0]
   \   0000066C   0x2C1A             CMP      R4,#+26
   \   0000066E   0xDB00             BLT.N    ??CenterLineGet_48
   \   00000670   0x2100             MOVS     R1,#+0
   \                     ??CenterLineGet_48: (+1)
   \   00000672   0xF8DF 0x475C      LDR.W    R4,??CenterLineGet_0+0xC
   \   00000676   0x7824             LDRB     R4,[R4, #+0]
   \   00000678   0x2C3B             CMP      R4,#+59
   \   0000067A   0xDA05             BGE.N    ??CenterLineGet_49
   \   0000067C   0xF8DF 0x4750      LDR.W    R4,??CenterLineGet_0+0xC
   \   00000680   0x7824             LDRB     R4,[R4, #+0]
   \   00000682   0x2C1B             CMP      R4,#+27
   \   00000684   0xDA00             BGE.N    ??CenterLineGet_49
   \   00000686   0x2200             MOVS     R2,#+0
   \                     ??CenterLineGet_49: (+1)
   \   00000688   0xF8DF 0x4908      LDR.W    R4,??CenterLineGet_10+0x8
   \   0000068C   0x7824             LDRB     R4,[R4, #+0]
   \   0000068E   0x2C1A             CMP      R4,#+26
   \   00000690   0xDB00             BLT.N    ??CenterLineGet_50
   \   00000692   0x2300             MOVS     R3,#+0
   \                     ??CenterLineGet_50: (+1)
   \   00000694   0xF8DF 0x4900      LDR.W    R4,??CenterLineGet_10+0xC
   \   00000698   0x7824             LDRB     R4,[R4, #+0]
   \   0000069A   0x2C3B             CMP      R4,#+59
   \   0000069C   0xDA0A             BGE.N    ??CenterLineGet_51
   \   0000069E   0xF8DF 0x48F8      LDR.W    R4,??CenterLineGet_10+0xC
   \   000006A2   0x7824             LDRB     R4,[R4, #+0]
   \   000006A4   0x2C1B             CMP      R4,#+27
   \   000006A6   0xDA05             BGE.N    ??CenterLineGet_51
   \   000006A8   0x2000             MOVS     R0,#+0
   \   000006AA   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000006AC   0x2A00             CMP      R2,#+0
   \   000006AE   0xD101             BNE.N    ??CenterLineGet_51
   \   000006B0   0x2000             MOVS     R0,#+0
   \   000006B2   0xE628             B.N      ??CenterLineGet_4
   \                     ??CenterLineGet_51: (+1)
   \   000006B4   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000006B6   0x2B01             CMP      R3,#+1
   \   000006B8   0xF040 0x8095      BNE.W    ??CenterLineGet_52
   \   000006BC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000006BE   0x2801             CMP      R0,#+1
   \   000006C0   0xF040 0x8091      BNE.W    ??CenterLineGet_52
   \   000006C4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000006C6   0x2900             CMP      R1,#+0
   \   000006C8   0xD102             BNE.N    ??CenterLineGet_53
   \   000006CA   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000006CC   0x2A00             CMP      R2,#+0
   \   000006CE   0xD00C             BEQ.N    ??CenterLineGet_54
   \                     ??CenterLineGet_53: (+1)
   \   000006D0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000006D2   0x2901             CMP      R1,#+1
   \   000006D4   0xD102             BNE.N    ??CenterLineGet_55
   \   000006D6   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000006D8   0x2A00             CMP      R2,#+0
   \   000006DA   0xD006             BEQ.N    ??CenterLineGet_54
   \                     ??CenterLineGet_55: (+1)
   \   000006DC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000006DE   0x2900             CMP      R1,#+0
   \   000006E0   0xF040 0x8081      BNE.W    ??CenterLineGet_52
   \   000006E4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000006E6   0x2A01             CMP      R2,#+1
   \   000006E8   0xD17D             BNE.N    ??CenterLineGet_52
   \                     ??CenterLineGet_54: (+1)
   \   000006EA   0xF8DF 0x08AC      LDR.W    R0,??CenterLineGet_10+0xC
   \   000006EE   0x7800             LDRB     R0,[R0, #+0]
   \   000006F0   0xF8DF 0x18A0      LDR.W    R1,??CenterLineGet_10+0x8
   \   000006F4   0x7809             LDRB     R1,[R1, #+0]
   \   000006F6   0x1A40             SUBS     R0,R0,R1
   \   000006F8   0x2806             CMP      R0,#+6
   \   000006FA   0xDB36             BLT.N    ??CenterLineGet_56
   \   000006FC   0xF8DF 0x089C      LDR.W    R0,??CenterLineGet_10+0x10
   \   00000700   0xF8DF 0x1894      LDR.W    R1,??CenterLineGet_10+0xC
   \   00000704   0x7809             LDRB     R1,[R1, #+0]
   \   00000706   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   0000070A   0xF8DF 0x1890      LDR.W    R1,??CenterLineGet_10+0x10
   \   0000070E   0xF8DF 0x2888      LDR.W    R2,??CenterLineGet_10+0xC
   \   00000712   0x7812             LDRB     R2,[R2, #+0]
   \   00000714   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000718   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   0000071C   0x1A40             SUBS     R0,R0,R1
   \   0000071E   0x.... 0x....      BL       __aeabi_i2d
   \   00000722   0x2200             MOVS     R2,#+0
   \   00000724   0xF8DF 0x37CC      LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   00000728   0x.... 0x....      BL       __aeabi_dmul
   \   0000072C   0x0004             MOVS     R4,R0
   \   0000072E   0x000D             MOVS     R5,R1
   \   00000730   0xF8DF 0x0868      LDR.W    R0,??CenterLineGet_10+0x10
   \   00000734   0xF8DF 0x1860      LDR.W    R1,??CenterLineGet_10+0xC
   \   00000738   0x7809             LDRB     R1,[R1, #+0]
   \   0000073A   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   0000073E   0x6840             LDR      R0,[R0, #+4]
   \   00000740   0xF8DF 0x1858      LDR.W    R1,??CenterLineGet_10+0x10
   \   00000744   0xF8DF 0x2850      LDR.W    R2,??CenterLineGet_10+0xC
   \   00000748   0x7812             LDRB     R2,[R2, #+0]
   \   0000074A   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   0000074E   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   00000752   0x1A40             SUBS     R0,R0,R1
   \   00000754   0x.... 0x....      BL       __aeabi_i2d
   \   00000758   0x0002             MOVS     R2,R0
   \   0000075A   0x000B             MOVS     R3,R1
   \   0000075C   0x0020             MOVS     R0,R4
   \   0000075E   0x0029             MOVS     R1,R5
   \   00000760   0x.... 0x....      BL       __aeabi_ddiv
   \   00000764   0x.... 0x....      BL       __aeabi_d2f
   \   00000768   0xE000             B.N      ??CenterLineGet_57
   \                     ??CenterLineGet_56: (+1)
   \   0000076A   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGet_57: (+1)
   \   0000076C   0x0001             MOVS     R1,R0
   \   0000076E   0x.... 0x....      BL       __aeabi_fmul
   \   00000772   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   00000776   0x.... 0x....      BL       __aeabi_fadd
   \   0000077A   0x.... 0x....      BL       __aeabi_f2d
   \   0000077E   0x.... 0x....      BL       sqrt
   \   00000782   0x2200             MOVS     R2,#+0
   \   00000784   0xF8DF 0x376C      LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   00000788   0x.... 0x....      BL       __aeabi_dmul
   \   0000078C   0x2200             MOVS     R2,#+0
   \   0000078E   0xF8DF 0x3768      LDR.W    R3,??CenterLineGet_8+0x4  ;; 0x40690000
   \   00000792   0x.... 0x....      BL       __aeabi_dmul
   \   00000796   0x2200             MOVS     R2,#+0
   \   00000798   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   0000079C   0x.... 0x....      BL       __aeabi_ddiv
   \   000007A0   0x.... 0x....      BL       __aeabi_d2iz
   \   000007A4   0x0004             MOVS     R4,R0
   \   000007A6   0xF8DF 0x0754      LDR.W    R0,??CenterLineGet_8+0x8
   \   000007AA   0x7800             LDRB     R0,[R0, #+0]
   \   000007AC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000007AE   0xFB90 0xF0F4      SDIV     R0,R0,R4
   \   000007B2   0x.... 0x....      BL       __aeabi_i2f
   \   000007B6   0x.... 0x....      LDR.W    R1,??DataTable50
   \   000007BA   0x6008             STR      R0,[R1, #+0]
   \   000007BC   0xF8DF 0x073C      LDR.W    R0,??CenterLineGet_8+0x8
   \   000007C0   0x7801             LDRB     R1,[R0, #+0]
   \   000007C2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000007C4   0x0020             MOVS     R0,R4
   \   000007C6   0x.... 0x....      BL       MaxRe
   \   000007CA   0xF8DF 0x1730      LDR.W    R1,??CenterLineGet_8+0x8
   \   000007CE   0x7008             STRB     R0,[R1, #+0]
   \                     ??CenterLineGet_58: (+1)
   \   000007D0   0xF8DF 0x0728      LDR.W    R0,??CenterLineGet_8+0x8
   \   000007D4   0xF890 0x9000      LDRB     R9,[R0, #+0]
   \   000007D8   0x2400             MOVS     R4,#+0
   \   000007DA   0x2500             MOVS     R5,#+0
   \   000007DC   0xF8DF 0x05F8      LDR.W    R0,??CenterLineGet_0+0x14
   \   000007E0   0xF890 0x8000      LDRB     R8,[R0, #+0]
   \   000007E4   0xE339             B.N      ??CenterLineGet_59
   \                     ??CenterLineGet_52: (+1)
   \   000007E6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000007E8   0x2901             CMP      R1,#+1
   \   000007EA   0xF040 0x808A      BNE.W    ??CenterLineGet_60
   \   000007EE   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000007F0   0x2A01             CMP      R2,#+1
   \   000007F2   0xF040 0x8086      BNE.W    ??CenterLineGet_60
   \   000007F6   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000007F8   0x2B00             CMP      R3,#+0
   \   000007FA   0xD102             BNE.N    ??CenterLineGet_61
   \   000007FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000007FE   0x2800             CMP      R0,#+0
   \   00000800   0xD00B             BEQ.N    ??CenterLineGet_62
   \                     ??CenterLineGet_61: (+1)
   \   00000802   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000804   0x2B01             CMP      R3,#+1
   \   00000806   0xD102             BNE.N    ??CenterLineGet_63
   \   00000808   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000080A   0x2800             CMP      R0,#+0
   \   0000080C   0xD005             BEQ.N    ??CenterLineGet_62
   \                     ??CenterLineGet_63: (+1)
   \   0000080E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000810   0x2B00             CMP      R3,#+0
   \   00000812   0xD176             BNE.N    ??CenterLineGet_60
   \   00000814   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000816   0x2801             CMP      R0,#+1
   \   00000818   0xD173             BNE.N    ??CenterLineGet_60
   \                     ??CenterLineGet_62: (+1)
   \   0000081A   0xF8DF 0x05B4      LDR.W    R0,??CenterLineGet_0+0xC
   \   0000081E   0x7800             LDRB     R0,[R0, #+0]
   \   00000820   0xF8DF 0x15A8      LDR.W    R1,??CenterLineGet_0+0x8
   \   00000824   0x7809             LDRB     R1,[R1, #+0]
   \   00000826   0x1A40             SUBS     R0,R0,R1
   \   00000828   0x2806             CMP      R0,#+6
   \   0000082A   0xDB36             BLT.N    ??CenterLineGet_64
   \   0000082C   0xF8DF 0x05AC      LDR.W    R0,??CenterLineGet_0+0x18
   \   00000830   0xF8DF 0x159C      LDR.W    R1,??CenterLineGet_0+0xC
   \   00000834   0x7809             LDRB     R1,[R1, #+0]
   \   00000836   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   0000083A   0xF8DF 0x15A0      LDR.W    R1,??CenterLineGet_0+0x18
   \   0000083E   0xF8DF 0x2590      LDR.W    R2,??CenterLineGet_0+0xC
   \   00000842   0x7812             LDRB     R2,[R2, #+0]
   \   00000844   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000848   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   0000084C   0x1A40             SUBS     R0,R0,R1
   \   0000084E   0x.... 0x....      BL       __aeabi_i2d
   \   00000852   0x2200             MOVS     R2,#+0
   \   00000854   0xF8DF 0x369C      LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   00000858   0x.... 0x....      BL       __aeabi_dmul
   \   0000085C   0x0004             MOVS     R4,R0
   \   0000085E   0x000D             MOVS     R5,R1
   \   00000860   0xF8DF 0x0578      LDR.W    R0,??CenterLineGet_0+0x18
   \   00000864   0xF8DF 0x1568      LDR.W    R1,??CenterLineGet_0+0xC
   \   00000868   0x7809             LDRB     R1,[R1, #+0]
   \   0000086A   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   0000086E   0x6840             LDR      R0,[R0, #+4]
   \   00000870   0xF8DF 0x1568      LDR.W    R1,??CenterLineGet_0+0x18
   \   00000874   0xF8DF 0x2558      LDR.W    R2,??CenterLineGet_0+0xC
   \   00000878   0x7812             LDRB     R2,[R2, #+0]
   \   0000087A   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   0000087E   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   00000882   0x1A40             SUBS     R0,R0,R1
   \   00000884   0x.... 0x....      BL       __aeabi_i2d
   \   00000888   0x0002             MOVS     R2,R0
   \   0000088A   0x000B             MOVS     R3,R1
   \   0000088C   0x0020             MOVS     R0,R4
   \   0000088E   0x0029             MOVS     R1,R5
   \   00000890   0x.... 0x....      BL       __aeabi_ddiv
   \   00000894   0x.... 0x....      BL       __aeabi_d2f
   \   00000898   0xE000             B.N      ??CenterLineGet_65
   \                     ??CenterLineGet_64: (+1)
   \   0000089A   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGet_65: (+1)
   \   0000089C   0x0001             MOVS     R1,R0
   \   0000089E   0x.... 0x....      BL       __aeabi_fmul
   \   000008A2   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   000008A6   0x.... 0x....      BL       __aeabi_fadd
   \   000008AA   0x.... 0x....      BL       __aeabi_f2d
   \   000008AE   0x.... 0x....      BL       sqrt
   \   000008B2   0x2200             MOVS     R2,#+0
   \   000008B4   0xF8DF 0x363C      LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   000008B8   0x.... 0x....      BL       __aeabi_dmul
   \   000008BC   0x2200             MOVS     R2,#+0
   \   000008BE   0xF8DF 0x3638      LDR.W    R3,??CenterLineGet_8+0x4  ;; 0x40690000
   \   000008C2   0x.... 0x....      BL       __aeabi_dmul
   \   000008C6   0x2200             MOVS     R2,#+0
   \   000008C8   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   000008CC   0x.... 0x....      BL       __aeabi_ddiv
   \   000008D0   0x.... 0x....      BL       __aeabi_d2iz
   \   000008D4   0x0004             MOVS     R4,R0
   \   000008D6   0xF8DF 0x0624      LDR.W    R0,??CenterLineGet_8+0x8
   \   000008DA   0x7800             LDRB     R0,[R0, #+0]
   \   000008DC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000008DE   0xFB90 0xF0F4      SDIV     R0,R0,R4
   \   000008E2   0x.... 0x....      BL       __aeabi_i2f
   \   000008E6   0x.... 0x....      LDR.W    R1,??DataTable50
   \   000008EA   0x6008             STR      R0,[R1, #+0]
   \   000008EC   0xF8DF 0x060C      LDR.W    R0,??CenterLineGet_8+0x8
   \   000008F0   0x7801             LDRB     R1,[R0, #+0]
   \   000008F2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000008F4   0x0020             MOVS     R0,R4
   \   000008F6   0x.... 0x....      BL       MaxRe
   \   000008FA   0xF8DF 0x1600      LDR.W    R1,??CenterLineGet_8+0x8
   \   000008FE   0x7008             STRB     R0,[R1, #+0]
   \   00000900   0xE766             B.N      ??CenterLineGet_58
   \                     ??CenterLineGet_60: (+1)
   \   00000902   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000904   0x2901             CMP      R1,#+1
   \   00000906   0xF040 0x80E7      BNE.W    ??CenterLineGet_66
   \   0000090A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000090C   0x2A01             CMP      R2,#+1
   \   0000090E   0xF040 0x80E3      BNE.W    ??CenterLineGet_66
   \   00000912   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000914   0x2B01             CMP      R3,#+1
   \   00000916   0xF040 0x80DF      BNE.W    ??CenterLineGet_66
   \   0000091A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000091C   0x2801             CMP      R0,#+1
   \   0000091E   0xF040 0x80DB      BNE.W    ??CenterLineGet_66
   \   00000922   0xF8DF 0x04AC      LDR.W    R0,??CenterLineGet_0+0xC
   \   00000926   0x7800             LDRB     R0,[R0, #+0]
   \   00000928   0xF8DF 0x14A0      LDR.W    R1,??CenterLineGet_0+0x8
   \   0000092C   0x7809             LDRB     R1,[R1, #+0]
   \   0000092E   0x1A40             SUBS     R0,R0,R1
   \   00000930   0x2806             CMP      R0,#+6
   \   00000932   0xDB36             BLT.N    ??CenterLineGet_67
   \   00000934   0xF8DF 0x04A4      LDR.W    R0,??CenterLineGet_0+0x18
   \   00000938   0xF8DF 0x1494      LDR.W    R1,??CenterLineGet_0+0xC
   \   0000093C   0x7809             LDRB     R1,[R1, #+0]
   \   0000093E   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000942   0xF8DF 0x1498      LDR.W    R1,??CenterLineGet_0+0x18
   \   00000946   0xF8DF 0x2488      LDR.W    R2,??CenterLineGet_0+0xC
   \   0000094A   0x7812             LDRB     R2,[R2, #+0]
   \   0000094C   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000950   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   00000954   0x1A40             SUBS     R0,R0,R1
   \   00000956   0x.... 0x....      BL       __aeabi_i2d
   \   0000095A   0x2200             MOVS     R2,#+0
   \   0000095C   0xF8DF 0x3594      LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   00000960   0x.... 0x....      BL       __aeabi_dmul
   \   00000964   0x0004             MOVS     R4,R0
   \   00000966   0x000D             MOVS     R5,R1
   \   00000968   0xF8DF 0x0470      LDR.W    R0,??CenterLineGet_0+0x18
   \   0000096C   0xF8DF 0x1460      LDR.W    R1,??CenterLineGet_0+0xC
   \   00000970   0x7809             LDRB     R1,[R1, #+0]
   \   00000972   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000976   0x6840             LDR      R0,[R0, #+4]
   \   00000978   0xF8DF 0x1460      LDR.W    R1,??CenterLineGet_0+0x18
   \   0000097C   0xF8DF 0x2450      LDR.W    R2,??CenterLineGet_0+0xC
   \   00000980   0x7812             LDRB     R2,[R2, #+0]
   \   00000982   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000986   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   0000098A   0x1A40             SUBS     R0,R0,R1
   \   0000098C   0x.... 0x....      BL       __aeabi_i2d
   \   00000990   0x0002             MOVS     R2,R0
   \   00000992   0x000B             MOVS     R3,R1
   \   00000994   0x0020             MOVS     R0,R4
   \   00000996   0x0029             MOVS     R1,R5
   \   00000998   0x.... 0x....      BL       __aeabi_ddiv
   \   0000099C   0x.... 0x....      BL       __aeabi_d2f
   \   000009A0   0xE000             B.N      ??CenterLineGet_68
   \                     ??CenterLineGet_67: (+1)
   \   000009A2   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGet_68: (+1)
   \   000009A4   0x0001             MOVS     R1,R0
   \   000009A6   0x.... 0x....      BL       __aeabi_fmul
   \   000009AA   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   000009AE   0x.... 0x....      BL       __aeabi_fadd
   \   000009B2   0x.... 0x....      BL       __aeabi_f2d
   \   000009B6   0x.... 0x....      BL       sqrt
   \   000009BA   0x2200             MOVS     R2,#+0
   \   000009BC   0xF8DF 0x3534      LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   000009C0   0x.... 0x....      BL       __aeabi_dmul
   \   000009C4   0x2200             MOVS     R2,#+0
   \   000009C6   0xF8DF 0x3530      LDR.W    R3,??CenterLineGet_8+0x4  ;; 0x40690000
   \   000009CA   0x.... 0x....      BL       __aeabi_dmul
   \   000009CE   0x2200             MOVS     R2,#+0
   \   000009D0   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   000009D4   0x.... 0x....      BL       __aeabi_ddiv
   \   000009D8   0x.... 0x....      BL       __aeabi_d2iz
   \   000009DC   0x0004             MOVS     R4,R0
   \   000009DE   0xF8DF 0x05B8      LDR.W    R0,??CenterLineGet_10+0xC
   \   000009E2   0x7800             LDRB     R0,[R0, #+0]
   \   000009E4   0xF8DF 0x15AC      LDR.W    R1,??CenterLineGet_10+0x8
   \   000009E8   0x7809             LDRB     R1,[R1, #+0]
   \   000009EA   0x1A40             SUBS     R0,R0,R1
   \   000009EC   0x2806             CMP      R0,#+6
   \   000009EE   0xDB36             BLT.N    ??CenterLineGet_69
   \   000009F0   0xF8DF 0x05A8      LDR.W    R0,??CenterLineGet_10+0x10
   \   000009F4   0xF8DF 0x15A0      LDR.W    R1,??CenterLineGet_10+0xC
   \   000009F8   0x7809             LDRB     R1,[R1, #+0]
   \   000009FA   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   000009FE   0xF8DF 0x159C      LDR.W    R1,??CenterLineGet_10+0x10
   \   00000A02   0xF8DF 0x2594      LDR.W    R2,??CenterLineGet_10+0xC
   \   00000A06   0x7812             LDRB     R2,[R2, #+0]
   \   00000A08   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000A0C   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   00000A10   0x1A40             SUBS     R0,R0,R1
   \   00000A12   0x.... 0x....      BL       __aeabi_i2d
   \   00000A16   0x2200             MOVS     R2,#+0
   \   00000A18   0xF8DF 0x34D8      LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   00000A1C   0x.... 0x....      BL       __aeabi_dmul
   \   00000A20   0x4680             MOV      R8,R0
   \   00000A22   0x4689             MOV      R9,R1
   \   00000A24   0xF8DF 0x0574      LDR.W    R0,??CenterLineGet_10+0x10
   \   00000A28   0xF8DF 0x156C      LDR.W    R1,??CenterLineGet_10+0xC
   \   00000A2C   0x7809             LDRB     R1,[R1, #+0]
   \   00000A2E   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000A32   0x6840             LDR      R0,[R0, #+4]
   \   00000A34   0xF8DF 0x1564      LDR.W    R1,??CenterLineGet_10+0x10
   \   00000A38   0xF8DF 0x255C      LDR.W    R2,??CenterLineGet_10+0xC
   \   00000A3C   0x7812             LDRB     R2,[R2, #+0]
   \   00000A3E   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000A42   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   00000A46   0x1A40             SUBS     R0,R0,R1
   \   00000A48   0x.... 0x....      BL       __aeabi_i2d
   \   00000A4C   0x0002             MOVS     R2,R0
   \   00000A4E   0x000B             MOVS     R3,R1
   \   00000A50   0x4640             MOV      R0,R8
   \   00000A52   0x4649             MOV      R1,R9
   \   00000A54   0x.... 0x....      BL       __aeabi_ddiv
   \   00000A58   0x.... 0x....      BL       __aeabi_d2f
   \   00000A5C   0xE000             B.N      ??CenterLineGet_70
   \                     ??CenterLineGet_69: (+1)
   \   00000A5E   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGet_70: (+1)
   \   00000A60   0x0001             MOVS     R1,R0
   \   00000A62   0x.... 0x....      BL       __aeabi_fmul
   \   00000A66   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   00000A6A   0x.... 0x....      BL       __aeabi_fadd
   \   00000A6E   0x.... 0x....      BL       __aeabi_f2d
   \   00000A72   0x.... 0x....      BL       sqrt
   \   00000A76   0x0002             MOVS     R2,R0
   \   00000A78   0x000B             MOVS     R3,R1
   \   00000A7A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000A7C   0x0021             MOVS     R1,R4
   \   00000A7E   0x000C             MOVS     R4,R1
   \   00000A80   0x2000             MOVS     R0,#+0
   \   00000A82   0xF8DF 0x1470      LDR.W    R1,??CenterLineGet_8  ;; 0x3ff00000
   \   00000A86   0x.... 0x....      BL       __aeabi_dmul
   \   00000A8A   0x2200             MOVS     R2,#+0
   \   00000A8C   0xF8DF 0x3468      LDR.W    R3,??CenterLineGet_8+0x4  ;; 0x40690000
   \   00000A90   0x.... 0x....      BL       __aeabi_dmul
   \   00000A94   0x2200             MOVS     R2,#+0
   \   00000A96   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   00000A9A   0x.... 0x....      BL       __aeabi_ddiv
   \   00000A9E   0x.... 0x....      BL       __aeabi_d2iz
   \   00000AA2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000AA4   0x0021             MOVS     R1,R4
   \   00000AA6   0x.... 0x....      BL       MaxRe
   \   00000AAA   0x0004             MOVS     R4,R0
   \   00000AAC   0xF8DF 0x044C      LDR.W    R0,??CenterLineGet_8+0x8
   \   00000AB0   0x7800             LDRB     R0,[R0, #+0]
   \   00000AB2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000AB4   0xFB90 0xF0F4      SDIV     R0,R0,R4
   \   00000AB8   0x.... 0x....      BL       __aeabi_i2f
   \   00000ABC   0x.... 0x....      LDR.W    R1,??DataTable50
   \   00000AC0   0x6008             STR      R0,[R1, #+0]
   \   00000AC2   0xF8DF 0x0438      LDR.W    R0,??CenterLineGet_8+0x8
   \   00000AC6   0x7801             LDRB     R1,[R0, #+0]
   \   00000AC8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000ACA   0x0020             MOVS     R0,R4
   \   00000ACC   0x.... 0x....      BL       MaxRe
   \   00000AD0   0xF8DF 0x1428      LDR.W    R1,??CenterLineGet_8+0x8
   \   00000AD4   0x7008             STRB     R0,[R1, #+0]
   \   00000AD6   0xE67B             B.N      ??CenterLineGet_58
   \                     ??CenterLineGet_66: (+1)
   \   00000AD8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000ADA   0x2A00             CMP      R2,#+0
   \   00000ADC   0xD104             BNE.N    ??CenterLineGet_71
   \   00000ADE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000AE0   0x2800             CMP      R0,#+0
   \   00000AE2   0xD101             BNE.N    ??CenterLineGet_71
   \   00000AE4   0x2000             MOVS     R0,#+0
   \   00000AE6   0xE40E             B.N      ??CenterLineGet_4
   \                     ??CenterLineGet_71: (+1)
   \   00000AE8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000AEA   0x2901             CMP      R1,#+1
   \   00000AEC   0xD169             BNE.N    ??CenterLineGet_72
   \   00000AEE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000AF0   0x2B00             CMP      R3,#+0
   \   00000AF2   0xD166             BNE.N    ??CenterLineGet_72
   \   00000AF4   0x48B6             LDR.N    R0,??CenterLineGet_0+0xC
   \   00000AF6   0x7800             LDRB     R0,[R0, #+0]
   \   00000AF8   0x49B4             LDR.N    R1,??CenterLineGet_0+0x8
   \   00000AFA   0x7809             LDRB     R1,[R1, #+0]
   \   00000AFC   0x1A40             SUBS     R0,R0,R1
   \   00000AFE   0x2806             CMP      R0,#+6
   \   00000B00   0xDB2E             BLT.N    ??CenterLineGet_73
   \   00000B02   0x48B6             LDR.N    R0,??CenterLineGet_0+0x18
   \   00000B04   0x49B2             LDR.N    R1,??CenterLineGet_0+0xC
   \   00000B06   0x7809             LDRB     R1,[R1, #+0]
   \   00000B08   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000B0C   0x49B3             LDR.N    R1,??CenterLineGet_0+0x18
   \   00000B0E   0x4AB0             LDR.N    R2,??CenterLineGet_0+0xC
   \   00000B10   0x7812             LDRB     R2,[R2, #+0]
   \   00000B12   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000B16   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   00000B1A   0x1A40             SUBS     R0,R0,R1
   \   00000B1C   0x.... 0x....      BL       __aeabi_i2d
   \   00000B20   0x2200             MOVS     R2,#+0
   \   00000B22   0xF8DF 0x33D0      LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   00000B26   0x.... 0x....      BL       __aeabi_dmul
   \   00000B2A   0x0004             MOVS     R4,R0
   \   00000B2C   0x000D             MOVS     R5,R1
   \   00000B2E   0x48AB             LDR.N    R0,??CenterLineGet_0+0x18
   \   00000B30   0x49A7             LDR.N    R1,??CenterLineGet_0+0xC
   \   00000B32   0x7809             LDRB     R1,[R1, #+0]
   \   00000B34   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000B38   0x6840             LDR      R0,[R0, #+4]
   \   00000B3A   0x49A8             LDR.N    R1,??CenterLineGet_0+0x18
   \   00000B3C   0x4AA4             LDR.N    R2,??CenterLineGet_0+0xC
   \   00000B3E   0x7812             LDRB     R2,[R2, #+0]
   \   00000B40   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000B44   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   00000B48   0x1A40             SUBS     R0,R0,R1
   \   00000B4A   0x.... 0x....      BL       __aeabi_i2d
   \   00000B4E   0x0002             MOVS     R2,R0
   \   00000B50   0x000B             MOVS     R3,R1
   \   00000B52   0x0020             MOVS     R0,R4
   \   00000B54   0x0029             MOVS     R1,R5
   \   00000B56   0x.... 0x....      BL       __aeabi_ddiv
   \   00000B5A   0x.... 0x....      BL       __aeabi_d2f
   \   00000B5E   0xE000             B.N      ??CenterLineGet_74
   \                     ??CenterLineGet_73: (+1)
   \   00000B60   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGet_74: (+1)
   \   00000B62   0x0001             MOVS     R1,R0
   \   00000B64   0x.... 0x....      BL       __aeabi_fmul
   \   00000B68   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   00000B6C   0x.... 0x....      BL       __aeabi_fadd
   \   00000B70   0x.... 0x....      BL       __aeabi_f2d
   \   00000B74   0x.... 0x....      BL       sqrt
   \   00000B78   0x2200             MOVS     R2,#+0
   \   00000B7A   0xF8DF 0x3378      LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   00000B7E   0x.... 0x....      BL       __aeabi_dmul
   \   00000B82   0x2200             MOVS     R2,#+0
   \   00000B84   0xF8DF 0x3370      LDR.W    R3,??CenterLineGet_8+0x4  ;; 0x40690000
   \   00000B88   0x.... 0x....      BL       __aeabi_dmul
   \   00000B8C   0x2200             MOVS     R2,#+0
   \   00000B8E   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   00000B92   0x.... 0x....      BL       __aeabi_ddiv
   \   00000B96   0x.... 0x....      BL       __aeabi_d2iz
   \   00000B9A   0x0004             MOVS     R4,R0
   \   00000B9C   0x48D7             LDR.N    R0,??CenterLineGet_8+0x8
   \   00000B9E   0x7800             LDRB     R0,[R0, #+0]
   \   00000BA0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000BA2   0xFB90 0xF0F4      SDIV     R0,R0,R4
   \   00000BA6   0x.... 0x....      BL       __aeabi_i2f
   \   00000BAA   0x.... 0x....      LDR.W    R1,??DataTable50
   \   00000BAE   0x6008             STR      R0,[R1, #+0]
   \   00000BB0   0x48D2             LDR.N    R0,??CenterLineGet_8+0x8
   \   00000BB2   0x7801             LDRB     R1,[R0, #+0]
   \   00000BB4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000BB6   0x0020             MOVS     R0,R4
   \   00000BB8   0x.... 0x....      BL       MaxRe
   \   00000BBC   0x49CF             LDR.N    R1,??CenterLineGet_8+0x8
   \   00000BBE   0x7008             STRB     R0,[R1, #+0]
   \   00000BC0   0xE606             B.N      ??CenterLineGet_58
   \                     ??CenterLineGet_72: (+1)
   \   00000BC2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000BC4   0x2900             CMP      R1,#+0
   \   00000BC6   0xD16F             BNE.N    ??CenterLineGet_75
   \   00000BC8   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000BCA   0x2B01             CMP      R3,#+1
   \   00000BCC   0xD16C             BNE.N    ??CenterLineGet_75
   \   00000BCE   0xF8DF 0x03C8      LDR.W    R0,??CenterLineGet_10+0xC
   \   00000BD2   0x7800             LDRB     R0,[R0, #+0]
   \   00000BD4   0xF8DF 0x13BC      LDR.W    R1,??CenterLineGet_10+0x8
   \   00000BD8   0x7809             LDRB     R1,[R1, #+0]
   \   00000BDA   0x1A40             SUBS     R0,R0,R1
   \   00000BDC   0x2806             CMP      R0,#+6
   \   00000BDE   0xDB34             BLT.N    ??CenterLineGet_76
   \   00000BE0   0xF8DF 0x03B8      LDR.W    R0,??CenterLineGet_10+0x10
   \   00000BE4   0xF8DF 0x13B0      LDR.W    R1,??CenterLineGet_10+0xC
   \   00000BE8   0x7809             LDRB     R1,[R1, #+0]
   \   00000BEA   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000BEE   0xF8DF 0x13AC      LDR.W    R1,??CenterLineGet_10+0x10
   \   00000BF2   0xF8DF 0x23A4      LDR.W    R2,??CenterLineGet_10+0xC
   \   00000BF6   0x7812             LDRB     R2,[R2, #+0]
   \   00000BF8   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000BFC   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   00000C00   0x1A40             SUBS     R0,R0,R1
   \   00000C02   0x.... 0x....      BL       __aeabi_i2d
   \   00000C06   0x2200             MOVS     R2,#+0
   \   00000C08   0x4BBA             LDR.N    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   00000C0A   0x.... 0x....      BL       __aeabi_dmul
   \   00000C0E   0x0004             MOVS     R4,R0
   \   00000C10   0x000D             MOVS     R5,R1
   \   00000C12   0xF8DF 0x0388      LDR.W    R0,??CenterLineGet_10+0x10
   \   00000C16   0xF8DF 0x1380      LDR.W    R1,??CenterLineGet_10+0xC
   \   00000C1A   0x7809             LDRB     R1,[R1, #+0]
   \   00000C1C   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000C20   0x6840             LDR      R0,[R0, #+4]
   \   00000C22   0xF8DF 0x1378      LDR.W    R1,??CenterLineGet_10+0x10
   \   00000C26   0x4ADC             LDR.N    R2,??CenterLineGet_10+0xC
   \   00000C28   0x7812             LDRB     R2,[R2, #+0]
   \   00000C2A   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000C2E   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   00000C32   0x1A40             SUBS     R0,R0,R1
   \   00000C34   0x.... 0x....      BL       __aeabi_i2d
   \   00000C38   0x0002             MOVS     R2,R0
   \   00000C3A   0x000B             MOVS     R3,R1
   \   00000C3C   0x0020             MOVS     R0,R4
   \   00000C3E   0x0029             MOVS     R1,R5
   \   00000C40   0x.... 0x....      BL       __aeabi_ddiv
   \   00000C44   0x.... 0x....      BL       __aeabi_d2f
   \   00000C48   0xE000             B.N      ??CenterLineGet_77
   \                     ??CenterLineGet_76: (+1)
   \   00000C4A   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGet_77: (+1)
   \   00000C4C   0x0001             MOVS     R1,R0
   \   00000C4E   0x.... 0x....      BL       __aeabi_fmul
   \   00000C52   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   00000C56   0x.... 0x....      BL       __aeabi_fadd
   \   00000C5A   0x.... 0x....      BL       __aeabi_f2d
   \   00000C5E   0x.... 0x....      BL       sqrt
   \   00000C62   0x2200             MOVS     R2,#+0
   \   00000C64   0x4BA3             LDR.N    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   00000C66   0x.... 0x....      BL       __aeabi_dmul
   \   00000C6A   0x2200             MOVS     R2,#+0
   \   00000C6C   0x4BA2             LDR.N    R3,??CenterLineGet_8+0x4  ;; 0x40690000
   \   00000C6E   0x.... 0x....      BL       __aeabi_dmul
   \   00000C72   0x2200             MOVS     R2,#+0
   \   00000C74   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   00000C78   0x.... 0x....      BL       __aeabi_ddiv
   \   00000C7C   0x.... 0x....      BL       __aeabi_d2iz
   \   00000C80   0x0004             MOVS     R4,R0
   \   00000C82   0x489E             LDR.N    R0,??CenterLineGet_8+0x8
   \   00000C84   0x7800             LDRB     R0,[R0, #+0]
   \   00000C86   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000C88   0xFB90 0xF0F4      SDIV     R0,R0,R4
   \   00000C8C   0x.... 0x....      BL       __aeabi_i2f
   \   00000C90   0x.... 0x....      LDR.W    R1,??DataTable50
   \   00000C94   0x6008             STR      R0,[R1, #+0]
   \   00000C96   0x4899             LDR.N    R0,??CenterLineGet_8+0x8
   \   00000C98   0x7801             LDRB     R1,[R0, #+0]
   \   00000C9A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000C9C   0x0020             MOVS     R0,R4
   \   00000C9E   0x.... 0x....      BL       MaxRe
   \   00000CA2   0x4996             LDR.N    R1,??CenterLineGet_8+0x8
   \   00000CA4   0x7008             STRB     R0,[R1, #+0]
   \   00000CA6   0xE593             B.N      ??CenterLineGet_58
   \                     ??CenterLineGet_75: (+1)
   \   00000CA8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000CAA   0x2900             CMP      R1,#+0
   \   00000CAC   0xF040 0x80D0      BNE.W    ??CenterLineGet_78
   \   00000CB0   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000CB2   0x2B00             CMP      R3,#+0
   \   00000CB4   0xF040 0x80CC      BNE.W    ??CenterLineGet_78
   \   00000CB8   0x4845             LDR.N    R0,??CenterLineGet_0+0xC
   \   00000CBA   0x7800             LDRB     R0,[R0, #+0]
   \   00000CBC   0x4943             LDR.N    R1,??CenterLineGet_0+0x8
   \   00000CBE   0x7809             LDRB     R1,[R1, #+0]
   \   00000CC0   0x1A40             SUBS     R0,R0,R1
   \   00000CC2   0x2806             CMP      R0,#+6
   \   00000CC4   0xDB2D             BLT.N    ??CenterLineGet_79
   \   00000CC6   0x4845             LDR.N    R0,??CenterLineGet_0+0x18
   \   00000CC8   0x4941             LDR.N    R1,??CenterLineGet_0+0xC
   \   00000CCA   0x7809             LDRB     R1,[R1, #+0]
   \   00000CCC   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000CD0   0x4942             LDR.N    R1,??CenterLineGet_0+0x18
   \   00000CD2   0x4A3F             LDR.N    R2,??CenterLineGet_0+0xC
   \   00000CD4   0x7812             LDRB     R2,[R2, #+0]
   \   00000CD6   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000CDA   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   00000CDE   0x1A40             SUBS     R0,R0,R1
   \   00000CE0   0x.... 0x....      BL       __aeabi_i2d
   \   00000CE4   0x2200             MOVS     R2,#+0
   \   00000CE6   0x4B83             LDR.N    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   00000CE8   0x.... 0x....      BL       __aeabi_dmul
   \   00000CEC   0x0004             MOVS     R4,R0
   \   00000CEE   0x000D             MOVS     R5,R1
   \   00000CF0   0x483A             LDR.N    R0,??CenterLineGet_0+0x18
   \   00000CF2   0x4937             LDR.N    R1,??CenterLineGet_0+0xC
   \   00000CF4   0x7809             LDRB     R1,[R1, #+0]
   \   00000CF6   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000CFA   0x6840             LDR      R0,[R0, #+4]
   \   00000CFC   0x4937             LDR.N    R1,??CenterLineGet_0+0x18
   \   00000CFE   0x4A34             LDR.N    R2,??CenterLineGet_0+0xC
   \   00000D00   0x7812             LDRB     R2,[R2, #+0]
   \   00000D02   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000D06   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   00000D0A   0x1A40             SUBS     R0,R0,R1
   \   00000D0C   0x.... 0x....      BL       __aeabi_i2d
   \   00000D10   0x0002             MOVS     R2,R0
   \   00000D12   0x000B             MOVS     R3,R1
   \   00000D14   0x0020             MOVS     R0,R4
   \   00000D16   0x0029             MOVS     R1,R5
   \   00000D18   0x.... 0x....      BL       __aeabi_ddiv
   \   00000D1C   0x.... 0x....      BL       __aeabi_d2f
   \   00000D20   0xE000             B.N      ??CenterLineGet_80
   \                     ??CenterLineGet_79: (+1)
   \   00000D22   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGet_80: (+1)
   \   00000D24   0x0001             MOVS     R1,R0
   \   00000D26   0x.... 0x....      BL       __aeabi_fmul
   \   00000D2A   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   00000D2E   0x.... 0x....      BL       __aeabi_fadd
   \   00000D32   0x.... 0x....      BL       __aeabi_f2d
   \   00000D36   0x.... 0x....      BL       sqrt
   \   00000D3A   0x2200             MOVS     R2,#+0
   \   00000D3C   0x4B6D             LDR.N    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   00000D3E   0x.... 0x....      BL       __aeabi_dmul
   \   00000D42   0x2200             MOVS     R2,#+0
   \   00000D44   0x4B6C             LDR.N    R3,??CenterLineGet_8+0x4  ;; 0x40690000
   \   00000D46   0x.... 0x....      BL       __aeabi_dmul
   \   00000D4A   0x2200             MOVS     R2,#+0
   \   00000D4C   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   00000D50   0x.... 0x....      BL       __aeabi_ddiv
   \   00000D54   0x.... 0x....      BL       __aeabi_d2iz
   \   00000D58   0x0004             MOVS     R4,R0
   \   00000D5A   0x488F             LDR.N    R0,??CenterLineGet_10+0xC
   \   00000D5C   0x7800             LDRB     R0,[R0, #+0]
   \   00000D5E   0x498D             LDR.N    R1,??CenterLineGet_10+0x8
   \   00000D60   0x7809             LDRB     R1,[R1, #+0]
   \   00000D62   0x1A40             SUBS     R0,R0,R1
   \   00000D64   0x2806             CMP      R0,#+6
   \   00000D66   0xDB3B             BLT.N    ??CenterLineGet_81
   \   00000D68   0x488C             LDR.N    R0,??CenterLineGet_10+0x10
   \   00000D6A   0x498B             LDR.N    R1,??CenterLineGet_10+0xC
   \   00000D6C   0x7809             LDRB     R1,[R1, #+0]
   \   00000D6E   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000D72   0x498A             LDR.N    R1,??CenterLineGet_10+0x10
   \   00000D74   0x4A88             LDR.N    R2,??CenterLineGet_10+0xC
   \   00000D76   0x7812             LDRB     R2,[R2, #+0]
   \   00000D78   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000D7C   0xF851 0x1C20      LDR      R1,[R1, #-32]
   \   00000D80   0x1A40             SUBS     R0,R0,R1
   \   00000D82   0x.... 0x....      BL       __aeabi_i2d
   \   00000D86   0x2200             MOVS     R2,#+0
   \   00000D88   0x4B5A             LDR.N    R3,??CenterLineGet_8  ;; 0x3ff00000
   \   00000D8A   0x.... 0x....      BL       __aeabi_dmul
   \   00000D8E   0x4680             MOV      R8,R0
   \   00000D90   0x4689             MOV      R9,R1
   \   00000D92   0x4882             LDR.N    R0,??CenterLineGet_10+0x10
   \   00000D94   0x4980             LDR.N    R1,??CenterLineGet_10+0xC
   \   00000D96   0x7809             LDRB     R1,[R1, #+0]
   \   00000D98   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000D9C   0x6840             LDR      R0,[R0, #+4]
   \   00000D9E   0x497F             LDR.N    R1,??CenterLineGet_10+0x10
   \   00000DA0   0x4A7D             LDR.N    R2,??CenterLineGet_10+0xC
   \   00000DA2   0x7812             LDRB     R2,[R2, #+0]
   \   00000DA4   0xEB11 0x01C2      ADDS     R1,R1,R2, LSL #+3
   \   00000DA8   0xF851 0x1C1C      LDR      R1,[R1, #-28]
   \   00000DAC   0x1A40             SUBS     R0,R0,R1
   \   00000DAE   0x.... 0x....      BL       __aeabi_i2d
   \   00000DB2   0x0002             MOVS     R2,R0
   \   00000DB4   0x000B             MOVS     R3,R1
   \   00000DB6   0x4640             MOV      R0,R8
   \   00000DB8   0x4649             MOV      R1,R9
   \   00000DBA   0x.... 0x....      BL       __aeabi_ddiv
   \   00000DBE   0x.... 0x....      BL       __aeabi_d2f
   \   00000DC2   0xE00E             B.N      ??CenterLineGet_82
   \                     ??CenterLineGet_0:
   \   00000DC4   0x........         DC32     BlackLeftDone
   \   00000DC8   0x........         DC32     BlackRightDone
   \   00000DCC   0x........         DC32     BlackLeftHeadLine
   \   00000DD0   0x........         DC32     BlackLeftEndLine
   \   00000DD4   0x........         DC32     CenterHeadLine
   \   00000DD8   0x........         DC32     CenterEndLine
   \   00000DDC   0x........         DC32     BlackUdisLeftLocation
   \                     ??CenterLineGet_81: (+1)
   \   00000DE0   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGet_82: (+1)
   \   00000DE2   0x0001             MOVS     R1,R0
   \   00000DE4   0x.... 0x....      BL       __aeabi_fmul
   \   00000DE8   0xF05F 0x517E      MOVS     R1,#+1065353216
   \   00000DEC   0x.... 0x....      BL       __aeabi_fadd
   \   00000DF0   0x.... 0x....      BL       __aeabi_f2d
   \   00000DF4   0x.... 0x....      BL       sqrt
   \   00000DF8   0x0002             MOVS     R2,R0
   \   00000DFA   0x000B             MOVS     R3,R1
   \   00000DFC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000DFE   0x0021             MOVS     R1,R4
   \   00000E00   0x000C             MOVS     R4,R1
   \   00000E02   0x2000             MOVS     R0,#+0
   \   00000E04   0x493B             LDR.N    R1,??CenterLineGet_8  ;; 0x3ff00000
   \   00000E06   0x.... 0x....      BL       __aeabi_dmul
   \   00000E0A   0x2200             MOVS     R2,#+0
   \   00000E0C   0x4B3A             LDR.N    R3,??CenterLineGet_8+0x4  ;; 0x40690000
   \   00000E0E   0x.... 0x....      BL       __aeabi_dmul
   \   00000E12   0x2200             MOVS     R2,#+0
   \   00000E14   0xF05F 0x4380      MOVS     R3,#+1073741824
   \   00000E18   0x.... 0x....      BL       __aeabi_ddiv
   \   00000E1C   0x.... 0x....      BL       __aeabi_d2iz
   \   00000E20   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000E22   0x0021             MOVS     R1,R4
   \   00000E24   0x.... 0x....      BL       MaxRe
   \   00000E28   0x0004             MOVS     R4,R0
   \   00000E2A   0x4834             LDR.N    R0,??CenterLineGet_8+0x8
   \   00000E2C   0x7800             LDRB     R0,[R0, #+0]
   \   00000E2E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000E30   0xFB90 0xF0F4      SDIV     R0,R0,R4
   \   00000E34   0x.... 0x....      BL       __aeabi_i2f
   \   00000E38   0x.... 0x....      LDR.W    R1,??DataTable50
   \   00000E3C   0x6008             STR      R0,[R1, #+0]
   \   00000E3E   0x482F             LDR.N    R0,??CenterLineGet_8+0x8
   \   00000E40   0x7801             LDRB     R1,[R0, #+0]
   \   00000E42   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000E44   0x0020             MOVS     R0,R4
   \   00000E46   0x.... 0x....      BL       MaxRe
   \   00000E4A   0x492C             LDR.N    R1,??CenterLineGet_8+0x8
   \   00000E4C   0x7008             STRB     R0,[R1, #+0]
   \   00000E4E   0xE4BF             B.N      ??CenterLineGet_58
   \                     ??CenterLineGet_78: (+1)
   \   00000E50   0x2000             MOVS     R0,#+0
   \   00000E52   0xF7FF 0xBA58      B.W      ??CenterLineGet_4
   \                     ??CenterLineGet_83: (+1)
   \   00000E56   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \                     ??CenterLineGet_59: (+1)
   \   00000E5A   0x484D             LDR.N    R0,??CenterLineGet_10+0x4
   \   00000E5C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000E60   0x2103             MOVS     R1,#+3
   \   00000E62   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00000E66   0x7800             LDRB     R0,[R0, #+0]
   \   00000E68   0x28FF             CMP      R0,#+255
   \   00000E6A   0xF000 0x8099      BEQ.W    ??CenterLineGet_84
   \   00000E6E   0xF8DF 0x03C0      LDR.W    R0,??CenterLineGet_34
   \   00000E72   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000E76   0x2103             MOVS     R1,#+3
   \   00000E78   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00000E7C   0x7800             LDRB     R0,[R0, #+0]
   \   00000E7E   0x28FF             CMP      R0,#+255
   \   00000E80   0xF000 0x808E      BEQ.W    ??CenterLineGet_84
   \   00000E84   0x2400             MOVS     R4,#+0
   \   00000E86   0x.... 0x....      LDR.W    R0,??DataTable53
   \   00000E8A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000E8E   0xF850 0x0038      LDR      R0,[R0, R8, LSL #+3]
   \   00000E92   0x4942             LDR.N    R1,??CenterLineGet_10+0x10
   \   00000E94   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000E98   0xF851 0x1038      LDR      R1,[R1, R8, LSL #+3]
   \   00000E9C   0x1808             ADDS     R0,R1,R0
   \   00000E9E   0x2102             MOVS     R1,#+2
   \   00000EA0   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000EA4   0x4939             LDR.N    R1,??CenterLineGet_10
   \   00000EA6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000EAA   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   00000EAE   0x483B             LDR.N    R0,??CenterLineGet_10+0x10
   \   00000EB0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000EB4   0xF850 0x0038      LDR      R0,[R0, R8, LSL #+3]
   \   00000EB8   0x.... 0x....      LDR.W    R1,??DataTable53
   \   00000EBC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000EC0   0xF851 0x1038      LDR      R1,[R1, R8, LSL #+3]
   \   00000EC4   0x4288             CMP      R0,R1
   \   00000EC6   0xDA1B             BGE.N    ??CenterLineGet_85
   \   00000EC8   0x.... 0x....      LDR.W    R0,??DataTable53
   \   00000ECC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000ED0   0xF850 0x0038      LDR      R0,[R0, R8, LSL #+3]
   \   00000ED4   0x4931             LDR.N    R1,??CenterLineGet_10+0x10
   \   00000ED6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000EDA   0xF851 0x1038      LDR      R1,[R1, R8, LSL #+3]
   \   00000EDE   0x1A40             SUBS     R0,R0,R1
   \   00000EE0   0x2102             MOVS     R1,#+2
   \   00000EE2   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000EE6   0x.... 0x....      LDR.W    R1,??DataTable53_1
   \   00000EEA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000EEE   0xF808 0x0001      STRB     R0,[R8, R1]
   \   00000EF2   0xE01A             B.N      ??CenterLineGet_86
   \                     ??CenterLineGet_8:
   \   00000EF4   0x3FF00000         DC32     0x3ff00000
   \   00000EF8   0x40690000         DC32     0x40690000
   \   00000EFC   0x........         DC32     RoadHalfWidth
   \                     ??CenterLineGet_85: (+1)
   \   00000F00   0x4826             LDR.N    R0,??CenterLineGet_10+0x10
   \   00000F02   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000F06   0xF850 0x0038      LDR      R0,[R0, R8, LSL #+3]
   \   00000F0A   0x.... 0x....      LDR.W    R1,??DataTable53
   \   00000F0E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000F12   0xF851 0x1038      LDR      R1,[R1, R8, LSL #+3]
   \   00000F16   0x1A40             SUBS     R0,R0,R1
   \   00000F18   0x2102             MOVS     R1,#+2
   \   00000F1A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000F1E   0x.... 0x....      LDR.W    R1,??DataTable53_1
   \   00000F22   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000F26   0xF808 0x0001      STRB     R0,[R8, R1]
   \                     ??CenterLineGet_86: (+1)
   \   00000F2A   0x.... 0x....      LDR.W    R0,??DataTable53_1
   \   00000F2E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000F32   0xF818 0x9000      LDRB     R9,[R8, R0]
   \   00000F36   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000F3A   0xF1B8 0x0F3B      CMP      R8,#+59
   \   00000F3E   0xF040 0x80EB      BNE.W    ??CenterLineGet_87
   \   00000F42   0x.... 0x....      LDR.W    R0,??DataTable53_1
   \   00000F46   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000F4A   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   00000F4E   0x2865             CMP      R0,#+101
   \   00000F50   0xDB04             BLT.N    ??CenterLineGet_88
   \   00000F52   0x2064             MOVS     R0,#+100
   \   00000F54   0x.... 0x....      LDR.W    R1,??DataTable54
   \   00000F58   0x7008             STRB     R0,[R1, #+0]
   \   00000F5A   0xE0DD             B.N      ??CenterLineGet_87
   \                     ??CenterLineGet_88: (+1)
   \   00000F5C   0x.... 0x....      LDR.W    R0,??DataTable53_1
   \   00000F60   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000F64   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   00000F68   0x2846             CMP      R0,#+70
   \   00000F6A   0xDA04             BGE.N    ??CenterLineGet_89
   \   00000F6C   0x2046             MOVS     R0,#+70
   \   00000F6E   0x.... 0x....      LDR.W    R1,??DataTable54
   \   00000F72   0x7008             STRB     R0,[R1, #+0]
   \   00000F74   0xE0D0             B.N      ??CenterLineGet_87
   \                     ??CenterLineGet_89: (+1)
   \   00000F76   0x.... 0x....      LDR.W    R0,??DataTable53_1
   \   00000F7A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000F7E   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   00000F82   0x.... 0x....      LDR.W    R1,??DataTable54
   \   00000F86   0x7008             STRB     R0,[R1, #+0]
   \   00000F88   0xE0C6             B.N      ??CenterLineGet_87
   \   00000F8A   0xBF00             Nop      
   \                     ??CenterLineGet_10:
   \   00000F8C   0x........         DC32     CenterLineLoc
   \   00000F90   0x........         DC32     BlackLeftLoc
   \   00000F94   0x........         DC32     BlackRightHeadLine
   \   00000F98   0x........         DC32     BlackRightEndLine
   \   00000F9C   0x........         DC32     BlackUdisRightLocation
   \                     ??CenterLineGet_84: (+1)
   \   00000FA0   0x.... 0x....      LDR.W    R0,??DataTable54_1
   \   00000FA4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000FA8   0x2103             MOVS     R1,#+3
   \   00000FAA   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00000FAE   0x7800             LDRB     R0,[R0, #+0]
   \   00000FB0   0x28FF             CMP      R0,#+255
   \   00000FB2   0xD018             BEQ.N    ??CenterLineGet_90
   \   00000FB4   0x489E             LDR.N    R0,??CenterLineGet_34
   \   00000FB6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000FBA   0x2103             MOVS     R1,#+3
   \   00000FBC   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00000FC0   0x7800             LDRB     R0,[R0, #+0]
   \   00000FC2   0x28FF             CMP      R0,#+255
   \   00000FC4   0xD10F             BNE.N    ??CenterLineGet_90
   \   00000FC6   0x2400             MOVS     R4,#+0
   \   00000FC8   0x.... 0x....      LDR.W    R0,??DataTable53
   \   00000FCC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000FD0   0xF850 0x0038      LDR      R0,[R0, R8, LSL #+3]
   \   00000FD4   0xFA50 0xF089      UXTAB    R0,R0,R9
   \   00000FD8   0x.... 0x....      LDR.W    R1,??DataTable54_2
   \   00000FDC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000FE0   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   00000FE4   0xE098             B.N      ??CenterLineGet_87
   \                     ??CenterLineGet_90: (+1)
   \   00000FE6   0x.... 0x....      LDR.W    R0,??DataTable54_1
   \   00000FEA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000FEE   0x2103             MOVS     R1,#+3
   \   00000FF0   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00000FF4   0x7800             LDRB     R0,[R0, #+0]
   \   00000FF6   0x28FF             CMP      R0,#+255
   \   00000FF8   0xD11A             BNE.N    ??CenterLineGet_91
   \   00000FFA   0x488D             LDR.N    R0,??CenterLineGet_34
   \   00000FFC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001000   0x2103             MOVS     R1,#+3
   \   00001002   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00001006   0x7800             LDRB     R0,[R0, #+0]
   \   00001008   0x28FF             CMP      R0,#+255
   \   0000100A   0xD011             BEQ.N    ??CenterLineGet_91
   \   0000100C   0x2400             MOVS     R4,#+0
   \   0000100E   0x.... 0x....      LDR.W    R0,??DataTable54_3
   \   00001012   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001016   0xF850 0x0038      LDR      R0,[R0, R8, LSL #+3]
   \   0000101A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000101E   0xEBB0 0x0009      SUBS     R0,R0,R9
   \   00001022   0x.... 0x....      LDR.W    R1,??DataTable54_2
   \   00001026   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000102A   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   0000102E   0xE073             B.N      ??CenterLineGet_87
   \                     ??CenterLineGet_91: (+1)
   \   00001030   0x.... 0x....      LDR.W    R0,??DataTable54_1
   \   00001034   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001038   0x2103             MOVS     R1,#+3
   \   0000103A   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   0000103E   0x7800             LDRB     R0,[R0, #+0]
   \   00001040   0x28FF             CMP      R0,#+255
   \   00001042   0xD169             BNE.N    ??CenterLineGet_87
   \   00001044   0x487A             LDR.N    R0,??CenterLineGet_34
   \   00001046   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000104A   0x2103             MOVS     R1,#+3
   \   0000104C   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00001050   0x7800             LDRB     R0,[R0, #+0]
   \   00001052   0x28FF             CMP      R0,#+255
   \   00001054   0xD160             BNE.N    ??CenterLineGet_87
   \   00001056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00001058   0x2C00             CMP      R4,#+0
   \   0000105A   0xD12E             BNE.N    ??CenterLineGet_92
   \   0000105C   0x2401             MOVS     R4,#+1
   \   0000105E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001062   0xF118 0x0004      ADDS     R0,R8,#+4
   \   00001066   0x283C             CMP      R0,#+60
   \   00001068   0xDA26             BGE.N    ??CenterLineGet_93
   \   0000106A   0x2500             MOVS     R5,#+0
   \   0000106C   0x2000             MOVS     R0,#+0
   \   0000106E   0xE012             B.N      ??CenterLineGet_94
   \                     ??CenterLineGet_95: (+1)
   \   00001070   0xEB10 0x0108      ADDS     R1,R0,R8
   \   00001074   0x1C49             ADDS     R1,R1,#+1
   \   00001076   0xAA00             ADD      R2,SP,#+0
   \   00001078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000107A   0x5481             STRB     R1,[R0, R2]
   \   0000107C   0x.... 0x....      LDR.W    R1,??DataTable54_2
   \   00001080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00001082   0xFA50 0xF288      UXTAB    R2,R0,R8
   \   00001086   0xEB11 0x0142      ADDS     R1,R1,R2, LSL #+1
   \   0000108A   0x8849             LDRH     R1,[R1, #+2]
   \   0000108C   0xAA01             ADD      R2,SP,#+4
   \   0000108E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00001090   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   \   00001094   0x1C40             ADDS     R0,R0,#+1
   \                     ??CenterLineGet_94: (+1)
   \   00001096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00001098   0x2804             CMP      R0,#+4
   \   0000109A   0xDBE9             BLT.N    ??CenterLineGet_95
   \   0000109C   0x2204             MOVS     R2,#+4
   \   0000109E   0xA901             ADD      R1,SP,#+4
   \   000010A0   0xA800             ADD      R0,SP,#+0
   \   000010A2   0x.... 0x....      BL       LeastSquareInt16a1
   \   000010A6   0x0006             MOVS     R6,R0
   \   000010A8   0x2304             MOVS     R3,#+4
   \   000010AA   0x0032             MOVS     R2,R6
   \   000010AC   0xA901             ADD      R1,SP,#+4
   \   000010AE   0xA800             ADD      R0,SP,#+0
   \   000010B0   0x.... 0x....      BL       LeastSquareInt16a0
   \   000010B4   0x0007             MOVS     R7,R0
   \   000010B6   0xE000             B.N      ??CenterLineGet_92
   \                     ??CenterLineGet_93: (+1)
   \   000010B8   0x2501             MOVS     R5,#+1
   \                     ??CenterLineGet_92: (+1)
   \   000010BA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000010BC   0x2D00             CMP      R5,#+0
   \   000010BE   0xD10E             BNE.N    ??CenterLineGet_96
   \   000010C0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000010C4   0xFB08 0x7006      MLA      R0,R8,R6,R7
   \   000010C8   0xF44F 0x717A      MOV      R1,#+1000
   \   000010CC   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000010D0   0x.... 0x....      LDR.W    R1,??DataTable54_2
   \   000010D4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000010D8   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   000010DC   0xE01C             B.N      ??CenterLineGet_87
   \                     ??CenterLineGet_96: (+1)
   \   000010DE   0x.... 0x....      LDR.W    R0,??DataTable54_2
   \   000010E2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000010E6   0xEB10 0x0048      ADDS     R0,R0,R8, LSL #+1
   \   000010EA   0x8840             LDRH     R0,[R0, #+2]
   \   000010EC   0x.... 0x....      LDR.W    R1,??DataTable54_2
   \   000010F0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000010F4   0xEB11 0x0148      ADDS     R1,R1,R8, LSL #+1
   \   000010F8   0x8849             LDRH     R1,[R1, #+2]
   \   000010FA   0x1808             ADDS     R0,R1,R0
   \   000010FC   0x.... 0x....      LDR.W    R1,??DataTable54_2
   \   00001100   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001104   0xEB11 0x0148      ADDS     R1,R1,R8, LSL #+1
   \   00001108   0x8889             LDRH     R1,[R1, #+4]
   \   0000110A   0x1A40             SUBS     R0,R0,R1
   \   0000110C   0x.... 0x....      LDR.W    R1,??DataTable54_2
   \   00001110   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001114   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \                     ??CenterLineGet_87: (+1)
   \   00001118   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000111C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00001120   0xF47F 0xAE99      BNE.W    ??CenterLineGet_83
   \   00001124   0x.... 0x....      LDR.W    R0,??DataTable56
   \   00001128   0x7800             LDRB     R0,[R0, #+0]
   \   0000112A   0x283B             CMP      R0,#+59
   \   0000112C   0xF43F 0xA8EA      BEQ.W    ??CenterLineGet_22
   \   00001130   0xF05F 0x083B      MOVS     R8,#+59
   \   00001134   0xE009             B.N      ??CenterLineGet_97
   \                     ??CenterLineGet_98: (+1)
   \   00001136   0xF647 0x70FF      MOVW     R0,#+32767
   \   0000113A   0x.... 0x....      LDR.W    R1,??DataTable54_2
   \   0000113E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001142   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   00001146   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \                     ??CenterLineGet_97: (+1)
   \   0000114A   0x.... 0x....      LDR.W    R0,??DataTable56
   \   0000114E   0x7800             LDRB     R0,[R0, #+0]
   \   00001150   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001154   0x4580             CMP      R8,R0
   \   00001156   0xD1EE             BNE.N    ??CenterLineGet_98
   \   00001158   0xF7FF 0xB8D4      B.W      ??CenterLineGet_22
   \                     ??CenterLineGet_47: (+1)
   \   0000115C   0x2400             MOVS     R4,#+0
   \   0000115E   0x2500             MOVS     R5,#+0
   \   00001160   0x.... 0x....      LDR.W    R0,??DataTable56
   \   00001164   0xF890 0x8000      LDRB     R8,[R0, #+0]
   \   00001168   0xE001             B.N      ??CenterLineGet_99
   \                     ??CenterLineGet_100: (+1)
   \   0000116A   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \                     ??CenterLineGet_99: (+1)
   \   0000116E   0x.... 0x....      LDR.W    R0,??DataTable54_1
   \   00001172   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001176   0x2103             MOVS     R1,#+3
   \   00001178   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   0000117C   0x7800             LDRB     R0,[R0, #+0]
   \   0000117E   0x28FF             CMP      R0,#+255
   \   00001180   0xD058             BEQ.N    ??CenterLineGet_101
   \   00001182   0x482B             LDR.N    R0,??CenterLineGet_34
   \   00001184   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001188   0x2103             MOVS     R1,#+3
   \   0000118A   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   0000118E   0x7800             LDRB     R0,[R0, #+0]
   \   00001190   0x28FF             CMP      R0,#+255
   \   00001192   0xD04F             BEQ.N    ??CenterLineGet_101
   \   00001194   0x2400             MOVS     R4,#+0
   \   00001196   0x.... 0x....      LDR.W    R0,??DataTable53
   \   0000119A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000119E   0xF850 0x0038      LDR      R0,[R0, R8, LSL #+3]
   \   000011A2   0x.... 0x....      LDR.W    R1,??DataTable54_3
   \   000011A6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000011AA   0xF851 0x1038      LDR      R1,[R1, R8, LSL #+3]
   \   000011AE   0x1808             ADDS     R0,R1,R0
   \   000011B0   0x2102             MOVS     R1,#+2
   \   000011B2   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000011B6   0x.... 0x....      LDR.W    R1,??DataTable54_2
   \   000011BA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000011BE   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   000011C2   0x.... 0x....      LDR.W    R0,??DataTable54_3
   \   000011C6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000011CA   0xF850 0x0038      LDR      R0,[R0, R8, LSL #+3]
   \   000011CE   0x.... 0x....      LDR.W    R1,??DataTable53
   \   000011D2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000011D6   0xF851 0x1038      LDR      R1,[R1, R8, LSL #+3]
   \   000011DA   0x4288             CMP      R0,R1
   \   000011DC   0xDA13             BGE.N    ??CenterLineGet_102
   \   000011DE   0x.... 0x....      LDR.W    R0,??DataTable53
   \   000011E2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000011E6   0xF850 0x0038      LDR      R0,[R0, R8, LSL #+3]
   \   000011EA   0x.... 0x....      LDR.W    R1,??DataTable54_3
   \   000011EE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000011F2   0xF851 0x1038      LDR      R1,[R1, R8, LSL #+3]
   \   000011F6   0x1A40             SUBS     R0,R0,R1
   \   000011F8   0x2102             MOVS     R1,#+2
   \   000011FA   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000011FE   0x.... 0x....      LDR.W    R1,??DataTable56_1
   \   00001202   0x7008             STRB     R0,[R1, #+0]
   \   00001204   0xE0D7             B.N      ??CenterLineGet_103
   \                     ??CenterLineGet_102: (+1)
   \   00001206   0x.... 0x....      LDR.W    R0,??DataTable54_3
   \   0000120A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000120E   0xF850 0x0038      LDR      R0,[R0, R8, LSL #+3]
   \   00001212   0x.... 0x....      LDR.W    R1,??DataTable53
   \   00001216   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000121A   0xF851 0x1038      LDR      R1,[R1, R8, LSL #+3]
   \   0000121E   0x1A40             SUBS     R0,R0,R1
   \   00001220   0x2102             MOVS     R1,#+2
   \   00001222   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00001226   0x.... 0x....      LDR.W    R1,??DataTable56_1
   \   0000122A   0x7008             STRB     R0,[R1, #+0]
   \   0000122C   0xE0C3             B.N      ??CenterLineGet_103
   \   0000122E   0xBF00             Nop      
   \                     ??CenterLineGet_34:
   \   00001230   0x........         DC32     BlackRightLoc
   \                     ??CenterLineGet_101: (+1)
   \   00001234   0x.... 0x....      LDR.W    R0,??DataTable54_1
   \   00001238   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000123C   0x2103             MOVS     R1,#+3
   \   0000123E   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00001242   0x7800             LDRB     R0,[R0, #+0]
   \   00001244   0x28FF             CMP      R0,#+255
   \   00001246   0xD01B             BEQ.N    ??CenterLineGet_104
   \   00001248   0x.... 0x....      LDR.W    R0,??DataTable56_2
   \   0000124C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001250   0x2103             MOVS     R1,#+3
   \   00001252   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   00001256   0x7800             LDRB     R0,[R0, #+0]
   \   00001258   0x28FF             CMP      R0,#+255
   \   0000125A   0xD111             BNE.N    ??CenterLineGet_104
   \   0000125C   0x2400             MOVS     R4,#+0
   \   0000125E   0x.... 0x....      LDR.W    R0,??DataTable53
   \   00001262   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001266   0xF850 0x0038      LDR      R0,[R0, R8, LSL #+3]
   \   0000126A   0x.... 0x....      LDR.W    R1,??DataTable56_1
   \   0000126E   0x7809             LDRB     R1,[R1, #+0]
   \   00001270   0x1A40             SUBS     R0,R0,R1
   \   00001272   0x.... 0x....      LDR.W    R1,??DataTable54_2
   \   00001276   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000127A   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   0000127E   0xE09A             B.N      ??CenterLineGet_103
   \                     ??CenterLineGet_104: (+1)
   \   00001280   0x.... 0x....      LDR.W    R0,??DataTable54_1
   \   00001284   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001288   0x2103             MOVS     R1,#+3
   \   0000128A   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   0000128E   0x7800             LDRB     R0,[R0, #+0]
   \   00001290   0x28FF             CMP      R0,#+255
   \   00001292   0xD11B             BNE.N    ??CenterLineGet_105
   \   00001294   0x.... 0x....      LDR.W    R0,??DataTable56_2
   \   00001298   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000129C   0x2103             MOVS     R1,#+3
   \   0000129E   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   000012A2   0x7800             LDRB     R0,[R0, #+0]
   \   000012A4   0x28FF             CMP      R0,#+255
   \   000012A6   0xD011             BEQ.N    ??CenterLineGet_105
   \   000012A8   0x2400             MOVS     R4,#+0
   \   000012AA   0x.... 0x....      LDR.W    R0,??DataTable54_3
   \   000012AE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000012B2   0xF850 0x0038      LDR      R0,[R0, R8, LSL #+3]
   \   000012B6   0x.... 0x....      LDR.W    R1,??DataTable56_1
   \   000012BA   0x7809             LDRB     R1,[R1, #+0]
   \   000012BC   0x1840             ADDS     R0,R0,R1
   \   000012BE   0x.... 0x....      LDR.W    R1,??DataTable54_2
   \   000012C2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000012C6   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   000012CA   0xE074             B.N      ??CenterLineGet_103
   \                     ??CenterLineGet_105: (+1)
   \   000012CC   0x.... 0x....      LDR.W    R0,??DataTable54_1
   \   000012D0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000012D4   0x2103             MOVS     R1,#+3
   \   000012D6   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   000012DA   0x7800             LDRB     R0,[R0, #+0]
   \   000012DC   0x28FF             CMP      R0,#+255
   \   000012DE   0xD16A             BNE.N    ??CenterLineGet_103
   \   000012E0   0x.... 0x....      LDR.W    R0,??DataTable56_2
   \   000012E4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000012E8   0x2103             MOVS     R1,#+3
   \   000012EA   0xFB01 0x0008      MLA      R0,R1,R8,R0
   \   000012EE   0x7800             LDRB     R0,[R0, #+0]
   \   000012F0   0x28FF             CMP      R0,#+255
   \   000012F2   0xD160             BNE.N    ??CenterLineGet_103
   \   000012F4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000012F6   0x2C00             CMP      R4,#+0
   \   000012F8   0xD12E             BNE.N    ??CenterLineGet_106
   \   000012FA   0x2401             MOVS     R4,#+1
   \   000012FC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001300   0xF118 0x0004      ADDS     R0,R8,#+4
   \   00001304   0x283C             CMP      R0,#+60
   \   00001306   0xDA26             BGE.N    ??CenterLineGet_107
   \   00001308   0x2500             MOVS     R5,#+0
   \   0000130A   0x2000             MOVS     R0,#+0
   \   0000130C   0xE012             B.N      ??CenterLineGet_108
   \                     ??CenterLineGet_109: (+1)
   \   0000130E   0xEB10 0x0108      ADDS     R1,R0,R8
   \   00001312   0x1C49             ADDS     R1,R1,#+1
   \   00001314   0xAA00             ADD      R2,SP,#+0
   \   00001316   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00001318   0x5481             STRB     R1,[R0, R2]
   \   0000131A   0x.... 0x....      LDR.W    R1,??DataTable54_2
   \   0000131E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00001320   0xFA50 0xF288      UXTAB    R2,R0,R8
   \   00001324   0xEB11 0x0142      ADDS     R1,R1,R2, LSL #+1
   \   00001328   0x8849             LDRH     R1,[R1, #+2]
   \   0000132A   0xAA01             ADD      R2,SP,#+4
   \   0000132C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000132E   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
   \   00001332   0x1C40             ADDS     R0,R0,#+1
   \                     ??CenterLineGet_108: (+1)
   \   00001334   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00001336   0x2804             CMP      R0,#+4
   \   00001338   0xDBE9             BLT.N    ??CenterLineGet_109
   \   0000133A   0x2204             MOVS     R2,#+4
   \   0000133C   0xA901             ADD      R1,SP,#+4
   \   0000133E   0xA800             ADD      R0,SP,#+0
   \   00001340   0x.... 0x....      BL       LeastSquareInt16a1
   \   00001344   0x0006             MOVS     R6,R0
   \   00001346   0x2304             MOVS     R3,#+4
   \   00001348   0x0032             MOVS     R2,R6
   \   0000134A   0xA901             ADD      R1,SP,#+4
   \   0000134C   0xA800             ADD      R0,SP,#+0
   \   0000134E   0x.... 0x....      BL       LeastSquareInt16a0
   \   00001352   0x0007             MOVS     R7,R0
   \   00001354   0xE000             B.N      ??CenterLineGet_106
   \                     ??CenterLineGet_107: (+1)
   \   00001356   0x2501             MOVS     R5,#+1
   \                     ??CenterLineGet_106: (+1)
   \   00001358   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000135A   0x2D00             CMP      R5,#+0
   \   0000135C   0xD10E             BNE.N    ??CenterLineGet_110
   \   0000135E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001362   0xFB08 0x7006      MLA      R0,R8,R6,R7
   \   00001366   0xF44F 0x717A      MOV      R1,#+1000
   \   0000136A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000136E   0x.... 0x....      LDR.W    R1,??DataTable54_2
   \   00001372   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001376   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   0000137A   0xE01C             B.N      ??CenterLineGet_103
   \                     ??CenterLineGet_110: (+1)
   \   0000137C   0x.... 0x....      LDR.W    R0,??DataTable54_2
   \   00001380   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001384   0xEB10 0x0048      ADDS     R0,R0,R8, LSL #+1
   \   00001388   0x8840             LDRH     R0,[R0, #+2]
   \   0000138A   0x.... 0x....      LDR.W    R1,??DataTable54_2
   \   0000138E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00001392   0xEB11 0x0148      ADDS     R1,R1,R8, LSL #+1
   \   00001396   0x8849             LDRH     R1,[R1, #+2]
   \   00001398   0x1808             ADDS     R0,R1,R0
   \   0000139A   0x.... 0x....      LDR.W    R1,??DataTable54_2
   \   0000139E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000013A2   0xEB11 0x0148      ADDS     R1,R1,R8, LSL #+1
   \   000013A6   0x8889             LDRH     R1,[R1, #+4]
   \   000013A8   0x1A40             SUBS     R0,R0,R1
   \   000013AA   0x.... 0x....      LDR.W    R1,??DataTable54_2
   \   000013AE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000013B2   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \                     ??CenterLineGet_103: (+1)
   \   000013B6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000013BA   0xF1B8 0x0F00      CMP      R8,#+0
   \   000013BE   0xF47F 0xAED4      BNE.W    ??CenterLineGet_100
   \   000013C2   0x.... 0x....      LDR.W    R0,??DataTable56
   \   000013C6   0x7800             LDRB     R0,[R0, #+0]
   \   000013C8   0x283B             CMP      R0,#+59
   \   000013CA   0xF43E 0xAF9B      BEQ.W    ??CenterLineGet_22
   \   000013CE   0xF05F 0x083B      MOVS     R8,#+59
   \   000013D2   0xE009             B.N      ??CenterLineGet_111
   \                     ??CenterLineGet_112: (+1)
   \   000013D4   0xF647 0x70FF      MOVW     R0,#+32767
   \   000013D8   0x.... 0x....      LDR.W    R1,??DataTable54_2
   \   000013DC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000013E0   0xF821 0x0018      STRH     R0,[R1, R8, LSL #+1]
   \   000013E4   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \                     ??CenterLineGet_111: (+1)
   \   000013E8   0x.... 0x....      LDR.W    R0,??DataTable56
   \   000013EC   0x7800             LDRB     R0,[R0, #+0]
   \   000013EE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000013F2   0x4580             CMP      R8,R0
   \   000013F4   0xD1EE             BNE.N    ??CenterLineGet_112
   \   000013F6   0xF7FE 0xBF85      B.W      ??CenterLineGet_22
   \                     ??CenterLineGet_46: (+1)
   \   000013FA   0x2000             MOVS     R0,#+0
   \   000013FC   0xF7FE 0xBF83      B.W      ??CenterLineGet_4
  10248          }
  10249          
  10250          
  10251          
  10252          
  10253          
  10254          //中心线求取时，根据两列偏差绝对值来求取赛道半宽度的函数。
  10255          //val为第39行与第59的列偏差的绝对值。
  10256          //返回估计出来的赛道半宽度。

   \                                 In section .text, align 2, keep-with-next
  10257          uint8 CenterLineHalfWidthGet(uint8 val)
  10258          {
  10259            uint8 temphalfwidth;
  10260            
  10261            if(val <= 25)
   \                     CenterLineHalfWidthGet: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x281A             CMP      R0,#+26
   \   00000004   0xDA01             BGE.N    ??CenterLineHalfWidthGet_0
  10262            {
  10263              temphalfwidth = 100;
   \   00000006   0x2064             MOVS     R0,#+100
   \   00000008   0xE00A             B.N      ??CenterLineHalfWidthGet_1
  10264            }
  10265            else
  10266            {
  10267              if(val <= 30)
   \                     ??CenterLineHalfWidthGet_0: (+1)
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x281F             CMP      R0,#+31
   \   0000000E   0xDA01             BGE.N    ??CenterLineHalfWidthGet_2
  10268              {
  10269                //temphalfwidth = 95;
  10270                temphalfwidth = 110;
   \   00000010   0x206E             MOVS     R0,#+110
   \   00000012   0xE005             B.N      ??CenterLineHalfWidthGet_1
  10271              }
  10272              else
  10273              {
  10274                if(val <= 35)
   \                     ??CenterLineHalfWidthGet_2: (+1)
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x2824             CMP      R0,#+36
   \   00000018   0xDA01             BGE.N    ??CenterLineHalfWidthGet_3
  10275                {
  10276                  //temphalfwidth = 105;
  10277                  temphalfwidth = 120;
   \   0000001A   0x2078             MOVS     R0,#+120
   \   0000001C   0xE000             B.N      ??CenterLineHalfWidthGet_1
  10278                }
  10279                else
  10280                {
  10281                    //temphalfwidth = 110;
  10282                    temphalfwidth = 130;
   \                     ??CenterLineHalfWidthGet_3: (+1)
   \   0000001E   0x2082             MOVS     R0,#+130
  10283                }
  10284              }
  10285            }
  10286            
  10287            return temphalfwidth;
   \                     ??CenterLineHalfWidthGet_1: (+1)
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x4770             BX       LR               ;; return
  10288          }
  10289          
  10290          
  10291          
  10292          
  10293          //图像重新赋值，摄像头反转版本。

   \                                 In section .text, align 2, keep-with-next
  10294          void ImgReversePut(void)
  10295          {
   \                     ImgReversePut: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
  10296          
  10297              uint16 i, j, k, temp1, temp2;   
  10298              
  10299              temp1 = CameraRealLeftCol;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable56_3
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
  10300              temp2 = CameraRealLeftCol + CameraRealWidth;
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable56_3
   \   0000000C   0x7809             LDRB     R1,[R1, #+0]
   \   0000000E   0x31FA             ADDS     R1,R1,#+250
  10301              //temp1 = CameraWidth/2 - CameraRealWidth/2 - 1;
  10302              //temp2 = CameraWidth/2 + CameraRealWidth/2 - 1;
  10303              
  10304              if (ImgPresent == ImgNO1)    //如果当前是第1幅图像正在接收数据（即第2幅图像接收完成）
   \   00000010   0x.... 0x....      LDR.W    R2,??DataTable56_4
   \   00000014   0x7812             LDRB     R2,[R2, #+0]
   \   00000016   0x2A01             CMP      R2,#+1
   \   00000018   0xD123             BNE.N    ??ImgReversePut_0
  10305              {
  10306                for(i = 0; i < CameraHight; i++)
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0xE01B             B.N      ??ImgReversePut_1
  10307                {
  10308                  k = 0;
  10309                  for(j = temp1; j < temp2; j++)
  10310                  {
  10311                    ImgNew[CameraHight-1-i][CameraRealWidth-1-k] = ImgStore2[i][j];
   \                     ??ImgReversePut_2: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R5,??DataTable56_5
   \   00000022   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000024   0x4256             RSBS     R6,R2,#+0
   \   00000026   0x27FA             MOVS     R7,#+250
   \   00000028   0xFB07 0x5506      MLA      R5,R7,R6,R5
   \   0000002C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002E   0x1B2D             SUBS     R5,R5,R4
   \   00000030   0xF643 0x2697      MOVW     R6,#+14999
   \   00000034   0x.... 0x....      LDR.W    R7,??DataTable56_6
   \   00000038   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000003A   0xF44F 0x7CA0      MOV      R12,#+320
   \   0000003E   0xFB0C 0x7702      MLA      R7,R12,R2,R7
   \   00000042   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000044   0x5DDF             LDRB     R7,[R3, R7]
   \   00000046   0x5577             STRB     R7,[R6, R5]
  10312                    k++;
   \   00000048   0x1C64             ADDS     R4,R4,#+1
  10313                  }
   \   0000004A   0x1C5B             ADDS     R3,R3,#+1
   \                     ??ImgReversePut_3: (+1)
   \   0000004C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000004E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000050   0x428B             CMP      R3,R1
   \   00000052   0xD3E4             BCC.N    ??ImgReversePut_2
   \   00000054   0x1C52             ADDS     R2,R2,#+1
   \                     ??ImgReversePut_1: (+1)
   \   00000056   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000058   0x2A3C             CMP      R2,#+60
   \   0000005A   0xDA2B             BGE.N    ??ImgReversePut_4
   \   0000005C   0x2400             MOVS     R4,#+0
   \   0000005E   0x0003             MOVS     R3,R0
   \   00000060   0xE7F4             B.N      ??ImgReversePut_3
  10314                }
  10315              }
  10316              else if (ImgPresent == ImgNO2)  //如果当前是第2幅图像正在接收数据（即第1幅图像接收完成）
   \                     ??ImgReversePut_0: (+1)
   \   00000062   0x.... 0x....      LDR.W    R2,??DataTable56_4
   \   00000066   0x7812             LDRB     R2,[R2, #+0]
   \   00000068   0x2A02             CMP      R2,#+2
   \   0000006A   0xD123             BNE.N    ??ImgReversePut_4
  10317              {
  10318                for(i = 0; i < CameraHight; i++)
   \   0000006C   0x2200             MOVS     R2,#+0
   \   0000006E   0xE01B             B.N      ??ImgReversePut_5
  10319                {
  10320                  k = 0;
  10321                  for(j = temp1; j < temp2; j++)
  10322                  {
  10323                    ImgNew[CameraHight-1-i][CameraRealWidth-1-k] = ImgStore1[i][j];
   \                     ??ImgReversePut_6: (+1)
   \   00000070   0x.... 0x....      LDR.W    R5,??DataTable56_5
   \   00000074   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000076   0x4256             RSBS     R6,R2,#+0
   \   00000078   0x27FA             MOVS     R7,#+250
   \   0000007A   0xFB07 0x5506      MLA      R5,R7,R6,R5
   \   0000007E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000080   0x1B2D             SUBS     R5,R5,R4
   \   00000082   0xF643 0x2697      MOVW     R6,#+14999
   \   00000086   0x.... 0x....      LDR.W    R7,??DataTable57
   \   0000008A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000008C   0xF44F 0x7CA0      MOV      R12,#+320
   \   00000090   0xFB0C 0x7702      MLA      R7,R12,R2,R7
   \   00000094   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000096   0x5DDF             LDRB     R7,[R3, R7]
   \   00000098   0x5577             STRB     R7,[R6, R5]
  10324                    k++;
   \   0000009A   0x1C64             ADDS     R4,R4,#+1
  10325                  }
   \   0000009C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??ImgReversePut_7: (+1)
   \   0000009E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000A0   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000A2   0x428B             CMP      R3,R1
   \   000000A4   0xD3E4             BCC.N    ??ImgReversePut_6
   \   000000A6   0x1C52             ADDS     R2,R2,#+1
   \                     ??ImgReversePut_5: (+1)
   \   000000A8   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000AA   0x2A3C             CMP      R2,#+60
   \   000000AC   0xDA02             BGE.N    ??ImgReversePut_4
   \   000000AE   0x2400             MOVS     R4,#+0
   \   000000B0   0x0003             MOVS     R3,R0
   \   000000B2   0xE7F4             B.N      ??ImgReversePut_7
  10326                }
  10327              }
  10328              else 
  10329              {
  10330                  //uart_sendN(UART0, (uint8 *)"\nError In FieldIsr()!", 21);   //错误警告
  10331              }
  10332            
  10333          }
   \                     ??ImgReversePut_4: (+1)
   \   000000B4   0xBCF0             POP      {R4-R7}
   \   000000B6   0x4770             BX       LR               ;; return
  10334          
  10335          
  10336          
  10337          //图像重新赋值,行不变（行中DMA中变化，选取需要的行），列无法在DMA中变化，就在这里变化。
  10338          ///////////////////////////////////////////但这里需要用示波器测量一下时间，看是不是耗费了太多时间。

   \                                 In section .text, align 2, keep-with-next
  10339          void ImgPut(void)
  10340          {
   \                     ImgPut: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
  10341              uint16 i, j, k, temp1, temp2;   
  10342              
  10343              temp1 = CameraRealLeftCol;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable56_3
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
  10344              temp2 = CameraRealLeftCol + CameraRealWidth;
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable56_3
   \   0000000C   0x7809             LDRB     R1,[R1, #+0]
   \   0000000E   0x31FA             ADDS     R1,R1,#+250
  10345              //temp1 = CameraWidth/2 - CameraRealWidth/2 - 1;
  10346              //temp2 = CameraWidth/2 + CameraRealWidth/2 - 1;
  10347              
  10348              if (ImgPresent == ImgNO1)    //如果当前是第1幅图像正在接收数据（即第2幅图像接收完成）
   \   00000010   0x.... 0x....      LDR.W    R2,??DataTable56_4
   \   00000014   0x7812             LDRB     R2,[R2, #+0]
   \   00000016   0x2A01             CMP      R2,#+1
   \   00000018   0xD11F             BNE.N    ??ImgPut_0
  10349              {
  10350                for(i = 0; i < CameraHight; i++)
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0xE017             B.N      ??ImgPut_1
  10351                {
  10352                  k = 0;
  10353                  for(j = temp1; j < temp2; j++)
  10354                  {
  10355                    ImgNew[i][k] = ImgStore2[i][j];
   \                     ??ImgPut_2: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R5,??DataTable56_5
   \   00000022   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000024   0x26FA             MOVS     R6,#+250
   \   00000026   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   0000002A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002C   0x.... 0x....      LDR.W    R6,??DataTable56_6
   \   00000030   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000032   0xF44F 0x77A0      MOV      R7,#+320
   \   00000036   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   0000003A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000003C   0x5D9E             LDRB     R6,[R3, R6]
   \   0000003E   0x5566             STRB     R6,[R4, R5]
  10356                    k++;
   \   00000040   0x1C64             ADDS     R4,R4,#+1
  10357                  }
   \   00000042   0x1C5B             ADDS     R3,R3,#+1
   \                     ??ImgPut_3: (+1)
   \   00000044   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000046   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000048   0x428B             CMP      R3,R1
   \   0000004A   0xD3E8             BCC.N    ??ImgPut_2
   \   0000004C   0x1C52             ADDS     R2,R2,#+1
   \                     ??ImgPut_1: (+1)
   \   0000004E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000050   0x2A3C             CMP      R2,#+60
   \   00000052   0xDA27             BGE.N    ??ImgPut_4
   \   00000054   0x2400             MOVS     R4,#+0
   \   00000056   0x0003             MOVS     R3,R0
   \   00000058   0xE7F4             B.N      ??ImgPut_3
  10358                }
  10359              }
  10360              else if (ImgPresent == ImgNO2)  //如果当前是第2幅图像正在接收数据（即第1幅图像接收完成）
   \                     ??ImgPut_0: (+1)
   \   0000005A   0x.... 0x....      LDR.W    R2,??DataTable56_4
   \   0000005E   0x7812             LDRB     R2,[R2, #+0]
   \   00000060   0x2A02             CMP      R2,#+2
   \   00000062   0xD11F             BNE.N    ??ImgPut_4
  10361              {
  10362                for(i = 0; i < CameraHight; i++)
   \   00000064   0x2200             MOVS     R2,#+0
   \   00000066   0xE017             B.N      ??ImgPut_5
  10363                {
  10364                  k = 0;
  10365                  for(j = temp1; j < temp2; j++)
  10366                  {
  10367                    ImgNew[i][k] = ImgStore1[i][j];
   \                     ??ImgPut_6: (+1)
   \   00000068   0x.... 0x....      LDR.W    R5,??DataTable56_5
   \   0000006C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000006E   0x26FA             MOVS     R6,#+250
   \   00000070   0xFB06 0x5502      MLA      R5,R6,R2,R5
   \   00000074   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000076   0x.... 0x....      LDR.W    R6,??DataTable57
   \   0000007A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000007C   0xF44F 0x77A0      MOV      R7,#+320
   \   00000080   0xFB07 0x6602      MLA      R6,R7,R2,R6
   \   00000084   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000086   0x5D9E             LDRB     R6,[R3, R6]
   \   00000088   0x5566             STRB     R6,[R4, R5]
  10368                    k++;
   \   0000008A   0x1C64             ADDS     R4,R4,#+1
  10369                  }
   \   0000008C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??ImgPut_7: (+1)
   \   0000008E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000090   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000092   0x428B             CMP      R3,R1
   \   00000094   0xD3E8             BCC.N    ??ImgPut_6
   \   00000096   0x1C52             ADDS     R2,R2,#+1
   \                     ??ImgPut_5: (+1)
   \   00000098   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000009A   0x2A3C             CMP      R2,#+60
   \   0000009C   0xDA02             BGE.N    ??ImgPut_4
   \   0000009E   0x2400             MOVS     R4,#+0
   \   000000A0   0x0003             MOVS     R3,R0
   \   000000A2   0xE7F4             B.N      ??ImgPut_7
  10370                }
  10371              }
  10372              else 
  10373              {
  10374                  //uart_sendN(UART0, (uint8 *)"\nError In FieldIsr()!", 21);   //错误警告
  10375              }
  10376          
  10377          }
   \                     ??ImgPut_4: (+1)
   \   000000A4   0xBCF0             POP      {R4-R7}
   \   000000A6   0x4770             BX       LR               ;; return
  10378          
  10379          
  10380          
  10381          
  10382          
  10383          //中心线离散度求取函数。自身的离散程度，和中心线的。

   \                                 In section .text, align 2, keep-with-next
  10384          void ErrorGet(void)
  10385          {
   \                     ErrorGet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
  10386            uint8 row;
  10387            uint8 avg = 0;
   \   00000002   0x2700             MOVS     R7,#+0
  10388            float temp;
  10389            uint8 index;
  10390            //求取平均值
  10391            temp = 0;
   \   00000004   0x2400             MOVS     R4,#+0
  10392            index = 0;
   \   00000006   0x2500             MOVS     R5,#+0
  10393            for(row = CameraHight - 1; ; row--)
   \   00000008   0x263B             MOVS     R6,#+59
   \   0000000A   0xE000             B.N      ??ErrorGet_0
   \                     ??ErrorGet_1: (+1)
   \   0000000C   0x1E76             SUBS     R6,R6,#+1
  10394            {
  10395              if(CenterLineLoc[row] != MaxValUint8)
   \                     ??ErrorGet_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable54_2
   \   00000012   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000014   0xF930 0x0016      LDRSH    R0,[R0, R6, LSL #+1]
   \   00000018   0x28FF             CMP      R0,#+255
   \   0000001A   0xD00B             BEQ.N    ??ErrorGet_2
  10396              {
  10397                temp += CenterLineLoc[row];
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable54_2
   \   00000020   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000022   0xF930 0x0016      LDRSH    R0,[R0, R6, LSL #+1]
   \   00000026   0x.... 0x....      BL       __aeabi_i2f
   \   0000002A   0x0021             MOVS     R1,R4
   \   0000002C   0x.... 0x....      BL       __aeabi_fadd
   \   00000030   0x0004             MOVS     R4,R0
  10398                index++;
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
  10399              }
  10400              if(row == 0) break;
   \                     ??ErrorGet_2: (+1)
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xD1E8             BNE.N    ??ErrorGet_1
  10401            }
  10402            avg = (uint8)(temp / index);
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000042   0x0001             MOVS     R1,R0
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       __aeabi_fdiv
   \   0000004A   0x.... 0x....      BL       __aeabi_f2iz
   \   0000004E   0x0007             MOVS     R7,R0
  10403            /*
  10404            //1. 先取线头
  10405            for(row = CameraHight - 1; ; row--)
  10406            {
  10407              if(CenterLineLoc[row] != MaxValUint8)
  10408              {
  10409                avg = CenterLineLoc[row];
  10410                break;
  10411              }
  10412              if(row == 0) break;
  10413            }
  10414            //2. 叠加求平均
  10415            for(row--; ; row--)
  10416            {
  10417              if(CenterLineLoc[row] != MaxValUint8)
  10418              {
  10419                avg = (avg + CenterLineLoc[row]) / 2;
  10420              }
  10421              if(row == 0) break;    
  10422            }
  10423            */
  10424            
  10425          
  10426            temp = 0;
   \   00000050   0x2400             MOVS     R4,#+0
  10427            index = 0;
   \   00000052   0x2500             MOVS     R5,#+0
  10428            for(row = CameraHight - 1; ; row--)
   \   00000054   0x263B             MOVS     R6,#+59
   \   00000056   0xE000             B.N      ??ErrorGet_3
   \                     ??ErrorGet_4: (+1)
   \   00000058   0x1E76             SUBS     R6,R6,#+1
  10429            {
  10430              if(CenterLineLoc[row] != MaxValUint8)
   \                     ??ErrorGet_3: (+1)
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable54_2
   \   0000005E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000060   0xF930 0x0016      LDRSH    R0,[R0, R6, LSL #+1]
   \   00000064   0x28FF             CMP      R0,#+255
   \   00000066   0xD00F             BEQ.N    ??ErrorGet_5
  10431              {
  10432                temp += AbsRe(CenterLineLoc[row], avg);
   \   00000068   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000006A   0x0039             MOVS     R1,R7
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable54_2
   \   00000070   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000072   0xF930 0x0016      LDRSH    R0,[R0, R6, LSL #+1]
   \   00000076   0x.... 0x....      BL       AbsRe
   \   0000007A   0x.... 0x....      BL       __aeabi_i2f
   \   0000007E   0x0021             MOVS     R1,R4
   \   00000080   0x.... 0x....      BL       __aeabi_fadd
   \   00000084   0x0004             MOVS     R4,R0
  10433                index++;
   \   00000086   0x1C6D             ADDS     R5,R5,#+1
  10434              }
  10435              if(row == 0) break;
   \                     ??ErrorGet_5: (+1)
   \   00000088   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008A   0x2E00             CMP      R6,#+0
   \   0000008C   0xD1E4             BNE.N    ??ErrorGet_4
  10436            }
  10437            ErrorGetSelf = (uint8)(temp / index);
   \   0000008E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000090   0x0028             MOVS     R0,R5
   \   00000092   0x.... 0x....      BL       __aeabi_ui2f
   \   00000096   0x0001             MOVS     R1,R0
   \   00000098   0x0020             MOVS     R0,R4
   \   0000009A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000009E   0x.... 0x....      BL       __aeabi_f2iz
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable57_1
   \   000000A6   0x7008             STRB     R0,[R1, #+0]
  10438            ErrorGetCen = AbsRe(avg, PhyCenterCol);
   \   000000A8   0x217D             MOVS     R1,#+125
   \   000000AA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000AC   0x0038             MOVS     R0,R7
   \   000000AE   0x.... 0x....      BL       AbsRe
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable57_2
   \   000000B6   0x7008             STRB     R0,[R1, #+0]
  10439            
  10440          }
   \   000000B8   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
  10441          
  10442          
  10443          
  10444          //开根号运算
  10445          //本来传进来传出去都是uint16型的，但是我调用的时候只会用到uint8型的，且不会超出255.

   \                                 In section .text, align 2, keep-with-next
  10446          uint16 MathSqrt(uint16 x1)
  10447          {
  10448            uint8 ans = 0, p = 0x80;
   \                     MathSqrt: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x2280             MOVS     R2,#+128
  10449            uint16 x = x1;
   \   00000004   0xE00C             B.N      ??MathSqrt_0
  10450            
  10451            while(p!=0)
  10452            {
  10453              ans += p;
   \                     ??MathSqrt_1: (+1)
   \   00000006   0x1851             ADDS     R1,R2,R1
  10454              if(ans * ans > x) ans -=p;
   \   00000008   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0xFB01 0xF301      MUL      R3,R1,R1
   \   00000012   0x4298             CMP      R0,R3
   \   00000014   0xDA00             BGE.N    ??MathSqrt_2
   \   00000016   0x1A89             SUBS     R1,R1,R2
  10455              p = (uint8)(p / 2);
   \                     ??MathSqrt_2: (+1)
   \   00000018   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001A   0x2302             MOVS     R3,#+2
   \   0000001C   0xFB92 0xF2F3      SDIV     R2,R2,R3
  10456            }
   \                     ??MathSqrt_0: (+1)
   \   00000020   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000022   0x2A00             CMP      R2,#+0
   \   00000024   0xD1EF             BNE.N    ??MathSqrt_1
  10457            return ans;  
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0x0008             MOVS     R0,R1
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0x4770             BX       LR               ;; return
  10458          }
  10459          
  10460          //曲线的曲率求取，曲线向右拐（三点为顺时针方向分布），曲率为负，曲线向左拐（三点为逆时钟方向分布），曲率为正
  10461          //K = 4*SABC/AB/BC/AC

   \                                 In section .text, align 2, keep-with-next
  10462          int16 CurveGet(int16 AX, uint8 AY, int16 BX, uint8 BY, int16 CX, uint8 CY)
  10463          {
   \                     CurveGet: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0xF9BD 0x9028      LDRSH    R9,[SP, #+40]
   \   00000010   0x9C0B             LDR      R4,[SP, #+44]
  10464            int16 SABC_temp; //三角形的面积，有正负。
  10465            int16 tempab, tempbc, tempac;
  10466            int16 AB, BC, AC; //三角形的边长，均为正。
  10467            int16 result;
  10468            //int16 K;        //曲率结果，有正负。
  10469            
  10470            SABC_temp = ((BX - AX) * (CY - AY) - (CX - AX) * (BY - AY));
   \   00000012   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   00000014   0xB22D             SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
   \   00000016   0x1B78             SUBS     R0,R7,R5
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0x1BA1             SUBS     R1,R4,R6
   \   0000001E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000022   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000024   0xEBB8 0x0206      SUBS     R2,R8,R6
   \   00000028   0xB22D             SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
   \   0000002A   0xFA0F 0xF989      SXTH     R9,R9            ;; SignExt  R9,R9,#+16,#+16
   \   0000002E   0xEBB5 0x0309      SUBS     R3,R5,R9
   \   00000032   0x435A             MULS     R2,R3,R2
   \   00000034   0xFB01 0x2A00      MLA      R10,R1,R0,R2
  10471            
  10472            tempab = (BX - AX) * (BX - AX) + (BY - AY) * (BY - AY);
   \   00000038   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   0000003A   0xB22D             SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
   \   0000003C   0x1B78             SUBS     R0,R7,R5
   \   0000003E   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   00000040   0xB22D             SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
   \   00000042   0x1B79             SUBS     R1,R7,R5
   \   00000044   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0xEBB8 0x0206      SUBS     R2,R8,R6
   \   0000004E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000052   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000054   0xEBB8 0x0306      SUBS     R3,R8,R6
   \   00000058   0x435A             MULS     R2,R3,R2
   \   0000005A   0xFB01 0x2000      MLA      R0,R1,R0,R2
  10473            if(tempab > 100) 
   \   0000005E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000060   0x2865             CMP      R0,#+101
   \   00000062   0xDB0A             BLT.N    ??CurveGet_0
  10474            {
  10475              AB = MathSqrt(tempab / 100) * 10; //失掉两位的精度，因为求根运算范围的限制。
   \   00000064   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000066   0x2164             MOVS     R1,#+100
   \   00000068   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000006C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006E   0x.... 0x....      BL       MathSqrt
   \   00000072   0x210A             MOVS     R1,#+10
   \   00000074   0xFB10 0xFB01      SMULBB   R11,R0,R1
   \   00000078   0xE003             B.N      ??CurveGet_1
  10476            }
  10477            else
  10478            {
  10479              AB = MathSqrt(tempab);
   \                     ??CurveGet_0: (+1)
   \   0000007A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000007C   0x.... 0x....      BL       MathSqrt
   \   00000080   0x4683             MOV      R11,R0
  10480            }
  10481            
  10482            tempbc = (BX - CX) * (BX - CX) + (BY - CY) * (BY - CY);
   \                     ??CurveGet_1: (+1)
   \   00000082   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   00000084   0xFA0F 0xF989      SXTH     R9,R9            ;; SignExt  R9,R9,#+16,#+16
   \   00000088   0xEBB7 0x0009      SUBS     R0,R7,R9
   \   0000008C   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   0000008E   0xFA0F 0xF989      SXTH     R9,R9            ;; SignExt  R9,R9,#+16,#+16
   \   00000092   0xEBB7 0x0109      SUBS     R1,R7,R9
   \   00000096   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000009A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009C   0xEBB8 0x0204      SUBS     R2,R8,R4
   \   000000A0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A6   0xEBB8 0x0304      SUBS     R3,R8,R4
   \   000000AA   0x435A             MULS     R2,R3,R2
   \   000000AC   0xFB01 0x2000      MLA      R0,R1,R0,R2
  10483            if(tempbc > 100) 
   \   000000B0   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000000B2   0x2865             CMP      R0,#+101
   \   000000B4   0xDB0A             BLT.N    ??CurveGet_2
  10484            {
  10485              BC = MathSqrt(tempbc / 100) * 10; //失掉两位的精度，因为求根运算范围的限制。
   \   000000B6   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000000B8   0x2164             MOVS     R1,#+100
   \   000000BA   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000BE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C0   0x.... 0x....      BL       MathSqrt
   \   000000C4   0x210A             MOVS     R1,#+10
   \   000000C6   0xFB10 0xF701      SMULBB   R7,R0,R1
   \   000000CA   0xE003             B.N      ??CurveGet_3
  10486            }
  10487            else
  10488            {
  10489              BC = MathSqrt(tempbc);
   \                     ??CurveGet_2: (+1)
   \   000000CC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000CE   0x.... 0x....      BL       MathSqrt
   \   000000D2   0x0007             MOVS     R7,R0
  10490            }
  10491            
  10492            tempac = (CX - AX) * (CX - AX) + (CY - AY) * (CY - AY);
   \                     ??CurveGet_3: (+1)
   \   000000D4   0xFA0F 0xF989      SXTH     R9,R9            ;; SignExt  R9,R9,#+16,#+16
   \   000000D8   0xB22D             SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
   \   000000DA   0xEBB9 0x0005      SUBS     R0,R9,R5
   \   000000DE   0xFA0F 0xF989      SXTH     R9,R9            ;; SignExt  R9,R9,#+16,#+16
   \   000000E2   0xB22D             SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
   \   000000E4   0xEBB9 0x0105      SUBS     R1,R9,R5
   \   000000E8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000EC   0x1BA2             SUBS     R2,R4,R6
   \   000000EE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000F2   0x1BA3             SUBS     R3,R4,R6
   \   000000F4   0x435A             MULS     R2,R3,R2
   \   000000F6   0xFB01 0x2000      MLA      R0,R1,R0,R2
  10493            if(tempac > 100) 
   \   000000FA   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000000FC   0x2865             CMP      R0,#+101
   \   000000FE   0xDB0A             BLT.N    ??CurveGet_4
  10494            {
  10495              AC = MathSqrt(tempac / 100) * 10; //失掉两位的精度，因为求根运算范围的限制。
   \   00000100   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000102   0x2164             MOVS     R1,#+100
   \   00000104   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000108   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000010A   0x.... 0x....      BL       MathSqrt
   \   0000010E   0x210A             MOVS     R1,#+10
   \   00000110   0xFB10 0xF001      SMULBB   R0,R0,R1
   \   00000114   0xE002             B.N      ??CurveGet_5
  10496            }
  10497            else
  10498            {
  10499              AC = MathSqrt(tempac);
   \                     ??CurveGet_4: (+1)
   \   00000116   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000118   0x.... 0x....      BL       MathSqrt
  10500            }
  10501            
  10502            result = CurveGetCompen * SABC_temp / AB / BC / AC;
   \                     ??CurveGet_5: (+1)
   \   0000011C   0xF44F 0x61FA      MOV      R1,#+2000
   \   00000120   0xFB1A 0xF101      SMULBB   R1,R10,R1
   \   00000124   0xFA0F 0xFB8B      SXTH     R11,R11          ;; SignExt  R11,R11,#+16,#+16
   \   00000128   0xFB91 0xF1FB      SDIV     R1,R1,R11
   \   0000012C   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   0000012E   0xFB91 0xF1F7      SDIV     R1,R1,R7
   \   00000132   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000134   0xFB91 0xF0F0      SDIV     R0,R1,R0
  10503            if(result >= MaxValUint8) 
   \   00000138   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000013A   0x28FF             CMP      R0,#+255
   \   0000013C   0xDB01             BLT.N    ??CurveGet_6
  10504            {
  10505              result = MaxValUint8 - 1;           //不能大过MaxValUint8
   \   0000013E   0x20FE             MOVS     R0,#+254
   \   00000140   0xE006             B.N      ??CurveGet_7
  10506            }
  10507            else if(result + MaxValUint8 < 0)
   \                     ??CurveGet_6: (+1)
   \   00000142   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000144   0xF110 0x01FF      ADDS     R1,R0,#+255
   \   00000148   0x2900             CMP      R1,#+0
   \   0000014A   0xD501             BPL.N    ??CurveGet_7
  10508            {
  10509              result = 1 - MaxValUint8;           //不能小过-MaxValUint8
   \   0000014C   0xF07F 0x00FD      MVNS     R0,#+253
  10510            }
  10511            else
  10512            {
  10513            }
  10514            
  10515            return result;
   \                     ??CurveGet_7: (+1)
   \   00000150   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000152   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
  10516          }
  10517          
  10518          
  10519          
  10520          //SABC的面积求取，顺时针则返回负值，逆时针则返回正值。
  10521          //以左下角为原点，向右为x轴正方向(0~249)，向上为y轴正方向(0~49)。

   \                                 In section .text, align 2, keep-with-next
  10522          int16 SABCGet(uint8 x1, uint8 y1, uint8 x2, uint8 y2, uint8 x3, uint8 y3)
  10523          {
   \                     SABCGet: (+1)
   \   00000000   0xB410             PUSH     {R4}
  10524            int16 SABC_temp;
  10525            
  10526            SABC_temp = ((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)) / 2;
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x1A14             SUBS     R4,R2,R0
   \   00000008   0x9A02             LDR      R2,[SP, #+8]
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x1A52             SUBS     R2,R2,R1
   \   0000000E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x1A5B             SUBS     R3,R3,R1
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x9901             LDR      R1,[SP, #+4]
   \   00000018   0x1A40             SUBS     R0,R0,R1
   \   0000001A   0xFB00 0xF003      MUL      R0,R0,R3
   \   0000001E   0xFB02 0x0004      MLA      R0,R2,R4,R0
   \   00000022   0x2102             MOVS     R1,#+2
   \   00000024   0xFB90 0xF0F1      SDIV     R0,R0,R1
  10527            
  10528            return SABC_temp;
   \   00000028   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000002A   0xBC10             POP      {R4}
   \   0000002C   0x4770             BX       LR               ;; return
  10529          }
  10530          
  10531          
  10532          
  10533          
  10534          //中心线的曲率和斜率求取

   \                                 In section .text, align 2, keep-with-next
  10535          uint8 CurveSlopeGetCenter(void)
  10536          {
   \                     CurveSlopeGetCenter: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
  10537            uint8 row;
  10538            uint8 temp;
  10539            uint8 tempslopex[3];
  10540            int16 tempslopey[3];
  10541            
  10542            //1. 
  10543            //曲率符号预先清零。
  10544            CurveLineChosenC1 = MaxValUint8;
   \   00000004   0x20FF             MOVS     R0,#+255
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable57_3
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
  10545            CurveLineChosenC2 = MaxValUint8;
   \   0000000C   0x20FF             MOVS     R0,#+255
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable57_4
   \   00000012   0x7008             STRB     R0,[R1, #+0]
  10546            CurveLineChosenC3 = MaxValUint8;
   \   00000014   0x20FF             MOVS     R0,#+255
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable57_5
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
  10547            
  10548            if(CenterHeadLine == MaxValUint8 || CenterEndLine == MaxValUint8)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable57_6
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x28FF             CMP      R0,#+255
   \   00000024   0xD004             BEQ.N    ??CurveSlopeGetCenter_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable56
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x28FF             CMP      R0,#+255
   \   0000002E   0xD10A             BNE.N    ??CurveSlopeGetCenter_1
  10549            {
  10550              CURVEC = MaxValUint8;  //return 0之前要将中心线曲率置无效值。
   \                     ??CurveSlopeGetCenter_0: (+1)
   \   00000030   0x20FF             MOVS     R0,#+255
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable57_7
   \   00000036   0x8008             STRH     R0,[R1, #+0]
  10551              SlopeC = MaxValInt16;  //return 0之前要将中心线斜率置无效值。
   \   00000038   0xF647 0x70FF      MOVW     R0,#+32767
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable57_8
   \   00000040   0x6008             STR      R0,[R1, #+0]
  10552              return 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE0D8             B.N      ??CurveSlopeGetCenter_2
  10553            }
  10554            
  10555            //曲率基于的行1 CurveLineChosen1，即中心线的线头。
  10556            if(CenterHeadLine >= CameraHight - 2)
   \                     ??CurveSlopeGetCenter_1: (+1)
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable57_6
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x283A             CMP      R0,#+58
   \   0000004E   0xDB0E             BLT.N    ??CurveSlopeGetCenter_3
  10557            {
  10558              CurveLineChosenC1 = MaxValUint8;  
   \   00000050   0x20FF             MOVS     R0,#+255
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable57_3
   \   00000056   0x7008             STRB     R0,[R1, #+0]
  10559              CURVEC = MaxValUint8;  //return 0之前要将中心线曲率置无效值。
   \   00000058   0x20FF             MOVS     R0,#+255
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable57_7
   \   0000005E   0x8008             STRH     R0,[R1, #+0]
  10560              SlopeC = MaxValInt16;  //return 0之前要将中心线斜率置无效值。
   \   00000060   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable57_8
   \   00000068   0x6008             STR      R0,[R1, #+0]
  10561              return 0;    
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE0C4             B.N      ??CurveSlopeGetCenter_2
  10562            }
  10563            else
  10564            {
  10565              CurveLineChosenC1 = CenterHeadLine;    
   \                     ??CurveSlopeGetCenter_3: (+1)
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable57_6
   \   00000072   0x7800             LDRB     R0,[R0, #+0]
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable57_3
   \   00000078   0x7008             STRB     R0,[R1, #+0]
  10566            }
  10567            
  10568            
  10569            //把第1个有效值到CameraHight-1的距离分成2段。
  10570            temp = (CenterEndLine - 1 - CenterHeadLine) / 2;
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable56
   \   0000007E   0x7800             LDRB     R0,[R0, #+0]
   \   00000080   0x1E40             SUBS     R0,R0,#+1
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable57_6
   \   00000086   0x7809             LDRB     R1,[R1, #+0]
   \   00000088   0x1A40             SUBS     R0,R0,R1
   \   0000008A   0x2102             MOVS     R1,#+2
   \   0000008C   0xFB90 0xF1F1      SDIV     R1,R0,R1
  10571            //2 * 2 + 1 = 5, 即如果有效行只有3行以内的话，就放弃求取曲率和斜率。（因为会很不精确）
  10572            if(temp <= 2) 
   \   00000090   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000092   0x2903             CMP      R1,#+3
   \   00000094   0xDA0E             BGE.N    ??CurveSlopeGetCenter_4
  10573            {
  10574              CurveLineChosenC1 = MaxValUint8;
   \   00000096   0x20FF             MOVS     R0,#+255
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable57_3
   \   0000009C   0x7008             STRB     R0,[R1, #+0]
  10575              CURVEC = MaxValUint8;  //return 0之前要将中心线曲率置无效值。
   \   0000009E   0x20FF             MOVS     R0,#+255
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable57_7
   \   000000A4   0x8008             STRH     R0,[R1, #+0]
  10576              SlopeC = MaxValInt16;  //return 0之前要将中心线斜率置无效值。
   \   000000A6   0xF647 0x70FF      MOVW     R0,#+32767
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable57_8
   \   000000AE   0x6008             STR      R0,[R1, #+0]
  10577              return 0;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xE0A1             B.N      ??CurveSlopeGetCenter_2
  10578            }
  10579            
  10580            //曲率基于的行2 CurveLineChosen2
  10581            for(row = CurveLineChosenC1 + temp - 1; ; row++)
   \                     ??CurveSlopeGetCenter_4: (+1)
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable57_3
   \   000000B8   0x7800             LDRB     R0,[R0, #+0]
   \   000000BA   0x1808             ADDS     R0,R1,R0
   \   000000BC   0x1E40             SUBS     R0,R0,#+1
  10582            {
  10583              if(row > CenterEndLine - 1) 
   \   000000BE   0x.... 0x....      LDR.W    R2,??DataTable56
   \   000000C2   0x7812             LDRB     R2,[R2, #+0]
   \   000000C4   0x1E52             SUBS     R2,R2,#+1
   \   000000C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C8   0x4282             CMP      R2,R0
   \   000000CA   0xDA12             BGE.N    ??CurveSlopeGetCenter_5
  10584              {
  10585                CurveLineChosenC1 = MaxValUint8;
   \   000000CC   0x20FF             MOVS     R0,#+255
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable57_3
   \   000000D2   0x7008             STRB     R0,[R1, #+0]
  10586                CurveLineChosenC2 = MaxValUint8;
   \   000000D4   0x20FF             MOVS     R0,#+255
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable57_4
   \   000000DA   0x7008             STRB     R0,[R1, #+0]
  10587                CURVEC = MaxValUint8;  //return 0之前要将中心线曲率置无效值。
   \   000000DC   0x20FF             MOVS     R0,#+255
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable57_7
   \   000000E2   0x8008             STRH     R0,[R1, #+0]
  10588                SlopeC = MaxValInt16;  //return 0之前要将中心线斜率置无效值。
   \   000000E4   0xF647 0x70FF      MOVW     R0,#+32767
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable57_8
   \   000000EC   0x6008             STR      R0,[R1, #+0]
  10589                return 0;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0xE082             B.N      ??CurveSlopeGetCenter_2
  10590              }
  10591              //不用判断该行是不是无效值。因为中心线连续。
  10592              CurveLineChosenC2 = row;
   \                     ??CurveSlopeGetCenter_5: (+1)
   \   000000F2   0x.... 0x....      LDR.W    R2,??DataTable57_4
   \   000000F6   0x7010             STRB     R0,[R2, #+0]
  10593              break;
  10594              
  10595            }
  10596            
  10597            //曲率基于的行3 CurveLineChosen3
  10598            for(row = CurveLineChosenC2 + temp - 1; ; row++)
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable57_4
   \   000000FC   0x7800             LDRB     R0,[R0, #+0]
   \   000000FE   0x1808             ADDS     R0,R1,R0
   \   00000100   0x1E40             SUBS     R0,R0,#+1
  10599            {
  10600              if(row > CenterEndLine) 
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable56
   \   00000106   0x7809             LDRB     R1,[R1, #+0]
   \   00000108   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010A   0x4281             CMP      R1,R0
   \   0000010C   0xD216             BCS.N    ??CurveSlopeGetCenter_6
  10601              {
  10602                CurveLineChosenC1 = MaxValUint8;
   \   0000010E   0x20FF             MOVS     R0,#+255
   \   00000110   0x.... 0x....      LDR.W    R1,??DataTable57_3
   \   00000114   0x7008             STRB     R0,[R1, #+0]
  10603                CurveLineChosenC2 = MaxValUint8;
   \   00000116   0x20FF             MOVS     R0,#+255
   \   00000118   0x.... 0x....      LDR.W    R1,??DataTable57_4
   \   0000011C   0x7008             STRB     R0,[R1, #+0]
  10604                CurveLineChosenC3 = MaxValUint8;
   \   0000011E   0x20FF             MOVS     R0,#+255
   \   00000120   0x.... 0x....      LDR.W    R1,??DataTable57_5
   \   00000124   0x7008             STRB     R0,[R1, #+0]
  10605                CURVEC = MaxValUint8;  //return 0之前要将中心线曲率置无效值。
   \   00000126   0x20FF             MOVS     R0,#+255
   \   00000128   0x.... 0x....      LDR.W    R1,??DataTable57_7
   \   0000012C   0x8008             STRH     R0,[R1, #+0]
  10606                SlopeC = MaxValInt16;  //return 0之前要将中心线斜率置无效值。      
   \   0000012E   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable57_8
   \   00000136   0x6008             STR      R0,[R1, #+0]
  10607                return 0;
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0xE05D             B.N      ??CurveSlopeGetCenter_2
  10608              }
  10609              //不用判断该行是不是无效值。因为中心线连续。
  10610              CurveLineChosenC3 = row;
   \                     ??CurveSlopeGetCenter_6: (+1)
   \   0000013C   0x.... 0x....      LDR.W    R1,??DataTable57_5
   \   00000140   0x7008             STRB     R0,[R1, #+0]
  10611              break;
  10612            }
  10613            //SABCC中心线曲率三角形面积的求取
  10614            //SABCC = SABCGet(CenterLineLoc[CurveLineChosenC1], CameraHight - 1 - CurveLineChosenC1,
  10615            //                CenterLineLoc[CurveLineChosenC2], CameraHight - 1 - CurveLineChosenC2,
  10616            //                CenterLineLoc[CurveLineChosenC3], CameraHight - 1 - CurveLineChosenC3
  10617            //                );
  10618            //曲率求取，最大值不会超过MaxValUint8;
  10619            CURVEC = CurveGet(CenterLineLoc[CurveLineChosenC1], CameraHight - 1 - CurveLineChosenC1,
  10620                             CenterLineLoc[CurveLineChosenC2], CameraHight - 1 - CurveLineChosenC2,
  10621                             CenterLineLoc[CurveLineChosenC3], CameraHight - 1 - CurveLineChosenC3
  10622                             );
   \   00000142   0x.... 0x....      LDR.W    R0,??DataTable57_5
   \   00000146   0x7800             LDRB     R0,[R0, #+0]
   \   00000148   0xF1D0 0x003B      RSBS     R0,R0,#+59
   \   0000014C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014E   0x9001             STR      R0,[SP, #+4]
   \   00000150   0x....             LDR.N    R0,??DataTable54_2
   \   00000152   0x.... 0x....      LDR.W    R1,??DataTable57_5
   \   00000156   0x7809             LDRB     R1,[R1, #+0]
   \   00000158   0xF930 0x0011      LDRSH    R0,[R0, R1, LSL #+1]
   \   0000015C   0x9000             STR      R0,[SP, #+0]
   \   0000015E   0x.... 0x....      LDR.W    R0,??DataTable57_4
   \   00000162   0x7800             LDRB     R0,[R0, #+0]
   \   00000164   0xF1D0 0x033B      RSBS     R3,R0,#+59
   \   00000168   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000016A   0x....             LDR.N    R0,??DataTable54_2
   \   0000016C   0x.... 0x....      LDR.W    R1,??DataTable57_4
   \   00000170   0x7809             LDRB     R1,[R1, #+0]
   \   00000172   0xF930 0x2011      LDRSH    R2,[R0, R1, LSL #+1]
   \   00000176   0x.... 0x....      LDR.W    R0,??DataTable57_3
   \   0000017A   0x7800             LDRB     R0,[R0, #+0]
   \   0000017C   0xF1D0 0x013B      RSBS     R1,R0,#+59
   \   00000180   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000182   0x....             LDR.N    R0,??DataTable54_2
   \   00000184   0x.... 0x....      LDR.W    R4,??DataTable57_3
   \   00000188   0x7824             LDRB     R4,[R4, #+0]
   \   0000018A   0xF930 0x0014      LDRSH    R0,[R0, R4, LSL #+1]
   \   0000018E   0x.... 0x....      BL       CurveGet
   \   00000192   0x.... 0x....      LDR.W    R1,??DataTable57_7
   \   00000196   0x8008             STRH     R0,[R1, #+0]
  10623            //中心线斜率求取，左上角为原点，向下X，向右Y。应该不会超过MaxValUint8
  10624            tempslopex[0] = CurveLineChosenC1;
   \   00000198   0x.... 0x....      LDR.W    R0,??DataTable57_3
   \   0000019C   0x7800             LDRB     R0,[R0, #+0]
   \   0000019E   0xF88D 0x0008      STRB     R0,[SP, #+8]
  10625            tempslopex[1] = CurveLineChosenC2;
   \   000001A2   0x.... 0x....      LDR.W    R0,??DataTable57_4
   \   000001A6   0x7800             LDRB     R0,[R0, #+0]
   \   000001A8   0xF88D 0x0009      STRB     R0,[SP, #+9]
  10626            tempslopex[2] = CurveLineChosenC3;
   \   000001AC   0x.... 0x....      LDR.W    R0,??DataTable57_5
   \   000001B0   0x7800             LDRB     R0,[R0, #+0]
   \   000001B2   0xF88D 0x000A      STRB     R0,[SP, #+10]
  10627            tempslopey[0] = CenterLineLoc[CurveLineChosenC1];
   \   000001B6   0x....             LDR.N    R0,??DataTable54_2
   \   000001B8   0x.... 0x....      LDR.W    R1,??DataTable57_3
   \   000001BC   0x7809             LDRB     R1,[R1, #+0]
   \   000001BE   0xF830 0x0011      LDRH     R0,[R0, R1, LSL #+1]
   \   000001C2   0xF8AD 0x000C      STRH     R0,[SP, #+12]
  10628            tempslopey[1] = CenterLineLoc[CurveLineChosenC2];
   \   000001C6   0x....             LDR.N    R0,??DataTable54_2
   \   000001C8   0x.... 0x....      LDR.W    R1,??DataTable57_4
   \   000001CC   0x7809             LDRB     R1,[R1, #+0]
   \   000001CE   0xF830 0x0011      LDRH     R0,[R0, R1, LSL #+1]
   \   000001D2   0xF8AD 0x000E      STRH     R0,[SP, #+14]
  10629            tempslopey[2] = CenterLineLoc[CurveLineChosenC3];
   \   000001D6   0x....             LDR.N    R0,??DataTable54_2
   \   000001D8   0x.... 0x....      LDR.W    R1,??DataTable57_5
   \   000001DC   0x7809             LDRB     R1,[R1, #+0]
   \   000001DE   0xF830 0x0011      LDRH     R0,[R0, R1, LSL #+1]
   \   000001E2   0xF8AD 0x0010      STRH     R0,[SP, #+16]
  10630            SlopeC = LeastSquareInt16a1(tempslopex, tempslopey, 3);  //已经乘以了LeastSquareMulti倍。
   \   000001E6   0x2203             MOVS     R2,#+3
   \   000001E8   0xA903             ADD      R1,SP,#+12
   \   000001EA   0xA802             ADD      R0,SP,#+8
   \   000001EC   0x.... 0x....      BL       LeastSquareInt16a1
   \   000001F0   0x.... 0x....      LDR.W    R1,??DataTable57_8
   \   000001F4   0x6008             STR      R0,[R1, #+0]
  10631            
  10632            return 1;
   \   000001F6   0x2001             MOVS     R0,#+1
   \                     ??CurveSlopeGetCenter_2: (+1)
   \   000001F8   0xB006             ADD      SP,SP,#+24
   \   000001FA   0xBD10             POP      {R4,PC}          ;; return
  10633            
  10634          }
  10635          
  10636          //左黑线的曲率和斜率求取

   \                                 In section .text, align 2, keep-with-next
  10637          uint8 CurveSlopeGetLeft(void)
  10638          {
   \                     CurveSlopeGetLeft: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
  10639            uint8 row;
  10640            uint8 temp;
  10641            uint8 tempslopex[3];
  10642            int16 tempslopey[3];
  10643            
  10644            //左右黑线有可能只有一边提取成功，若不成功，就不用费时间了。
  10645            if(BlackLeftDone == 1)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable57_9
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xF040 0x8108      BNE.W    ??CurveSlopeGetLeft_0
  10646            {
  10647              //2. 左黑线曲率符号求取
  10648              //曲率符号预先清零。
  10649              CurveLineChosenL1 = MaxValUint8;
   \   00000010   0x20FF             MOVS     R0,#+255
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable57_10
   \   00000016   0x7008             STRB     R0,[R1, #+0]
  10650              CurveLineChosenL2 = MaxValUint8;
   \   00000018   0x20FF             MOVS     R0,#+255
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable57_11
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
  10651              CurveLineChosenL3 = MaxValUint8;
   \   00000020   0x20FF             MOVS     R0,#+255
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable57_12
   \   00000026   0x7008             STRB     R0,[R1, #+0]
  10652              
  10653              //曲率基于的行1 CurveLineChosen1，即左线线头BlackLeftHeadLine.
  10654              if(BlackLeftHeadLine == MaxValUint8 || BlackLeftEndLine == MaxValUint8)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable57_13
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x28FF             CMP      R0,#+255
   \   00000030   0xD004             BEQ.N    ??CurveSlopeGetLeft_1
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable57_14
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x28FF             CMP      R0,#+255
   \   0000003A   0xD10B             BNE.N    ??CurveSlopeGetLeft_2
  10655              {
  10656                CURVEL = MaxValInt16;       //return 0之前，要把左黑线的曲率置无效值。
   \                     ??CurveSlopeGetLeft_1: (+1)
   \   0000003C   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable57_15
   \   00000044   0x8008             STRH     R0,[R1, #+0]
  10657                SlopeL = MaxValInt16;       //return 0之前，要把左黑线的斜率置无效值。
   \   00000046   0xF647 0x70FF      MOVW     R0,#+32767
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable57_16
   \   0000004E   0x6008             STR      R0,[R1, #+0]
  10658                return 0;      
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE0F0             B.N      ??CurveSlopeGetLeft_3
  10659              }
  10660              
  10661              if(BlackLeftHeadLine >= CameraHight - 2)
   \                     ??CurveSlopeGetLeft_2: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable57_13
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x283A             CMP      R0,#+58
   \   0000005C   0xDB0B             BLT.N    ??CurveSlopeGetLeft_4
  10662              {
  10663                CURVEL = MaxValInt16;       //return 0之前，要把左黑线的曲率置无效值。
   \   0000005E   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable57_15
   \   00000066   0x8008             STRH     R0,[R1, #+0]
  10664                SlopeL = MaxValInt16;       //return 0之前，要把左黑线的斜率置无效值。
   \   00000068   0xF647 0x70FF      MOVW     R0,#+32767
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable57_16
   \   00000070   0x6008             STR      R0,[R1, #+0]
  10665                return 0;      
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xE0DF             B.N      ??CurveSlopeGetLeft_3
  10666              }
  10667              else
  10668              {
  10669                CurveLineChosenL1 = BlackLeftHeadLine;
   \                     ??CurveSlopeGetLeft_4: (+1)
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable57_13
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable57_10
   \   00000080   0x7008             STRB     R0,[R1, #+0]
  10670              }
  10671          
  10672              //把第1个有效值到CameraHight-1的距离分成2段。
  10673              temp = (BlackLeftEndLine - 1 - BlackLeftHeadLine) / 2;
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable57_14
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0x1E40             SUBS     R0,R0,#+1
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable57_13
   \   0000008E   0x7809             LDRB     R1,[R1, #+0]
   \   00000090   0x1A40             SUBS     R0,R0,R1
   \   00000092   0x2102             MOVS     R1,#+2
   \   00000094   0xFB90 0xF1F1      SDIV     R1,R0,R1
  10674              //2 * 2 + 1 = 5, 即如果有效行只有3行以内的话，就放弃求取曲率和斜率。（因为会很不精确）
  10675              if(temp <= 2) 
   \   00000098   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009A   0x2903             CMP      R1,#+3
   \   0000009C   0xDA0F             BGE.N    ??CurveSlopeGetLeft_5
  10676              {
  10677                CurveLineChosenL1 = MaxValUint8;
   \   0000009E   0x20FF             MOVS     R0,#+255
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable57_10
   \   000000A4   0x7008             STRB     R0,[R1, #+0]
  10678                CURVEL = MaxValInt16;       //return 0之前，要把左黑线的曲率置无效值。
   \   000000A6   0xF647 0x70FF      MOVW     R0,#+32767
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable57_15
   \   000000AE   0x8008             STRH     R0,[R1, #+0]
  10679                SlopeL = MaxValInt16;       //return 0之前，要把左黑线的斜率置无效值。      
   \   000000B0   0xF647 0x70FF      MOVW     R0,#+32767
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable57_16
   \   000000B8   0x6008             STR      R0,[R1, #+0]
  10680                return 0;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xE0BB             B.N      ??CurveSlopeGetLeft_3
  10681              }
  10682              
  10683              //曲率基于的行2 CurveLineChosen2
  10684              for(row = CurveLineChosenL1 + temp - 1; ; row++)
   \                     ??CurveSlopeGetLeft_5: (+1)
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable57_10
   \   000000C2   0x7800             LDRB     R0,[R0, #+0]
   \   000000C4   0x1808             ADDS     R0,R1,R0
   \   000000C6   0x1E40             SUBS     R0,R0,#+1
  10685              {
  10686                if (row > BlackLeftEndLine - 1) 
   \   000000C8   0x.... 0x....      LDR.W    R2,??DataTable57_14
   \   000000CC   0x7812             LDRB     R2,[R2, #+0]
   \   000000CE   0x1E52             SUBS     R2,R2,#+1
   \   000000D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D2   0x4282             CMP      R2,R0
   \   000000D4   0xDA13             BGE.N    ??CurveSlopeGetLeft_6
  10687                {
  10688                  CurveLineChosenL1 = MaxValUint8;
   \   000000D6   0x20FF             MOVS     R0,#+255
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable57_10
   \   000000DC   0x7008             STRB     R0,[R1, #+0]
  10689                  CurveLineChosenL2 = MaxValUint8;
   \   000000DE   0x20FF             MOVS     R0,#+255
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable57_11
   \   000000E4   0x7008             STRB     R0,[R1, #+0]
  10690                  CURVEL = MaxValInt16;       //return 0之前，要把左黑线的曲率置无效值。
   \   000000E6   0xF647 0x70FF      MOVW     R0,#+32767
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable57_15
   \   000000EE   0x8008             STRH     R0,[R1, #+0]
  10691                  SlopeL = MaxValInt16;       //return 0之前，要把左黑线的斜率置无效值。     
   \   000000F0   0xF647 0x70FF      MOVW     R0,#+32767
   \   000000F4   0x.... 0x....      LDR.W    R1,??DataTable57_16
   \   000000F8   0x6008             STR      R0,[R1, #+0]
  10692                  return 0;
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0xE09B             B.N      ??CurveSlopeGetLeft_3
  10693                }
  10694                //不用判断是不是无效值。因为左黑线连续。
  10695                CurveLineChosenL2 = row;
   \                     ??CurveSlopeGetLeft_6: (+1)
   \   000000FE   0x.... 0x....      LDR.W    R2,??DataTable57_11
   \   00000102   0x7010             STRB     R0,[R2, #+0]
  10696                break;
  10697              }
  10698              
  10699              //曲率基于的行3 CurveLineChosen3
  10700              for(row = CurveLineChosenL2 + temp - 1; ; row++)
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable57_11
   \   00000108   0x7800             LDRB     R0,[R0, #+0]
   \   0000010A   0x1808             ADDS     R0,R1,R0
   \   0000010C   0x1E40             SUBS     R0,R0,#+1
  10701              {
  10702                if (row > BlackLeftEndLine) 
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable57_14
   \   00000112   0x7809             LDRB     R1,[R1, #+0]
   \   00000114   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000116   0x4281             CMP      R1,R0
   \   00000118   0xD217             BCS.N    ??CurveSlopeGetLeft_7
  10703                {
  10704                  CurveLineChosenL1 = MaxValUint8;
   \   0000011A   0x20FF             MOVS     R0,#+255
   \   0000011C   0x.... 0x....      LDR.W    R1,??DataTable57_10
   \   00000120   0x7008             STRB     R0,[R1, #+0]
  10705                  CurveLineChosenL2 = MaxValUint8;
   \   00000122   0x20FF             MOVS     R0,#+255
   \   00000124   0x.... 0x....      LDR.W    R1,??DataTable57_11
   \   00000128   0x7008             STRB     R0,[R1, #+0]
  10706                  CurveLineChosenL3 = MaxValUint8;
   \   0000012A   0x20FF             MOVS     R0,#+255
   \   0000012C   0x.... 0x....      LDR.W    R1,??DataTable57_12
   \   00000130   0x7008             STRB     R0,[R1, #+0]
  10707                  CURVEL = MaxValInt16;       //return 0之前，要把左黑线的曲率置无效值。
   \   00000132   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000136   0x.... 0x....      LDR.W    R1,??DataTable57_15
   \   0000013A   0x8008             STRH     R0,[R1, #+0]
  10708                  SlopeL = MaxValInt16;       //return 0之前，要把左黑线的斜率置无效值。        
   \   0000013C   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000140   0x.... 0x....      LDR.W    R1,??DataTable57_16
   \   00000144   0x6008             STR      R0,[R1, #+0]
  10709                  return 0;
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0xE075             B.N      ??CurveSlopeGetLeft_3
  10710                }
  10711                //不用判断是不是无效值。因为左黑线连续。
  10712                CurveLineChosenL3 = row;
   \                     ??CurveSlopeGetLeft_7: (+1)
   \   0000014A   0x.... 0x....      LDR.W    R1,??DataTable57_12
   \   0000014E   0x7008             STRB     R0,[R1, #+0]
  10713                break;
  10714              }
  10715              //SABCL左黑线曲率三角形面积的求取
  10716              //SABCL = SABCGet(BlackLeftLoc[CurveLineChosenL1,0], CameraHight - 1 - CurveLineChosenL1,
  10717              //               BlackLeftLoc[CurveLineChosenL2,0], CameraHight - 1 - CurveLineChosenL2,
  10718              //               BlackLeftLoc[CurveLineChosenL3,0], CameraHight - 1 - CurveLineChosenL3
  10719              //               );
  10720              
  10721          //    CURVEL = CurveGet(BlackUdisLeftLocation[CurveLineChosenL1].x, CameraHight - 1 - CurveLineChosenL1,
  10722          //                      BlackUdisLeftLocation[CurveLineChosenL2].x, CameraHight - 1 - CurveLineChosenL2,
  10723          //                      BlackUdisLeftLocation[CurveLineChosenL3].x, CameraHight - 1 - CurveLineChosenL3
  10724          //                      );
  10725              
  10726              CURVEL = CurveGet(BlackLeftLoc[CurveLineChosenL1][0], CameraHight - 1 - CurveLineChosenL1,
  10727                                BlackLeftLoc[CurveLineChosenL2][0], CameraHight - 1 - CurveLineChosenL2,
  10728                                BlackLeftLoc[CurveLineChosenL3][0], CameraHight - 1 - CurveLineChosenL3
  10729                                );
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable57_12
   \   00000154   0x7800             LDRB     R0,[R0, #+0]
   \   00000156   0xF1D0 0x003B      RSBS     R0,R0,#+59
   \   0000015A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015C   0x9001             STR      R0,[SP, #+4]
   \   0000015E   0x....             LDR.N    R0,??DataTable54_1
   \   00000160   0x.... 0x....      LDR.W    R1,??DataTable57_12
   \   00000164   0x7809             LDRB     R1,[R1, #+0]
   \   00000166   0x2203             MOVS     R2,#+3
   \   00000168   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000016C   0x7800             LDRB     R0,[R0, #+0]
   \   0000016E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000170   0x9000             STR      R0,[SP, #+0]
   \   00000172   0x.... 0x....      LDR.W    R0,??DataTable57_11
   \   00000176   0x7800             LDRB     R0,[R0, #+0]
   \   00000178   0xF1D0 0x033B      RSBS     R3,R0,#+59
   \   0000017C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000017E   0x....             LDR.N    R0,??DataTable54_1
   \   00000180   0x.... 0x....      LDR.W    R1,??DataTable57_11
   \   00000184   0x7809             LDRB     R1,[R1, #+0]
   \   00000186   0x2203             MOVS     R2,#+3
   \   00000188   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000018C   0x7802             LDRB     R2,[R0, #+0]
   \   0000018E   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   00000190   0x.... 0x....      LDR.W    R0,??DataTable57_10
   \   00000194   0x7800             LDRB     R0,[R0, #+0]
   \   00000196   0xF1D0 0x013B      RSBS     R1,R0,#+59
   \   0000019A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000019C   0x....             LDR.N    R0,??DataTable54_1
   \   0000019E   0x.... 0x....      LDR.W    R4,??DataTable57_10
   \   000001A2   0x7824             LDRB     R4,[R4, #+0]
   \   000001A4   0x2503             MOVS     R5,#+3
   \   000001A6   0xFB05 0x0004      MLA      R0,R5,R4,R0
   \   000001AA   0x7800             LDRB     R0,[R0, #+0]
   \   000001AC   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000001AE   0x.... 0x....      BL       CurveGet
   \   000001B2   0x.... 0x....      LDR.W    R1,??DataTable57_15
   \   000001B6   0x8008             STRH     R0,[R1, #+0]
  10730              //左黑线斜率求取，左上角为原点，向下X，向右Y。
  10731              tempslopex[0] = CurveLineChosenL1;
   \   000001B8   0x.... 0x....      LDR.W    R0,??DataTable57_10
   \   000001BC   0x7800             LDRB     R0,[R0, #+0]
   \   000001BE   0xF88D 0x0008      STRB     R0,[SP, #+8]
  10732              tempslopex[1] = CurveLineChosenL2;
   \   000001C2   0x.... 0x....      LDR.W    R0,??DataTable57_11
   \   000001C6   0x7800             LDRB     R0,[R0, #+0]
   \   000001C8   0xF88D 0x0009      STRB     R0,[SP, #+9]
  10733              tempslopex[2] = CurveLineChosenL3;
   \   000001CC   0x.... 0x....      LDR.W    R0,??DataTable57_12
   \   000001D0   0x7800             LDRB     R0,[R0, #+0]
   \   000001D2   0xF88D 0x000A      STRB     R0,[SP, #+10]
  10734              tempslopey[0] = BlackUdisLeftLocation[CurveLineChosenL1].x;
   \   000001D6   0x.... 0x....      LDR.W    R0,??DataTable57_17
   \   000001DA   0x.... 0x....      LDR.W    R1,??DataTable57_10
   \   000001DE   0x7809             LDRB     R1,[R1, #+0]
   \   000001E0   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   000001E4   0xF8AD 0x000C      STRH     R0,[SP, #+12]
  10735              tempslopey[1] = BlackUdisLeftLocation[CurveLineChosenL2].x;
   \   000001E8   0x.... 0x....      LDR.W    R0,??DataTable57_17
   \   000001EC   0x.... 0x....      LDR.W    R1,??DataTable57_11
   \   000001F0   0x7809             LDRB     R1,[R1, #+0]
   \   000001F2   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   000001F6   0xF8AD 0x000E      STRH     R0,[SP, #+14]
  10736              tempslopey[2] = BlackUdisLeftLocation[CurveLineChosenL3].x;
   \   000001FA   0x.... 0x....      LDR.W    R0,??DataTable57_17
   \   000001FE   0x.... 0x....      LDR.W    R1,??DataTable57_12
   \   00000202   0x7809             LDRB     R1,[R1, #+0]
   \   00000204   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000208   0xF8AD 0x0010      STRH     R0,[SP, #+16]
  10737              SlopeL = LeastSquareInt16a1(tempslopex, tempslopey, 3);   //已经乘以了LeastSquareMulti倍。
   \   0000020C   0x2203             MOVS     R2,#+3
   \   0000020E   0xA903             ADD      R1,SP,#+12
   \   00000210   0xA802             ADD      R0,SP,#+8
   \   00000212   0x.... 0x....      BL       LeastSquareInt16a1
   \   00000216   0x.... 0x....      LDR.W    R1,??DataTable57_16
   \   0000021A   0x6008             STR      R0,[R1, #+0]
  10738              
  10739              return 1;
   \   0000021C   0x2001             MOVS     R0,#+1
   \   0000021E   0xE00A             B.N      ??CurveSlopeGetLeft_3
  10740            }
  10741            //左黑线提取失败，直接返回失败。
  10742            else
  10743            {
  10744              CURVEL = MaxValInt16;       //return 0之前，要把左黑线的曲率置无效值。
   \                     ??CurveSlopeGetLeft_0: (+1)
   \   00000220   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000224   0x.... 0x....      LDR.W    R1,??DataTable57_15
   \   00000228   0x8008             STRH     R0,[R1, #+0]
  10745              SlopeL = MaxValInt16;       //return 0之前，要把左黑线的斜率置无效值。
   \   0000022A   0xF647 0x70FF      MOVW     R0,#+32767
   \   0000022E   0x.... 0x....      LDR.W    R1,??DataTable57_16
   \   00000232   0x6008             STR      R0,[R1, #+0]
  10746              return 0;
   \   00000234   0x2000             MOVS     R0,#+0
   \                     ??CurveSlopeGetLeft_3: (+1)
   \   00000236   0xB005             ADD      SP,SP,#+20
   \   00000238   0xBD30             POP      {R4,R5,PC}       ;; return
  10747            }
  10748          }
  10749          
  10750          
  10751          
  10752          //右黑线的曲率和斜率求取

   \                                 In section .text, align 2, keep-with-next
  10753          uint8 CurveSlopeGetRight(void)
  10754          {
   \                     CurveSlopeGetRight: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
  10755            uint8 row;
  10756            uint8 temp;
  10757            uint8 tempslopex[3];
  10758            int16 tempslopey[3];
  10759          
  10760            //左右黑线有可能只有一边提取成功，若不成功，就不用费时间了。
  10761            if(BlackRightDone == 1)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable57_18
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xF040 0x8104      BNE.W    ??CurveSlopeGetRight_0
  10762            {
  10763              //3. 右黑线曲率符号求取
  10764              //曲率符号预先清零。
  10765              CurveLineChosenR1 = MaxValUint8;
   \   00000010   0x20FF             MOVS     R0,#+255
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable57_19
   \   00000016   0x7008             STRB     R0,[R1, #+0]
  10766              CurveLineChosenR2 = MaxValUint8;
   \   00000018   0x20FF             MOVS     R0,#+255
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable57_20
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
  10767              CurveLineChosenR3 = MaxValUint8;
   \   00000020   0x20FF             MOVS     R0,#+255
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable57_21
   \   00000026   0x7008             STRB     R0,[R1, #+0]
  10768              
  10769              //曲率基于的行1 CurveLineChosen1，从上到下取第一个有效值。
  10770              if(BlackRightHeadLine == MaxValUint8 || BlackRightEndLine == MaxValUint8)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable57_22
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x28FF             CMP      R0,#+255
   \   00000030   0xD004             BEQ.N    ??CurveSlopeGetRight_1
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable57_23
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x28FF             CMP      R0,#+255
   \   0000003A   0xD10B             BNE.N    ??CurveSlopeGetRight_2
  10771              {
  10772                CURVER = MaxValInt16;      //return 0前先把右黑线的曲率置无效值。   
   \                     ??CurveSlopeGetRight_1: (+1)
   \   0000003C   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable58
   \   00000044   0x8008             STRH     R0,[R1, #+0]
  10773                SlopeR = MaxValInt16;      //return 0前先把右黑线的斜率置无效值。        
   \   00000046   0xF647 0x70FF      MOVW     R0,#+32767
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable58_1
   \   0000004E   0x6008             STR      R0,[R1, #+0]
  10774                return 0;      
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE0EC             B.N      ??CurveSlopeGetRight_3
  10775              }
  10776              if(BlackRightHeadLine  >= CameraHight - 2)
   \                     ??CurveSlopeGetRight_2: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable57_22
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x283A             CMP      R0,#+58
   \   0000005C   0xDB0B             BLT.N    ??CurveSlopeGetRight_4
  10777              {
  10778                CURVER = MaxValInt16;      //return 0前先把右黑线的曲率置无效值。   
   \   0000005E   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable58
   \   00000066   0x8008             STRH     R0,[R1, #+0]
  10779                SlopeR = MaxValInt16;      //return 0前先把右黑线的斜率置无效值。        
   \   00000068   0xF647 0x70FF      MOVW     R0,#+32767
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable58_1
   \   00000070   0x6008             STR      R0,[R1, #+0]
  10780                return 0;      
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xE0DB             B.N      ??CurveSlopeGetRight_3
  10781              }
  10782              else
  10783              {
  10784                CurveLineChosenR1 = BlackRightHeadLine;
   \                     ??CurveSlopeGetRight_4: (+1)
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable57_22
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable57_19
   \   00000080   0x7008             STRB     R0,[R1, #+0]
  10785              }
  10786          
  10787              //把第1个有效值到CameraHight-1的距离分成2段。
  10788              temp = (BlackRightEndLine - 1 - BlackRightHeadLine) / 2;
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable57_23
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0x1E40             SUBS     R0,R0,#+1
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable57_22
   \   0000008E   0x7809             LDRB     R1,[R1, #+0]
   \   00000090   0x1A40             SUBS     R0,R0,R1
   \   00000092   0x2102             MOVS     R1,#+2
   \   00000094   0xFB90 0xF1F1      SDIV     R1,R0,R1
  10789              //2 * 2 + 1 = 5, 即如果有效行只有3行以内的话，就放弃求取曲率和斜率。（因为会很不精确）
  10790              if(temp <= 2)
   \   00000098   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000009A   0x2903             CMP      R1,#+3
   \   0000009C   0xDA0F             BGE.N    ??CurveSlopeGetRight_5
  10791              {
  10792                CurveLineChosenR1 = MaxValUint8;
   \   0000009E   0x20FF             MOVS     R0,#+255
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable57_19
   \   000000A4   0x7008             STRB     R0,[R1, #+0]
  10793                CURVER = MaxValInt16;      //return 0前先把右黑线的曲率置无效值。   
   \   000000A6   0xF647 0x70FF      MOVW     R0,#+32767
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable58
   \   000000AE   0x8008             STRH     R0,[R1, #+0]
  10794                SlopeR = MaxValInt16;      //return 0前先把右黑线的斜率置无效值。      
   \   000000B0   0xF647 0x70FF      MOVW     R0,#+32767
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable58_1
   \   000000B8   0x6008             STR      R0,[R1, #+0]
  10795                return 0;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xE0B7             B.N      ??CurveSlopeGetRight_3
  10796              }
  10797              
  10798              //曲率基于的行2 CurveLineChosen2
  10799              for(row = CurveLineChosenR1 + temp - 1; ; row++)
   \                     ??CurveSlopeGetRight_5: (+1)
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable57_19
   \   000000C2   0x7800             LDRB     R0,[R0, #+0]
   \   000000C4   0x1808             ADDS     R0,R1,R0
   \   000000C6   0x1E40             SUBS     R0,R0,#+1
  10800              {
  10801                if (row > BlackRightEndLine - 1) 
   \   000000C8   0x.... 0x....      LDR.W    R2,??DataTable57_23
   \   000000CC   0x7812             LDRB     R2,[R2, #+0]
   \   000000CE   0x1E52             SUBS     R2,R2,#+1
   \   000000D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D2   0x4282             CMP      R2,R0
   \   000000D4   0xDA13             BGE.N    ??CurveSlopeGetRight_6
  10802                {
  10803                  CurveLineChosenR1 = MaxValUint8;
   \   000000D6   0x20FF             MOVS     R0,#+255
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable57_19
   \   000000DC   0x7008             STRB     R0,[R1, #+0]
  10804                  CurveLineChosenR2 = MaxValUint8;
   \   000000DE   0x20FF             MOVS     R0,#+255
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable57_20
   \   000000E4   0x7008             STRB     R0,[R1, #+0]
  10805                  CURVER = MaxValInt16;      //return 0前先把右黑线的曲率置无效值。   
   \   000000E6   0xF647 0x70FF      MOVW     R0,#+32767
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable58
   \   000000EE   0x8008             STRH     R0,[R1, #+0]
  10806                  SlopeR = MaxValInt16;      //return 0前先把右黑线的斜率置无效值。      
   \   000000F0   0xF647 0x70FF      MOVW     R0,#+32767
   \   000000F4   0x.... 0x....      LDR.W    R1,??DataTable58_1
   \   000000F8   0x6008             STR      R0,[R1, #+0]
  10807                  return 0;
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0xE097             B.N      ??CurveSlopeGetRight_3
  10808                }
  10809                //不用判断该行是不是无效值，因为右线连续。
  10810                CurveLineChosenR2 = row;
   \                     ??CurveSlopeGetRight_6: (+1)
   \   000000FE   0x.... 0x....      LDR.W    R2,??DataTable57_20
   \   00000102   0x7010             STRB     R0,[R2, #+0]
  10811                break;
  10812              }
  10813              
  10814              //曲率基于的行3 CurveLineChosen3
  10815              for(row = CurveLineChosenR2 + temp - 1; ; row++)
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable57_20
   \   00000108   0x7800             LDRB     R0,[R0, #+0]
   \   0000010A   0x1808             ADDS     R0,R1,R0
   \   0000010C   0x1E40             SUBS     R0,R0,#+1
  10816              {
  10817                if (row > BlackRightEndLine) 
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable57_23
   \   00000112   0x7809             LDRB     R1,[R1, #+0]
   \   00000114   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000116   0x4281             CMP      R1,R0
   \   00000118   0xD217             BCS.N    ??CurveSlopeGetRight_7
  10818                {
  10819                  CurveLineChosenR1 = MaxValUint8;
   \   0000011A   0x20FF             MOVS     R0,#+255
   \   0000011C   0x.... 0x....      LDR.W    R1,??DataTable57_19
   \   00000120   0x7008             STRB     R0,[R1, #+0]
  10820                  CurveLineChosenR2 = MaxValUint8;
   \   00000122   0x20FF             MOVS     R0,#+255
   \   00000124   0x.... 0x....      LDR.W    R1,??DataTable57_20
   \   00000128   0x7008             STRB     R0,[R1, #+0]
  10821                  CurveLineChosenR3 = MaxValUint8;
   \   0000012A   0x20FF             MOVS     R0,#+255
   \   0000012C   0x.... 0x....      LDR.W    R1,??DataTable57_21
   \   00000130   0x7008             STRB     R0,[R1, #+0]
  10822                  CURVER = MaxValInt16;      //return 0前先把右黑线的曲率置无效值。   
   \   00000132   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000136   0x.... 0x....      LDR.W    R1,??DataTable58
   \   0000013A   0x8008             STRH     R0,[R1, #+0]
  10823                  SlopeR = MaxValInt16;      //return 0前先把右黑线的斜率置无效值。        
   \   0000013C   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000140   0x.... 0x....      LDR.W    R1,??DataTable58_1
   \   00000144   0x6008             STR      R0,[R1, #+0]
  10824                  return 0;
   \   00000146   0x2000             MOVS     R0,#+0
   \   00000148   0xE071             B.N      ??CurveSlopeGetRight_3
  10825                }
  10826                //不用判断该行是不是无效值，因为右线连续。
  10827                CurveLineChosenR3 = row;
   \                     ??CurveSlopeGetRight_7: (+1)
   \   0000014A   0x.... 0x....      LDR.W    R1,??DataTable57_21
   \   0000014E   0x7008             STRB     R0,[R1, #+0]
  10828                break;
  10829              }   
  10830              //SABCR右黑线曲率三角形面积的求取
  10831              //SABCR = SABCGet(BlackRightLoc[CurveLineChosenR1,0], CameraHight - 1 - CurveLineChosenR1, 
  10832              //                BlackRightLoc[CurveLineChosenR2,0], CameraHight - 1 - CurveLineChosenR2, 
  10833              //                BlackRightLoc[CurveLineChosenR3,0], CameraHight - 1 - CurveLineChosenR3
  10834              //                );
  10835              
  10836          //    CURVER = CurveGet(BlackUdisRightLocation[CurveLineChosenR1].x, CameraHight - 1 - CurveLineChosenR1,
  10837          //                      BlackUdisRightLocation[CurveLineChosenR2].x, CameraHight - 1 - CurveLineChosenR2,
  10838          //                      BlackUdisRightLocation[CurveLineChosenR3].x, CameraHight - 1 - CurveLineChosenR3
  10839          //                      );
  10840              
  10841              CURVER = CurveGet(BlackRightLoc[CurveLineChosenR1][0], CameraHight - 1 - CurveLineChosenR1,
  10842                                BlackRightLoc[CurveLineChosenR2][0], CameraHight - 1 - CurveLineChosenR2,
  10843                                BlackRightLoc[CurveLineChosenR3][0], CameraHight - 1 - CurveLineChosenR3
  10844                                );
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable57_21
   \   00000154   0x7800             LDRB     R0,[R0, #+0]
   \   00000156   0xF1D0 0x003B      RSBS     R0,R0,#+59
   \   0000015A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015C   0x9001             STR      R0,[SP, #+4]
   \   0000015E   0x....             LDR.N    R0,??DataTable56_2
   \   00000160   0x.... 0x....      LDR.W    R1,??DataTable57_21
   \   00000164   0x7809             LDRB     R1,[R1, #+0]
   \   00000166   0x2203             MOVS     R2,#+3
   \   00000168   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000016C   0x7800             LDRB     R0,[R0, #+0]
   \   0000016E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000170   0x9000             STR      R0,[SP, #+0]
   \   00000172   0x.... 0x....      LDR.W    R0,??DataTable57_20
   \   00000176   0x7800             LDRB     R0,[R0, #+0]
   \   00000178   0xF1D0 0x033B      RSBS     R3,R0,#+59
   \   0000017C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000017E   0x....             LDR.N    R0,??DataTable56_2
   \   00000180   0x.... 0x....      LDR.W    R1,??DataTable57_20
   \   00000184   0x7809             LDRB     R1,[R1, #+0]
   \   00000186   0x2203             MOVS     R2,#+3
   \   00000188   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000018C   0x7802             LDRB     R2,[R0, #+0]
   \   0000018E   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   00000190   0x.... 0x....      LDR.W    R0,??DataTable57_19
   \   00000194   0x7800             LDRB     R0,[R0, #+0]
   \   00000196   0xF1D0 0x013B      RSBS     R1,R0,#+59
   \   0000019A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000019C   0x....             LDR.N    R0,??DataTable56_2
   \   0000019E   0x.... 0x....      LDR.W    R4,??DataTable57_19
   \   000001A2   0x7824             LDRB     R4,[R4, #+0]
   \   000001A4   0x2503             MOVS     R5,#+3
   \   000001A6   0xFB05 0x0004      MLA      R0,R5,R4,R0
   \   000001AA   0x7800             LDRB     R0,[R0, #+0]
   \   000001AC   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000001AE   0x.... 0x....      BL       CurveGet
   \   000001B2   0x.... 0x....      LDR.W    R1,??DataTable58
   \   000001B6   0x8008             STRH     R0,[R1, #+0]
  10845              
  10846              //右黑线斜率求取，左上角为原点，向下X，向右Y。
  10847              tempslopex[0] = CurveLineChosenR1;
   \   000001B8   0x.... 0x....      LDR.W    R0,??DataTable57_19
   \   000001BC   0x7800             LDRB     R0,[R0, #+0]
   \   000001BE   0xF88D 0x0008      STRB     R0,[SP, #+8]
  10848              tempslopex[1] = CurveLineChosenR2;
   \   000001C2   0x.... 0x....      LDR.W    R0,??DataTable57_20
   \   000001C6   0x7800             LDRB     R0,[R0, #+0]
   \   000001C8   0xF88D 0x0009      STRB     R0,[SP, #+9]
  10849              tempslopex[2] = CurveLineChosenR3;
   \   000001CC   0x....             LDR.N    R0,??DataTable57_21
   \   000001CE   0x7800             LDRB     R0,[R0, #+0]
   \   000001D0   0xF88D 0x000A      STRB     R0,[SP, #+10]
  10850              tempslopey[0] = BlackUdisRightLocation[CurveLineChosenR1].x;
   \   000001D4   0x.... 0x....      LDR.W    R0,??DataTable58_2
   \   000001D8   0x....             LDR.N    R1,??DataTable57_19
   \   000001DA   0x7809             LDRB     R1,[R1, #+0]
   \   000001DC   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   000001E0   0xF8AD 0x000C      STRH     R0,[SP, #+12]
  10851              tempslopey[1] = BlackUdisRightLocation[CurveLineChosenR2].x;
   \   000001E4   0x.... 0x....      LDR.W    R0,??DataTable58_2
   \   000001E8   0x....             LDR.N    R1,??DataTable57_20
   \   000001EA   0x7809             LDRB     R1,[R1, #+0]
   \   000001EC   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   000001F0   0xF8AD 0x000E      STRH     R0,[SP, #+14]
  10852              tempslopey[2] = BlackUdisRightLocation[CurveLineChosenR3].x;
   \   000001F4   0x.... 0x....      LDR.W    R0,??DataTable58_2
   \   000001F8   0x....             LDR.N    R1,??DataTable57_21
   \   000001FA   0x7809             LDRB     R1,[R1, #+0]
   \   000001FC   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000200   0xF8AD 0x0010      STRH     R0,[SP, #+16]
  10853              SlopeR = LeastSquareInt16a1(tempslopex, tempslopey, 3);         //已经乘以了LeastSquareMulti倍。
   \   00000204   0x2203             MOVS     R2,#+3
   \   00000206   0xA903             ADD      R1,SP,#+12
   \   00000208   0xA802             ADD      R0,SP,#+8
   \   0000020A   0x.... 0x....      BL       LeastSquareInt16a1
   \   0000020E   0x.... 0x....      LDR.W    R1,??DataTable58_1
   \   00000212   0x6008             STR      R0,[R1, #+0]
  10854              
  10855              return 1;
   \   00000214   0x2001             MOVS     R0,#+1
   \   00000216   0xE00A             B.N      ??CurveSlopeGetRight_3
  10856            }
  10857            //右黑线提取失败，直接返回失败。
  10858            else
  10859            {
  10860              CURVER = MaxValInt16;      //return 0前先把右黑线的曲率置无效值。   
   \                     ??CurveSlopeGetRight_0: (+1)
   \   00000218   0xF647 0x70FF      MOVW     R0,#+32767
   \   0000021C   0x.... 0x....      LDR.W    R1,??DataTable58
   \   00000220   0x8008             STRH     R0,[R1, #+0]
  10861              SlopeR = MaxValInt16;      //return 0前先把右黑线的斜率置无效值。
   \   00000222   0xF647 0x70FF      MOVW     R0,#+32767
   \   00000226   0x.... 0x....      LDR.W    R1,??DataTable58_1
   \   0000022A   0x6008             STR      R0,[R1, #+0]
  10862              return 0;
   \   0000022C   0x2000             MOVS     R0,#+0
   \                     ??CurveSlopeGetRight_3: (+1)
   \   0000022E   0xB005             ADD      SP,SP,#+20
   \   00000230   0xBD30             POP      {R4,R5,PC}       ;; return
  10863            }
  10864            
  10865          }
  10866          
  10867          
  10868          
  10869          
  10870          
  10871          //曲率符号求取
  10872          //影响：CurveSL, CurveSC, CurveSR, 0无效，1正，2负
  10873          //      SABCL, SABCC, SABCR

   \                                 In section .text, align 2, keep-with-next
  10874          uint8 CurveSlopeGet(void)
  10875          {
   \                     CurveSlopeGet: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10876            //左、右黑线的斜曲率求取在BlackGet函数中已经进行过了，相应标志位也已经更新。
  10877            //曲率、斜率求取的标志位，1成功，0失败。默认置为成功。
  10878            CurveSlopeFlagC = 1;  
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable58_3
   \   00000008   0x7008             STRB     R0,[R1, #+0]
  10879            
  10880            //中心线的曲率、斜率的求取。
  10881            if(CurveSlopeGetCenter() == 0)
   \   0000000A   0x.... 0x....      BL       CurveSlopeGetCenter
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD103             BNE.N    ??CurveSlopeGet_0
  10882            {
  10883              CurveSlopeFlagC = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable58_3
   \   00000018   0x7008             STRB     R0,[R1, #+0]
  10884              //uart_sendN(UART0, (uint8 *)"\nCurveSlopeGetCenter() Failed!", 30);
  10885            }  
  10886            
  10887            //只有当3条线的曲率、斜率求取均失败的时候，才返回0，意在提醒后面的赛道类型不用判断了。
  10888            if(CurveSlopeFlagL == 0 && CurveSlopeFlagC == 0 && CurveSlopeFlagR == 0)
   \                     ??CurveSlopeGet_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable58_4
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD10B             BNE.N    ??CurveSlopeGet_1
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable58_3
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD106             BNE.N    ??CurveSlopeGet_1
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable58_5
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD101             BNE.N    ??CurveSlopeGet_1
  10889            {
  10890              return 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE000             B.N      ??CurveSlopeGet_2
  10891            }
  10892            else
  10893            {
  10894              return 1;
   \                     ??CurveSlopeGet_1: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
   \                     ??CurveSlopeGet_2: (+1)
   \   0000003E   0xBD02             POP      {R1,PC}          ;; return
  10895            }
  10896            
  10897          }
  10898          
  10899          
  10900          //直角线头差判断第6步，非障碍确认。
  10901          //其实是效仿障碍判断中的非障碍边确认。
  10902          //输入：dir 0表示非左障碍确认，1表示非右障碍确认
  10903          //返回：1成功 0失败

   \                                 In section .text, align 2, keep-with-next
  10904          uint8 AngleStep1JudgeNotBrick(uint8 dir)
  10905          {
   \                     AngleStep1JudgeNotBrick: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
  10906            uint8 row;
  10907            uint8 col;
  10908            uint8 count3;
  10909              
  10910            int32 a0, a1;
  10911            uint8 i, index, tempend;
  10912            
  10913            uint8 x[BrickSlopeRowNum];   //取多少个点在一开始有定义。
  10914            uint8 y[BrickSlopeRowNum];
  10915            
  10916            uint8 tempheadrow;
  10917            
  10918            //非左障碍确认
  10919            if(dir == 0)
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xF040 0x8097      BNE.W    ??AngleStep1JudgeNotBrick_0
  10920            {
  10921              //2. 1 非障碍边最小二乘法
  10922              index = 0;    
   \   0000000C   0x2000             MOVS     R0,#+0
  10923              for(i = BrickEndRow + 1; ; i++)
   \   0000000E   0x2124             MOVS     R1,#+36
   \   00000010   0xE000             B.N      ??AngleStep1JudgeNotBrick_1
   \                     ??AngleStep1JudgeNotBrick_2: (+1)
   \   00000012   0x1C49             ADDS     R1,R1,#+1
  10924              {
  10925                if(BlackLeftLoc[i][0] != MaxValUint8)
   \                     ??AngleStep1JudgeNotBrick_1: (+1)
   \   00000014   0x.... 0x....      LDR.W    R2,??DataTable58_6
   \   00000018   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001A   0x2303             MOVS     R3,#+3
   \   0000001C   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000020   0x7812             LDRB     R2,[R2, #+0]
   \   00000022   0x2AFF             CMP      R2,#+255
   \   00000024   0xD00D             BEQ.N    ??AngleStep1JudgeNotBrick_3
  10926                {
  10927                  y[index] = BlackLeftLoc[i][0];
   \   00000026   0x.... 0x....      LDR.W    R2,??DataTable58_6
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x2303             MOVS     R3,#+3
   \   0000002E   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000032   0x7812             LDRB     R2,[R2, #+0]
   \   00000034   0xAB00             ADD      R3,SP,#+0
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x54C2             STRB     R2,[R0, R3]
  10928                  x[index] = i;
   \   0000003A   0xAA02             ADD      R2,SP,#+8
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0x5481             STRB     R1,[R0, R2]
  10929                  index++;
   \   00000040   0x1C40             ADDS     R0,R0,#+1
  10930                }
  10931                if(index == BrickSlopeRowNum)
   \                     ??AngleStep1JudgeNotBrick_3: (+1)
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x2808             CMP      R0,#+8
   \   00000046   0xD10D             BNE.N    ??AngleStep1JudgeNotBrick_4
  10932                {
  10933                  break;  
  10934                }
  10935                if(i == CameraHight - 1)
  10936                {
  10937                  return 0;
  10938                }
  10939              }
  10940              
  10941              //最小二乘法
  10942              //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
  10943              a1 = LeastSquarea1(x, y, BrickSlopeRowNum);
   \   00000048   0x2208             MOVS     R2,#+8
   \   0000004A   0xA900             ADD      R1,SP,#+0
   \   0000004C   0xA802             ADD      R0,SP,#+8
   \   0000004E   0x.... 0x....      BL       LeastSquarea1
   \   00000052   0x0004             MOVS     R4,R0
  10944              //左边，斜率应该是-PathJudgeStraightSlopeLimit~0,否则斜率不对，返回失败。
  10945              if(a1 < 0 && a1 + PathJudgeStraightSlopeLimit > 0)
   \   00000054   0x2C00             CMP      R4,#+0
   \   00000056   0xD503             BPL.N    ??AngleStep1JudgeNotBrick_5
   \   00000058   0xF604 0x0034      ADDW     R0,R4,#+2100
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xDA06             BGE.N    ??AngleStep1JudgeNotBrick_6
  10946              {
  10947              }
  10948              else
  10949              {
  10950                return 0;
   \                     ??AngleStep1JudgeNotBrick_5: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE105             B.N      ??AngleStep1JudgeNotBrick_7
  10951              }
   \                     ??AngleStep1JudgeNotBrick_4: (+1)
   \   00000064   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000066   0x293B             CMP      R1,#+59
   \   00000068   0xD1D3             BNE.N    ??AngleStep1JudgeNotBrick_2
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE100             B.N      ??AngleStep1JudgeNotBrick_7
  10952              a0 = LeastSquarea0(x, y, a1, BrickSlopeRowNum);
   \                     ??AngleStep1JudgeNotBrick_6: (+1)
   \   0000006E   0x2308             MOVS     R3,#+8
   \   00000070   0x0022             MOVS     R2,R4
   \   00000072   0xA900             ADD      R1,SP,#+0
   \   00000074   0xA802             ADD      R0,SP,#+8
   \   00000076   0x.... 0x....      BL       LeastSquarea0
   \   0000007A   0x0005             MOVS     R5,R0
  10953              //直角梯形的两个突出顶点所在列
  10954              //起始行（近行）黑点所在列。
  10955              AngleStep1NotBrickEndColL = (a0 + a1 * BrickEndRow) / LeastSquareMulti + BrickColCom;
   \   0000007C   0x2023             MOVS     R0,#+35
   \   0000007E   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   00000082   0xF44F 0x717A      MOV      R1,#+1000
   \   00000086   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000008A   0x1D40             ADDS     R0,R0,#+5
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable58_7
   \   00000090   0x7008             STRB     R0,[R1, #+0]
  10956              //直角梯形的直角边所在列。
  10957              //不能比该行有效右黑线还大。    
  10958              if(BlackRightLoc[BrickEndRow][0] != MaxValUint8)
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable58_8
   \   00000096   0xF890 0x0069      LDRB     R0,[R0, #+105]
   \   0000009A   0x28FF             CMP      R0,#+255
   \   0000009C   0xD00C             BEQ.N    ??AngleStep1JudgeNotBrick_8
  10959              {
  10960                AngleStep1NotBrickBorderColL = MinRe(AngleStep1NotBrickEndColL + BrickScanColNum, BlackRightLoc[BrickEndRow][0]); //这里与非障碍边不同，非障碍是BrickScanColNum / 2，这里为了保险，取BrickScanColNum。
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable58_8
   \   000000A2   0xF890 0x1069      LDRB     R1,[R0, #+105]
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable58_7
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0x303C             ADDS     R0,R0,#+60
   \   000000AE   0x.... 0x....      BL       MinRe
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable58_9
   \   000000B6   0x7008             STRB     R0,[R1, #+0]
  10961              }
  10962              else
  10963              {
  10964              }
  10965          
  10966              //2.2 非障碍边，开始扫描，找到黑点过多的行，则右障碍确认失败。
  10967              //为了防止检测过头，检测的最远行需要跟左线头挂勾。
  10968              //不能比BrickEndRow更近。
  10969              tempheadrow = MinRe(BrickEndRow, BlackLeftHeadLine);
   \                     ??AngleStep1JudgeNotBrick_8: (+1)
   \   000000B8   0x....             LDR.N    R0,??DataTable57_13
   \   000000BA   0x7801             LDRB     R1,[R0, #+0]
   \   000000BC   0x2023             MOVS     R0,#+35
   \   000000BE   0x.... 0x....      BL       MinRe
   \   000000C2   0x0006             MOVS     R6,R0
  10970              //不能比BrickHeadRow更远。
  10971              tempheadrow = MaxRe(BrickHeadRow, tempheadrow);    
   \   000000C4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000C6   0x0031             MOVS     R1,R6
   \   000000C8   0x200F             MOVS     R0,#+15
   \   000000CA   0x.... 0x....      BL       MaxRe
   \   000000CE   0x0006             MOVS     R6,R0
  10972              for(row = tempheadrow; ; row++)
   \   000000D0   0xE000             B.N      ??AngleStep1JudgeNotBrick_9
   \                     ??AngleStep1JudgeNotBrick_10: (+1)
   \   000000D2   0x1C76             ADDS     R6,R6,#+1
  10973              {
  10974                //对某一行的处理。
  10975                //该行黑点计数
  10976                count3 = 0;
   \                     ??AngleStep1JudgeNotBrick_9: (+1)
   \   000000D4   0x2700             MOVS     R7,#+0
  10977                //从右往左扫描。
  10978                tempend = (a0 + a1 * row) / LeastSquareMulti + BrickColCom;   //记得除以增加的倍数
   \   000000D6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D8   0xFB06 0x5004      MLA      R0,R6,R4,R5
   \   000000DC   0xF44F 0x717A      MOV      R1,#+1000
   \   000000E0   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000E4   0x1D40             ADDS     R0,R0,#+5
  10979                //限幅。
  10980                tempend = MinRe(tempend, AngleStep1NotBrickBorderColL);
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable58_9
   \   000000EA   0x7809             LDRB     R1,[R1, #+0]
   \   000000EC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EE   0x.... 0x....      BL       MinRe
  10981                //黑点扫描。
  10982                for(col = AngleStep1NotBrickBorderColL; ; col--)
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable58_9
   \   000000F6   0x7809             LDRB     R1,[R1, #+0]
   \   000000F8   0xE000             B.N      ??AngleStep1JudgeNotBrick_11
   \                     ??AngleStep1JudgeNotBrick_12: (+1)
   \   000000FA   0x1E49             SUBS     R1,R1,#+1
  10983                {
  10984                  if(ImgNew[row][col] < LimitLeftB)  //够黑
   \                     ??AngleStep1JudgeNotBrick_11: (+1)
   \   000000FC   0x.... 0x....      LDR.W    R2,??DataTable58_10
   \   00000100   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000102   0x23FA             MOVS     R3,#+250
   \   00000104   0xFB03 0x2206      MLA      R2,R3,R6,R2
   \   00000108   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000010A   0x5C8A             LDRB     R2,[R1, R2]
   \   0000010C   0x.... 0x....      LDR.W    R3,??DataTable58_11
   \   00000110   0x781B             LDRB     R3,[R3, #+0]
   \   00000112   0x429A             CMP      R2,R3
   \   00000114   0xD200             BCS.N    ??AngleStep1JudgeNotBrick_13
  10985                  {
  10986                    count3++;
   \   00000116   0x1C7F             ADDS     R7,R7,#+1
  10987                  }
  10988                  else
  10989                  {
  10990                  }
  10991                  //向左扫描至边界
  10992                  if(col <= tempend || col == 0) break;
   \                     ??AngleStep1JudgeNotBrick_13: (+1)
   \   00000118   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000011C   0x4288             CMP      R0,R1
   \   0000011E   0xD202             BCS.N    ??AngleStep1JudgeNotBrick_14
   \   00000120   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000122   0x2900             CMP      R1,#+0
   \   00000124   0xD1E9             BNE.N    ??AngleStep1JudgeNotBrick_12
  10993                }
  10994                //该行黑点个数大于BrickLineBlackCountNum个时，则行计数加1.
  10995                if(count3 > BrickLineBlackCountNum) 
   \                     ??AngleStep1JudgeNotBrick_14: (+1)
   \   00000126   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000128   0x2F15             CMP      R7,#+21
   \   0000012A   0xDB01             BLT.N    ??AngleStep1JudgeNotBrick_15
  10996                {
  10997                  //存在有行黑点过多，则直接返回失败
  10998                  return 0;
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0xE09F             B.N      ??AngleStep1JudgeNotBrick_7
  10999                }
  11000                else
  11001                {
  11002                }
  11003                
  11004                if(row == BrickEndRow) break;
   \                     ??AngleStep1JudgeNotBrick_15: (+1)
   \   00000130   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000132   0x2E23             CMP      R6,#+35
   \   00000134   0xD1CD             BNE.N    ??AngleStep1JudgeNotBrick_10
  11005              }
  11006              
  11007              //3. 最终确认，返回成功。
  11008              return 1;
   \   00000136   0x2001             MOVS     R0,#+1
   \   00000138   0xE09A             B.N      ??AngleStep1JudgeNotBrick_7
  11009                 
  11010            }
  11011            //非右障碍确认
  11012            else if(dir == 1)
   \                     ??AngleStep1JudgeNotBrick_0: (+1)
   \   0000013A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013C   0x2801             CMP      R0,#+1
   \   0000013E   0xF040 0x8096      BNE.W    ??AngleStep1JudgeNotBrick_16
  11013            {
  11014              //1. 最小二乘法
  11015              index = 0;    
   \   00000142   0x2000             MOVS     R0,#+0
  11016              for(i = BrickEndRow + 1; ; i++)
   \   00000144   0x2124             MOVS     R1,#+36
   \   00000146   0xE000             B.N      ??AngleStep1JudgeNotBrick_17
   \                     ??AngleStep1JudgeNotBrick_18: (+1)
   \   00000148   0x1C49             ADDS     R1,R1,#+1
  11017              {
  11018                if(BlackRightLoc[i][0] != MaxValUint8)
   \                     ??AngleStep1JudgeNotBrick_17: (+1)
   \   0000014A   0x.... 0x....      LDR.W    R2,??DataTable58_8
   \   0000014E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000150   0x2303             MOVS     R3,#+3
   \   00000152   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000156   0x7812             LDRB     R2,[R2, #+0]
   \   00000158   0x2AFF             CMP      R2,#+255
   \   0000015A   0xD00D             BEQ.N    ??AngleStep1JudgeNotBrick_19
  11019                {
  11020                  y[index] = BlackRightLoc[i][0];
   \   0000015C   0x.... 0x....      LDR.W    R2,??DataTable58_8
   \   00000160   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000162   0x2303             MOVS     R3,#+3
   \   00000164   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000168   0x7812             LDRB     R2,[R2, #+0]
   \   0000016A   0xAB00             ADD      R3,SP,#+0
   \   0000016C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000016E   0x54C2             STRB     R2,[R0, R3]
  11021                  x[index] = i;
   \   00000170   0xAA02             ADD      R2,SP,#+8
   \   00000172   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000174   0x5481             STRB     R1,[R0, R2]
  11022                  index++;
   \   00000176   0x1C40             ADDS     R0,R0,#+1
  11023                }
  11024                if(index == BrickSlopeRowNum)
   \                     ??AngleStep1JudgeNotBrick_19: (+1)
   \   00000178   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000017A   0x2808             CMP      R0,#+8
   \   0000017C   0xD10C             BNE.N    ??AngleStep1JudgeNotBrick_20
  11025                {
  11026                  break;  
  11027                }
  11028                if(i == CameraHight - 1)
  11029                {
  11030                  return 0;
  11031                }
  11032              }
  11033              
  11034              //最小二乘法
  11035              //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
  11036              a1 = LeastSquarea1(x, y, BrickSlopeRowNum);
   \   0000017E   0x2208             MOVS     R2,#+8
   \   00000180   0xA900             ADD      R1,SP,#+0
   \   00000182   0xA802             ADD      R0,SP,#+8
   \   00000184   0x.... 0x....      BL       LeastSquarea1
   \   00000188   0x0004             MOVS     R4,R0
  11037              //右边，斜率应该是0~PathJudgeStraightSlopeLimit,否则斜率不对，返回失败。
  11038              if(a1 > 0 && a1 < PathJudgeStraightSlopeLimit)
   \   0000018A   0x1E60             SUBS     R0,R4,#+1
   \   0000018C   0xF640 0x0133      MOVW     R1,#+2099
   \   00000190   0x4288             CMP      R0,R1
   \   00000192   0xD306             BCC.N    ??AngleStep1JudgeNotBrick_21
  11039              {
  11040              }
  11041              else
  11042              {
  11043                return 0;
   \   00000194   0x2000             MOVS     R0,#+0
   \   00000196   0xE06B             B.N      ??AngleStep1JudgeNotBrick_7
  11044              }
   \                     ??AngleStep1JudgeNotBrick_20: (+1)
   \   00000198   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000019A   0x293B             CMP      R1,#+59
   \   0000019C   0xD1D4             BNE.N    ??AngleStep1JudgeNotBrick_18
   \   0000019E   0x2000             MOVS     R0,#+0
   \   000001A0   0xE066             B.N      ??AngleStep1JudgeNotBrick_7
  11045              a0 = LeastSquarea0(x, y, a1, BrickSlopeRowNum);
   \                     ??AngleStep1JudgeNotBrick_21: (+1)
   \   000001A2   0x2308             MOVS     R3,#+8
   \   000001A4   0x0022             MOVS     R2,R4
   \   000001A6   0xA900             ADD      R1,SP,#+0
   \   000001A8   0xA802             ADD      R0,SP,#+8
   \   000001AA   0x.... 0x....      BL       LeastSquarea0
   \   000001AE   0x0005             MOVS     R5,R0
  11046              //直角梯形的两个突出顶点所在列
  11047              //起始行（近行）黑点所在列。
  11048              AngleStep1NotBrickEndColR = (a0 + a1 * BrickEndRow) / LeastSquareMulti - BrickColCom;   //变量有改，不会重叠。
   \   000001B0   0x2023             MOVS     R0,#+35
   \   000001B2   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   000001B6   0xF44F 0x717A      MOV      R1,#+1000
   \   000001BA   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000001BE   0x1F40             SUBS     R0,R0,#+5
   \   000001C0   0x.... 0x....      LDR.W    R1,??DataTable58_12
   \   000001C4   0x7008             STRB     R0,[R1, #+0]
  11049              //直角梯形的直角边所在列。不能比当前行的有效左黑线还要小。
  11050              if(BlackLeftLoc[BrickEndRow][0] != MaxValUint8)
   \   000001C6   0x.... 0x....      LDR.W    R0,??DataTable58_6
   \   000001CA   0xF890 0x0069      LDRB     R0,[R0, #+105]
   \   000001CE   0x28FF             CMP      R0,#+255
   \   000001D0   0xD00C             BEQ.N    ??AngleStep1JudgeNotBrick_22
  11051              {
  11052                AngleStep1NotBrickBorderColR = MaxRe(AngleStep1NotBrickEndColR - BrickScanColNum, BlackLeftLoc[BrickEndRow][0]);  //这里与非障碍边不同，非障碍是BrickScanColNum / 2，这里为了保险，取BrickScanColNum。
   \   000001D2   0x.... 0x....      LDR.W    R0,??DataTable58_6
   \   000001D6   0xF890 0x1069      LDRB     R1,[R0, #+105]
   \   000001DA   0x.... 0x....      LDR.W    R0,??DataTable58_12
   \   000001DE   0x7800             LDRB     R0,[R0, #+0]
   \   000001E0   0x383C             SUBS     R0,R0,#+60
   \   000001E2   0x.... 0x....      BL       MaxRe
   \   000001E6   0x.... 0x....      LDR.W    R1,??DataTable58_13
   \   000001EA   0x7008             STRB     R0,[R1, #+0]
  11053              }
  11054              else
  11055              {
  11056              }
  11057              
  11058              //2.2 非障碍边，开始扫描，找到黑点过多的行，则左障碍确认失败。进行右障碍扫描。
  11059              //为了防止检测过头，检测的最远行需要跟右线头挂勾。
  11060              //不能比BrickEndRow更近。
  11061              tempheadrow = MinRe(BrickEndRow, BlackRightHeadLine);
   \                     ??AngleStep1JudgeNotBrick_22: (+1)
   \   000001EC   0x....             LDR.N    R0,??DataTable57_22
   \   000001EE   0x7801             LDRB     R1,[R0, #+0]
   \   000001F0   0x2023             MOVS     R0,#+35
   \   000001F2   0x.... 0x....      BL       MinRe
   \   000001F6   0x0006             MOVS     R6,R0
  11062              //不能比BrickHeadRow更远。
  11063              tempheadrow = MaxRe(BrickHeadRow, tempheadrow);    
   \   000001F8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001FA   0x0031             MOVS     R1,R6
   \   000001FC   0x200F             MOVS     R0,#+15
   \   000001FE   0x.... 0x....      BL       MaxRe
   \   00000202   0x0006             MOVS     R6,R0
  11064              for(row = tempheadrow; ; row++)
   \   00000204   0xE000             B.N      ??AngleStep1JudgeNotBrick_23
   \                     ??AngleStep1JudgeNotBrick_24: (+1)
   \   00000206   0x1C76             ADDS     R6,R6,#+1
  11065              {
  11066                //对某一行的处理。
  11067                //该行黑点计数，从左往右扫描。
  11068                count3 = 0;
   \                     ??AngleStep1JudgeNotBrick_23: (+1)
   \   00000208   0x2700             MOVS     R7,#+0
  11069                //当前行的扫描的右边界。
  11070                tempend = (a0 + a1 * row) / LeastSquareMulti - BrickColCom;   //记得除以增加的倍数
   \   0000020A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000020C   0xFB06 0x5004      MLA      R0,R6,R4,R5
   \   00000210   0xF44F 0x717A      MOV      R1,#+1000
   \   00000214   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000218   0x1F40             SUBS     R0,R0,#+5
  11071                //限幅。
  11072                tempend = MaxRe(tempend, AngleStep1NotBrickBorderColR);
   \   0000021A   0x.... 0x....      LDR.W    R1,??DataTable58_13
   \   0000021E   0x7809             LDRB     R1,[R1, #+0]
   \   00000220   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000222   0x.... 0x....      BL       MaxRe
  11073                //黑点扫描。
  11074                for(col = AngleStep1NotBrickBorderColR; ; col++)
   \   00000226   0x.... 0x....      LDR.W    R1,??DataTable58_13
   \   0000022A   0x7809             LDRB     R1,[R1, #+0]
   \   0000022C   0xE000             B.N      ??AngleStep1JudgeNotBrick_25
   \                     ??AngleStep1JudgeNotBrick_26: (+1)
   \   0000022E   0x1C49             ADDS     R1,R1,#+1
  11075                {
  11076                  if(ImgNew[row][col] < LimitRightB)  //够黑
   \                     ??AngleStep1JudgeNotBrick_25: (+1)
   \   00000230   0x.... 0x....      LDR.W    R2,??DataTable58_10
   \   00000234   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000236   0x23FA             MOVS     R3,#+250
   \   00000238   0xFB03 0x2206      MLA      R2,R3,R6,R2
   \   0000023C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000023E   0x5C8A             LDRB     R2,[R1, R2]
   \   00000240   0x.... 0x....      LDR.W    R3,??DataTable59
   \   00000244   0x781B             LDRB     R3,[R3, #+0]
   \   00000246   0x429A             CMP      R2,R3
   \   00000248   0xD200             BCS.N    ??AngleStep1JudgeNotBrick_27
  11077                  {
  11078                    count3++;
   \   0000024A   0x1C7F             ADDS     R7,R7,#+1
  11079                  }
  11080                  else
  11081                  {
  11082                  }
  11083                  //向右扫描至边界
  11084                  if(col >= tempend || col == CameraRealWidth - 1) break;
   \                     ??AngleStep1JudgeNotBrick_27: (+1)
   \   0000024C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000024E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000250   0x4281             CMP      R1,R0
   \   00000252   0xD202             BCS.N    ??AngleStep1JudgeNotBrick_28
   \   00000254   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000256   0x29F9             CMP      R1,#+249
   \   00000258   0xD1E9             BNE.N    ??AngleStep1JudgeNotBrick_26
  11085                }
  11086                //该行黑点个数大于BrickLineBlackCountNum个时，则行计数加1.
  11087                if(count3 > BrickLineBlackCountNum) 
   \                     ??AngleStep1JudgeNotBrick_28: (+1)
   \   0000025A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000025C   0x2F15             CMP      R7,#+21
   \   0000025E   0xDB01             BLT.N    ??AngleStep1JudgeNotBrick_29
  11088                {
  11089                  //存在有行黑点过多，则直接返回失败
  11090                  return 0;
   \   00000260   0x2000             MOVS     R0,#+0
   \   00000262   0xE005             B.N      ??AngleStep1JudgeNotBrick_7
  11091                }
  11092                else
  11093                {
  11094                }
  11095                
  11096                if(row == BrickEndRow) break;
   \                     ??AngleStep1JudgeNotBrick_29: (+1)
   \   00000264   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000266   0x2E23             CMP      R6,#+35
   \   00000268   0xD1CD             BNE.N    ??AngleStep1JudgeNotBrick_24
  11097              }
  11098              
  11099              //3. 最终确认
  11100              //走到这里说明没有非障碍检测成功，返回成功。
  11101              return 1;
   \   0000026A   0x2001             MOVS     R0,#+1
   \   0000026C   0xE000             B.N      ??AngleStep1JudgeNotBrick_7
  11102            }
  11103            else
  11104            {
  11105            }
  11106          
  11107            
  11108            //常态为返回失败。
  11109            return 0;
   \                     ??AngleStep1JudgeNotBrick_16: (+1)
   \   0000026E   0x2000             MOVS     R0,#+0
   \                     ??AngleStep1JudgeNotBrick_7: (+1)
   \   00000270   0xB005             ADD      SP,SP,#+20
   \   00000272   0xBDF0             POP      {R4-R7,PC}       ;; return
  11110          }
  11111          
  11112          
  11113          
  11114          //======================================================================
  11115          //函数名：AngleStep1Judge
  11116          //功  能：直角弯初步判断
  11117          //参  数：
  11118          //返  回：1成功，0失败
  11119          //影  响：
  11120          //说  明：1. 这只是初步判断，需确认多次方可确认为直角弯。
  11121          //        2. 其实还可以添加第6步，就是矮线的左右边有黑色区域。
  11122          //             
  11123          //======================================================================

   \                                 In section .text, align 2, keep-with-next
  11124          uint8 AngleStep1Judge(void)
  11125          {
   \                     AngleStep1Judge: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
  11126            uint8 i, j, col;
  11127            uint8 errorcount;
  11128            uint8 templ, tempr;
  11129            uint8 check_row, leftborder, rightborder;
  11130            uint8 leftbordercal, rightbordercal;
  11131            //由于现在进来之前不需要判断直道，所以需要先做一遍直道做的事情。
  11132            //若判断不准，可以尝试把errorcount的阈值减小。
  11133          
  11134            //1. 左、右黑线均提取成功
  11135            if(BlackLeftDone == 1 && BlackRightDone == 1)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable59_1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD104             BNE.N    ??AngleStep1Judge_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable59_2
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD001             BEQ.N    ??AngleStep1Judge_1
  11136            {
  11137            }
  11138            else
  11139            {
  11140              return 0;
   \                     ??AngleStep1Judge_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE3E5             B.N      ??AngleStep1Judge_2
  11141            }
  11142            
  11143            //进来后进一步需要判断的条件：
  11144            //2. 线头有高度差
  11145            //左线头比右线头高很多，则有可能是右直角弯。
  11146            if (BlackRightHeadLine >= BlackLeftHeadLine + AngleHeadLineNum)
   \                     ??AngleStep1Judge_1: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable59_3
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable59_4
   \   00000026   0x7809             LDRB     R1,[R1, #+0]
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable59_5
   \   0000002C   0x7812             LDRB     R2,[R2, #+0]
   \   0000002E   0x1851             ADDS     R1,R2,R1
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xF2C0 0x81EB      BLT.W    ??AngleStep1Judge_3
  11147            {
  11148                //3. 左线十字状态未进入或失败（反正不能成功），线尾很近
  11149                //   右线十字状态未进入或失败（反正不能成功），线尾很近
  11150                //BlackLeftCrossDone 0未进入，1失败，2成功
  11151                //BlackLeftStep4Flag 0未进入，1失败，2成功
  11152                if ((BlackLeftCrossDone != 2)
  11153                //&& (BlackLeftEndLine > CameraHight - 5)
  11154                && (BlackRightCrossDone != 2)
  11155                //&& (BlackRightEndLine > CameraHight - 5)
  11156                && (CURVEL <= 30 && CURVEL >= 0 - 30)      //左曲率应该是个绝对值较小的值
  11157                && (CURVER <= 30 && CURVER >= 0 - 40)      //右直角弯 //右曲率应该是个绝对值较小的值
  11158                  )
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable59_6
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2802             CMP      R0,#+2
   \   0000003E   0xF000 0x83D2      BEQ.W    ??AngleStep1Judge_4
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable59_7
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0x2802             CMP      R0,#+2
   \   0000004A   0xF000 0x83CC      BEQ.W    ??AngleStep1Judge_4
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable59_8
   \   00000052   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000056   0x301E             ADDS     R0,R0,#+30
   \   00000058   0x283D             CMP      R0,#+61
   \   0000005A   0xF080 0x83C4      BCS.W    ??AngleStep1Judge_4
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable58
   \   00000062   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000066   0x3028             ADDS     R0,R0,#+40
   \   00000068   0x2847             CMP      R0,#+71
   \   0000006A   0xF080 0x83BC      BCS.W    ??AngleStep1Judge_4
  11159                {
  11160                    //3.5 检查右线头处有没有小拐弯，如果有小拐弯，则返回失败。
  11161                    if(BlackRightLoc[BlackRightHeadLine][0] > BlackRightLoc[BlackRightHeadLine+1][0] && BlackRightLoc[BlackRightHeadLine+1][0] > BlackRightLoc[BlackRightHeadLine+2][0])
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable58_8
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable59_3
   \   00000076   0x7809             LDRB     R1,[R1, #+0]
   \   00000078   0x2203             MOVS     R2,#+3
   \   0000007A   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000007E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable58_8
   \   00000084   0x.... 0x....      LDR.W    R2,??DataTable59_3
   \   00000088   0x7812             LDRB     R2,[R2, #+0]
   \   0000008A   0x2303             MOVS     R3,#+3
   \   0000008C   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000090   0x7809             LDRB     R1,[R1, #+0]
   \   00000092   0x4288             CMP      R0,R1
   \   00000094   0xD215             BCS.N    ??AngleStep1Judge_5
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable58_8
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable59_3
   \   0000009E   0x7809             LDRB     R1,[R1, #+0]
   \   000000A0   0x2203             MOVS     R2,#+3
   \   000000A2   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000000A6   0x7980             LDRB     R0,[R0, #+6]
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable58_8
   \   000000AC   0x.... 0x....      LDR.W    R2,??DataTable59_3
   \   000000B0   0x7812             LDRB     R2,[R2, #+0]
   \   000000B2   0x2303             MOVS     R3,#+3
   \   000000B4   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000000B8   0x78C9             LDRB     R1,[R1, #+3]
   \   000000BA   0x4288             CMP      R0,R1
   \   000000BC   0xD201             BCS.N    ??AngleStep1Judge_5
  11162                    {
  11163                      return 0;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xE392             B.N      ??AngleStep1Judge_2
  11164                    }
  11165                    else
  11166                    {
  11167                    }
  11168                    
  11169                    //4. 两线5Slope数组均很小
  11170                    //左线
  11171                    //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
  11172                    //直角弯长线头策略，1表示去掉长线线头。
  11173                    if(AngleLongHeadLineStrategy == 1)
   \                     ??AngleStep1Judge_5: (+1)
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable60
   \   000000C6   0x7800             LDRB     R0,[R0, #+0]
   \   000000C8   0x2801             CMP      R0,#+1
   \   000000CA   0xD128             BNE.N    ??AngleStep1Judge_6
  11174                    {
  11175                      if(BlackLeftEndLine - BlackLeftHeadLine - 4 - AngleHeadLineNum < 0 || BlackLeft5SlopeIndex - 1 - AngleHeadLineNum < 0)
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable60_1
   \   000000D0   0x7800             LDRB     R0,[R0, #+0]
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable59_4
   \   000000D6   0x7809             LDRB     R1,[R1, #+0]
   \   000000D8   0x1A40             SUBS     R0,R0,R1
   \   000000DA   0x1F00             SUBS     R0,R0,#+4
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable59_5
   \   000000E0   0x7809             LDRB     R1,[R1, #+0]
   \   000000E2   0x1A40             SUBS     R0,R0,R1
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD409             BMI.N    ??AngleStep1Judge_7
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable60_2
   \   000000EC   0x7800             LDRB     R0,[R0, #+0]
   \   000000EE   0x1E40             SUBS     R0,R0,#+1
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable59_5
   \   000000F4   0x7809             LDRB     R1,[R1, #+0]
   \   000000F6   0x1A40             SUBS     R0,R0,R1
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD501             BPL.N    ??AngleStep1Judge_8
  11176                      {
  11177                        return 0;
   \                     ??AngleStep1Judge_7: (+1)
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0xE373             B.N      ??AngleStep1Judge_2
  11178                      }
  11179                      else
  11180                      {        
  11181                      }
  11182                      templ = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 4, BlackLeft5SlopeIndex - 1);               
   \                     ??AngleStep1Judge_8: (+1)
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable60_2
   \   00000104   0x7800             LDRB     R0,[R0, #+0]
   \   00000106   0x1E41             SUBS     R1,R0,#+1
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable60_1
   \   0000010C   0x7800             LDRB     R0,[R0, #+0]
   \   0000010E   0x.... 0x....      LDR.W    R2,??DataTable59_4
   \   00000112   0x7812             LDRB     R2,[R2, #+0]
   \   00000114   0x1A80             SUBS     R0,R0,R2
   \   00000116   0x1F00             SUBS     R0,R0,#+4
   \   00000118   0x.... 0x....      BL       MinRe
   \   0000011C   0xE01F             B.N      ??AngleStep1Judge_9
  11183                    }
  11184                    //0表示不去掉。
  11185                    else
  11186                    {
  11187                      if(BlackLeftEndLine - BlackLeftHeadLine - 4 < 0 || BlackLeft5SlopeIndex - 1 < 0)
   \                     ??AngleStep1Judge_6: (+1)
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable60_1
   \   00000122   0x7800             LDRB     R0,[R0, #+0]
   \   00000124   0x.... 0x....      LDR.W    R1,??DataTable59_4
   \   00000128   0x7809             LDRB     R1,[R1, #+0]
   \   0000012A   0x1A40             SUBS     R0,R0,R1
   \   0000012C   0x1F00             SUBS     R0,R0,#+4
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD405             BMI.N    ??AngleStep1Judge_10
   \   00000132   0x.... 0x....      LDR.W    R0,??DataTable60_2
   \   00000136   0x7800             LDRB     R0,[R0, #+0]
   \   00000138   0x1E40             SUBS     R0,R0,#+1
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD501             BPL.N    ??AngleStep1Judge_11
  11188                      {
  11189                        return 0;
   \                     ??AngleStep1Judge_10: (+1)
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0xE352             B.N      ??AngleStep1Judge_2
  11190                      }
  11191                      else
  11192                      {        
  11193                      }
  11194                      templ = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 4, BlackLeft5SlopeIndex - 1);            
   \                     ??AngleStep1Judge_11: (+1)
   \   00000142   0x.... 0x....      LDR.W    R0,??DataTable60_2
   \   00000146   0x7800             LDRB     R0,[R0, #+0]
   \   00000148   0x1E41             SUBS     R1,R0,#+1
   \   0000014A   0x.... 0x....      LDR.W    R0,??DataTable60_1
   \   0000014E   0x7800             LDRB     R0,[R0, #+0]
   \   00000150   0x.... 0x....      LDR.W    R2,??DataTable59_4
   \   00000154   0x7812             LDRB     R2,[R2, #+0]
   \   00000156   0x1A80             SUBS     R0,R0,R2
   \   00000158   0x1F00             SUBS     R0,R0,#+4
   \   0000015A   0x.... 0x....      BL       MinRe
  11195                    }
  11196                    //错误计数清零
  11197                    errorcount = 0;
   \                     ??AngleStep1Judge_9: (+1)
   \   0000015E   0x2200             MOVS     R2,#+0
  11198                    //逐个判断小5点斜率是否满足条件
  11199                    for(i = 0; ; i++)
   \   00000160   0x2100             MOVS     R1,#+0
   \   00000162   0xE000             B.N      ??AngleStep1Judge_12
   \                     ??AngleStep1Judge_13: (+1)
   \   00000164   0x1C49             ADDS     R1,R1,#+1
  11200                    {
  11201                      if(BlackLeft5Slope[i] > 0 || BlackLeft5Slope[i] < 0 - PathJudgeStraightSlopeLimit) //右上到左下的斜率是负的。 
   \                     ??AngleStep1Judge_12: (+1)
   \   00000166   0x.... 0x....      LDR.W    R3,??DataTable60_3
   \   0000016A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000016C   0xF853 0x3021      LDR      R3,[R3, R1, LSL #+2]
   \   00000170   0xF603 0x0334      ADDW     R3,R3,#+2100
   \   00000174   0xF640 0x0435      MOVW     R4,#+2101
   \   00000178   0x42A3             CMP      R3,R4
   \   0000017A   0xD303             BCC.N    ??AngleStep1Judge_14
  11202                      {
  11203                        errorcount++;
   \   0000017C   0x1C52             ADDS     R2,R2,#+1
  11204                        if(errorcount > 3) break;   //允许有若干个点斜率超出范围
   \   0000017E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000180   0x2A04             CMP      R2,#+4
   \   00000182   0xDA03             BGE.N    ??AngleStep1Judge_15
  11205                      }
  11206                
  11207                      if(i == templ) break;
   \                     ??AngleStep1Judge_14: (+1)
   \   00000184   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000186   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000188   0x4281             CMP      R1,R0
   \   0000018A   0xD1EB             BNE.N    ??AngleStep1Judge_13
  11208                    }
  11209                    //不满足条件，返回失败。
  11210                    if(i != templ) return 0;
   \                     ??AngleStep1Judge_15: (+1)
   \   0000018C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000018E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000190   0x4281             CMP      R1,R0
   \   00000192   0xD001             BEQ.N    ??AngleStep1Judge_16
   \   00000194   0x2000             MOVS     R0,#+0
   \   00000196   0xE327             B.N      ??AngleStep1Judge_2
  11211                    
  11212                    //右线
  11213                    //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
  11214                    if(BlackRightEndLine - BlackRightHeadLine - 4 < 0 || BlackRight5SlopeIndex - 1 < 0)
   \                     ??AngleStep1Judge_16: (+1)
   \   00000198   0x.... 0x....      LDR.W    R0,??DataTable60_4
   \   0000019C   0x7800             LDRB     R0,[R0, #+0]
   \   0000019E   0x.... 0x....      LDR.W    R1,??DataTable59_3
   \   000001A2   0x7809             LDRB     R1,[R1, #+0]
   \   000001A4   0x1A40             SUBS     R0,R0,R1
   \   000001A6   0x1F00             SUBS     R0,R0,#+4
   \   000001A8   0x2800             CMP      R0,#+0
   \   000001AA   0xD405             BMI.N    ??AngleStep1Judge_17
   \   000001AC   0x.... 0x....      LDR.W    R0,??DataTable60_5
   \   000001B0   0x7800             LDRB     R0,[R0, #+0]
   \   000001B2   0x1E40             SUBS     R0,R0,#+1
   \   000001B4   0x2800             CMP      R0,#+0
   \   000001B6   0xD501             BPL.N    ??AngleStep1Judge_18
  11215                    {
  11216                      return 0;
   \                     ??AngleStep1Judge_17: (+1)
   \   000001B8   0x2000             MOVS     R0,#+0
   \   000001BA   0xE315             B.N      ??AngleStep1Judge_2
  11217                    }
  11218                    else
  11219                    {
  11220                    }
  11221                    tempr = MinRe(BlackRightEndLine - BlackRightHeadLine - 4, BlackRight5SlopeIndex - 1);
   \                     ??AngleStep1Judge_18: (+1)
   \   000001BC   0x.... 0x....      LDR.W    R0,??DataTable60_5
   \   000001C0   0x7800             LDRB     R0,[R0, #+0]
   \   000001C2   0x1E41             SUBS     R1,R0,#+1
   \   000001C4   0x.... 0x....      LDR.W    R0,??DataTable60_4
   \   000001C8   0x7800             LDRB     R0,[R0, #+0]
   \   000001CA   0x.... 0x....      LDR.W    R2,??DataTable59_3
   \   000001CE   0x7812             LDRB     R2,[R2, #+0]
   \   000001D0   0x1A80             SUBS     R0,R0,R2
   \   000001D2   0x1F00             SUBS     R0,R0,#+4
   \   000001D4   0x.... 0x....      BL       MinRe
  11222                    //错误计数清零
  11223                    errorcount = 0;
   \   000001D8   0x2200             MOVS     R2,#+0
  11224                    //逐个判断小5点斜率是否满足条件
  11225                    for(i = 0; ; i++)
   \   000001DA   0x2100             MOVS     R1,#+0
   \   000001DC   0xE000             B.N      ??AngleStep1Judge_19
   \                     ??AngleStep1Judge_20: (+1)
   \   000001DE   0x1C49             ADDS     R1,R1,#+1
  11226                    {
  11227                      if(BlackRight5Slope[i] < 0 || BlackRight5Slope[i] > PathJudgeStraightSlopeLimit) //左上到右下的斜率是正的。
   \                     ??AngleStep1Judge_19: (+1)
   \   000001E0   0x.... 0x....      LDR.W    R3,??DataTable60_6
   \   000001E4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001E6   0xF853 0x3021      LDR      R3,[R3, R1, LSL #+2]
   \   000001EA   0x1E1B             SUBS     R3,R3,#+0
   \   000001EC   0xF640 0x0435      MOVW     R4,#+2101
   \   000001F0   0x42A3             CMP      R3,R4
   \   000001F2   0xD303             BCC.N    ??AngleStep1Judge_21
  11228                      {
  11229                        errorcount++;
   \   000001F4   0x1C52             ADDS     R2,R2,#+1
  11230                        if(errorcount > 3) break;   //允许有若干个点斜率超出范围
   \   000001F6   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001F8   0x2A04             CMP      R2,#+4
   \   000001FA   0xDA03             BGE.N    ??AngleStep1Judge_22
  11231                      }
  11232                
  11233                      if(i == tempr) break;
   \                     ??AngleStep1Judge_21: (+1)
   \   000001FC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000200   0x4281             CMP      R1,R0
   \   00000202   0xD1EC             BNE.N    ??AngleStep1Judge_20
  11234                    }
  11235                    //不满足条件，返回失败。
  11236                    if(i != tempr) return 0;
   \                     ??AngleStep1Judge_22: (+1)
   \   00000204   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000206   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000208   0x4281             CMP      R1,R0
   \   0000020A   0xD001             BEQ.N    ??AngleStep1Judge_23
   \   0000020C   0x2000             MOVS     R0,#+0
   \   0000020E   0xE2EB             B.N      ??AngleStep1Judge_2
  11237                    
  11238                    //若左右两线都满足要求，会继续往下走。
  11239          
  11240                    //5. 对右线头往上一些点进行白区域检测。
  11241                    //5.1. 一竖
  11242                    col = BlackRightLoc[BlackRightHeadLine][0];   //这里采用原始的黑点，不能采用矫正后的。
   \                     ??AngleStep1Judge_23: (+1)
   \   00000210   0x.... 0x....      LDR.W    R0,??DataTable58_8
   \   00000214   0x.... 0x....      LDR.W    R1,??DataTable59_3
   \   00000218   0x7809             LDRB     R1,[R1, #+0]
   \   0000021A   0x2203             MOVS     R2,#+3
   \   0000021C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000220   0x7800             LDRB     R0,[R0, #+0]
  11243                    for(i = BlackRightHeadLine-3; i > (BlackRightHeadLine-AngleHeadLineNum); i--)
   \   00000222   0x.... 0x....      LDR.W    R1,??DataTable59_3
   \   00000226   0x7809             LDRB     R1,[R1, #+0]
   \   00000228   0x1EC9             SUBS     R1,R1,#+3
   \   0000022A   0xE004             B.N      ??AngleStep1Judge_24
  11244                    {
  11245                      //与右线白点阈值进行比较，必须大于白点阈值。
  11246                      if(ImgNew[i][col] < LimitRightW - AngleWhiteAreaLimitVal)
  11247                      {
  11248                        flag222 = 10;
  11249                        //只要有一个点不满足，即判定不是直角弯。
  11250                        break;
  11251                      }
  11252                      else
  11253                      {
  11254                        flag222 = 0;
   \                     ??AngleStep1Judge_25: (+1)
   \   0000022C   0x2200             MOVS     R2,#+0
   \   0000022E   0x.... 0x....      LDR.W    R3,??DataTable60_7
   \   00000232   0x601A             STR      R2,[R3, #+0]
  11255                      }
   \   00000234   0x1E49             SUBS     R1,R1,#+1
   \                     ??AngleStep1Judge_24: (+1)
   \   00000236   0x.... 0x....      LDR.W    R2,??DataTable59_3
   \   0000023A   0x7812             LDRB     R2,[R2, #+0]
   \   0000023C   0x.... 0x....      LDR.W    R3,??DataTable59_5
   \   00000240   0x781B             LDRB     R3,[R3, #+0]
   \   00000242   0x1AD2             SUBS     R2,R2,R3
   \   00000244   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000246   0x428A             CMP      R2,R1
   \   00000248   0xDA11             BGE.N    ??AngleStep1Judge_26
   \   0000024A   0x.... 0x....      LDR.W    R2,??DataTable58_10
   \   0000024E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000250   0x23FA             MOVS     R3,#+250
   \   00000252   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000256   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000258   0x5C82             LDRB     R2,[R0, R2]
   \   0000025A   0x.... 0x....      LDR.W    R3,??DataTable60_8
   \   0000025E   0x781B             LDRB     R3,[R3, #+0]
   \   00000260   0x3B14             SUBS     R3,R3,#+20
   \   00000262   0x429A             CMP      R2,R3
   \   00000264   0xDAE2             BGE.N    ??AngleStep1Judge_25
   \   00000266   0x220A             MOVS     R2,#+10
   \   00000268   0x.... 0x....      LDR.W    R3,??DataTable60_7
   \   0000026C   0x601A             STR      R2,[R3, #+0]
  11256                    }
  11257                    //从下到上一直满足白点，且最上与最下两个点像素差值够小。
  11258                    if(
  11259                      (i <= BlackRightHeadLine-AngleHeadLineNum)
  11260                    &&(AbsInt(ImgNew[BlackRightHeadLine-3][col] - ImgNew[BlackRightHeadLine-AngleHeadLineNum][col]) < 2 * AngleWhiteAreaLimitVal)
  11261                      )
   \                     ??AngleStep1Judge_26: (+1)
   \   0000026E   0x.... 0x....      LDR.W    R2,??DataTable59_3
   \   00000272   0x7812             LDRB     R2,[R2, #+0]
   \   00000274   0x.... 0x....      LDR.W    R3,??DataTable59_5
   \   00000278   0x781B             LDRB     R3,[R3, #+0]
   \   0000027A   0x1AD2             SUBS     R2,R2,R3
   \   0000027C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000027E   0x428A             CMP      R2,R1
   \   00000280   0xF2C0 0x82B1      BLT.W    ??AngleStep1Judge_4
   \   00000284   0x.... 0x....      LDR.W    R1,??DataTable58_10
   \   00000288   0x.... 0x....      LDR.W    R2,??DataTable59_3
   \   0000028C   0x7812             LDRB     R2,[R2, #+0]
   \   0000028E   0x23FA             MOVS     R3,#+250
   \   00000290   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000294   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000296   0x1841             ADDS     R1,R0,R1
   \   00000298   0xF2A1 0x21EE      SUBW     R1,R1,#+750
   \   0000029C   0x7809             LDRB     R1,[R1, #+0]
   \   0000029E   0x.... 0x....      LDR.W    R2,??DataTable58_10
   \   000002A2   0x.... 0x....      LDR.W    R3,??DataTable59_3
   \   000002A6   0x781B             LDRB     R3,[R3, #+0]
   \   000002A8   0x.... 0x....      LDR.W    R4,??DataTable59_5
   \   000002AC   0x7824             LDRB     R4,[R4, #+0]
   \   000002AE   0x1B1B             SUBS     R3,R3,R4
   \   000002B0   0x24FA             MOVS     R4,#+250
   \   000002B2   0xFB04 0x2203      MLA      R2,R4,R3,R2
   \   000002B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002B8   0x5C80             LDRB     R0,[R0, R2]
   \   000002BA   0x1A08             SUBS     R0,R1,R0
   \   000002BC   0x.... 0x....      BL       AbsInt
   \   000002C0   0x2828             CMP      R0,#+40
   \   000002C2   0xF280 0x8290      BGE.W    ??AngleStep1Judge_4
  11262                    {
  11263                      //5.2. 一横
  11264                      check_row = BlackRightHeadLine - AngleHeadLineNum / 2;
   \   000002C6   0x.... 0x....      LDR.W    R0,??DataTable59_3
   \   000002CA   0x7800             LDRB     R0,[R0, #+0]
   \   000002CC   0x.... 0x....      LDR.W    R1,??DataTable59_5
   \   000002D0   0x7809             LDRB     R1,[R1, #+0]
   \   000002D2   0x2202             MOVS     R2,#+2
   \   000002D4   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   000002D8   0x1A44             SUBS     R4,R0,R1
  11265                      //一横的左边界
  11266                      //不能小于图像左边界
  11267                      leftborder = MaxRe(0, BlackRightLoc[BlackRightHeadLine][0] - 15);
   \   000002DA   0x.... 0x....      LDR.W    R0,??DataTable58_8
   \   000002DE   0x.... 0x....      LDR.W    R1,??DataTable59_3
   \   000002E2   0x7809             LDRB     R1,[R1, #+0]
   \   000002E4   0x2203             MOVS     R2,#+3
   \   000002E6   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000002EA   0x7800             LDRB     R0,[R0, #+0]
   \   000002EC   0xF1B0 0x010F      SUBS     R1,R0,#+15
   \   000002F0   0x2000             MOVS     R0,#+0
   \   000002F2   0x.... 0x....      BL       MaxRe
   \   000002F6   0x0005             MOVS     R5,R0
  11268                      leftbordercal = MaxRe(0, BlackRightLoc[BlackRightHeadLine][0] - 15);
   \   000002F8   0x.... 0x....      LDR.W    R0,??DataTable58_8
   \   000002FC   0x.... 0x....      LDR.W    R1,??DataTable59_3
   \   00000300   0x7809             LDRB     R1,[R1, #+0]
   \   00000302   0x2203             MOVS     R2,#+3
   \   00000304   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000308   0x7800             LDRB     R0,[R0, #+0]
   \   0000030A   0xF1B0 0x010F      SUBS     R1,R0,#+15
   \   0000030E   0x2000             MOVS     R0,#+0
   \   00000310   0x.... 0x....      BL       MaxRe
   \   00000314   0x0006             MOVS     R6,R0
  11269                      //不能比该行有效左黑线小。
  11270                      if(BlackLeftLoc[check_row][0] != MaxValUint8)
   \   00000316   0x.... 0x....      LDR.W    R0,??DataTable58_6
   \   0000031A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000031C   0x2103             MOVS     R1,#+3
   \   0000031E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000322   0x7800             LDRB     R0,[R0, #+0]
   \   00000324   0x28FF             CMP      R0,#+255
   \   00000326   0xD017             BEQ.N    ??AngleStep1Judge_27
  11271                      {
  11272                        leftborder = MaxRe(BlackLeftLoc[check_row][0], leftborder);
   \   00000328   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000032A   0x0029             MOVS     R1,R5
   \   0000032C   0x.... 0x....      LDR.W    R0,??DataTable58_6
   \   00000330   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000332   0x2203             MOVS     R2,#+3
   \   00000334   0xFB02 0x0004      MLA      R0,R2,R4,R0
   \   00000338   0x7800             LDRB     R0,[R0, #+0]
   \   0000033A   0x.... 0x....      BL       MaxRe
   \   0000033E   0x0005             MOVS     R5,R0
  11273                        leftbordercal = MaxRe(BlackLeftLoc[check_row][0], leftbordercal);
   \   00000340   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000342   0x0031             MOVS     R1,R6
   \   00000344   0x.... 0x....      LDR.W    R0,??DataTable58_6
   \   00000348   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000034A   0x2203             MOVS     R2,#+3
   \   0000034C   0xFB02 0x0004      MLA      R0,R2,R4,R0
   \   00000350   0x7800             LDRB     R0,[R0, #+0]
   \   00000352   0x.... 0x....      BL       MaxRe
   \   00000356   0x0006             MOVS     R6,R0
  11274                      }
  11275                      else
  11276                      {
  11277                      } 
  11278                      //一横的右边界。
  11279                      rightborder = MinRe(CameraRealWidth - 1, BlackRightLoc[BlackRightHeadLine][0] + 15);
   \                     ??AngleStep1Judge_27: (+1)
   \   00000358   0x.... 0x....      LDR.W    R0,??DataTable58_8
   \   0000035C   0x.... 0x....      LDR.W    R1,??DataTable59_3
   \   00000360   0x7809             LDRB     R1,[R1, #+0]
   \   00000362   0x2203             MOVS     R2,#+3
   \   00000364   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000368   0x7800             LDRB     R0,[R0, #+0]
   \   0000036A   0xF110 0x010F      ADDS     R1,R0,#+15
   \   0000036E   0x20F9             MOVS     R0,#+249
   \   00000370   0x.... 0x....      BL       MinRe
   \   00000374   0x0007             MOVS     R7,R0
  11280                      rightbordercal = MinRe(CameraRealWidth - 1, BlackRightLoc[BlackRightHeadLine][0] + 15);
   \   00000376   0x.... 0x....      LDR.W    R0,??DataTable58_8
   \   0000037A   0x.... 0x....      LDR.W    R1,??DataTable59_3
   \   0000037E   0x7809             LDRB     R1,[R1, #+0]
   \   00000380   0x2203             MOVS     R2,#+3
   \   00000382   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000386   0x7800             LDRB     R0,[R0, #+0]
   \   00000388   0xF110 0x010F      ADDS     R1,R0,#+15
   \   0000038C   0x20F9             MOVS     R0,#+249
   \   0000038E   0x.... 0x....      BL       MinRe
   \   00000392   0x4680             MOV      R8,R0
  11281                      //从左到右进行白点检查
  11282                      for(j = leftborder; j < rightborder; j++)
   \   00000394   0xE000             B.N      ??AngleStep1Judge_28
   \                     ??AngleStep1Judge_29: (+1)
   \   00000396   0x1C6D             ADDS     R5,R5,#+1
   \                     ??AngleStep1Judge_28: (+1)
   \   00000398   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000039A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000039C   0x42BD             CMP      R5,R7
   \   0000039E   0xD20D             BCS.N    ??AngleStep1Judge_30
  11283                      {
  11284                        if(ImgNew[check_row][j] < LimitRightW - AngleWhiteAreaLimitVal) break;              
   \   000003A0   0x.... 0x....      LDR.W    R0,??DataTable58_10
   \   000003A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003A6   0x21FA             MOVS     R1,#+250
   \   000003A8   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000003AC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003AE   0x5C28             LDRB     R0,[R5, R0]
   \   000003B0   0x.... 0x....      LDR.W    R1,??DataTable60_8
   \   000003B4   0x7809             LDRB     R1,[R1, #+0]
   \   000003B6   0x3914             SUBS     R1,R1,#+20
   \   000003B8   0x4288             CMP      R0,R1
   \   000003BA   0xDAEC             BGE.N    ??AngleStep1Judge_29
  11285                      }
  11286                      //从左到右一直满足白点，且最左最右两点差值够小，进入第6步。
  11287                      if(
  11288                        (j >= rightborder) 
  11289                      &&(AbsInt(ImgNew[check_row][leftbordercal] - ImgNew[check_row][rightbordercal]) < 2 * AngleWhiteAreaLimitVal) //隔的点比较多，允许差值稍微大一些。
  11290                        )
   \                     ??AngleStep1Judge_30: (+1)
   \   000003BC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003BE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000003C0   0x42BD             CMP      R5,R7
   \   000003C2   0xF0C0 0x8210      BCC.W    ??AngleStep1Judge_4
   \   000003C6   0x.... 0x....      LDR.W    R0,??DataTable58_10
   \   000003CA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003CC   0x21FA             MOVS     R1,#+250
   \   000003CE   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000003D2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000003D4   0x5C30             LDRB     R0,[R6, R0]
   \   000003D6   0x.... 0x....      LDR.W    R1,??DataTable58_10
   \   000003DA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003DC   0x22FA             MOVS     R2,#+250
   \   000003DE   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000003E2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000003E6   0xF818 0x1001      LDRB     R1,[R8, R1]
   \   000003EA   0x1A40             SUBS     R0,R0,R1
   \   000003EC   0x.... 0x....      BL       AbsInt
   \   000003F0   0x2828             CMP      R0,#+40
   \   000003F2   0xF280 0x81F8      BGE.W    ??AngleStep1Judge_4
  11291                      {
  11292                        //6. 非右障碍确认成功，则最终确认是右直角。
  11293                        if(AngleStep1JudgeNotBrick(1) == 1)
   \   000003F6   0x2001             MOVS     R0,#+1
   \   000003F8   0x.... 0x....      BL       AngleStep1JudgeNotBrick
   \   000003FC   0x2801             CMP      R0,#+1
   \   000003FE   0xF040 0x81F2      BNE.W    ??AngleStep1Judge_4
  11294                        {
  11295                          PathType = PathTypeAngleR;
   \   00000402   0x2005             MOVS     R0,#+5
   \   00000404   0x.... 0x....      LDR.W    R1,??DataTable61
   \   00000408   0x7008             STRB     R0,[R1, #+0]
   \   0000040A   0xE1EC             B.N      ??AngleStep1Judge_4
  11296                        }
  11297                        else
  11298                        {
  11299                        }
  11300                      }
  11301                      else
  11302                      {
  11303                        
  11304                      }           
  11305                    }
  11306                    else
  11307                    {            
  11308                    }
  11309                }
  11310                //否则仍为直道
  11311                else
  11312                {
  11313                }
  11314          
  11315            }
  11316            //右线头比左线头高很多，则有可能是左直角弯。
  11317            else if (BlackLeftHeadLine >= BlackRightHeadLine + AngleHeadLineNum)
   \                     ??AngleStep1Judge_3: (+1)
   \   0000040C   0x.... 0x....      LDR.W    R0,??DataTable59_4
   \   00000410   0x7800             LDRB     R0,[R0, #+0]
   \   00000412   0x.... 0x....      LDR.W    R1,??DataTable59_3
   \   00000416   0x7809             LDRB     R1,[R1, #+0]
   \   00000418   0x.... 0x....      LDR.W    R2,??DataTable59_5
   \   0000041C   0x7812             LDRB     R2,[R2, #+0]
   \   0000041E   0x1851             ADDS     R1,R2,R1
   \   00000420   0x4288             CMP      R0,R1
   \   00000422   0xF2C0 0x81E0      BLT.W    ??AngleStep1Judge_4
  11318            {
  11319                //3. 左线十字状态未进入或失败（反正不能成功），线尾很近
  11320                //   右线十字状态未进入或失败（反正不能成功），线尾很近
  11321                //BlackLeftCrossDone 0未进入，1失败，2成功
  11322                //BlackLeftStep4Flag 0未进入，1失败，2成功
  11323                if ((BlackLeftCrossDone != 2)
  11324                //&& (BlackLeftEndLine > CameraHight - 5)
  11325                && (BlackRightCrossDone != 2)
  11326                //&& (BlackRightEndLine > CameraHight - 5)
  11327                && (CURVEL <= 40 && CURVEL >= 0 - 30)      //左直角弯//左曲率应该是个绝对值较小的值
  11328                && (CURVER <= 30 && CURVER >= 0 - 30)      //右曲率应该是个绝对值较小的值
  11329                  )
   \   00000426   0x.... 0x....      LDR.W    R0,??DataTable59_6
   \   0000042A   0x7800             LDRB     R0,[R0, #+0]
   \   0000042C   0x2802             CMP      R0,#+2
   \   0000042E   0xF000 0x81DA      BEQ.W    ??AngleStep1Judge_4
   \   00000432   0x.... 0x....      LDR.W    R0,??DataTable59_7
   \   00000436   0x7800             LDRB     R0,[R0, #+0]
   \   00000438   0x2802             CMP      R0,#+2
   \   0000043A   0xF000 0x81D4      BEQ.W    ??AngleStep1Judge_4
   \   0000043E   0x.... 0x....      LDR.W    R0,??DataTable59_8
   \   00000442   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000446   0x301E             ADDS     R0,R0,#+30
   \   00000448   0x2847             CMP      R0,#+71
   \   0000044A   0xF080 0x81CC      BCS.W    ??AngleStep1Judge_4
   \   0000044E   0x.... 0x....      LDR.W    R0,??DataTable58
   \   00000452   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000456   0x301E             ADDS     R0,R0,#+30
   \   00000458   0x283D             CMP      R0,#+61
   \   0000045A   0xF080 0x81C4      BCS.W    ??AngleStep1Judge_4
  11330                {
  11331                    //3.5 检查左线头处有没有小拐弯，如果有小拐弯，则返回失败。
  11332                    if(BlackLeftLoc[BlackLeftHeadLine][0] < BlackLeftLoc[BlackLeftHeadLine+1][0] && BlackLeftLoc[BlackLeftHeadLine+1][0] < BlackLeftLoc[BlackLeftHeadLine+2][0])
   \   0000045E   0x.... 0x....      LDR.W    R0,??DataTable58_6
   \   00000462   0x.... 0x....      LDR.W    R1,??DataTable59_4
   \   00000466   0x7809             LDRB     R1,[R1, #+0]
   \   00000468   0x2203             MOVS     R2,#+3
   \   0000046A   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000046E   0x7800             LDRB     R0,[R0, #+0]
   \   00000470   0x.... 0x....      LDR.W    R1,??DataTable58_6
   \   00000474   0x.... 0x....      LDR.W    R2,??DataTable59_4
   \   00000478   0x7812             LDRB     R2,[R2, #+0]
   \   0000047A   0x2303             MOVS     R3,#+3
   \   0000047C   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000480   0x78C9             LDRB     R1,[R1, #+3]
   \   00000482   0x4288             CMP      R0,R1
   \   00000484   0xD213             BCS.N    ??AngleStep1Judge_31
   \   00000486   0x....             LDR.N    R0,??DataTable58_6
   \   00000488   0x.... 0x....      LDR.W    R1,??DataTable59_4
   \   0000048C   0x7809             LDRB     R1,[R1, #+0]
   \   0000048E   0x2203             MOVS     R2,#+3
   \   00000490   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000494   0x78C0             LDRB     R0,[R0, #+3]
   \   00000496   0x....             LDR.N    R1,??DataTable58_6
   \   00000498   0x.... 0x....      LDR.W    R2,??DataTable59_4
   \   0000049C   0x7812             LDRB     R2,[R2, #+0]
   \   0000049E   0x2303             MOVS     R3,#+3
   \   000004A0   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000004A4   0x7989             LDRB     R1,[R1, #+6]
   \   000004A6   0x4288             CMP      R0,R1
   \   000004A8   0xD201             BCS.N    ??AngleStep1Judge_31
  11333                    {
  11334                      return 0;
   \   000004AA   0x2000             MOVS     R0,#+0
   \   000004AC   0xE19C             B.N      ??AngleStep1Judge_2
  11335                    }
  11336                    else
  11337                    {
  11338                    }
  11339          
  11340                    //4. 两线5Slope数组均很小
  11341                    //左线
  11342                    //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
  11343                    if(BlackLeftEndLine - BlackLeftHeadLine - 4 < 0 || BlackLeft5SlopeIndex - 1 < 0)
   \                     ??AngleStep1Judge_31: (+1)
   \   000004AE   0x.... 0x....      LDR.W    R0,??DataTable60_1
   \   000004B2   0x7800             LDRB     R0,[R0, #+0]
   \   000004B4   0x.... 0x....      LDR.W    R1,??DataTable59_4
   \   000004B8   0x7809             LDRB     R1,[R1, #+0]
   \   000004BA   0x1A40             SUBS     R0,R0,R1
   \   000004BC   0x1F00             SUBS     R0,R0,#+4
   \   000004BE   0x2800             CMP      R0,#+0
   \   000004C0   0xD405             BMI.N    ??AngleStep1Judge_32
   \   000004C2   0x.... 0x....      LDR.W    R0,??DataTable60_2
   \   000004C6   0x7800             LDRB     R0,[R0, #+0]
   \   000004C8   0x1E40             SUBS     R0,R0,#+1
   \   000004CA   0x2800             CMP      R0,#+0
   \   000004CC   0xD501             BPL.N    ??AngleStep1Judge_33
  11344                    {
  11345                      return 0;
   \                     ??AngleStep1Judge_32: (+1)
   \   000004CE   0x2000             MOVS     R0,#+0
   \   000004D0   0xE18A             B.N      ??AngleStep1Judge_2
  11346                    }
  11347                    else
  11348                    {        
  11349                    }
  11350                    templ = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 4, BlackLeft5SlopeIndex - 1);
   \                     ??AngleStep1Judge_33: (+1)
   \   000004D2   0x.... 0x....      LDR.W    R0,??DataTable60_2
   \   000004D6   0x7800             LDRB     R0,[R0, #+0]
   \   000004D8   0x1E41             SUBS     R1,R0,#+1
   \   000004DA   0x.... 0x....      LDR.W    R0,??DataTable60_1
   \   000004DE   0x7800             LDRB     R0,[R0, #+0]
   \   000004E0   0x.... 0x....      LDR.W    R2,??DataTable59_4
   \   000004E4   0x7812             LDRB     R2,[R2, #+0]
   \   000004E6   0x1A80             SUBS     R0,R0,R2
   \   000004E8   0x1F00             SUBS     R0,R0,#+4
   \   000004EA   0x.... 0x....      BL       MinRe
  11351                    //错误计数清零
  11352                    errorcount = 0;
   \   000004EE   0x2200             MOVS     R2,#+0
  11353                    //逐个判断小5点斜率是否满足条件
  11354                    for(i = 0; ; i++)
   \   000004F0   0x2100             MOVS     R1,#+0
   \   000004F2   0xE000             B.N      ??AngleStep1Judge_34
   \                     ??AngleStep1Judge_35: (+1)
   \   000004F4   0x1C49             ADDS     R1,R1,#+1
  11355                    {
  11356                      if(BlackLeft5Slope[i] > 0 || BlackLeft5Slope[i] < 0 - PathJudgeStraightSlopeLimit) //右上到左下的斜率是负的。 
   \                     ??AngleStep1Judge_34: (+1)
   \   000004F6   0x.... 0x....      LDR.W    R3,??DataTable60_3
   \   000004FA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000004FC   0xF853 0x3021      LDR      R3,[R3, R1, LSL #+2]
   \   00000500   0xF603 0x0334      ADDW     R3,R3,#+2100
   \   00000504   0xF640 0x0435      MOVW     R4,#+2101
   \   00000508   0x42A3             CMP      R3,R4
   \   0000050A   0xD303             BCC.N    ??AngleStep1Judge_36
  11357                      {
  11358                        errorcount++;
   \   0000050C   0x1C52             ADDS     R2,R2,#+1
  11359                        if(errorcount > 3) break;   //允许有若干个点斜率超出范围
   \   0000050E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000510   0x2A04             CMP      R2,#+4
   \   00000512   0xDA03             BGE.N    ??AngleStep1Judge_37
  11360                      }
  11361                
  11362                      if(i == templ) break;
   \                     ??AngleStep1Judge_36: (+1)
   \   00000514   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000516   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000518   0x4281             CMP      R1,R0
   \   0000051A   0xD1EB             BNE.N    ??AngleStep1Judge_35
  11363                    }
  11364                    //不满足条件，返回失败。
  11365                    if(i != templ) return 0;
   \                     ??AngleStep1Judge_37: (+1)
   \   0000051C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000051E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000520   0x4281             CMP      R1,R0
   \   00000522   0xD001             BEQ.N    ??AngleStep1Judge_38
   \   00000524   0x2000             MOVS     R0,#+0
   \   00000526   0xE15F             B.N      ??AngleStep1Judge_2
  11366                    
  11367                    //右线
  11368                    //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
  11369                    //直角弯线头差策略，1表示去掉长线的线头。
  11370                    if(AngleLongHeadLineStrategy == 1)
   \                     ??AngleStep1Judge_38: (+1)
   \   00000528   0x.... 0x....      LDR.W    R0,??DataTable60
   \   0000052C   0x7800             LDRB     R0,[R0, #+0]
   \   0000052E   0x2801             CMP      R0,#+1
   \   00000530   0xD130             BNE.N    ??AngleStep1Judge_39
  11371                    {
  11372                      if(BlackRightEndLine - BlackRightHeadLine - 4 - AngleHeadLineNum < 0 || BlackRight5SlopeIndex - 1 - AngleHeadLineNum < 0)
   \   00000532   0x.... 0x....      LDR.W    R0,??DataTable60_4
   \   00000536   0x7800             LDRB     R0,[R0, #+0]
   \   00000538   0x.... 0x....      LDR.W    R1,??DataTable59_3
   \   0000053C   0x7809             LDRB     R1,[R1, #+0]
   \   0000053E   0x1A40             SUBS     R0,R0,R1
   \   00000540   0x1F00             SUBS     R0,R0,#+4
   \   00000542   0x.... 0x....      LDR.W    R1,??DataTable59_5
   \   00000546   0x7809             LDRB     R1,[R1, #+0]
   \   00000548   0x1A40             SUBS     R0,R0,R1
   \   0000054A   0x2800             CMP      R0,#+0
   \   0000054C   0xD409             BMI.N    ??AngleStep1Judge_40
   \   0000054E   0x.... 0x....      LDR.W    R0,??DataTable60_5
   \   00000552   0x7800             LDRB     R0,[R0, #+0]
   \   00000554   0x1E40             SUBS     R0,R0,#+1
   \   00000556   0x.... 0x....      LDR.W    R1,??DataTable59_5
   \   0000055A   0x7809             LDRB     R1,[R1, #+0]
   \   0000055C   0x1A40             SUBS     R0,R0,R1
   \   0000055E   0x2800             CMP      R0,#+0
   \   00000560   0xD501             BPL.N    ??AngleStep1Judge_41
  11373                      {
  11374                        return 0;
   \                     ??AngleStep1Judge_40: (+1)
   \   00000562   0x2000             MOVS     R0,#+0
   \   00000564   0xE140             B.N      ??AngleStep1Judge_2
  11375                      }
  11376                      else
  11377                      {
  11378                      }
  11379                      tempr = MinRe(BlackRightEndLine - BlackRightHeadLine - 4 - AngleHeadLineNum, BlackRight5SlopeIndex - 1 - AngleHeadLineNum);
   \                     ??AngleStep1Judge_41: (+1)
   \   00000566   0x.... 0x....      LDR.W    R0,??DataTable60_5
   \   0000056A   0x7800             LDRB     R0,[R0, #+0]
   \   0000056C   0x1E40             SUBS     R0,R0,#+1
   \   0000056E   0x.... 0x....      LDR.W    R1,??DataTable59_5
   \   00000572   0x7809             LDRB     R1,[R1, #+0]
   \   00000574   0x1A41             SUBS     R1,R0,R1
   \   00000576   0x.... 0x....      LDR.W    R0,??DataTable60_4
   \   0000057A   0x7800             LDRB     R0,[R0, #+0]
   \   0000057C   0x.... 0x....      LDR.W    R2,??DataTable59_3
   \   00000580   0x7812             LDRB     R2,[R2, #+0]
   \   00000582   0x1A80             SUBS     R0,R0,R2
   \   00000584   0x1F00             SUBS     R0,R0,#+4
   \   00000586   0x.... 0x....      LDR.W    R2,??DataTable59_5
   \   0000058A   0x7812             LDRB     R2,[R2, #+0]
   \   0000058C   0x1A80             SUBS     R0,R0,R2
   \   0000058E   0x.... 0x....      BL       MinRe
   \   00000592   0xE01F             B.N      ??AngleStep1Judge_42
  11380                    }
  11381                    //0表示不去掉长线的线头。
  11382                    else
  11383                    {
  11384                      if(BlackRightEndLine - BlackRightHeadLine - 4 < 0 || BlackRight5SlopeIndex - 1 < 0)
   \                     ??AngleStep1Judge_39: (+1)
   \   00000594   0x.... 0x....      LDR.W    R0,??DataTable60_4
   \   00000598   0x7800             LDRB     R0,[R0, #+0]
   \   0000059A   0x.... 0x....      LDR.W    R1,??DataTable59_3
   \   0000059E   0x7809             LDRB     R1,[R1, #+0]
   \   000005A0   0x1A40             SUBS     R0,R0,R1
   \   000005A2   0x1F00             SUBS     R0,R0,#+4
   \   000005A4   0x2800             CMP      R0,#+0
   \   000005A6   0xD405             BMI.N    ??AngleStep1Judge_43
   \   000005A8   0x.... 0x....      LDR.W    R0,??DataTable60_5
   \   000005AC   0x7800             LDRB     R0,[R0, #+0]
   \   000005AE   0x1E40             SUBS     R0,R0,#+1
   \   000005B0   0x2800             CMP      R0,#+0
   \   000005B2   0xD501             BPL.N    ??AngleStep1Judge_44
  11385                      {
  11386                        return 0;
   \                     ??AngleStep1Judge_43: (+1)
   \   000005B4   0x2000             MOVS     R0,#+0
   \   000005B6   0xE117             B.N      ??AngleStep1Judge_2
  11387                      }
  11388                      else
  11389                      {
  11390                      }
  11391                      tempr = MinRe(BlackRightEndLine - BlackRightHeadLine - 4, BlackRight5SlopeIndex - 1);
   \                     ??AngleStep1Judge_44: (+1)
   \   000005B8   0x.... 0x....      LDR.W    R0,??DataTable60_5
   \   000005BC   0x7800             LDRB     R0,[R0, #+0]
   \   000005BE   0x1E41             SUBS     R1,R0,#+1
   \   000005C0   0x.... 0x....      LDR.W    R0,??DataTable60_4
   \   000005C4   0x7800             LDRB     R0,[R0, #+0]
   \   000005C6   0x.... 0x....      LDR.W    R2,??DataTable59_3
   \   000005CA   0x7812             LDRB     R2,[R2, #+0]
   \   000005CC   0x1A80             SUBS     R0,R0,R2
   \   000005CE   0x1F00             SUBS     R0,R0,#+4
   \   000005D0   0x.... 0x....      BL       MinRe
  11392                      
  11393                    }
  11394                    //错误计数清零
  11395                    errorcount = 0;
   \                     ??AngleStep1Judge_42: (+1)
   \   000005D4   0x2200             MOVS     R2,#+0
  11396                    //逐个判断小5点斜率是否满足条件
  11397                    for(i = 0; ; i++)
   \   000005D6   0x2100             MOVS     R1,#+0
   \   000005D8   0xE000             B.N      ??AngleStep1Judge_45
   \                     ??AngleStep1Judge_46: (+1)
   \   000005DA   0x1C49             ADDS     R1,R1,#+1
  11398                    {
  11399                      if(BlackRight5Slope[i] < 0 || BlackRight5Slope[i] > PathJudgeStraightSlopeLimit) //左上到右下的斜率是正的。
   \                     ??AngleStep1Judge_45: (+1)
   \   000005DC   0x.... 0x....      LDR.W    R3,??DataTable60_6
   \   000005E0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000005E2   0xF853 0x3021      LDR      R3,[R3, R1, LSL #+2]
   \   000005E6   0x1E1B             SUBS     R3,R3,#+0
   \   000005E8   0xF640 0x0435      MOVW     R4,#+2101
   \   000005EC   0x42A3             CMP      R3,R4
   \   000005EE   0xD303             BCC.N    ??AngleStep1Judge_47
  11400                      {
  11401                        errorcount++;
   \   000005F0   0x1C52             ADDS     R2,R2,#+1
  11402                        if(errorcount > 3) break;   //允许有若干个点斜率超出范围
   \   000005F2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000005F4   0x2A04             CMP      R2,#+4
   \   000005F6   0xDA03             BGE.N    ??AngleStep1Judge_48
  11403                      }
  11404                
  11405                      if(i == tempr) break;
   \                     ??AngleStep1Judge_47: (+1)
   \   000005F8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000005FA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005FC   0x4281             CMP      R1,R0
   \   000005FE   0xD1EC             BNE.N    ??AngleStep1Judge_46
  11406                    }
  11407                    //不满足条件，返回失败。
  11408                    if(i != tempr) return 0;
   \                     ??AngleStep1Judge_48: (+1)
   \   00000600   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000602   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000604   0x4281             CMP      R1,R0
   \   00000606   0xD001             BEQ.N    ??AngleStep1Judge_49
   \   00000608   0x2000             MOVS     R0,#+0
   \   0000060A   0xE0ED             B.N      ??AngleStep1Judge_2
  11409                    
  11410                    //若左右两线都满足要求，会继续往下走。        
  11411          
  11412                    //5. 对左线头往上一些点进行白区域检测。
  11413                    //5.1. 一竖
  11414                    col = BlackLeftLoc[BlackLeftHeadLine][0];   //这里采用原始的黑点，不能采用矫正后的。
   \                     ??AngleStep1Judge_49: (+1)
   \   0000060C   0x....             LDR.N    R0,??DataTable58_6
   \   0000060E   0x.... 0x....      LDR.W    R1,??DataTable59_4
   \   00000612   0x7809             LDRB     R1,[R1, #+0]
   \   00000614   0x2203             MOVS     R2,#+3
   \   00000616   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000061A   0x7800             LDRB     R0,[R0, #+0]
  11415                    for(i = BlackLeftHeadLine-3; i > (BlackLeftHeadLine-AngleHeadLineNum); i--)
   \   0000061C   0x.... 0x....      LDR.W    R1,??DataTable59_4
   \   00000620   0x7809             LDRB     R1,[R1, #+0]
   \   00000622   0x1EC9             SUBS     R1,R1,#+3
   \   00000624   0xE004             B.N      ??AngleStep1Judge_50
  11416                    {
  11417                      //与右线白点阈值进行比较，必须大于白点阈值。
  11418                      if(ImgNew[i][col] < LimitLeftW - AngleWhiteAreaLimitVal)
  11419                      {
  11420                        flag222 = 10;
  11421                        //只要有一个点不满足，即判定不是直角弯。
  11422                        break;
  11423                      }
  11424                      else
  11425                      {
  11426                        flag222 = 0;
   \                     ??AngleStep1Judge_51: (+1)
   \   00000626   0x2200             MOVS     R2,#+0
   \   00000628   0x.... 0x....      LDR.W    R3,??DataTable60_7
   \   0000062C   0x601A             STR      R2,[R3, #+0]
  11427                      }
   \   0000062E   0x1E49             SUBS     R1,R1,#+1
   \                     ??AngleStep1Judge_50: (+1)
   \   00000630   0x.... 0x....      LDR.W    R2,??DataTable59_4
   \   00000634   0x7812             LDRB     R2,[R2, #+0]
   \   00000636   0x.... 0x....      LDR.W    R3,??DataTable59_5
   \   0000063A   0x781B             LDRB     R3,[R3, #+0]
   \   0000063C   0x1AD2             SUBS     R2,R2,R3
   \   0000063E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000640   0x428A             CMP      R2,R1
   \   00000642   0xDA10             BGE.N    ??AngleStep1Judge_52
   \   00000644   0x....             LDR.N    R2,??DataTable58_10
   \   00000646   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000648   0x23FA             MOVS     R3,#+250
   \   0000064A   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   0000064E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000650   0x5C82             LDRB     R2,[R0, R2]
   \   00000652   0x.... 0x....      LDR.W    R3,??DataTable61_1
   \   00000656   0x781B             LDRB     R3,[R3, #+0]
   \   00000658   0x3B14             SUBS     R3,R3,#+20
   \   0000065A   0x429A             CMP      R2,R3
   \   0000065C   0xDAE3             BGE.N    ??AngleStep1Judge_51
   \   0000065E   0x220A             MOVS     R2,#+10
   \   00000660   0x.... 0x....      LDR.W    R3,??DataTable60_7
   \   00000664   0x601A             STR      R2,[R3, #+0]
  11428                    }
  11429                    //从下到上一直满足白点，且最上与最下两个点像素差值够小。
  11430                    if(
  11431                      (i <= BlackLeftHeadLine-AngleHeadLineNum)
  11432                    &&(AbsInt(ImgNew[BlackLeftHeadLine-3][col] - ImgNew[BlackLeftHeadLine-AngleHeadLineNum][col]) < 2 * AngleWhiteAreaLimitVal) //隔的点比较多，允许差值稍微大一些。
  11433                      )
   \                     ??AngleStep1Judge_52: (+1)
   \   00000666   0x.... 0x....      LDR.W    R2,??DataTable59_4
   \   0000066A   0x7812             LDRB     R2,[R2, #+0]
   \   0000066C   0x.... 0x....      LDR.W    R3,??DataTable59_5
   \   00000670   0x781B             LDRB     R3,[R3, #+0]
   \   00000672   0x1AD2             SUBS     R2,R2,R3
   \   00000674   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000676   0x428A             CMP      R2,R1
   \   00000678   0xF2C0 0x80B5      BLT.W    ??AngleStep1Judge_4
   \   0000067C   0x....             LDR.N    R1,??DataTable58_10
   \   0000067E   0x.... 0x....      LDR.W    R2,??DataTable59_4
   \   00000682   0x7812             LDRB     R2,[R2, #+0]
   \   00000684   0x23FA             MOVS     R3,#+250
   \   00000686   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   0000068A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000068C   0x1841             ADDS     R1,R0,R1
   \   0000068E   0xF2A1 0x21EE      SUBW     R1,R1,#+750
   \   00000692   0x7809             LDRB     R1,[R1, #+0]
   \   00000694   0x....             LDR.N    R2,??DataTable58_10
   \   00000696   0x.... 0x....      LDR.W    R3,??DataTable59_4
   \   0000069A   0x781B             LDRB     R3,[R3, #+0]
   \   0000069C   0x.... 0x....      LDR.W    R4,??DataTable59_5
   \   000006A0   0x7824             LDRB     R4,[R4, #+0]
   \   000006A2   0x1B1B             SUBS     R3,R3,R4
   \   000006A4   0x24FA             MOVS     R4,#+250
   \   000006A6   0xFB04 0x2203      MLA      R2,R4,R3,R2
   \   000006AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000006AC   0x5C80             LDRB     R0,[R0, R2]
   \   000006AE   0x1A08             SUBS     R0,R1,R0
   \   000006B0   0x.... 0x....      BL       AbsInt
   \   000006B4   0x2828             CMP      R0,#+40
   \   000006B6   0xF280 0x8096      BGE.W    ??AngleStep1Judge_4
  11434                    {
  11435                      //5.2. 一横
  11436                      check_row = BlackLeftHeadLine - AngleHeadLineNum / 2;
   \   000006BA   0x.... 0x....      LDR.W    R0,??DataTable59_4
   \   000006BE   0x7800             LDRB     R0,[R0, #+0]
   \   000006C0   0x.... 0x....      LDR.W    R1,??DataTable59_5
   \   000006C4   0x7809             LDRB     R1,[R1, #+0]
   \   000006C6   0x2202             MOVS     R2,#+2
   \   000006C8   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   000006CC   0x1A44             SUBS     R4,R0,R1
  11437                      //一横的左边界
  11438                      //不能小于图像左边界
  11439                      leftborder = MaxRe(0, BlackLeftLoc[BlackLeftHeadLine][0] - 15);
   \   000006CE   0x....             LDR.N    R0,??DataTable58_6
   \   000006D0   0x.... 0x....      LDR.W    R1,??DataTable59_4
   \   000006D4   0x7809             LDRB     R1,[R1, #+0]
   \   000006D6   0x2203             MOVS     R2,#+3
   \   000006D8   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000006DC   0x7800             LDRB     R0,[R0, #+0]
   \   000006DE   0xF1B0 0x010F      SUBS     R1,R0,#+15
   \   000006E2   0x2000             MOVS     R0,#+0
   \   000006E4   0x.... 0x....      BL       MaxRe
   \   000006E8   0x0005             MOVS     R5,R0
  11440                      leftbordercal = MaxRe(0, BlackLeftLoc[BlackLeftHeadLine][0] - 15);
   \   000006EA   0x....             LDR.N    R0,??DataTable58_6
   \   000006EC   0x.... 0x....      LDR.W    R1,??DataTable59_4
   \   000006F0   0x7809             LDRB     R1,[R1, #+0]
   \   000006F2   0x2203             MOVS     R2,#+3
   \   000006F4   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000006F8   0x7800             LDRB     R0,[R0, #+0]
   \   000006FA   0xF1B0 0x010F      SUBS     R1,R0,#+15
   \   000006FE   0x2000             MOVS     R0,#+0
   \   00000700   0x.... 0x....      BL       MaxRe
   \   00000704   0x0006             MOVS     R6,R0
  11441                      //一横的右边界。
  11442                      rightborder = MinRe(CameraRealWidth - 1, BlackLeftLoc[BlackLeftHeadLine][0] + 15);
   \   00000706   0x....             LDR.N    R0,??DataTable58_6
   \   00000708   0x.... 0x....      LDR.W    R1,??DataTable59_4
   \   0000070C   0x7809             LDRB     R1,[R1, #+0]
   \   0000070E   0x2203             MOVS     R2,#+3
   \   00000710   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000714   0x7800             LDRB     R0,[R0, #+0]
   \   00000716   0xF110 0x010F      ADDS     R1,R0,#+15
   \   0000071A   0x20F9             MOVS     R0,#+249
   \   0000071C   0x.... 0x....      BL       MinRe
   \   00000720   0x0007             MOVS     R7,R0
  11443                      rightbordercal = MinRe(CameraRealWidth - 1, BlackLeftLoc[BlackLeftHeadLine][0] + 15);
   \   00000722   0x....             LDR.N    R0,??DataTable58_6
   \   00000724   0x.... 0x....      LDR.W    R1,??DataTable59_4
   \   00000728   0x7809             LDRB     R1,[R1, #+0]
   \   0000072A   0x2203             MOVS     R2,#+3
   \   0000072C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000730   0x7800             LDRB     R0,[R0, #+0]
   \   00000732   0xF110 0x010F      ADDS     R1,R0,#+15
   \   00000736   0x20F9             MOVS     R0,#+249
   \   00000738   0x.... 0x....      BL       MinRe
   \   0000073C   0x4680             MOV      R8,R0
  11444                      //不能比该行有效右黑线还大
  11445                      if(BlackRightLoc[check_row][0] != MaxValUint8)
   \   0000073E   0x....             LDR.N    R0,??DataTable58_8
   \   00000740   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000742   0x2103             MOVS     R1,#+3
   \   00000744   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000748   0x7800             LDRB     R0,[R0, #+0]
   \   0000074A   0x28FF             CMP      R0,#+255
   \   0000074C   0xD016             BEQ.N    ??AngleStep1Judge_53
  11446                      {
  11447                        rightborder = MinRe(BlackRightLoc[check_row][0], rightborder);
   \   0000074E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000750   0x0039             MOVS     R1,R7
   \   00000752   0x....             LDR.N    R0,??DataTable58_8
   \   00000754   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000756   0x2203             MOVS     R2,#+3
   \   00000758   0xFB02 0x0004      MLA      R0,R2,R4,R0
   \   0000075C   0x7800             LDRB     R0,[R0, #+0]
   \   0000075E   0x.... 0x....      BL       MinRe
   \   00000762   0x0007             MOVS     R7,R0
  11448                        rightbordercal = MinRe(BlackRightLoc[check_row][0], rightbordercal);
   \   00000764   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000768   0x4641             MOV      R1,R8
   \   0000076A   0x....             LDR.N    R0,??DataTable58_8
   \   0000076C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000076E   0x2203             MOVS     R2,#+3
   \   00000770   0xFB02 0x0004      MLA      R0,R2,R4,R0
   \   00000774   0x7800             LDRB     R0,[R0, #+0]
   \   00000776   0x.... 0x....      BL       MinRe
   \   0000077A   0x4680             MOV      R8,R0
  11449                      }
  11450                      else
  11451                      {
  11452                      }
  11453                      //从左到右进行白点检查
  11454                      for(j = leftborder; j < rightborder; j++)
   \                     ??AngleStep1Judge_53: (+1)
   \   0000077C   0xE000             B.N      ??AngleStep1Judge_54
   \                     ??AngleStep1Judge_55: (+1)
   \   0000077E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??AngleStep1Judge_54: (+1)
   \   00000780   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000782   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000784   0x42BD             CMP      R5,R7
   \   00000786   0xD20C             BCS.N    ??AngleStep1Judge_56
  11455                      {
  11456                        if(ImgNew[check_row][j] < LimitLeftW - AngleWhiteAreaLimitVal) break;              
   \   00000788   0x....             LDR.N    R0,??DataTable58_10
   \   0000078A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000078C   0x21FA             MOVS     R1,#+250
   \   0000078E   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000792   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000794   0x5C28             LDRB     R0,[R5, R0]
   \   00000796   0x.... 0x....      LDR.W    R1,??DataTable61_1
   \   0000079A   0x7809             LDRB     R1,[R1, #+0]
   \   0000079C   0x3914             SUBS     R1,R1,#+20
   \   0000079E   0x4288             CMP      R0,R1
   \   000007A0   0xDAED             BGE.N    ??AngleStep1Judge_55
  11457                      }
  11458                      //从左到右一直满足白点，且最左最右两点差值够小，进入第6步。
  11459                      if(
  11460                        (j >= rightborder) 
  11461                      &&(AbsInt(ImgNew[check_row][leftbordercal] - ImgNew[check_row][rightbordercal]) < 2 * AngleWhiteAreaLimitVal)
  11462                        )
   \                     ??AngleStep1Judge_56: (+1)
   \   000007A2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000007A4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000007A6   0x42BD             CMP      R5,R7
   \   000007A8   0xD31D             BCC.N    ??AngleStep1Judge_4
   \   000007AA   0x....             LDR.N    R0,??DataTable58_10
   \   000007AC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000007AE   0x21FA             MOVS     R1,#+250
   \   000007B0   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000007B4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000007B6   0x5C30             LDRB     R0,[R6, R0]
   \   000007B8   0x....             LDR.N    R1,??DataTable58_10
   \   000007BA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000007BC   0x22FA             MOVS     R2,#+250
   \   000007BE   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000007C2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000007C6   0xF818 0x1001      LDRB     R1,[R8, R1]
   \   000007CA   0x1A40             SUBS     R0,R0,R1
   \   000007CC   0x.... 0x....      BL       AbsInt
   \   000007D0   0x2828             CMP      R0,#+40
   \   000007D2   0xDA08             BGE.N    ??AngleStep1Judge_4
  11463                      {
  11464                        //6. 非左障碍确认成功，则最终确认是左直角。
  11465                        if(AngleStep1JudgeNotBrick(0) == 1)
   \   000007D4   0x2000             MOVS     R0,#+0
   \   000007D6   0x.... 0x....      BL       AngleStep1JudgeNotBrick
   \   000007DA   0x2801             CMP      R0,#+1
   \   000007DC   0xD103             BNE.N    ??AngleStep1Judge_4
  11466                        {
  11467                          PathType = PathTypeAngleL;
   \   000007DE   0x2004             MOVS     R0,#+4
   \   000007E0   0x.... 0x....      LDR.W    R1,??DataTable61
   \   000007E4   0x7008             STRB     R0,[R1, #+0]
  11468                        }
  11469                        else
  11470                        {
  11471                        }
  11472                      }
  11473                      else
  11474                      {
  11475                      }            
  11476                    }
  11477                    else
  11478                    {
  11479                    }
  11480                }
  11481                //否则仍为直道
  11482                else
  11483                {
  11484                }
  11485            }
  11486            //否则保持直道不变。
  11487            else
  11488            {
  11489            }
  11490            return 1;
   \                     ??AngleStep1Judge_4: (+1)
   \   000007E6   0x2001             MOVS     R0,#+1
   \                     ??AngleStep1Judge_2: (+1)
   \   000007E8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
  11491            
  11492          }
  11493          
  11494          
  11495          
  11496          
  11497          //======================================================================
  11498          //函数名：PathLCRAngle1Judge
  11499          //功  能：直道、左弯、右弯判断，直角弯第1阶段预判。
  11500          //参  数：
  11501          //返  回：1成功，0失败。
  11502          //影  响：
  11503          //说  明：1. 只有在斜曲率求取失败时才会返回0，否则只会返回1. 
  11504          //        2. 在左右黑线都求取成功的时候，会进行直角弯第1阶段预判。
  11505          //             
  11506          //======================================================================

   \                                 In section .text, align 2, keep-with-next
  11507          uint8 PathLCRAngle1Judge(void)
  11508          {
   \                     PathLCRAngle1Judge: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
  11509            
  11510            //ErrorGet();
  11511            int32 AbsSlopeC;
  11512            uint8 curvetempLL, curvetempLR, curvetempRL, curvetempRR;
  11513            uint8 slopetempLL, slopetempLR, slopetempRL, slopetempRR;
  11514            
  11515            //以下是一套以斜率为主导的赛道类型判断方法
  11516          
  11517            //赛道类型PathType: 0未知 1直道 2左内 3左中 4左外 5右内 6右中 7右外
  11518            PathType = PathTypeUnknown;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable61
   \   00000008   0x7008             STRB     R0,[R1, #+0]
  11519            //曲率符号获取成功
  11520            //如果CurveSlopeGet()返回0，则代表3条线的曲率、斜率均求取失败，不用进行下面的判断。
  11521            if(CurveSlopeGet() == 1)
   \   0000000A   0x.... 0x....      BL       CurveSlopeGet
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xF040 0x8208      BNE.W    ??PathLCRAngle1Judge_0
  11522            {
  11523              //先将绝对值求出来，后面就不用反复使用了。
  11524              AbsSlopeC = AbsInt(SlopeC);
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable61_2
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x.... 0x....      BL       AbsInt
  11525              //AbsSlopeL = AbsSelfFloat(SlopeL);
  11526              //AbsSlopeR = AbsSelfFloat(SlopeR);
  11527              //不用判断中心线成功，到这里了肯定是成功的。
  11528              //此时中心线的曲率、斜率一定存在，左线或者右线不一定。
  11529              //下面用来“或”的时候用,对于曲率来说，左负右正。对于斜率来说，左正右负。
  11530              curvetempRL = (CurveSlopeFlagL == 1 && (CURVEL > CurveStraightLimitL));        //如果该线曲率无效，就为0，如果有效，就有可能为1.用以判断左线曲率是否朝右。
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable61_3
   \   00000022   0x7809             LDRB     R1,[R1, #+0]
   \   00000024   0x2901             CMP      R1,#+1
   \   00000026   0xD107             BNE.N    ??PathLCRAngle1Judge_1
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable59_8
   \   0000002C   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   00000030   0x291F             CMP      R1,#+31
   \   00000032   0xDB01             BLT.N    ??PathLCRAngle1Judge_1
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0xE000             B.N      ??PathLCRAngle1Judge_2
   \                     ??PathLCRAngle1Judge_1: (+1)
   \   00000038   0x2100             MOVS     R1,#+0
  11531              curvetempRR = (CurveSlopeFlagR == 1 && (CURVER > CurveStraightLimitR));        //如果该线曲率无效，就为0，如果有效，就有可能为1.用以判断右线曲率是否朝右。
   \                     ??PathLCRAngle1Judge_2: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R2,??DataTable61_4
   \   0000003E   0x7812             LDRB     R2,[R2, #+0]
   \   00000040   0x2A01             CMP      R2,#+1
   \   00000042   0xD107             BNE.N    ??PathLCRAngle1Judge_3
   \   00000044   0x.... 0x....      LDR.W    R2,??DataTable61_5
   \   00000048   0xF9B2 0x2000      LDRSH    R2,[R2, #+0]
   \   0000004C   0x2A1F             CMP      R2,#+31
   \   0000004E   0xDB01             BLT.N    ??PathLCRAngle1Judge_3
   \   00000050   0x2201             MOVS     R2,#+1
   \   00000052   0xE000             B.N      ??PathLCRAngle1Judge_4
   \                     ??PathLCRAngle1Judge_3: (+1)
   \   00000054   0x2200             MOVS     R2,#+0
  11532              curvetempLL = (CurveSlopeFlagL == 1 && (CURVEL + CurveStraightLimitL < 0));    //如果该线曲率无效，就为0，如果有效，就有可能为1.用以判断左线曲率是否朝左。          
   \                     ??PathLCRAngle1Judge_4: (+1)
   \   00000056   0x.... 0x....      LDR.W    R3,??DataTable61_3
   \   0000005A   0x781B             LDRB     R3,[R3, #+0]
   \   0000005C   0x2B01             CMP      R3,#+1
   \   0000005E   0xD108             BNE.N    ??PathLCRAngle1Judge_5
   \   00000060   0x.... 0x....      LDR.W    R3,??DataTable59_8
   \   00000064   0xF9B3 0x3000      LDRSH    R3,[R3, #+0]
   \   00000068   0x331E             ADDS     R3,R3,#+30
   \   0000006A   0x2B00             CMP      R3,#+0
   \   0000006C   0xD501             BPL.N    ??PathLCRAngle1Judge_5
   \   0000006E   0x2301             MOVS     R3,#+1
   \   00000070   0xE000             B.N      ??PathLCRAngle1Judge_6
   \                     ??PathLCRAngle1Judge_5: (+1)
   \   00000072   0x2300             MOVS     R3,#+0
  11533              curvetempLR = (CurveSlopeFlagR == 1 && (CURVER + CurveStraightLimitR < 0));    //如果该线曲率无效，就为0，如果有效，就有可能为1.用以判断右线曲率是否朝左。  
   \                     ??PathLCRAngle1Judge_6: (+1)
   \   00000074   0x.... 0x....      LDR.W    R4,??DataTable61_4
   \   00000078   0x7824             LDRB     R4,[R4, #+0]
   \   0000007A   0x2C01             CMP      R4,#+1
   \   0000007C   0xD108             BNE.N    ??PathLCRAngle1Judge_7
   \   0000007E   0x.... 0x....      LDR.W    R4,??DataTable61_5
   \   00000082   0xF9B4 0x4000      LDRSH    R4,[R4, #+0]
   \   00000086   0x341E             ADDS     R4,R4,#+30
   \   00000088   0x2C00             CMP      R4,#+0
   \   0000008A   0xD501             BPL.N    ??PathLCRAngle1Judge_7
   \   0000008C   0x2401             MOVS     R4,#+1
   \   0000008E   0xE000             B.N      ??PathLCRAngle1Judge_8
   \                     ??PathLCRAngle1Judge_7: (+1)
   \   00000090   0x2400             MOVS     R4,#+0
  11534              slopetempRL = (CurveSlopeFlagL == 1 && (SlopeL + SlopeLimitL < 0));            //如果该线斜率无效，就为0，如果有效，就有可能为1.用以判断左线斜率是否朝右。
   \                     ??PathLCRAngle1Judge_8: (+1)
   \   00000092   0x.... 0x....      LDR.W    R5,??DataTable61_3
   \   00000096   0x782D             LDRB     R5,[R5, #+0]
   \   00000098   0x2D01             CMP      R5,#+1
   \   0000009A   0xD108             BNE.N    ??PathLCRAngle1Judge_9
   \   0000009C   0x.... 0x....      LDR.W    R5,??DataTable61_6
   \   000000A0   0x682D             LDR      R5,[R5, #+0]
   \   000000A2   0xF205 0x55DC      ADDW     R5,R5,#+1500
   \   000000A6   0x2D00             CMP      R5,#+0
   \   000000A8   0xD501             BPL.N    ??PathLCRAngle1Judge_9
   \   000000AA   0x2501             MOVS     R5,#+1
   \   000000AC   0xE000             B.N      ??PathLCRAngle1Judge_10
   \                     ??PathLCRAngle1Judge_9: (+1)
   \   000000AE   0x2500             MOVS     R5,#+0
  11535              slopetempRR = (CurveSlopeFlagR == 1 && (SlopeR + SlopeLimitR < 0));            //如果该线斜率无效，就为0，如果有效，就有可能为1.用以判断右线斜率是否朝右。
   \                     ??PathLCRAngle1Judge_10: (+1)
   \   000000B0   0x.... 0x....      LDR.W    R6,??DataTable61_4
   \   000000B4   0x7836             LDRB     R6,[R6, #+0]
   \   000000B6   0x2E01             CMP      R6,#+1
   \   000000B8   0xD108             BNE.N    ??PathLCRAngle1Judge_11
   \   000000BA   0x.... 0x....      LDR.W    R6,??DataTable61_7
   \   000000BE   0x6836             LDR      R6,[R6, #+0]
   \   000000C0   0xF206 0x56DC      ADDW     R6,R6,#+1500
   \   000000C4   0x2E00             CMP      R6,#+0
   \   000000C6   0xD501             BPL.N    ??PathLCRAngle1Judge_11
   \   000000C8   0x2601             MOVS     R6,#+1
   \   000000CA   0xE000             B.N      ??PathLCRAngle1Judge_12
   \                     ??PathLCRAngle1Judge_11: (+1)
   \   000000CC   0x2600             MOVS     R6,#+0
  11536              slopetempLL = (CurveSlopeFlagL == 1 && (SlopeL > SlopeLimitL));                //如果该线斜率无效，就为0，如果有效，就有可能为1.用以判断左线斜率是否朝左。
   \                     ??PathLCRAngle1Judge_12: (+1)
   \   000000CE   0x.... 0x....      LDR.W    R7,??DataTable61_3
   \   000000D2   0x783F             LDRB     R7,[R7, #+0]
   \   000000D4   0x2F01             CMP      R7,#+1
   \   000000D6   0xD108             BNE.N    ??PathLCRAngle1Judge_13
   \   000000D8   0x.... 0x....      LDR.W    R7,??DataTable61_6
   \   000000DC   0x683F             LDR      R7,[R7, #+0]
   \   000000DE   0xF240 0x5CDD      MOVW     R12,#+1501
   \   000000E2   0x4567             CMP      R7,R12
   \   000000E4   0xDB01             BLT.N    ??PathLCRAngle1Judge_13
   \   000000E6   0x2701             MOVS     R7,#+1
   \   000000E8   0xE000             B.N      ??PathLCRAngle1Judge_14
   \                     ??PathLCRAngle1Judge_13: (+1)
   \   000000EA   0x2700             MOVS     R7,#+0
  11537              slopetempLR = (CurveSlopeFlagR == 1 && (SlopeR > SlopeLimitR));                //如果该线斜率无效，就为0，如果有效，就有可能为1.用以判断右线斜率是否朝左。
   \                     ??PathLCRAngle1Judge_14: (+1)
   \   000000EC   0x.... 0x....      LDR.W    R12,??DataTable61_4
   \   000000F0   0xF89C 0xC000      LDRB     R12,[R12, #+0]
   \   000000F4   0xF1BC 0x0F01      CMP      R12,#+1
   \   000000F8   0xD10A             BNE.N    ??PathLCRAngle1Judge_15
   \   000000FA   0x.... 0x....      LDR.W    R12,??DataTable61_7
   \   000000FE   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   00000102   0xF240 0x5EDD      MOVW     LR,#+1501
   \   00000106   0x45F4             CMP      R12,LR
   \   00000108   0xDB02             BLT.N    ??PathLCRAngle1Judge_15
   \   0000010A   0xF05F 0x0C01      MOVS     R12,#+1
   \   0000010E   0xE001             B.N      ??PathLCRAngle1Judge_16
   \                     ??PathLCRAngle1Judge_15: (+1)
   \   00000110   0xF05F 0x0C00      MOVS     R12,#+0
  11538              //下面用来“与”的时候用
  11539              /*
  11540              tempRL = ((CurveSlopeFlagL && (CURVEL > CurveStraightLimitL)) //如果该线曲率有效，则该逻辑就有可能是0。
  11541                    ||(!CurveSlopeFlagL)                                   //如果该线曲率无效，则该逻辑就一定是1.
  11542                      );
  11543              tempRR = ((CurveSlopeFlagR && (CURVER > CurveStraightLimitR)) //如果该线曲率有效，则该逻辑就有可能是0。
  11544                    ||(!CurveSlopeFlagR)                                   //如果该线曲率无效，则该逻辑就一定是1.
  11545                      );
  11546              tempLL = ((CurveSlopeFlagL && (CURVEL + CurveStraightLimitL < 0)) //如果该线曲率有效，则该逻辑就有可能是0。
  11547                    ||(!CurveSlopeFlagL)                                   //如果该线曲率无效，则该逻辑就一定是1.
  11548                      );
  11549              tempLR = ((CurveSlopeFlagR && (CURVER + CurveStraightLimitR < 0)) //如果该线曲率有效，则该逻辑就有可能是0。
  11550                    ||(!CurveSlopeFlagR)                                   //如果该线曲率无效，则该逻辑就一定是1.
  11551                      );
  11552              */
  11553                //1. 左右黑线均提取成功的情况。
  11554                if(BlackLeftDone == 1 && BlackRightDone == 1)
   \                     ??PathLCRAngle1Judge_16: (+1)
   \   00000114   0x.... 0x....      LDR.W    LR,??DataTable59_1
   \   00000118   0xF89E 0xE000      LDRB     LR,[LR, #+0]
   \   0000011C   0xF1BE 0x0F01      CMP      LR,#+1
   \   00000120   0xF040 0x8082      BNE.W    ??PathLCRAngle1Judge_17
   \   00000124   0x.... 0x....      LDR.W    LR,??DataTable59_2
   \   00000128   0xF89E 0xE000      LDRB     LR,[LR, #+0]
   \   0000012C   0xF1BE 0x0F01      CMP      LR,#+1
   \   00000130   0xD17A             BNE.N    ??PathLCRAngle1Judge_17
  11555                {
  11556                //1.1. 中心线斜率足够正。这一步避免了270度弯曲率小斜率大的判断失误问题。
  11557                if(AbsSlopeC <= SlopeLimitC)
   \   00000132   0xF240 0x5EDD      MOVW     LR,#+1501
   \   00000136   0x4570             CMP      R0,LR
   \   00000138   0xDA32             BGE.N    ??PathLCRAngle1Judge_18
  11558                {
  11559                  //1.1.1. 左、右线曲率里只要有一条比较大，且向右，那么判断为右弯。        
  11560                  if(
  11561                     //(CURVEC > CurveStraightLimitC)
  11562                      (curvetempRL)
  11563                   || (curvetempRR)
  11564                     )
   \   0000013A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000013C   0x2900             CMP      R1,#+0
   \   0000013E   0xD102             BNE.N    ??PathLCRAngle1Judge_19
   \   00000140   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000142   0x2A00             CMP      R2,#+0
   \   00000144   0xD00F             BEQ.N    ??PathLCRAngle1Judge_20
  11565                  {//1.1.1.1. 左右黑线斜率里只要有一条比较大，且向右，那么判断为右弯。
  11566                    if((slopetempRL)
  11567                    || (slopetempRR)
  11568                        )
   \                     ??PathLCRAngle1Judge_19: (+1)
   \   00000146   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000148   0x2D00             CMP      R5,#+0
   \   0000014A   0xD102             BNE.N    ??PathLCRAngle1Judge_21
   \   0000014C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000014E   0x2E00             CMP      R6,#+0
   \   00000150   0xD004             BEQ.N    ??PathLCRAngle1Judge_22
  11569                    {
  11570                      PathType = PathTypeRight;
   \                     ??PathLCRAngle1Judge_21: (+1)
   \   00000152   0x2003             MOVS     R0,#+3
   \   00000154   0x.... 0x....      LDR.W    R1,??DataTable61
   \   00000158   0x7008             STRB     R0,[R1, #+0]
   \   0000015A   0xE05C             B.N      ??PathLCRAngle1Judge_23
  11571                    }
  11572                    //1.1.1.2. 左右黑线斜率都不大，就算曲率比较大，也判断为直道。
  11573                    else
  11574                    {
  11575                        PathType = PathTypeStraight;
   \                     ??PathLCRAngle1Judge_22: (+1)
   \   0000015C   0x2001             MOVS     R0,#+1
   \   0000015E   0x.... 0x....      LDR.W    R1,??DataTable61
   \   00000162   0x7008             STRB     R0,[R1, #+0]
   \   00000164   0xE057             B.N      ??PathLCRAngle1Judge_23
  11576                    }
  11577                    
  11578                  }
  11579                  //1.1.2. 左、右线曲率里只要有一条比较大，且向左，那么判断为左弯。
  11580                  else if(
  11581                         //(CURVEC + CurveStraightLimitC < 0)
  11582                           (curvetempLL)
  11583                        || (curvetempLR)
  11584                          )
   \                     ??PathLCRAngle1Judge_20: (+1)
   \   00000166   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000168   0x2B00             CMP      R3,#+0
   \   0000016A   0xD102             BNE.N    ??PathLCRAngle1Judge_24
   \   0000016C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000016E   0x2C00             CMP      R4,#+0
   \   00000170   0xD011             BEQ.N    ??PathLCRAngle1Judge_25
  11585                  {   //1.1.2.1. 左右黑线斜率里只要有一条比较大，且向左，那么判断为左弯。
  11586                      if((slopetempLL)
  11587                      || (slopetempLR)
  11588                        )
   \                     ??PathLCRAngle1Judge_24: (+1)
   \   00000172   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000174   0x2F00             CMP      R7,#+0
   \   00000176   0xD104             BNE.N    ??PathLCRAngle1Judge_26
   \   00000178   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   0000017C   0xF1BC 0x0F00      CMP      R12,#+0
   \   00000180   0xD004             BEQ.N    ??PathLCRAngle1Judge_27
  11589                      {
  11590                          PathType = PathTypeLeft;
   \                     ??PathLCRAngle1Judge_26: (+1)
   \   00000182   0x2002             MOVS     R0,#+2
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable61
   \   00000188   0x7008             STRB     R0,[R1, #+0]
   \   0000018A   0xE044             B.N      ??PathLCRAngle1Judge_23
  11591                      }
  11592                      //1.1.2.2. 左右黑线斜率都不大，就算斜率比较大，也判断为直道。
  11593                      else
  11594                      {
  11595                          PathType = PathTypeStraight;
   \                     ??PathLCRAngle1Judge_27: (+1)
   \   0000018C   0x2001             MOVS     R0,#+1
   \   0000018E   0x.... 0x....      LDR.W    R1,??DataTable61
   \   00000192   0x7008             STRB     R0,[R1, #+0]
   \   00000194   0xE03F             B.N      ??PathLCRAngle1Judge_23
  11596                      }         
  11597                  }
  11598                  //1.1.3. 左、右线曲率都不大，那么就判断为直道。
  11599                  else
  11600                  {
  11601                    PathType = PathTypeStraight;
   \                     ??PathLCRAngle1Judge_25: (+1)
   \   00000196   0x2001             MOVS     R0,#+1
   \   00000198   0x.... 0x....      LDR.W    R1,??DataTable61
   \   0000019C   0x7008             STRB     R0,[R1, #+0]
   \   0000019E   0xE03A             B.N      ??PathLCRAngle1Judge_23
  11602                   
  11603                  }
  11604                }
  11605                //1.2. 斜率向左偏，最有可能是左道。对于斜率来说，向左是正，向右是负。
  11606                else if(SlopeC > SlopeLimitC)
   \                     ??PathLCRAngle1Judge_18: (+1)
   \   000001A0   0x.... 0x....      LDR.W    R0,??DataTable61_2
   \   000001A4   0x6800             LDR      R0,[R0, #+0]
   \   000001A6   0xF240 0x5EDD      MOVW     LR,#+1501
   \   000001AA   0x4570             CMP      R0,LR
   \   000001AC   0xDB17             BLT.N    ??PathLCRAngle1Judge_28
  11607                { //1.2.1. 三线只要有一个曲率比较大，且向左，就判断为左道。
  11608                  //左右黑线斜率里只要有一条比较大，且向左，那么判断为左弯。
  11609                  if(
  11610                     //(CURVEC + CurveStraightLimitC < 0)
  11611                     (curvetempLL)
  11612                  || (curvetempLR)
  11613                  || (slopetempLL)
  11614                  || (slopetempLR)
  11615                    )
   \   000001AE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001B0   0x2B00             CMP      R3,#+0
   \   000001B2   0xD10A             BNE.N    ??PathLCRAngle1Judge_29
   \   000001B4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001B6   0x2C00             CMP      R4,#+0
   \   000001B8   0xD107             BNE.N    ??PathLCRAngle1Judge_29
   \   000001BA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001BC   0x2F00             CMP      R7,#+0
   \   000001BE   0xD104             BNE.N    ??PathLCRAngle1Judge_29
   \   000001C0   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   000001C4   0xF1BC 0x0F00      CMP      R12,#+0
   \   000001C8   0xD004             BEQ.N    ??PathLCRAngle1Judge_30
  11616                  {
  11617                    PathType = PathTypeLeft;
   \                     ??PathLCRAngle1Judge_29: (+1)
   \   000001CA   0x2002             MOVS     R0,#+2
   \   000001CC   0x.... 0x....      LDR.W    R1,??DataTable61
   \   000001D0   0x7008             STRB     R0,[R1, #+0]
   \   000001D2   0xE020             B.N      ??PathLCRAngle1Judge_23
  11618                  }
  11619                  //1.2.2. 否则就是直道。
  11620                  else
  11621                  {
  11622                    PathType = PathTypeStraight;
   \                     ??PathLCRAngle1Judge_30: (+1)
   \   000001D4   0x2001             MOVS     R0,#+1
   \   000001D6   0x.... 0x....      LDR.W    R1,??DataTable61
   \   000001DA   0x7008             STRB     R0,[R1, #+0]
   \   000001DC   0xE01B             B.N      ??PathLCRAngle1Judge_23
  11623                  }
  11624                }
  11625                //1.3. 斜率向右偏，最有可能是右道。
  11626                else if(SlopeC + SlopeLimitC < 0)
   \                     ??PathLCRAngle1Judge_28: (+1)
   \   000001DE   0x.... 0x....      LDR.W    R0,??DataTable61_2
   \   000001E2   0x6800             LDR      R0,[R0, #+0]
   \   000001E4   0xF200 0x50DC      ADDW     R0,R0,#+1500
   \   000001E8   0x2800             CMP      R0,#+0
   \   000001EA   0xD514             BPL.N    ??PathLCRAngle1Judge_23
  11627                {
  11628                  //1.3.1. 三线只要有一个曲率比较大，且向右，就判断为右道。
  11629                  //左右黑线斜率里只要有一条比较大，且向右，那么判断为右弯。
  11630                  if(
  11631                     //(CURVEC > CurveStraightLimitC)
  11632                      (curvetempRL)
  11633                   || (curvetempRR)
  11634                   || (slopetempRL)
  11635                   || (slopetempRR)
  11636                     )
   \   000001EC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001EE   0x2900             CMP      R1,#+0
   \   000001F0   0xD108             BNE.N    ??PathLCRAngle1Judge_31
   \   000001F2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001F4   0x2A00             CMP      R2,#+0
   \   000001F6   0xD105             BNE.N    ??PathLCRAngle1Judge_31
   \   000001F8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001FA   0x2D00             CMP      R5,#+0
   \   000001FC   0xD102             BNE.N    ??PathLCRAngle1Judge_31
   \   000001FE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000200   0x2E00             CMP      R6,#+0
   \   00000202   0xD004             BEQ.N    ??PathLCRAngle1Judge_32
  11637                  {
  11638                    PathType = PathTypeRight;
   \                     ??PathLCRAngle1Judge_31: (+1)
   \   00000204   0x2003             MOVS     R0,#+3
   \   00000206   0x.... 0x....      LDR.W    R1,??DataTable61
   \   0000020A   0x7008             STRB     R0,[R1, #+0]
   \   0000020C   0xE003             B.N      ??PathLCRAngle1Judge_23
  11639                  }
  11640                  //1.3.2. 否则就是直道。
  11641                  else
  11642                  {
  11643                    PathType = PathTypeStraight;
   \                     ??PathLCRAngle1Judge_32: (+1)
   \   0000020E   0x2001             MOVS     R0,#+1
   \   00000210   0x.... 0x....      LDR.W    R1,??DataTable61
   \   00000214   0x7008             STRB     R0,[R1, #+0]
  11644                  }        
  11645                }
  11646                //1.4. 理论上不会走到这里。
  11647                else
  11648                {
  11649                }
  11650                
  11651                //若判断为直道，则启动直角弯单独检测。
  11652                if(PathType == PathTypeStraight)
   \                     ??PathLCRAngle1Judge_23: (+1)
   \   00000216   0x.... 0x....      LDR.W    R0,??DataTable61
   \   0000021A   0x7800             LDRB     R0,[R0, #+0]
   \   0000021C   0x2801             CMP      R0,#+1
   \   0000021E   0xF040 0x80FF      BNE.W    ??PathLCRAngle1Judge_33
  11653                {
  11654                  AngleStep1Judge();
   \   00000222   0x.... 0x....      BL       AngleStep1Judge
   \   00000226   0xE0FB             B.N      ??PathLCRAngle1Judge_33
  11655                }
  11656                else
  11657                {
  11658                }   
  11659                
  11660              }
  11661              //2. 左线提取成功，右线提取失败
  11662              else if(BlackLeftDone == 1 && BlackRightDone == 0)
   \                     ??PathLCRAngle1Judge_17: (+1)
   \   00000228   0x.... 0x....      LDR.W    LR,??DataTable59_1
   \   0000022C   0xF89E 0xE000      LDRB     LR,[LR, #+0]
   \   00000230   0xF1BE 0x0F01      CMP      LR,#+1
   \   00000234   0xD178             BNE.N    ??PathLCRAngle1Judge_34
   \   00000236   0x.... 0x....      LDR.W    LR,??DataTable59_2
   \   0000023A   0xF89E 0xE000      LDRB     LR,[LR, #+0]
   \   0000023E   0xF1BE 0x0F00      CMP      LR,#+0
   \   00000242   0xD171             BNE.N    ??PathLCRAngle1Judge_34
  11663              {
  11664                
  11665                //2.1. 中心线斜率足够正。
  11666                if(AbsSlopeC <= SlopeLimitC)
   \   00000244   0xF240 0x52DD      MOVW     R2,#+1501
   \   00000248   0x4290             CMP      R0,R2
   \   0000024A   0xDA31             BGE.N    ??PathLCRAngle1Judge_35
  11667                {
  11668                  //2.1.1. 中左线曲率里只要有一条比较大，且向右，那么判断为右弯。        
  11669                  if((CURVEC > CurveStraightLimitC)
  11670                   || (curvetempRL)
  11671                     )
   \   0000024C   0x.... 0x....      LDR.W    R0,??DataTable64
   \   00000250   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000254   0x281F             CMP      R0,#+31
   \   00000256   0xDA02             BGE.N    ??PathLCRAngle1Judge_36
   \   00000258   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000025A   0x2900             CMP      R1,#+0
   \   0000025C   0xD00C             BEQ.N    ??PathLCRAngle1Judge_37
  11672                  {   //2.1.1.1. 若左线斜率较大，且向右，那么判断为右弯。
  11673                      if (slopetempRL)
   \                     ??PathLCRAngle1Judge_36: (+1)
   \   0000025E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000260   0x2D00             CMP      R5,#+0
   \   00000262   0xD004             BEQ.N    ??PathLCRAngle1Judge_38
  11674                      {
  11675                          PathType = PathTypeRight;
   \   00000264   0x2003             MOVS     R0,#+3
   \   00000266   0x.... 0x....      LDR.W    R1,??DataTable61
   \   0000026A   0x7008             STRB     R0,[R1, #+0]
   \   0000026C   0xE0D8             B.N      ??PathLCRAngle1Judge_33
  11676                      }
  11677                      //2.1.1.2. 若左线斜率不大，就算曲率较大，也判断为直道。
  11678                      else
  11679                      {
  11680                          PathType = PathTypeStraight;
   \                     ??PathLCRAngle1Judge_38: (+1)
   \   0000026E   0x2001             MOVS     R0,#+1
   \   00000270   0x.... 0x....      LDR.W    R1,??DataTable61
   \   00000274   0x7008             STRB     R0,[R1, #+0]
   \   00000276   0xE0D3             B.N      ??PathLCRAngle1Judge_33
  11681                      }
  11682                    
  11683                  }
  11684                  //2.1.2. 中左线曲率里只要有一条比较大，且向左，那么判断为左弯。
  11685                  else if((CURVEC + CurveStraightLimitC < 0)
  11686                        || (curvetempLL)
  11687                          )
   \                     ??PathLCRAngle1Judge_37: (+1)
   \   00000278   0x.... 0x....      LDR.W    R0,??DataTable64
   \   0000027C   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000280   0x301E             ADDS     R0,R0,#+30
   \   00000282   0x2800             CMP      R0,#+0
   \   00000284   0xD402             BMI.N    ??PathLCRAngle1Judge_39
   \   00000286   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000288   0x2B00             CMP      R3,#+0
   \   0000028A   0xD00C             BEQ.N    ??PathLCRAngle1Judge_40
  11688                  {   //2.1.2.1. 若左线斜率较大，且向左，那么有判断为左弯。
  11689                      if (slopetempLL)
   \                     ??PathLCRAngle1Judge_39: (+1)
   \   0000028C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000028E   0x2F00             CMP      R7,#+0
   \   00000290   0xD004             BEQ.N    ??PathLCRAngle1Judge_41
  11690                      {
  11691                          PathType = PathTypeLeft;
   \   00000292   0x2002             MOVS     R0,#+2
   \   00000294   0x.... 0x....      LDR.W    R1,??DataTable61
   \   00000298   0x7008             STRB     R0,[R1, #+0]
   \   0000029A   0xE0C1             B.N      ??PathLCRAngle1Judge_33
  11692                      }
  11693                      //2.1.2.2. 若在线斜率不大，就算曲率较大，也判断为直道。
  11694                      else
  11695                      {
  11696                          PathType = PathTypeStraight;
   \                     ??PathLCRAngle1Judge_41: (+1)
   \   0000029C   0x2001             MOVS     R0,#+1
   \   0000029E   0x.... 0x....      LDR.W    R1,??DataTable61
   \   000002A2   0x7008             STRB     R0,[R1, #+0]
   \   000002A4   0xE0BC             B.N      ??PathLCRAngle1Judge_33
  11697                      }          
  11698                  }
  11699                  //2.1.3. 曲率都不大，最大值比较小。那么就判断为直道。
  11700                  else
  11701                  {
  11702                    PathType = PathTypeStraight;
   \                     ??PathLCRAngle1Judge_40: (+1)
   \   000002A6   0x2001             MOVS     R0,#+1
   \   000002A8   0x.... 0x....      LDR.W    R1,??DataTable61
   \   000002AC   0x7008             STRB     R0,[R1, #+0]
   \   000002AE   0xE0B7             B.N      ??PathLCRAngle1Judge_33
  11703                  }
  11704                }
  11705                //2.2. 斜率向左偏，最有可能是左道。对于斜率来说，向左是正，向右是负。
  11706                else if(SlopeC > SlopeLimitC)
   \                     ??PathLCRAngle1Judge_35: (+1)
   \   000002B0   0x.... 0x....      LDR.W    R0,??DataTable61_2
   \   000002B4   0x6800             LDR      R0,[R0, #+0]
   \   000002B6   0xF240 0x52DD      MOVW     R2,#+1501
   \   000002BA   0x4290             CMP      R0,R2
   \   000002BC   0xDB16             BLT.N    ??PathLCRAngle1Judge_42
  11707                { //2.2.1. 中左线只要有一个曲率比较大，且向左，就判断为左道。
  11708                  //若左线斜率较大，且向左，就判断为左道。
  11709                  if((CURVEC + CurveStraightLimitC < 0)
  11710                  || (curvetempLL)
  11711                  || (slopetempLL)
  11712                    )
   \   000002BE   0x.... 0x....      LDR.W    R0,??DataTable64
   \   000002C2   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   000002C6   0x301E             ADDS     R0,R0,#+30
   \   000002C8   0x2800             CMP      R0,#+0
   \   000002CA   0xD405             BMI.N    ??PathLCRAngle1Judge_43
   \   000002CC   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000002CE   0x2B00             CMP      R3,#+0
   \   000002D0   0xD102             BNE.N    ??PathLCRAngle1Judge_43
   \   000002D2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002D4   0x2F00             CMP      R7,#+0
   \   000002D6   0xD004             BEQ.N    ??PathLCRAngle1Judge_44
  11713                  {
  11714                    PathType = PathTypeLeft;
   \                     ??PathLCRAngle1Judge_43: (+1)
   \   000002D8   0x2002             MOVS     R0,#+2
   \   000002DA   0x.... 0x....      LDR.W    R1,??DataTable61
   \   000002DE   0x7008             STRB     R0,[R1, #+0]
   \   000002E0   0xE09E             B.N      ??PathLCRAngle1Judge_33
  11715                  }
  11716                  //2.2.2. 否则就是直道。
  11717                  else
  11718                  {
  11719                    PathType = PathTypeStraight;
   \                     ??PathLCRAngle1Judge_44: (+1)
   \   000002E2   0x2001             MOVS     R0,#+1
   \   000002E4   0x.... 0x....      LDR.W    R1,??DataTable61
   \   000002E8   0x7008             STRB     R0,[R1, #+0]
   \   000002EA   0xE099             B.N      ??PathLCRAngle1Judge_33
  11720                  }
  11721                }
  11722                //2.3. 斜率向右偏，最有可能是右道。
  11723                else if(SlopeC + SlopeLimitC < 0)
   \                     ??PathLCRAngle1Judge_42: (+1)
   \   000002EC   0x.... 0x....      LDR.W    R0,??DataTable61_2
   \   000002F0   0x6800             LDR      R0,[R0, #+0]
   \   000002F2   0xF200 0x50DC      ADDW     R0,R0,#+1500
   \   000002F6   0x2800             CMP      R0,#+0
   \   000002F8   0xF140 0x8092      BPL.W    ??PathLCRAngle1Judge_33
  11724                {
  11725                  //2.3.1. 中左线只要有一个曲率比较大，且向右，就判断为右道。
  11726                  //若左线斜率较大，且向右，就判断为右道。
  11727                  if((CURVEC > CurveStraightLimitC)
  11728                   || (curvetempRL)
  11729                   || (slopetempRL)
  11730                     )
   \   000002FC   0x.... 0x....      LDR.W    R0,??DataTable64
   \   00000300   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000304   0x281F             CMP      R0,#+31
   \   00000306   0xDA05             BGE.N    ??PathLCRAngle1Judge_45
   \   00000308   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000030A   0x2900             CMP      R1,#+0
   \   0000030C   0xD102             BNE.N    ??PathLCRAngle1Judge_45
   \   0000030E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000310   0x2D00             CMP      R5,#+0
   \   00000312   0xD004             BEQ.N    ??PathLCRAngle1Judge_46
  11731                  {
  11732                    PathType = PathTypeRight;
   \                     ??PathLCRAngle1Judge_45: (+1)
   \   00000314   0x2003             MOVS     R0,#+3
   \   00000316   0x.... 0x....      LDR.W    R1,??DataTable61
   \   0000031A   0x7008             STRB     R0,[R1, #+0]
   \   0000031C   0xE080             B.N      ??PathLCRAngle1Judge_33
  11733                  }
  11734                  //2.3.2. 否则就是直道。
  11735                  else
  11736                  {
  11737                    PathType = PathTypeStraight;
   \                     ??PathLCRAngle1Judge_46: (+1)
   \   0000031E   0x2001             MOVS     R0,#+1
   \   00000320   0x.... 0x....      LDR.W    R1,??DataTable61
   \   00000324   0x7008             STRB     R0,[R1, #+0]
   \   00000326   0xE07B             B.N      ??PathLCRAngle1Judge_33
  11738                  }        
  11739                }
  11740                //2.4. 理论上不会走到这里。
  11741                else
  11742                {
  11743                } 
  11744              }
  11745              //3. 左线提取失败，右线提取成功
  11746              else if(BlackLeftDone == 0 && BlackRightDone == 1)
   \                     ??PathLCRAngle1Judge_34: (+1)
   \   00000328   0x....             LDR.N    R1,??DataTable59_1
   \   0000032A   0x7809             LDRB     R1,[R1, #+0]
   \   0000032C   0x2900             CMP      R1,#+0
   \   0000032E   0xD177             BNE.N    ??PathLCRAngle1Judge_33
   \   00000330   0x....             LDR.N    R1,??DataTable59_2
   \   00000332   0x7809             LDRB     R1,[R1, #+0]
   \   00000334   0x2901             CMP      R1,#+1
   \   00000336   0xD173             BNE.N    ??PathLCRAngle1Judge_33
  11747              {             
  11748                //3.1. 中心线斜率足够正。
  11749                if(AbsSlopeC <= SlopeLimitC)
   \   00000338   0xF240 0x51DD      MOVW     R1,#+1501
   \   0000033C   0x4288             CMP      R0,R1
   \   0000033E   0xDA33             BGE.N    ??PathLCRAngle1Judge_47
  11750                { 
  11751                  //3.1.1. 中右线曲率里只要有一条比较大，且向右，那就判断为右弯。        
  11752                  if((CURVEC > CurveStraightLimitC)
  11753                   || (curvetempRR)
  11754                     )
   \   00000340   0x.... 0x....      LDR.W    R0,??DataTable64
   \   00000344   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000348   0x281F             CMP      R0,#+31
   \   0000034A   0xDA02             BGE.N    ??PathLCRAngle1Judge_48
   \   0000034C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000034E   0x2A00             CMP      R2,#+0
   \   00000350   0xD00C             BEQ.N    ??PathLCRAngle1Judge_49
  11755                  {   //3.1.1.1. 如果右线斜率较大，且向右，那就判断为右弯。
  11756                      if (slopetempRR)
   \                     ??PathLCRAngle1Judge_48: (+1)
   \   00000352   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000354   0x2E00             CMP      R6,#+0
   \   00000356   0xD004             BEQ.N    ??PathLCRAngle1Judge_50
  11757                      {
  11758                          PathType = PathTypeRight;
   \   00000358   0x2003             MOVS     R0,#+3
   \   0000035A   0x.... 0x....      LDR.W    R1,??DataTable61
   \   0000035E   0x7008             STRB     R0,[R1, #+0]
   \   00000360   0xE05E             B.N      ??PathLCRAngle1Judge_33
  11759                      }
  11760                      //3.1.1.2. 如果右线斜率不大，就算曲率较大，仍判断为直道。
  11761                      else
  11762                      {
  11763                          PathType = PathTypeStraight;
   \                     ??PathLCRAngle1Judge_50: (+1)
   \   00000362   0x2001             MOVS     R0,#+1
   \   00000364   0x.... 0x....      LDR.W    R1,??DataTable61
   \   00000368   0x7008             STRB     R0,[R1, #+0]
   \   0000036A   0xE059             B.N      ??PathLCRAngle1Judge_33
  11764                      }
  11765                    
  11766                  }
  11767                  //3.1.2. 中右线曲率里只要有一条比较大，且向左，那么有可能是左弯。
  11768                  else if((CURVEC + CurveStraightLimitC < 0)
  11769                        || (curvetempLR)
  11770                          )
   \                     ??PathLCRAngle1Judge_49: (+1)
   \   0000036C   0x.... 0x....      LDR.W    R0,??DataTable64
   \   00000370   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000374   0x301E             ADDS     R0,R0,#+30
   \   00000376   0x2800             CMP      R0,#+0
   \   00000378   0xD402             BMI.N    ??PathLCRAngle1Judge_51
   \   0000037A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000037C   0x2C00             CMP      R4,#+0
   \   0000037E   0xD00E             BEQ.N    ??PathLCRAngle1Judge_52
  11771                  {   //3.1.2.1. 如果右线斜率较大，且向左，那就判断为左弯。
  11772                      if (slopetempLR)
   \                     ??PathLCRAngle1Judge_51: (+1)
   \   00000380   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   00000384   0xF1BC 0x0F00      CMP      R12,#+0
   \   00000388   0xD004             BEQ.N    ??PathLCRAngle1Judge_53
  11773                      {
  11774                          PathType = PathTypeLeft;
   \   0000038A   0x2002             MOVS     R0,#+2
   \   0000038C   0x.... 0x....      LDR.W    R1,??DataTable61
   \   00000390   0x7008             STRB     R0,[R1, #+0]
   \   00000392   0xE045             B.N      ??PathLCRAngle1Judge_33
  11775                      }
  11776                      //3.1.2.2. 如果右线斜率不大，就算曲率较大，也判断为直道。
  11777                      else
  11778                      {
  11779                          PathType = PathTypeStraight;
   \                     ??PathLCRAngle1Judge_53: (+1)
   \   00000394   0x2001             MOVS     R0,#+1
   \   00000396   0x.... 0x....      LDR.W    R1,??DataTable61
   \   0000039A   0x7008             STRB     R0,[R1, #+0]
   \   0000039C   0xE040             B.N      ??PathLCRAngle1Judge_33
  11780                      }          
  11781                  }
  11782                  //3.1.3. 曲率都不大，最大值比较小。那么就判断为直道。
  11783                  else
  11784                  {
  11785                    PathType = PathTypeStraight;
   \                     ??PathLCRAngle1Judge_52: (+1)
   \   0000039E   0x2001             MOVS     R0,#+1
   \   000003A0   0x.... 0x....      LDR.W    R1,??DataTable61
   \   000003A4   0x7008             STRB     R0,[R1, #+0]
   \   000003A6   0xE03B             B.N      ??PathLCRAngle1Judge_33
  11786                  }
  11787                }
  11788                //3.2. 斜率向左偏，最有可能是左道。对于斜率来说，向左是正，向右是负。
  11789                else if(SlopeC > SlopeLimitC)
   \                     ??PathLCRAngle1Judge_47: (+1)
   \   000003A8   0x.... 0x....      LDR.W    R0,??DataTable61_2
   \   000003AC   0x6800             LDR      R0,[R0, #+0]
   \   000003AE   0xF240 0x51DD      MOVW     R1,#+1501
   \   000003B2   0x4288             CMP      R0,R1
   \   000003B4   0xDB18             BLT.N    ??PathLCRAngle1Judge_54
  11790                { //3.2.1. 中右线只要有一个曲率比较大，且向左，就判断为左道。
  11791                  //如果右线斜率较大，且向左，那就判断为左弯。
  11792                  if((CURVEC + CurveStraightLimitC < 0)
  11793                  || (curvetempLR)
  11794                  || (slopetempLR)
  11795                    )
   \   000003B6   0x.... 0x....      LDR.W    R0,??DataTable64
   \   000003BA   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   000003BE   0x301E             ADDS     R0,R0,#+30
   \   000003C0   0x2800             CMP      R0,#+0
   \   000003C2   0xD407             BMI.N    ??PathLCRAngle1Judge_55
   \   000003C4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003C6   0x2C00             CMP      R4,#+0
   \   000003C8   0xD104             BNE.N    ??PathLCRAngle1Judge_55
   \   000003CA   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   000003CE   0xF1BC 0x0F00      CMP      R12,#+0
   \   000003D2   0xD004             BEQ.N    ??PathLCRAngle1Judge_56
  11796                  {
  11797                    PathType = PathTypeLeft;
   \                     ??PathLCRAngle1Judge_55: (+1)
   \   000003D4   0x2002             MOVS     R0,#+2
   \   000003D6   0x.... 0x....      LDR.W    R1,??DataTable61
   \   000003DA   0x7008             STRB     R0,[R1, #+0]
   \   000003DC   0xE020             B.N      ??PathLCRAngle1Judge_33
  11798                  }
  11799                  //3.2.2. 否则就是直道。
  11800                  else
  11801                  {
  11802                    PathType = PathTypeStraight;
   \                     ??PathLCRAngle1Judge_56: (+1)
   \   000003DE   0x2001             MOVS     R0,#+1
   \   000003E0   0x.... 0x....      LDR.W    R1,??DataTable61
   \   000003E4   0x7008             STRB     R0,[R1, #+0]
   \   000003E6   0xE01B             B.N      ??PathLCRAngle1Judge_33
  11803                  }
  11804                }
  11805                //3.3. 斜率向右偏，最有可能是右道。
  11806                else if(SlopeC + SlopeLimitC < 0)
   \                     ??PathLCRAngle1Judge_54: (+1)
   \   000003E8   0x.... 0x....      LDR.W    R0,??DataTable61_2
   \   000003EC   0x6800             LDR      R0,[R0, #+0]
   \   000003EE   0xF200 0x50DC      ADDW     R0,R0,#+1500
   \   000003F2   0x2800             CMP      R0,#+0
   \   000003F4   0xD514             BPL.N    ??PathLCRAngle1Judge_33
  11807                {
  11808                  //3.3.1. 中右线只要有一个曲率比较大，且向右，就判断为右道。
  11809                  //如果右线斜率较大，且向右，那就判断为右弯。
  11810                  if((CURVEC > CurveStraightLimitC)
  11811                   || (curvetempRR)
  11812                   || (slopetempRR)
  11813                     )
   \   000003F6   0x.... 0x....      LDR.W    R0,??DataTable64
   \   000003FA   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   000003FE   0x281F             CMP      R0,#+31
   \   00000400   0xDA05             BGE.N    ??PathLCRAngle1Judge_57
   \   00000402   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000404   0x2A00             CMP      R2,#+0
   \   00000406   0xD102             BNE.N    ??PathLCRAngle1Judge_57
   \   00000408   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000040A   0x2E00             CMP      R6,#+0
   \   0000040C   0xD004             BEQ.N    ??PathLCRAngle1Judge_58
  11814                  {
  11815                    PathType = PathTypeRight;
   \                     ??PathLCRAngle1Judge_57: (+1)
   \   0000040E   0x2003             MOVS     R0,#+3
   \   00000410   0x.... 0x....      LDR.W    R1,??DataTable61
   \   00000414   0x7008             STRB     R0,[R1, #+0]
   \   00000416   0xE003             B.N      ??PathLCRAngle1Judge_33
  11816                  }
  11817                  //3.3.2. 否则就是直道。
  11818                  else
  11819                  {
  11820                    PathType = PathTypeStraight;
   \                     ??PathLCRAngle1Judge_58: (+1)
   \   00000418   0x2001             MOVS     R0,#+1
   \   0000041A   0x.... 0x....      LDR.W    R1,??DataTable61
   \   0000041E   0x7008             STRB     R0,[R1, #+0]
  11821                  }        
  11822                }
  11823                //3.4. 理论上不会走到这里。
  11824                else
  11825                {
  11826                }      
  11827              }
  11828              //4. 理论上不会出现这种情况。
  11829              else 
  11830              {
  11831              }
  11832              
  11833              return 1;
   \                     ??PathLCRAngle1Judge_33: (+1)
   \   00000420   0x2001             MOVS     R0,#+1
   \   00000422   0xE004             B.N      ??PathLCRAngle1Judge_59
  11834              //直道、左弯、右弯、判断完毕，直角弯预判完毕。
  11835            }
  11836            //3条线的曲率、斜率均求取失败，直接返回失败。
  11837            else
  11838            {
  11839              PathType = PathTypeUnknown;  
   \                     ??PathLCRAngle1Judge_0: (+1)
   \   00000424   0x2000             MOVS     R0,#+0
   \   00000426   0x.... 0x....      LDR.W    R1,??DataTable61
   \   0000042A   0x7008             STRB     R0,[R1, #+0]
  11840              return 0;
   \   0000042C   0x2000             MOVS     R0,#+0
   \                     ??PathLCRAngle1Judge_59: (+1)
   \   0000042E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
  11841            }
  11842          
  11843          }
  11844          
  11845          
  11846          //======================================================================
  11847          //函数名：PathSmallSJudgeStep2
  11848          //功  能：赛道类型判断时，小S弯第2个拐角的判断。
  11849          //参  数：row需要处理的前一行，sel 左线0 右线1，dir Z字形0 反Z字形1.
  11850          //返  回：1成功，0失败。
  11851          //影  响：
  11852          //说  明：1. 第2个拐角判断成功，则返回1。否则返回0.
  11853          //        2. 进入该函数前，黑线已经连续。
  11854          //             
  11855          //======================================================================

   \                                 In section .text, align 2, keep-with-next
  11856          uint8 PathSmallSJudgeStep2(uint8 row, uint8 sel, uint8 dir)
  11857          {
  11858            uint8 i;
  11859            
  11860            //左线
  11861            if(sel == 0)
   \                     PathSmallSJudgeStep2: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD13A             BNE.N    ??PathSmallSJudgeStep2_0
  11862            {
  11863              //Z字形
  11864              if(dir == 0)
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD11A             BNE.N    ??PathSmallSJudgeStep2_1
  11865              {
  11866                for(i = row + 1; i < BlackLeftEndLine - PathSmallSGapLine; i++)
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0xE000             B.N      ??PathSmallSJudgeStep2_2
   \                     ??PathSmallSJudgeStep2_3: (+1)
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \                     ??PathSmallSJudgeStep2_2: (+1)
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x....             LDR.N    R1,??DataTable60_1
   \   00000016   0x7809             LDRB     R1,[R1, #+0]
   \   00000018   0x1EC9             SUBS     R1,R1,#+3
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xDA2C             BGE.N    ??PathSmallSJudgeStep2_4
  11867                {
  11868                  //Z字形，需要检测从左上到右下的轨迹。
  11869                  if(BlackLeftLoc[i][0] < BlackLeftLoc[i + 1 + PathSmallSGapLine][0])
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable65
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x2203             MOVS     R2,#+3
   \   00000026   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   0000002A   0x7809             LDRB     R1,[R1, #+0]
   \   0000002C   0x.... 0x....      LDR.W    R2,??DataTable65
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x2303             MOVS     R3,#+3
   \   00000034   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000038   0x7B12             LDRB     R2,[R2, #+12]
   \   0000003A   0x4291             CMP      R1,R2
   \   0000003C   0xD2E8             BCS.N    ??PathSmallSJudgeStep2_3
  11870                  {
  11871                    return 1;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xE056             B.N      ??PathSmallSJudgeStep2_5
  11872                  }
  11873                  else
  11874                  {
  11875                  }
  11876                }
  11877              }
  11878              //反Z字形
  11879              else
  11880              {
  11881                for(i = row + 1; i < BlackLeftEndLine - PathSmallSGapLine; i++)
   \                     ??PathSmallSJudgeStep2_1: (+1)
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0xE000             B.N      ??PathSmallSJudgeStep2_6
   \                     ??PathSmallSJudgeStep2_7: (+1)
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \                     ??PathSmallSJudgeStep2_6: (+1)
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x....             LDR.N    R1,??DataTable60_1
   \   0000004C   0x7809             LDRB     R1,[R1, #+0]
   \   0000004E   0x1EC9             SUBS     R1,R1,#+3
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xDA11             BGE.N    ??PathSmallSJudgeStep2_4
  11882                {
  11883                  //反Z字形，需要检测从右上到左下的轨迹。
  11884                  if(BlackLeftLoc[i][0] >= BlackLeftLoc[i + 1 + PathSmallSGapLine][0])
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable65
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x2203             MOVS     R2,#+3
   \   0000005C   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   00000060   0x7809             LDRB     R1,[R1, #+0]
   \   00000062   0x.... 0x....      LDR.W    R2,??DataTable65
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0x2303             MOVS     R3,#+3
   \   0000006A   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000006E   0x7B12             LDRB     R2,[R2, #+12]
   \   00000070   0x4291             CMP      R1,R2
   \   00000072   0xD3E8             BCC.N    ??PathSmallSJudgeStep2_7
  11885                  {
  11886                    return 1;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xE03B             B.N      ??PathSmallSJudgeStep2_5
  11887                  }
  11888                  else
  11889                  {
  11890                  }
  11891                }
  11892              }
  11893              
  11894              //一直到有效黑线末尾仍未检测到相应的轨迹，第2个拐角检测失败，返回0。
  11895              return 0;
   \                     ??PathSmallSJudgeStep2_4: (+1)
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE039             B.N      ??PathSmallSJudgeStep2_5
  11896            }
  11897            //右线
  11898            else
  11899            {
  11900              //Z字形
  11901              if(dir == 0)
   \                     ??PathSmallSJudgeStep2_0: (+1)
   \   0000007C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000007E   0x2A00             CMP      R2,#+0
   \   00000080   0xD11A             BNE.N    ??PathSmallSJudgeStep2_8
  11902              {
  11903                for(i = row + 1; i < BlackRightEndLine - PathSmallSGapLine; i++)
   \   00000082   0x1C40             ADDS     R0,R0,#+1
   \   00000084   0xE000             B.N      ??PathSmallSJudgeStep2_9
   \                     ??PathSmallSJudgeStep2_10: (+1)
   \   00000086   0x1C40             ADDS     R0,R0,#+1
   \                     ??PathSmallSJudgeStep2_9: (+1)
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0x....             LDR.N    R1,??DataTable60_4
   \   0000008C   0x7809             LDRB     R1,[R1, #+0]
   \   0000008E   0x1EC9             SUBS     R1,R1,#+3
   \   00000090   0x4288             CMP      R0,R1
   \   00000092   0xDA2C             BGE.N    ??PathSmallSJudgeStep2_11
  11904                {
  11905                  //Z字形，需要检测从左上到右下的轨迹。
  11906                  if(BlackRightLoc[i][0] < BlackRightLoc[i + 1 + PathSmallSGapLine][0])
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable65_1
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009A   0x2203             MOVS     R2,#+3
   \   0000009C   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   000000A0   0x7809             LDRB     R1,[R1, #+0]
   \   000000A2   0x.... 0x....      LDR.W    R2,??DataTable65_1
   \   000000A6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A8   0x2303             MOVS     R3,#+3
   \   000000AA   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000AE   0x7B12             LDRB     R2,[R2, #+12]
   \   000000B0   0x4291             CMP      R1,R2
   \   000000B2   0xD2E8             BCS.N    ??PathSmallSJudgeStep2_10
  11907                  {
  11908                    return 1;
   \   000000B4   0x2001             MOVS     R0,#+1
   \   000000B6   0xE01B             B.N      ??PathSmallSJudgeStep2_5
  11909                  }
  11910                  else
  11911                  {
  11912                  }
  11913                }
  11914              }
  11915              //反Z字形
  11916              else
  11917              {
  11918                for(i = row + 1; i < BlackRightEndLine - PathSmallSGapLine; i++)
   \                     ??PathSmallSJudgeStep2_8: (+1)
   \   000000B8   0x1C40             ADDS     R0,R0,#+1
   \   000000BA   0xE000             B.N      ??PathSmallSJudgeStep2_12
   \                     ??PathSmallSJudgeStep2_13: (+1)
   \   000000BC   0x1C40             ADDS     R0,R0,#+1
   \                     ??PathSmallSJudgeStep2_12: (+1)
   \   000000BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C0   0x....             LDR.N    R1,??DataTable60_4
   \   000000C2   0x7809             LDRB     R1,[R1, #+0]
   \   000000C4   0x1EC9             SUBS     R1,R1,#+3
   \   000000C6   0x4288             CMP      R0,R1
   \   000000C8   0xDA11             BGE.N    ??PathSmallSJudgeStep2_11
  11919                {
  11920                  //反Z字形，需要检测从右上到左下的轨迹。
  11921                  if(BlackRightLoc[i][0] >= BlackRightLoc[i + 1 + PathSmallSGapLine][0])
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable65_1
   \   000000CE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D0   0x2203             MOVS     R2,#+3
   \   000000D2   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   000000D6   0x7809             LDRB     R1,[R1, #+0]
   \   000000D8   0x.... 0x....      LDR.W    R2,??DataTable65_1
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0x2303             MOVS     R3,#+3
   \   000000E0   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000E4   0x7B12             LDRB     R2,[R2, #+12]
   \   000000E6   0x4291             CMP      R1,R2
   \   000000E8   0xD3E8             BCC.N    ??PathSmallSJudgeStep2_13
  11922                  {
  11923                    return 1;
   \   000000EA   0x2001             MOVS     R0,#+1
   \   000000EC   0xE000             B.N      ??PathSmallSJudgeStep2_5
  11924                  }
  11925                  else
  11926                  {
  11927                  }
  11928                }
  11929              }
  11930              
  11931              //一直到有效黑线末尾仍未检测到相应的轨迹，第2个拐角检测失败，返回0。
  11932              return 0;
   \                     ??PathSmallSJudgeStep2_11: (+1)
   \   000000EE   0x2000             MOVS     R0,#+0
   \                     ??PathSmallSJudgeStep2_5: (+1)
   \   000000F0   0x4770             BX       LR               ;; return
  11933            }
  11934          
  11935          }
  11936          
  11937          
  11938          //======================================================================
  11939          //函数名：PathSmallSJudgeStep1
  11940          //功  能：赛道类型判断时，小S弯第1个拐角的判断。
  11941          //参  数：
  11942          //返  回：1成功，0失败。
  11943          //影  响：
  11944          //说  明：1. 返回1或0只是表示是否为小S弯。
  11945          //        2. 进入该函数前，黑线已经连续。
  11946          //             
  11947          //======================================================================

   \                                 In section .text, align 2, keep-with-next
  11948          uint8 PathSmallSJudgeStep1(void)
  11949          {
   \                     PathSmallSJudgeStep1: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  11950              uint8 i;
  11951              uint8 signflag1 = 2;    //初始为2，不为0也不为1.
   \   00000002   0x2002             MOVS     R0,#+2
  11952              //1. 线头够高。2. 从下往下的差会出现变化。
  11953          
  11954              //1. 左右黑线均提取成功。
  11955              if (BlackLeftDone == 1 && BlackRightDone == 1)
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable65_2
   \   00000008   0x7809             LDRB     R1,[R1, #+0]
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xF040 0x80CA      BNE.W    ??PathSmallSJudgeStep1_0
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable65_3
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x2901             CMP      R1,#+1
   \   00000018   0xF040 0x80C4      BNE.W    ??PathSmallSJudgeStep1_0
  11956              {
  11957                  //1.1. 左线线头够高。
  11958                  if (
  11959                      (BlackLeftHeadLine < PathSmallSHeadLimit) 
  11960                   && (BlackLeftEndLine > BlackLeftHeadLine + PathSmallSGapLine + 1)
  11961                      )
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable65_4
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x280A             CMP      R0,#+10
   \   00000024   0xDA58             BGE.N    ??PathSmallSJudgeStep1_1
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable65_4
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x1D00             ADDS     R0,R0,#+4
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable65_5
   \   00000032   0x7809             LDRB     R1,[R1, #+0]
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xDA4F             BGE.N    ??PathSmallSJudgeStep1_1
  11962                  {
  11963                      //初始为2，不为0也不为1.
  11964                      signflag1 = 2;
   \   00000038   0x2002             MOVS     R0,#+2
  11965                      
  11966                      //1.2. 两线有正到负 或者 负到正 的变化。 
  11967                      //左线
  11968                      for (i = BlackLeftHeadLine; i < BlackLeftEndLine - PathSmallSGapLine; i++)
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable65_4
   \   0000003E   0x780C             LDRB     R4,[R1, #+0]
   \   00000040   0xE001             B.N      ??PathSmallSJudgeStep1_2
  11969                      {
  11970                          //赛道右向。若检测到跳变，中途会return.
  11971                          if (BlackLeftLoc[i][0] >= BlackLeftLoc[i + 1 + PathSmallSGapLine][0])
  11972                          {
  11973                              //检测到跳变
  11974                              if (signflag1 == 0)
  11975                              {
  11976                                  //进行小S弯的第2个拐角的识别。左线，Z字形。
  11977                                  if(PathSmallSJudgeStep2(i, 0, 0) == 1)
  11978                                  {
  11979                                    PathSmallSDoneFlag = 1;   //小S弯判断成功。
  11980                                    PathSmallSDir = 1;    //小S弯先右向。
  11981                                    PathType = PathTypeSmallSR;   //右S
  11982                                    return 1;
  11983                                  }
  11984                                  else
  11985                                  {
  11986                                    //左线第2个拐角没有检测成功，没关系，下面会进行右线的检测。
  11987                                    //return 0;
  11988                                  }
  11989                              }
  11990                              else
  11991                              {
  11992                              }
  11993                              signflag1 = 1;
  11994                          }
  11995                          //赛道左向。
  11996                          else
  11997                          {   
  11998                              //检测到跳变。
  11999                              if (signflag1 == 1)
  12000                              { 
  12001                                  //进行小S弯的第2个拐角的识别。左线，反Z字形。
  12002                                  if(PathSmallSJudgeStep2(i, 0, 1) == 1)
  12003                                  {
  12004                                    PathSmallSDoneFlag = 1;   //小S弯判断成功。
  12005                                    PathSmallSDir = 0;    //小S弯先左向。
  12006                                    PathType = PathTypeSmallSL;  //左S
  12007                                    return 1;
  12008                                  }
  12009                                  else
  12010                                  {
  12011                                    //左线第2个拐角没有检测成功，没关系，下面会进行右线的检测。
  12012                                    //return 0;
  12013                                  }
  12014                              }
  12015                              else
  12016                              {
  12017                              }
  12018                              signflag1 = 0;
   \                     ??PathSmallSJudgeStep1_3: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \                     ??PathSmallSJudgeStep1_4: (+1)
   \   00000044   0x1C64             ADDS     R4,R4,#+1
   \                     ??PathSmallSJudgeStep1_2: (+1)
   \   00000046   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable65_5
   \   0000004C   0x7809             LDRB     R1,[R1, #+0]
   \   0000004E   0x1EC9             SUBS     R1,R1,#+3
   \   00000050   0x428C             CMP      R4,R1
   \   00000052   0xDA41             BGE.N    ??PathSmallSJudgeStep1_1
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable65
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0x2203             MOVS     R2,#+3
   \   0000005C   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   00000060   0x7809             LDRB     R1,[R1, #+0]
   \   00000062   0x.... 0x....      LDR.W    R2,??DataTable65
   \   00000066   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000068   0x2303             MOVS     R3,#+3
   \   0000006A   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   0000006E   0x7B12             LDRB     R2,[R2, #+12]
   \   00000070   0x4291             CMP      R1,R2
   \   00000072   0xD319             BCC.N    ??PathSmallSJudgeStep1_5
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD114             BNE.N    ??PathSmallSJudgeStep1_6
   \   0000007A   0x2200             MOVS     R2,#+0
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0x.... 0x....      BL       PathSmallSJudgeStep2
   \   00000086   0x2801             CMP      R0,#+1
   \   00000088   0xD10C             BNE.N    ??PathSmallSJudgeStep1_6
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable65_6
   \   00000090   0x7008             STRB     R0,[R1, #+0]
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable65_7
   \   00000098   0x7008             STRB     R0,[R1, #+0]
   \   0000009A   0x2007             MOVS     R0,#+7
   \   0000009C   0x....             LDR.N    R1,??DataTable61
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xE15E             B.N      ??PathSmallSJudgeStep1_7
   \                     ??PathSmallSJudgeStep1_6: (+1)
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0xE7CD             B.N      ??PathSmallSJudgeStep1_4
   \                     ??PathSmallSJudgeStep1_5: (+1)
   \   000000A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AA   0x2801             CMP      R0,#+1
   \   000000AC   0xD1C9             BNE.N    ??PathSmallSJudgeStep1_3
   \   000000AE   0x2201             MOVS     R2,#+1
   \   000000B0   0x2100             MOVS     R1,#+0
   \   000000B2   0x0020             MOVS     R0,R4
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0x.... 0x....      BL       PathSmallSJudgeStep2
   \   000000BA   0x2801             CMP      R0,#+1
   \   000000BC   0xD1C1             BNE.N    ??PathSmallSJudgeStep1_3
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable65_6
   \   000000C4   0x7008             STRB     R0,[R1, #+0]
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x.... 0x....      LDR.W    R1,??DataTable65_7
   \   000000CC   0x7008             STRB     R0,[R1, #+0]
   \   000000CE   0x2006             MOVS     R0,#+6
   \   000000D0   0x....             LDR.N    R1,??DataTable61
   \   000000D2   0x7008             STRB     R0,[R1, #+0]
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0xE144             B.N      ??PathSmallSJudgeStep1_7
  12019                          }
  12020                      }
  12021                      
  12022                      //到这里说明左线不成功，但没关系，继续分析右线。
  12023                  }
  12024                  //左线线头不够高，则直接跳过，分析右线。
  12025                  else
  12026                  {
  12027                  }
  12028                  
  12029                  //右线线头要够高。
  12030                  if(
  12031                      (BlackRightHeadLine < PathSmallSHeadLimit)
  12032                   && (BlackRightEndLine > BlackRightHeadLine + PathSmallSGapLine + 1)
  12033                     )
   \                     ??PathSmallSJudgeStep1_1: (+1)
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable65_8
   \   000000DC   0x7800             LDRB     R0,[R0, #+0]
   \   000000DE   0x280A             CMP      R0,#+10
   \   000000E0   0xDA5E             BGE.N    ??PathSmallSJudgeStep1_8
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable65_8
   \   000000E6   0x7800             LDRB     R0,[R0, #+0]
   \   000000E8   0x1D00             ADDS     R0,R0,#+4
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable65_9
   \   000000EE   0x7809             LDRB     R1,[R1, #+0]
   \   000000F0   0x4288             CMP      R0,R1
   \   000000F2   0xDA55             BGE.N    ??PathSmallSJudgeStep1_8
  12034                  {
  12035                    //初始为2，不为0也不为1.
  12036                    signflag1 = 2;
   \   000000F4   0x2002             MOVS     R0,#+2
  12037          
  12038                    //右线。左线若没有return，就继续找跳变。
  12039                    for (i = BlackRightHeadLine; i < BlackRightEndLine - PathSmallSGapLine; i++)
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable65_8
   \   000000FA   0x780C             LDRB     R4,[R1, #+0]
   \   000000FC   0xE001             B.N      ??PathSmallSJudgeStep1_9
  12040                    {
  12041                        //赛道右向。
  12042                        if (BlackRightLoc[i][0] >= BlackRightLoc[i + 1 + PathSmallSGapLine][0])
  12043                        {
  12044                            //检测到跳变
  12045                            if (signflag1 == 0)
  12046                            {
  12047                                //进行小S弯的第2个拐角的识别。右线，Z字形。
  12048                                if(PathSmallSJudgeStep2(i, 1, 0) == 1)
  12049                                {
  12050                                  PathSmallSDoneFlag = 1;   //小S弯判断成功。
  12051                                  PathSmallSDir = 1;    //小S弯先右向。
  12052                                  PathType = PathTypeSmallSR;   //右S
  12053                                  return 1;
  12054                                }
  12055                                else
  12056                                {
  12057                                  return 0;
  12058                                }
  12059                            }
  12060                            else
  12061                            {
  12062                            }
  12063                            signflag1 = 1;
  12064                        }
  12065                        //赛道左向。
  12066                        else
  12067                        {
  12068                            //检测到跳变。
  12069                            if (signflag1 == 1)
  12070                            {
  12071                                //进行小S弯的第2个拐角的识别。右线，反Z字形。
  12072                                if(PathSmallSJudgeStep2(i, 1, 1) == 1)
  12073                                {
  12074                                  PathSmallSDoneFlag = 1;   //小S弯判断成功。
  12075                                  PathSmallSDir = 0;    //小S弯先左向。
  12076                                  PathType = PathTypeSmallSL;   //左S
  12077                                  return 1;
  12078                                }
  12079                                else
  12080                                {
  12081                                  return 0;
  12082                                }
  12083                            }
  12084                            else
  12085                            {
  12086                            }
  12087                            signflag1 = 0;
   \                     ??PathSmallSJudgeStep1_10: (+1)
   \   000000FE   0x2000             MOVS     R0,#+0
   \                     ??PathSmallSJudgeStep1_11: (+1)
   \   00000100   0x1C64             ADDS     R4,R4,#+1
   \                     ??PathSmallSJudgeStep1_9: (+1)
   \   00000102   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable65_9
   \   00000108   0x7809             LDRB     R1,[R1, #+0]
   \   0000010A   0x1EC9             SUBS     R1,R1,#+3
   \   0000010C   0x428C             CMP      R4,R1
   \   0000010E   0xDA45             BGE.N    ??PathSmallSJudgeStep1_12
   \   00000110   0x.... 0x....      LDR.W    R1,??DataTable65_1
   \   00000114   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000116   0x2203             MOVS     R2,#+3
   \   00000118   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000011C   0x7809             LDRB     R1,[R1, #+0]
   \   0000011E   0x.... 0x....      LDR.W    R2,??DataTable65_1
   \   00000122   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000124   0x2303             MOVS     R3,#+3
   \   00000126   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   0000012A   0x7B12             LDRB     R2,[R2, #+12]
   \   0000012C   0x4291             CMP      R1,R2
   \   0000012E   0xD31B             BCC.N    ??PathSmallSJudgeStep1_13
   \   00000130   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD116             BNE.N    ??PathSmallSJudgeStep1_14
   \   00000136   0x2200             MOVS     R2,#+0
   \   00000138   0x2101             MOVS     R1,#+1
   \   0000013A   0x0020             MOVS     R0,R4
   \   0000013C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013E   0x.... 0x....      BL       PathSmallSJudgeStep2
   \   00000142   0x2801             CMP      R0,#+1
   \   00000144   0xD10C             BNE.N    ??PathSmallSJudgeStep1_15
   \   00000146   0x2001             MOVS     R0,#+1
   \   00000148   0x.... 0x....      LDR.W    R1,??DataTable65_6
   \   0000014C   0x7008             STRB     R0,[R1, #+0]
   \   0000014E   0x2001             MOVS     R0,#+1
   \   00000150   0x.... 0x....      LDR.W    R1,??DataTable65_7
   \   00000154   0x7008             STRB     R0,[R1, #+0]
   \   00000156   0x2007             MOVS     R0,#+7
   \   00000158   0x....             LDR.N    R1,??DataTable61
   \   0000015A   0x7008             STRB     R0,[R1, #+0]
   \   0000015C   0x2001             MOVS     R0,#+1
   \   0000015E   0xE100             B.N      ??PathSmallSJudgeStep1_7
   \                     ??PathSmallSJudgeStep1_15: (+1)
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0xE0FE             B.N      ??PathSmallSJudgeStep1_7
   \                     ??PathSmallSJudgeStep1_14: (+1)
   \   00000164   0x2001             MOVS     R0,#+1
   \   00000166   0xE7CB             B.N      ??PathSmallSJudgeStep1_11
   \                     ??PathSmallSJudgeStep1_13: (+1)
   \   00000168   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000016A   0x2801             CMP      R0,#+1
   \   0000016C   0xD1C7             BNE.N    ??PathSmallSJudgeStep1_10
   \   0000016E   0x2201             MOVS     R2,#+1
   \   00000170   0x2101             MOVS     R1,#+1
   \   00000172   0x0020             MOVS     R0,R4
   \   00000174   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000176   0x.... 0x....      BL       PathSmallSJudgeStep2
   \   0000017A   0x2801             CMP      R0,#+1
   \   0000017C   0xD10C             BNE.N    ??PathSmallSJudgeStep1_16
   \   0000017E   0x2001             MOVS     R0,#+1
   \   00000180   0x.... 0x....      LDR.W    R1,??DataTable65_6
   \   00000184   0x7008             STRB     R0,[R1, #+0]
   \   00000186   0x2000             MOVS     R0,#+0
   \   00000188   0x.... 0x....      LDR.W    R1,??DataTable65_7
   \   0000018C   0x7008             STRB     R0,[R1, #+0]
   \   0000018E   0x2006             MOVS     R0,#+6
   \   00000190   0x....             LDR.N    R1,??DataTable61
   \   00000192   0x7008             STRB     R0,[R1, #+0]
   \   00000194   0x2001             MOVS     R0,#+1
   \   00000196   0xE0E4             B.N      ??PathSmallSJudgeStep1_7
   \                     ??PathSmallSJudgeStep1_16: (+1)
   \   00000198   0x2000             MOVS     R0,#+0
   \   0000019A   0xE0E2             B.N      ??PathSmallSJudgeStep1_7
  12088                        }
  12089                    }
  12090          
  12091                    //若左右线中途都没有return 1，则返回检测失败。
  12092                    return 0;
   \                     ??PathSmallSJudgeStep1_12: (+1)
   \   0000019C   0x2000             MOVS     R0,#+0
   \   0000019E   0xE0E0             B.N      ??PathSmallSJudgeStep1_7
  12093                  }
  12094                  else
  12095                  {
  12096                    //右线线头过低，不符合小S弯。返回失败。
  12097                    return 0;
   \                     ??PathSmallSJudgeStep1_8: (+1)
   \   000001A0   0x2000             MOVS     R0,#+0
   \   000001A2   0xE0DE             B.N      ??PathSmallSJudgeStep1_7
  12098                  }
  12099              }
  12100              //2. 左线提取成功，右线提取失败。
  12101              else if (BlackLeftDone == 1 && BlackRightDone == 0)
   \                     ??PathSmallSJudgeStep1_0: (+1)
   \   000001A4   0x.... 0x....      LDR.W    R1,??DataTable65_2
   \   000001A8   0x7809             LDRB     R1,[R1, #+0]
   \   000001AA   0x2901             CMP      R1,#+1
   \   000001AC   0xD169             BNE.N    ??PathSmallSJudgeStep1_17
   \   000001AE   0x.... 0x....      LDR.W    R1,??DataTable65_3
   \   000001B2   0x7809             LDRB     R1,[R1, #+0]
   \   000001B4   0x2900             CMP      R1,#+0
   \   000001B6   0xD164             BNE.N    ??PathSmallSJudgeStep1_17
  12102              {
  12103                  //2.1. 左线线头要求够高。
  12104                  if (BlackLeftHeadLine < PathSmallSHeadLimit && BlackLeftEndLine > BlackLeftHeadLine + PathSmallSGapLine + 1)
   \   000001B8   0x.... 0x....      LDR.W    R1,??DataTable65_4
   \   000001BC   0x7809             LDRB     R1,[R1, #+0]
   \   000001BE   0x290A             CMP      R1,#+10
   \   000001C0   0xDA5D             BGE.N    ??PathSmallSJudgeStep1_18
   \   000001C2   0x.... 0x....      LDR.W    R1,??DataTable65_4
   \   000001C6   0x7809             LDRB     R1,[R1, #+0]
   \   000001C8   0x1D09             ADDS     R1,R1,#+4
   \   000001CA   0x.... 0x....      LDR.W    R2,??DataTable65_5
   \   000001CE   0x7812             LDRB     R2,[R2, #+0]
   \   000001D0   0x4291             CMP      R1,R2
   \   000001D2   0xDA54             BGE.N    ??PathSmallSJudgeStep1_18
  12105                  {
  12106                      //2.2. 检测跳变。
  12107                      for (i = BlackLeftHeadLine; i < BlackLeftEndLine - PathSmallSGapLine; i++)
   \   000001D4   0x.... 0x....      LDR.W    R1,??DataTable65_4
   \   000001D8   0x780C             LDRB     R4,[R1, #+0]
   \   000001DA   0xE001             B.N      ??PathSmallSJudgeStep1_19
  12108                      {
  12109          
  12110                          //赛道右向。若检测到跳变，中途会return.
  12111                          if (BlackLeftLoc[i][0] >= BlackLeftLoc[i + 1 + PathSmallSGapLine][0])
  12112                          {
  12113                              //检测到跳变
  12114                              if (signflag1 == 0)
  12115                              {                           
  12116                                  //进行小S弯的第2个拐角的识别。左线，Z字形。
  12117                                  if(PathSmallSJudgeStep2(i, 0, 0) == 1)
  12118                                  {
  12119                                    PathSmallSDoneFlag = 1;   //小S弯判断成功。
  12120                                    PathSmallSDir = 1;    //小S弯先右向。
  12121                                    PathType = PathTypeSmallSR;   //右S
  12122                                    return 1;
  12123                                  }
  12124                                  else
  12125                                  {
  12126                                    return 0;
  12127                                  }
  12128                              }
  12129                              else
  12130                              {
  12131                              }
  12132                              signflag1 = 1;
  12133                          }
  12134                          //赛道左向。
  12135                          else
  12136                          {
  12137                              //检测到跳变。
  12138                              if (signflag1 == 1)
  12139                              {                           
  12140                                  //进行小S弯的第2个拐角的识别。左线，反Z字形。
  12141                                  if(PathSmallSJudgeStep2(i, 0, 1) == 1)
  12142                                  {
  12143                                    PathSmallSDoneFlag = 1;   //小S弯判断成功。
  12144                                    PathSmallSDir = 0;    //小S弯先左向。
  12145                                    PathType = PathTypeSmallSL;  //左S
  12146                                    return 1;
  12147                                  }
  12148                                  else
  12149                                  {
  12150                                    return 0;
  12151                                  }
  12152                              }
  12153                              else
  12154                              {
  12155                              }
  12156                              signflag1 = 0;
   \                     ??PathSmallSJudgeStep1_20: (+1)
   \   000001DC   0x2000             MOVS     R0,#+0
   \                     ??PathSmallSJudgeStep1_21: (+1)
   \   000001DE   0x1C64             ADDS     R4,R4,#+1
   \                     ??PathSmallSJudgeStep1_19: (+1)
   \   000001E0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001E2   0x.... 0x....      LDR.W    R1,??DataTable65_5
   \   000001E6   0x7809             LDRB     R1,[R1, #+0]
   \   000001E8   0x1EC9             SUBS     R1,R1,#+3
   \   000001EA   0x428C             CMP      R4,R1
   \   000001EC   0xDA45             BGE.N    ??PathSmallSJudgeStep1_22
   \   000001EE   0x.... 0x....      LDR.W    R1,??DataTable65
   \   000001F2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001F4   0x2203             MOVS     R2,#+3
   \   000001F6   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000001FA   0x7809             LDRB     R1,[R1, #+0]
   \   000001FC   0x.... 0x....      LDR.W    R2,??DataTable65
   \   00000200   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000202   0x2303             MOVS     R3,#+3
   \   00000204   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   00000208   0x7B12             LDRB     R2,[R2, #+12]
   \   0000020A   0x4291             CMP      R1,R2
   \   0000020C   0xD31B             BCC.N    ??PathSmallSJudgeStep1_23
   \   0000020E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000210   0x2800             CMP      R0,#+0
   \   00000212   0xD116             BNE.N    ??PathSmallSJudgeStep1_24
   \   00000214   0x2200             MOVS     R2,#+0
   \   00000216   0x2100             MOVS     R1,#+0
   \   00000218   0x0020             MOVS     R0,R4
   \   0000021A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000021C   0x.... 0x....      BL       PathSmallSJudgeStep2
   \   00000220   0x2801             CMP      R0,#+1
   \   00000222   0xD10C             BNE.N    ??PathSmallSJudgeStep1_25
   \   00000224   0x2001             MOVS     R0,#+1
   \   00000226   0x.... 0x....      LDR.W    R1,??DataTable65_6
   \   0000022A   0x7008             STRB     R0,[R1, #+0]
   \   0000022C   0x2001             MOVS     R0,#+1
   \   0000022E   0x.... 0x....      LDR.W    R1,??DataTable65_7
   \   00000232   0x7008             STRB     R0,[R1, #+0]
   \   00000234   0x2007             MOVS     R0,#+7
   \   00000236   0x....             LDR.N    R1,??DataTable61
   \   00000238   0x7008             STRB     R0,[R1, #+0]
   \   0000023A   0x2001             MOVS     R0,#+1
   \   0000023C   0xE091             B.N      ??PathSmallSJudgeStep1_7
   \                     ??PathSmallSJudgeStep1_25: (+1)
   \   0000023E   0x2000             MOVS     R0,#+0
   \   00000240   0xE08F             B.N      ??PathSmallSJudgeStep1_7
   \                     ??PathSmallSJudgeStep1_24: (+1)
   \   00000242   0x2001             MOVS     R0,#+1
   \   00000244   0xE7CB             B.N      ??PathSmallSJudgeStep1_21
   \                     ??PathSmallSJudgeStep1_23: (+1)
   \   00000246   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000248   0x2801             CMP      R0,#+1
   \   0000024A   0xD1C7             BNE.N    ??PathSmallSJudgeStep1_20
   \   0000024C   0x2201             MOVS     R2,#+1
   \   0000024E   0x2100             MOVS     R1,#+0
   \   00000250   0x0020             MOVS     R0,R4
   \   00000252   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000254   0x.... 0x....      BL       PathSmallSJudgeStep2
   \   00000258   0x2801             CMP      R0,#+1
   \   0000025A   0xD10C             BNE.N    ??PathSmallSJudgeStep1_26
   \   0000025C   0x2001             MOVS     R0,#+1
   \   0000025E   0x.... 0x....      LDR.W    R1,??DataTable65_6
   \   00000262   0x7008             STRB     R0,[R1, #+0]
   \   00000264   0x2000             MOVS     R0,#+0
   \   00000266   0x.... 0x....      LDR.W    R1,??DataTable65_7
   \   0000026A   0x7008             STRB     R0,[R1, #+0]
   \   0000026C   0x2006             MOVS     R0,#+6
   \   0000026E   0x....             LDR.N    R1,??DataTable61
   \   00000270   0x7008             STRB     R0,[R1, #+0]
   \   00000272   0x2001             MOVS     R0,#+1
   \   00000274   0xE075             B.N      ??PathSmallSJudgeStep1_7
   \                     ??PathSmallSJudgeStep1_26: (+1)
   \   00000276   0x2000             MOVS     R0,#+0
   \   00000278   0xE073             B.N      ??PathSmallSJudgeStep1_7
  12157                          }
  12158                      }
  12159          
  12160                      //若左线中途没有return，则返回检测失败。
  12161                      return 0;
   \                     ??PathSmallSJudgeStep1_22: (+1)
   \   0000027A   0x2000             MOVS     R0,#+0
   \   0000027C   0xE071             B.N      ??PathSmallSJudgeStep1_7
  12162                  }
  12163                  //线头过低，不符合小S弯。返回失败。
  12164                  else
  12165                  {
  12166                      return 0;
   \                     ??PathSmallSJudgeStep1_18: (+1)
   \   0000027E   0x2000             MOVS     R0,#+0
   \   00000280   0xE06F             B.N      ??PathSmallSJudgeStep1_7
  12167                  }
  12168              }
  12169              //3. 右线提取成功，左线提取失败。
  12170              else if (BlackLeftDone == 0 && BlackRightDone == 1)
   \                     ??PathSmallSJudgeStep1_17: (+1)
   \   00000282   0x.... 0x....      LDR.W    R1,??DataTable65_2
   \   00000286   0x7809             LDRB     R1,[R1, #+0]
   \   00000288   0x2900             CMP      R1,#+0
   \   0000028A   0xD169             BNE.N    ??PathSmallSJudgeStep1_27
   \   0000028C   0x.... 0x....      LDR.W    R1,??DataTable65_3
   \   00000290   0x7809             LDRB     R1,[R1, #+0]
   \   00000292   0x2901             CMP      R1,#+1
   \   00000294   0xD164             BNE.N    ??PathSmallSJudgeStep1_27
  12171              {
  12172                  //3.1. 两线线头都要够高。
  12173                  if (BlackRightHeadLine < PathSmallSHeadLimit && BlackRightEndLine > BlackRightHeadLine + PathSmallSGapLine + 1)
   \   00000296   0x.... 0x....      LDR.W    R1,??DataTable65_8
   \   0000029A   0x7809             LDRB     R1,[R1, #+0]
   \   0000029C   0x290A             CMP      R1,#+10
   \   0000029E   0xDA5D             BGE.N    ??PathSmallSJudgeStep1_28
   \   000002A0   0x.... 0x....      LDR.W    R1,??DataTable65_8
   \   000002A4   0x7809             LDRB     R1,[R1, #+0]
   \   000002A6   0x1D09             ADDS     R1,R1,#+4
   \   000002A8   0x.... 0x....      LDR.W    R2,??DataTable65_9
   \   000002AC   0x7812             LDRB     R2,[R2, #+0]
   \   000002AE   0x4291             CMP      R1,R2
   \   000002B0   0xDA54             BGE.N    ??PathSmallSJudgeStep1_28
  12174                  {
  12175                      //右线。
  12176                      for (i = BlackRightHeadLine; i < BlackRightEndLine - PathSmallSGapLine; i++)
   \   000002B2   0x.... 0x....      LDR.W    R1,??DataTable65_8
   \   000002B6   0x780C             LDRB     R4,[R1, #+0]
   \   000002B8   0xE001             B.N      ??PathSmallSJudgeStep1_29
  12177                      {
  12178                            //赛道右向。
  12179                            if (BlackRightLoc[i][0] >= BlackRightLoc[i + 1 + PathSmallSGapLine][0])
  12180                            {
  12181                                //检测到跳变
  12182                                if (signflag1 == 0)
  12183                                {                           
  12184                                    //进行小S弯的第2个拐角的识别。右线，Z字形。
  12185                                    if(PathSmallSJudgeStep2(i, 1, 0) == 1)
  12186                                    {
  12187                                      PathSmallSDoneFlag = 1;   //小S弯判断成功。
  12188                                      PathSmallSDir = 1;    //小S弯先右向。
  12189                                      PathType = PathTypeSmallSR; //右S
  12190                                      return 1;
  12191                                    }
  12192                                    else
  12193                                    {
  12194                                      return 0;
  12195                                    }
  12196                                }
  12197                                else
  12198                                {
  12199                                }
  12200                                signflag1 = 1;
  12201                            }
  12202                            //赛道左向。
  12203                            else
  12204                            {
  12205                                //检测到跳变。
  12206                                if (signflag1 == 1)
  12207                                {                           
  12208                                    //进行小S弯的第2个拐角的识别。右线，反Z字形。
  12209                                    if(PathSmallSJudgeStep2(i, 1, 1) == 1)
  12210                                    {
  12211                                      PathSmallSDoneFlag = 1;   //小S弯判断成功。
  12212                                      PathSmallSDir = 0;    //小S弯先左向。
  12213                                      PathType = PathTypeSmallSL;  //左S
  12214                                      return 1;
  12215                                    }
  12216                                    else
  12217                                    {
  12218                                      return 0;
  12219                                    }
  12220                                }
  12221                                else
  12222                                {
  12223                                }
  12224                                signflag1 = 0;
   \                     ??PathSmallSJudgeStep1_30: (+1)
   \   000002BA   0x2000             MOVS     R0,#+0
   \                     ??PathSmallSJudgeStep1_31: (+1)
   \   000002BC   0x1C64             ADDS     R4,R4,#+1
   \                     ??PathSmallSJudgeStep1_29: (+1)
   \   000002BE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002C0   0x.... 0x....      LDR.W    R1,??DataTable65_9
   \   000002C4   0x7809             LDRB     R1,[R1, #+0]
   \   000002C6   0x1EC9             SUBS     R1,R1,#+3
   \   000002C8   0x428C             CMP      R4,R1
   \   000002CA   0xDA45             BGE.N    ??PathSmallSJudgeStep1_32
   \   000002CC   0x.... 0x....      LDR.W    R1,??DataTable65_1
   \   000002D0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002D2   0x2203             MOVS     R2,#+3
   \   000002D4   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   000002D8   0x7809             LDRB     R1,[R1, #+0]
   \   000002DA   0x.... 0x....      LDR.W    R2,??DataTable65_1
   \   000002DE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002E0   0x2303             MOVS     R3,#+3
   \   000002E2   0xFB03 0x2204      MLA      R2,R3,R4,R2
   \   000002E6   0x7B12             LDRB     R2,[R2, #+12]
   \   000002E8   0x4291             CMP      R1,R2
   \   000002EA   0xD31B             BCC.N    ??PathSmallSJudgeStep1_33
   \   000002EC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002EE   0x2800             CMP      R0,#+0
   \   000002F0   0xD116             BNE.N    ??PathSmallSJudgeStep1_34
   \   000002F2   0x2200             MOVS     R2,#+0
   \   000002F4   0x2101             MOVS     R1,#+1
   \   000002F6   0x0020             MOVS     R0,R4
   \   000002F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002FA   0x.... 0x....      BL       PathSmallSJudgeStep2
   \   000002FE   0x2801             CMP      R0,#+1
   \   00000300   0xD10C             BNE.N    ??PathSmallSJudgeStep1_35
   \   00000302   0x2001             MOVS     R0,#+1
   \   00000304   0x.... 0x....      LDR.W    R1,??DataTable65_6
   \   00000308   0x7008             STRB     R0,[R1, #+0]
   \   0000030A   0x2001             MOVS     R0,#+1
   \   0000030C   0x.... 0x....      LDR.W    R1,??DataTable65_7
   \   00000310   0x7008             STRB     R0,[R1, #+0]
   \   00000312   0x2007             MOVS     R0,#+7
   \   00000314   0x....             LDR.N    R1,??DataTable61
   \   00000316   0x7008             STRB     R0,[R1, #+0]
   \   00000318   0x2001             MOVS     R0,#+1
   \   0000031A   0xE022             B.N      ??PathSmallSJudgeStep1_7
   \                     ??PathSmallSJudgeStep1_35: (+1)
   \   0000031C   0x2000             MOVS     R0,#+0
   \   0000031E   0xE020             B.N      ??PathSmallSJudgeStep1_7
   \                     ??PathSmallSJudgeStep1_34: (+1)
   \   00000320   0x2001             MOVS     R0,#+1
   \   00000322   0xE7CB             B.N      ??PathSmallSJudgeStep1_31
   \                     ??PathSmallSJudgeStep1_33: (+1)
   \   00000324   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000326   0x2801             CMP      R0,#+1
   \   00000328   0xD1C7             BNE.N    ??PathSmallSJudgeStep1_30
   \   0000032A   0x2201             MOVS     R2,#+1
   \   0000032C   0x2101             MOVS     R1,#+1
   \   0000032E   0x0020             MOVS     R0,R4
   \   00000330   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000332   0x.... 0x....      BL       PathSmallSJudgeStep2
   \   00000336   0x2801             CMP      R0,#+1
   \   00000338   0xD10C             BNE.N    ??PathSmallSJudgeStep1_36
   \   0000033A   0x2001             MOVS     R0,#+1
   \   0000033C   0x.... 0x....      LDR.W    R1,??DataTable65_6
   \   00000340   0x7008             STRB     R0,[R1, #+0]
   \   00000342   0x2000             MOVS     R0,#+0
   \   00000344   0x.... 0x....      LDR.W    R1,??DataTable65_7
   \   00000348   0x7008             STRB     R0,[R1, #+0]
   \   0000034A   0x2006             MOVS     R0,#+6
   \   0000034C   0x....             LDR.N    R1,??DataTable61
   \   0000034E   0x7008             STRB     R0,[R1, #+0]
   \   00000350   0x2001             MOVS     R0,#+1
   \   00000352   0xE006             B.N      ??PathSmallSJudgeStep1_7
   \                     ??PathSmallSJudgeStep1_36: (+1)
   \   00000354   0x2000             MOVS     R0,#+0
   \   00000356   0xE004             B.N      ??PathSmallSJudgeStep1_7
  12225                            }
  12226                      }
  12227          
  12228                      //若右线中途没有return，则返回检测失败。
  12229                      return 0;
   \                     ??PathSmallSJudgeStep1_32: (+1)
   \   00000358   0x2000             MOVS     R0,#+0
   \   0000035A   0xE002             B.N      ??PathSmallSJudgeStep1_7
  12230                  }
  12231                  //线头过低，不符合小S弯。返回失败。
  12232                  else
  12233                  {
  12234                      return 0;
   \                     ??PathSmallSJudgeStep1_28: (+1)
   \   0000035C   0x2000             MOVS     R0,#+0
   \   0000035E   0xE000             B.N      ??PathSmallSJudgeStep1_7
  12235                  }
  12236          
  12237              }
  12238              //4. 理论上不会走到这里。
  12239              else
  12240              {
  12241                  return 0;
   \                     ??PathSmallSJudgeStep1_27: (+1)
   \   00000360   0x2000             MOVS     R0,#+0
   \                     ??PathSmallSJudgeStep1_7: (+1)
   \   00000362   0xBD10             POP      {R4,PC}          ;; return
  12242              }
  12243          
  12244          }
  12245          
  12246          
  12247          
  12248          //赛道类型判断
  12249          //======================================================================
  12250          //函数名：PathJudge
  12251          //功  能：赛道类型判断
  12252          //参  数：无
  12253          //返  回：1成功 0失败
  12254          //影  响：PathType
  12255          //说  明：1. 根据曲率和斜率来判断。
  12256          //        2. PathType: 0未知 1直道 2左内 3左中 4左外 5右内 6右中 7右外
  12257          //             
  12258          //======================================================================

   \                                 In section .text, align 2, keep-with-next
  12259          uint8 PathJudge(void)
  12260          {  
   \                     PathJudge: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  12261            uint8 flag1, flag2;
  12262            
  12263            
  12264            //直道、左弯、右弯判断，直角弯第1阶段预判。
  12265            //当斜曲率求取失败时，会返回0.
  12266            flag1 = PathLCRAngle1Judge();
   \   00000002   0x.... 0x....      BL       PathLCRAngle1Judge
  12267          
  12268            //小S弯判断。非小S弯会返回0.
  12269            //flag2 = PathSmallSJudgeStep1();
  12270            flag2 = 1;
   \   00000006   0x2101             MOVS     R1,#+1
  12271            
  12272            if(flag1 == 0 && flag2 == 0)
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD104             BNE.N    ??PathJudge_0
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD101             BNE.N    ??PathJudge_0
  12273            {
  12274              return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE000             B.N      ??PathJudge_1
  12275            }
  12276            else
  12277            {
  12278              return 1;
   \                     ??PathJudge_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \                     ??PathJudge_1: (+1)
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return
  12279            }
  12280            
  12281            //以下是一套以曲率为主导的赛道类型判断方法。
  12282            /*
  12283            //赛道类型PathType: 0未知 1直道 2左内 3左中 4左外 5右内 6右中 7右外
  12284            PathType = PathTypeUnknown;
  12285            //曲率符号获取成功
  12286            //如果CurveSlopeGet()返回0，则代表3条线的曲率、斜率均求取失败，不用进行下面的判断。
  12287            if(CurveSlopeGet())
  12288            {
  12289              //不用判断中心线成功，到这里了肯定是成功的。
  12290              //左右黑线均提取成功，的情况。
  12291              if(BlackLeftDone == 1 && BlackRightDone == 1)
  12292              { //全部逆时针，且逆得比较多，则为左弯，而且是小车走在左弯道较为中心的左弯。
  12293                if(
  12294                   (CURVEL + CurveStraightLimitL < 0) 
  12295                 &&(CURVEC + CurveStraightLimitC < 0)
  12296                 &&(CURVER + CurveStraightLimitR < 0)       
  12297                   )
  12298                {
  12299                  PathType = PathTypeLeftMiddle;
  12300                }
  12301                //全部顺时针，且顺得比较多，则为右弯，而且是小车走在右弯道较为中心的右弯。
  12302                else if(CURVEL > CurveStraightLimitL && CURVEC > CurveStraightLimitC && CURVER > CurveStraightLimitR)
  12303                {        
  12304                  PathType = PathTypeRightMiddle;
  12305                }
  12306                else
  12307                {
  12308                  if(
  12309                    (AbsSelf(CURVEL) < CurveStraightLimitL)
  12310                  &&(AbsSelf(CURVEC) < CurveStraightLimitC)
  12311                  &&(AbsSelf(CURVER) < CurveStraightLimitR) //三个值的绝对值够小。
  12312                  &&(SlopeL + SlopeLimitL < 0)              //左黑线斜率小于某负值
  12313                  &&(AbsSelfFloat(SlopeC) < SlopeLimitC)         //中心线斜率绝对值够小
  12314                  &&(SlopeR > SlopeLimitR)                  //右黑线斜率大于某正值
  12315                    )
  12316                  { //均小于阈值，为直道。
  12317                    PathType = PathTypeStraight;  
  12318                  }
  12319                  else
  12320                  {
  12321                    PathType = PathTypeUnknown; //未知赛道类型。  
  12322                  }
  12323                }
  12324              }
  12325              
  12326              //左黑线提取失败，右黑线提取成功，的情况。
  12327              if(BlackLeftDone == 0 && BlackRightDone == 1)
  12328              { //左弯道，外道。
  12329                if((CURVEC + CurveStraightLimitC < 0) 
  12330                 &&(CURVER + CurveStraightLimitR < 0)
  12331                   )
  12332                {
  12333                  PathType = PathTypeLeftOut;
  12334                }
  12335                //右弯道，内道。
  12336                else if(CURVEC > CurveStraightLimitC && CURVER > CurveStraightLimitR)
  12337                {
  12338                  PathType = PathTypeRightIn;
  12339                }
  12340                else
  12341                {
  12342                  if(
  12343                    (AbsSelf(CURVEC) < CurveStraightLimitC)
  12344                  &&(AbsSelf(CURVER) < CurveStraightLimitR)
  12345                  &&(AbsSelfFloat(SlopeC) < SlopeLimitC)         //中心线斜率绝对值够小
  12346                  &&(SlopeR > SlopeLimitR)                  //右黑线斜率大于某正值
  12347                    )
  12348                  { //均小于阈值，为直道。
  12349                    PathType = PathTypeStraight;  
  12350                  }
  12351                  else
  12352                  {
  12353                    PathType = PathTypeUnknown; //未知赛道类型。  
  12354                  }
  12355                }
  12356              }
  12357              
  12358              //右黑线提取失败，左黑线提取成功，的情况。
  12359              if(BlackLeftDone == 1 && BlackRightDone == 0)
  12360              { //左弯道，内道。
  12361                if((CURVEC + CurveStraightLimitC < 0)
  12362                 &&(CURVEL + CurveStraightLimitL < 0)
  12363                   )
  12364                {
  12365                  PathType = PathTypeLeftIn;
  12366                }
  12367                //右弯道，外道。
  12368                else if(CURVEC > CurveStraightLimitC && CURVEL > CurveStraightLimitL)
  12369                {
  12370                  PathType = PathTypeRightOut;
  12371                }
  12372                else
  12373                {
  12374                  if(
  12375                    (AbsSelf(CURVEC) < CurveStraightLimitC)
  12376                  &&(AbsSelf(CURVEL) < CurveStraightLimitL)
  12377                  &&(SlopeL + SlopeLimitL < 0)              //左黑线斜率小于某负值
  12378                  &&(AbsSelfFloat(SlopeC) < SlopeLimitC)         //中心线斜率绝对值够小          
  12379                    )
  12380                  { //均小于阈值，为直道。
  12381                    PathType = PathTypeStraight;  
  12382                  }
  12383                  else
  12384                  {
  12385                    PathType = PathTypeUnknown; //未知赛道类型。  
  12386                  }
  12387                }
  12388              }
  12389              
  12390              return 1;
  12391            }
  12392            //3条线的曲率、斜率均求取失败，直接返回失败。
  12393            else
  12394            {
  12395              PathType = PathTypeUnknown;  
  12396              return 0;
  12397            }
  12398            
  12399            */   //end of 以曲率为主导的赛道类型判断方法。
  12400            
  12401          }
  12402          
  12403          
  12404          
  12405          
  12406          
  12407          
  12408          
  12409          
  12410          //图像畸变矫正

   \                                 In section .text, align 2, keep-with-next
  12411          uint8 BlackUdis(void)
  12412          {
   \                     BlackUdis: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
  12413            uint8 row;
  12414            
  12415            //矫正
  12416            //对左黑线的畸变矫正
  12417            if(BlackLeftDone == 1)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable65_2
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xF040 0x813D      BNE.W    ??BlackUdis_0
  12418            {
  12419              //从线尾到线头。
  12420              for(row = BlackLeftEndLine; ; row--)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable65_5
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0xE000             B.N      ??BlackUdis_1
   \                     ??BlackUdis_2: (+1)
   \   00000016   0x1E40             SUBS     R0,R0,#+1
  12421              {
  12422                //近处的行
  12423                if(row > BlackUdisMiddleLine)
   \                     ??BlackUdis_1: (+1)
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x2827             CMP      R0,#+39
   \   0000001C   0xDB63             BLT.N    ??BlackUdis_3
  12424                {
  12425                  //列
  12426                  BlackUdisLeftLocation[row].x  = (BlackUdisMatrixLow[0] * BlackLeftLoc[row][0] + BlackUdisMatrixLow[1] * (row + 1) + BlackUdisMatrixLow[2]) 
  12427                                                / (BlackUdisMatrixLow[6] * BlackLeftLoc[row][0] + BlackUdisMatrixLow[7] * (row + 1) + 1000);
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable66
   \   00000022   0x6809             LDR      R1,[R1, #+0]
   \   00000024   0x.... 0x....      LDR.W    R2,??DataTable65
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x2303             MOVS     R3,#+3
   \   0000002C   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000030   0x7812             LDRB     R2,[R2, #+0]
   \   00000032   0x.... 0x....      LDR.W    R3,??DataTable66
   \   00000036   0x685B             LDR      R3,[R3, #+4]
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x1C44             ADDS     R4,R0,#+1
   \   0000003C   0x4363             MULS     R3,R4,R3
   \   0000003E   0xFB02 0x3101      MLA      R1,R2,R1,R3
   \   00000042   0x.... 0x....      LDR.W    R2,??DataTable66
   \   00000046   0x6892             LDR      R2,[R2, #+8]
   \   00000048   0x1851             ADDS     R1,R2,R1
   \   0000004A   0x.... 0x....      LDR.W    R2,??DataTable66
   \   0000004E   0x6992             LDR      R2,[R2, #+24]
   \   00000050   0x.... 0x....      LDR.W    R3,??DataTable65
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x2403             MOVS     R4,#+3
   \   00000058   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   0000005C   0x781B             LDRB     R3,[R3, #+0]
   \   0000005E   0x.... 0x....      LDR.W    R4,??DataTable66
   \   00000062   0x69E4             LDR      R4,[R4, #+28]
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0x1C45             ADDS     R5,R0,#+1
   \   00000068   0x436C             MULS     R4,R5,R4
   \   0000006A   0xFB03 0x4202      MLA      R2,R3,R2,R4
   \   0000006E   0xF512 0x727A      ADDS     R2,R2,#+1000
   \   00000072   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   00000076   0x.... 0x....      LDR.W    R2,??DataTable66_1
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0xF842 0x1030      STR      R1,[R2, R0, LSL #+3]
  12428                  //行
  12429                  BlackUdisLeftLocation[row].y  = (BlackUdisMatrixLow[3] * BlackLeftLoc[row][0] + BlackUdisMatrixLow[4] * (row + 1) + BlackUdisMatrixLow[5]) 
  12430                                                / (BlackUdisMatrixLow[6] * BlackLeftLoc[row][0] + BlackUdisMatrixLow[7] * (row + 1) + 1000);
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable66
   \   00000084   0x68C9             LDR      R1,[R1, #+12]
   \   00000086   0x.... 0x....      LDR.W    R2,??DataTable65
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008C   0x2303             MOVS     R3,#+3
   \   0000008E   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000092   0x7812             LDRB     R2,[R2, #+0]
   \   00000094   0x.... 0x....      LDR.W    R3,??DataTable66
   \   00000098   0x691B             LDR      R3,[R3, #+16]
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   0x1C44             ADDS     R4,R0,#+1
   \   0000009E   0x4363             MULS     R3,R4,R3
   \   000000A0   0xFB02 0x3101      MLA      R1,R2,R1,R3
   \   000000A4   0x.... 0x....      LDR.W    R2,??DataTable66
   \   000000A8   0x6952             LDR      R2,[R2, #+20]
   \   000000AA   0x1851             ADDS     R1,R2,R1
   \   000000AC   0x.... 0x....      LDR.W    R2,??DataTable66
   \   000000B0   0x6992             LDR      R2,[R2, #+24]
   \   000000B2   0x.... 0x....      LDR.W    R3,??DataTable65
   \   000000B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B8   0x2403             MOVS     R4,#+3
   \   000000BA   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   000000BE   0x781B             LDRB     R3,[R3, #+0]
   \   000000C0   0x.... 0x....      LDR.W    R4,??DataTable66
   \   000000C4   0x69E4             LDR      R4,[R4, #+28]
   \   000000C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C8   0x1C45             ADDS     R5,R0,#+1
   \   000000CA   0x436C             MULS     R4,R5,R4
   \   000000CC   0xFB03 0x4202      MLA      R2,R3,R2,R4
   \   000000D0   0xF512 0x727A      ADDS     R2,R2,#+1000
   \   000000D4   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   000000D8   0x.... 0x....      LDR.W    R2,??DataTable66_1
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   000000E2   0x6051             STR      R1,[R2, #+4]
   \   000000E4   0xE0C9             B.N      ??BlackUdis_4
  12431                }
  12432                else
  12433                {
  12434                  //中间的行
  12435                  if(row > BlackUdisFarLine)
   \                     ??BlackUdis_3: (+1)
   \   000000E6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E8   0x2813             CMP      R0,#+19
   \   000000EA   0xDB63             BLT.N    ??BlackUdis_5
  12436                  {
  12437                    //列
  12438                    BlackUdisLeftLocation[row].x  = (BlackUdisMatrixMiddle[0] * BlackLeftLoc[row][0] + BlackUdisMatrixMiddle[1] * (row + 1) + BlackUdisMatrixMiddle[2]) 
  12439                                                  / (BlackUdisMatrixMiddle[6] * BlackLeftLoc[row][0] + BlackUdisMatrixMiddle[7] * (row + 1) + 1000);
   \   000000EC   0x.... 0x....      LDR.W    R1,??DataTable66_2
   \   000000F0   0x6809             LDR      R1,[R1, #+0]
   \   000000F2   0x.... 0x....      LDR.W    R2,??DataTable65
   \   000000F6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F8   0x2303             MOVS     R3,#+3
   \   000000FA   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000FE   0x7812             LDRB     R2,[R2, #+0]
   \   00000100   0x.... 0x....      LDR.W    R3,??DataTable66_2
   \   00000104   0x685B             LDR      R3,[R3, #+4]
   \   00000106   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000108   0x1C44             ADDS     R4,R0,#+1
   \   0000010A   0x4363             MULS     R3,R4,R3
   \   0000010C   0xFB02 0x3101      MLA      R1,R2,R1,R3
   \   00000110   0x.... 0x....      LDR.W    R2,??DataTable66_2
   \   00000114   0x6892             LDR      R2,[R2, #+8]
   \   00000116   0x1851             ADDS     R1,R2,R1
   \   00000118   0x.... 0x....      LDR.W    R2,??DataTable66_2
   \   0000011C   0x6992             LDR      R2,[R2, #+24]
   \   0000011E   0x.... 0x....      LDR.W    R3,??DataTable65
   \   00000122   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000124   0x2403             MOVS     R4,#+3
   \   00000126   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   0000012A   0x781B             LDRB     R3,[R3, #+0]
   \   0000012C   0x.... 0x....      LDR.W    R4,??DataTable66_2
   \   00000130   0x69E4             LDR      R4,[R4, #+28]
   \   00000132   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000134   0x1C45             ADDS     R5,R0,#+1
   \   00000136   0x436C             MULS     R4,R5,R4
   \   00000138   0xFB03 0x4202      MLA      R2,R3,R2,R4
   \   0000013C   0xF512 0x727A      ADDS     R2,R2,#+1000
   \   00000140   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   00000144   0x.... 0x....      LDR.W    R2,??DataTable66_1
   \   00000148   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014A   0xF842 0x1030      STR      R1,[R2, R0, LSL #+3]
  12440                    //行
  12441                    BlackUdisLeftLocation[row].y  = (BlackUdisMatrixMiddle[3] * BlackLeftLoc[row][0] + BlackUdisMatrixMiddle[4] * (row + 1) + BlackUdisMatrixMiddle[5]) 
  12442                                                  / (BlackUdisMatrixMiddle[6] * BlackLeftLoc[row][0] + BlackUdisMatrixMiddle[7] * (row + 1) + 1000);     
   \   0000014E   0x.... 0x....      LDR.W    R1,??DataTable66_2
   \   00000152   0x68C9             LDR      R1,[R1, #+12]
   \   00000154   0x.... 0x....      LDR.W    R2,??DataTable65
   \   00000158   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015A   0x2303             MOVS     R3,#+3
   \   0000015C   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000160   0x7812             LDRB     R2,[R2, #+0]
   \   00000162   0x.... 0x....      LDR.W    R3,??DataTable66_2
   \   00000166   0x691B             LDR      R3,[R3, #+16]
   \   00000168   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000016A   0x1C44             ADDS     R4,R0,#+1
   \   0000016C   0x4363             MULS     R3,R4,R3
   \   0000016E   0xFB02 0x3101      MLA      R1,R2,R1,R3
   \   00000172   0x.... 0x....      LDR.W    R2,??DataTable66_2
   \   00000176   0x6952             LDR      R2,[R2, #+20]
   \   00000178   0x1851             ADDS     R1,R2,R1
   \   0000017A   0x.... 0x....      LDR.W    R2,??DataTable66_2
   \   0000017E   0x6992             LDR      R2,[R2, #+24]
   \   00000180   0x.... 0x....      LDR.W    R3,??DataTable65
   \   00000184   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000186   0x2403             MOVS     R4,#+3
   \   00000188   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   0000018C   0x781B             LDRB     R3,[R3, #+0]
   \   0000018E   0x.... 0x....      LDR.W    R4,??DataTable66_2
   \   00000192   0x69E4             LDR      R4,[R4, #+28]
   \   00000194   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000196   0x1C45             ADDS     R5,R0,#+1
   \   00000198   0x436C             MULS     R4,R5,R4
   \   0000019A   0xFB03 0x4202      MLA      R2,R3,R2,R4
   \   0000019E   0xF512 0x727A      ADDS     R2,R2,#+1000
   \   000001A2   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   000001A6   0x.... 0x....      LDR.W    R2,??DataTable66_1
   \   000001AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001AC   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   000001B0   0x6051             STR      R1,[R2, #+4]
   \   000001B2   0xE062             B.N      ??BlackUdis_4
  12443                  }
  12444                  //远处的行
  12445                  else
  12446                  {
  12447                    //列
  12448                    BlackUdisLeftLocation[row].x  = (BlackUdisMatrixFar[0] * BlackLeftLoc[row][0] + BlackUdisMatrixFar[1] * (row + 1) + BlackUdisMatrixFar[2]) 
  12449                                                  / (BlackUdisMatrixFar[6] * BlackLeftLoc[row][0] + BlackUdisMatrixFar[7] * (row + 1) + 1000);
   \                     ??BlackUdis_5: (+1)
   \   000001B4   0x.... 0x....      LDR.W    R1,??DataTable66_3
   \   000001B8   0x6809             LDR      R1,[R1, #+0]
   \   000001BA   0x.... 0x....      LDR.W    R2,??DataTable65
   \   000001BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001C0   0x2303             MOVS     R3,#+3
   \   000001C2   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000001C6   0x7812             LDRB     R2,[R2, #+0]
   \   000001C8   0x.... 0x....      LDR.W    R3,??DataTable66_3
   \   000001CC   0x685B             LDR      R3,[R3, #+4]
   \   000001CE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001D0   0x1C44             ADDS     R4,R0,#+1
   \   000001D2   0x4363             MULS     R3,R4,R3
   \   000001D4   0xFB02 0x3101      MLA      R1,R2,R1,R3
   \   000001D8   0x.... 0x....      LDR.W    R2,??DataTable66_3
   \   000001DC   0x6892             LDR      R2,[R2, #+8]
   \   000001DE   0x1851             ADDS     R1,R2,R1
   \   000001E0   0x.... 0x....      LDR.W    R2,??DataTable66_3
   \   000001E4   0x6992             LDR      R2,[R2, #+24]
   \   000001E6   0x.... 0x....      LDR.W    R3,??DataTable65
   \   000001EA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001EC   0x2403             MOVS     R4,#+3
   \   000001EE   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   000001F2   0x781B             LDRB     R3,[R3, #+0]
   \   000001F4   0x.... 0x....      LDR.W    R4,??DataTable66_3
   \   000001F8   0x69E4             LDR      R4,[R4, #+28]
   \   000001FA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001FC   0x1C45             ADDS     R5,R0,#+1
   \   000001FE   0x436C             MULS     R4,R5,R4
   \   00000200   0xFB03 0x4202      MLA      R2,R3,R2,R4
   \   00000204   0xF512 0x727A      ADDS     R2,R2,#+1000
   \   00000208   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   0000020C   0x.... 0x....      LDR.W    R2,??DataTable66_1
   \   00000210   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000212   0xF842 0x1030      STR      R1,[R2, R0, LSL #+3]
  12450                    //行
  12451                    BlackUdisLeftLocation[row].y  = (BlackUdisMatrixFar[3] * BlackLeftLoc[row][0] + BlackUdisMatrixFar[4] * (row + 1) + BlackUdisMatrixFar[5]) 
  12452                                                  / (BlackUdisMatrixFar[6] * BlackLeftLoc[row][0] + BlackUdisMatrixFar[7] * (row + 1) + 1000);          
   \   00000216   0x.... 0x....      LDR.W    R1,??DataTable66_3
   \   0000021A   0x68C9             LDR      R1,[R1, #+12]
   \   0000021C   0x.... 0x....      LDR.W    R2,??DataTable65
   \   00000220   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000222   0x2303             MOVS     R3,#+3
   \   00000224   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000228   0x7812             LDRB     R2,[R2, #+0]
   \   0000022A   0x.... 0x....      LDR.W    R3,??DataTable66_3
   \   0000022E   0x691B             LDR      R3,[R3, #+16]
   \   00000230   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000232   0x1C44             ADDS     R4,R0,#+1
   \   00000234   0x4363             MULS     R3,R4,R3
   \   00000236   0xFB02 0x3101      MLA      R1,R2,R1,R3
   \   0000023A   0x.... 0x....      LDR.W    R2,??DataTable66_3
   \   0000023E   0x6952             LDR      R2,[R2, #+20]
   \   00000240   0x1851             ADDS     R1,R2,R1
   \   00000242   0x.... 0x....      LDR.W    R2,??DataTable66_3
   \   00000246   0x6992             LDR      R2,[R2, #+24]
   \   00000248   0x.... 0x....      LDR.W    R3,??DataTable65
   \   0000024C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000024E   0x2403             MOVS     R4,#+3
   \   00000250   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   00000254   0x781B             LDRB     R3,[R3, #+0]
   \   00000256   0x.... 0x....      LDR.W    R4,??DataTable66_3
   \   0000025A   0x69E4             LDR      R4,[R4, #+28]
   \   0000025C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000025E   0x1C45             ADDS     R5,R0,#+1
   \   00000260   0x436C             MULS     R4,R5,R4
   \   00000262   0xFB03 0x4202      MLA      R2,R3,R2,R4
   \   00000266   0xF512 0x727A      ADDS     R2,R2,#+1000
   \   0000026A   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   0000026E   0x.... 0x....      LDR.W    R2,??DataTable66_1
   \   00000272   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000274   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   00000278   0x6051             STR      R1,[R2, #+4]
  12453                  }       
  12454                }
  12455                
  12456                if(row == BlackLeftHeadLine) break;
   \                     ??BlackUdis_4: (+1)
   \   0000027A   0x.... 0x....      LDR.W    R1,??DataTable65_4
   \   0000027E   0x7809             LDRB     R1,[R1, #+0]
   \   00000280   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000282   0x4288             CMP      R0,R1
   \   00000284   0xF47F 0xAEC7      BNE.W    ??BlackUdis_2
  12457              }
  12458            }
  12459            else
  12460            {    
  12461            }
  12462            
  12463            //对右黑线的畸变矫正
  12464            if(BlackRightDone == 1)
   \                     ??BlackUdis_0: (+1)
   \   00000288   0x.... 0x....      LDR.W    R0,??DataTable65_3
   \   0000028C   0x7800             LDRB     R0,[R0, #+0]
   \   0000028E   0x2801             CMP      R0,#+1
   \   00000290   0xF040 0x8138      BNE.W    ??BlackUdis_6
  12465            {
  12466              //从线尾到线头。
  12467              for(row = BlackRightEndLine; ; row--)
   \   00000294   0x.... 0x....      LDR.W    R0,??DataTable65_9
   \   00000298   0x7800             LDRB     R0,[R0, #+0]
   \   0000029A   0xE000             B.N      ??BlackUdis_7
   \                     ??BlackUdis_8: (+1)
   \   0000029C   0x1E40             SUBS     R0,R0,#+1
  12468              {
  12469                //近处的行
  12470                if(row > BlackUdisMiddleLine)
   \                     ??BlackUdis_7: (+1)
   \   0000029E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002A0   0x2827             CMP      R0,#+39
   \   000002A2   0xDB63             BLT.N    ??BlackUdis_9
  12471                {
  12472                  //列
  12473                  BlackUdisRightLocation[row].x  = (BlackUdisMatrixLow[0] * BlackRightLoc[row][0] + BlackUdisMatrixLow[1] * (row + 1) + BlackUdisMatrixLow[2]) 
  12474                                                 / (BlackUdisMatrixLow[6] * BlackRightLoc[row][0] + BlackUdisMatrixLow[7] * (row + 1) + 1000);
   \   000002A4   0x.... 0x....      LDR.W    R1,??DataTable66
   \   000002A8   0x6809             LDR      R1,[R1, #+0]
   \   000002AA   0x.... 0x....      LDR.W    R2,??DataTable65_1
   \   000002AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002B0   0x2303             MOVS     R3,#+3
   \   000002B2   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000002B6   0x7812             LDRB     R2,[R2, #+0]
   \   000002B8   0x.... 0x....      LDR.W    R3,??DataTable66
   \   000002BC   0x685B             LDR      R3,[R3, #+4]
   \   000002BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002C0   0x1C44             ADDS     R4,R0,#+1
   \   000002C2   0x4363             MULS     R3,R4,R3
   \   000002C4   0xFB02 0x3101      MLA      R1,R2,R1,R3
   \   000002C8   0x.... 0x....      LDR.W    R2,??DataTable66
   \   000002CC   0x6892             LDR      R2,[R2, #+8]
   \   000002CE   0x1851             ADDS     R1,R2,R1
   \   000002D0   0x.... 0x....      LDR.W    R2,??DataTable66
   \   000002D4   0x6992             LDR      R2,[R2, #+24]
   \   000002D6   0x.... 0x....      LDR.W    R3,??DataTable65_1
   \   000002DA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002DC   0x2403             MOVS     R4,#+3
   \   000002DE   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   000002E2   0x781B             LDRB     R3,[R3, #+0]
   \   000002E4   0x.... 0x....      LDR.W    R4,??DataTable66
   \   000002E8   0x69E4             LDR      R4,[R4, #+28]
   \   000002EA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002EC   0x1C45             ADDS     R5,R0,#+1
   \   000002EE   0x436C             MULS     R4,R5,R4
   \   000002F0   0xFB03 0x4202      MLA      R2,R3,R2,R4
   \   000002F4   0xF512 0x727A      ADDS     R2,R2,#+1000
   \   000002F8   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   000002FC   0x.... 0x....      LDR.W    R2,??DataTable66_4
   \   00000300   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000302   0xF842 0x1030      STR      R1,[R2, R0, LSL #+3]
  12475                  //行
  12476                  BlackUdisRightLocation[row].y  = (BlackUdisMatrixLow[3] * BlackRightLoc[row][0] + BlackUdisMatrixLow[4] * (row + 1) + BlackUdisMatrixLow[5]) 
  12477                                                 / (BlackUdisMatrixLow[6] * BlackRightLoc[row][0] + BlackUdisMatrixLow[7] * (row + 1) + 1000);
   \   00000306   0x.... 0x....      LDR.W    R1,??DataTable66
   \   0000030A   0x68C9             LDR      R1,[R1, #+12]
   \   0000030C   0x.... 0x....      LDR.W    R2,??DataTable65_1
   \   00000310   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000312   0x2303             MOVS     R3,#+3
   \   00000314   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000318   0x7812             LDRB     R2,[R2, #+0]
   \   0000031A   0x.... 0x....      LDR.W    R3,??DataTable66
   \   0000031E   0x691B             LDR      R3,[R3, #+16]
   \   00000320   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000322   0x1C44             ADDS     R4,R0,#+1
   \   00000324   0x4363             MULS     R3,R4,R3
   \   00000326   0xFB02 0x3101      MLA      R1,R2,R1,R3
   \   0000032A   0x.... 0x....      LDR.W    R2,??DataTable66
   \   0000032E   0x6952             LDR      R2,[R2, #+20]
   \   00000330   0x1851             ADDS     R1,R2,R1
   \   00000332   0x.... 0x....      LDR.W    R2,??DataTable66
   \   00000336   0x6992             LDR      R2,[R2, #+24]
   \   00000338   0x.... 0x....      LDR.W    R3,??DataTable65_1
   \   0000033C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000033E   0x2403             MOVS     R4,#+3
   \   00000340   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   00000344   0x781B             LDRB     R3,[R3, #+0]
   \   00000346   0x.... 0x....      LDR.W    R4,??DataTable66
   \   0000034A   0x69E4             LDR      R4,[R4, #+28]
   \   0000034C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000034E   0x1C45             ADDS     R5,R0,#+1
   \   00000350   0x436C             MULS     R4,R5,R4
   \   00000352   0xFB03 0x4202      MLA      R2,R3,R2,R4
   \   00000356   0xF512 0x727A      ADDS     R2,R2,#+1000
   \   0000035A   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   0000035E   0x.... 0x....      LDR.W    R2,??DataTable66_4
   \   00000362   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000364   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   00000368   0x6051             STR      R1,[R2, #+4]
   \   0000036A   0xE0C4             B.N      ??BlackUdis_10
  12478                }
  12479                else
  12480                {
  12481                  //中间的行
  12482                  if(row > BlackUdisFarLine)
   \                     ??BlackUdis_9: (+1)
   \   0000036C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000036E   0x2813             CMP      R0,#+19
   \   00000370   0xDB62             BLT.N    ??BlackUdis_11
  12483                  {
  12484                    //列
  12485                    BlackUdisRightLocation[row].x  = (BlackUdisMatrixMiddle[0] * BlackRightLoc[row][0] + BlackUdisMatrixMiddle[1] * (row + 1) + BlackUdisMatrixMiddle[2]) 
  12486                                                   / (BlackUdisMatrixMiddle[6] * BlackRightLoc[row][0] + BlackUdisMatrixMiddle[7] * (row + 1) + 1000);
   \   00000372   0x.... 0x....      LDR.W    R1,??DataTable66_2
   \   00000376   0x6809             LDR      R1,[R1, #+0]
   \   00000378   0x.... 0x....      LDR.W    R2,??DataTable65_1
   \   0000037C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000037E   0x2303             MOVS     R3,#+3
   \   00000380   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000384   0x7812             LDRB     R2,[R2, #+0]
   \   00000386   0x.... 0x....      LDR.W    R3,??DataTable66_2
   \   0000038A   0x685B             LDR      R3,[R3, #+4]
   \   0000038C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000038E   0x1C44             ADDS     R4,R0,#+1
   \   00000390   0x4363             MULS     R3,R4,R3
   \   00000392   0xFB02 0x3101      MLA      R1,R2,R1,R3
   \   00000396   0x.... 0x....      LDR.W    R2,??DataTable66_2
   \   0000039A   0x6892             LDR      R2,[R2, #+8]
   \   0000039C   0x1851             ADDS     R1,R2,R1
   \   0000039E   0x.... 0x....      LDR.W    R2,??DataTable66_2
   \   000003A2   0x6992             LDR      R2,[R2, #+24]
   \   000003A4   0x.... 0x....      LDR.W    R3,??DataTable65_1
   \   000003A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003AA   0x2403             MOVS     R4,#+3
   \   000003AC   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   000003B0   0x781B             LDRB     R3,[R3, #+0]
   \   000003B2   0x.... 0x....      LDR.W    R4,??DataTable66_2
   \   000003B6   0x69E4             LDR      R4,[R4, #+28]
   \   000003B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003BA   0x1C45             ADDS     R5,R0,#+1
   \   000003BC   0x436C             MULS     R4,R5,R4
   \   000003BE   0xFB03 0x4202      MLA      R2,R3,R2,R4
   \   000003C2   0xF512 0x727A      ADDS     R2,R2,#+1000
   \   000003C6   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   000003CA   0x.... 0x....      LDR.W    R2,??DataTable66_4
   \   000003CE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003D0   0xF842 0x1030      STR      R1,[R2, R0, LSL #+3]
  12487                    //行
  12488                    BlackUdisRightLocation[row].y  = (BlackUdisMatrixMiddle[3] * BlackRightLoc[row][0] + BlackUdisMatrixMiddle[4] * (row + 1) + BlackUdisMatrixMiddle[5]) 
  12489                                                   / (BlackUdisMatrixMiddle[6] * BlackRightLoc[row][0] + BlackUdisMatrixMiddle[7] * (row + 1) + 1000);     
   \   000003D4   0x.... 0x....      LDR.W    R1,??DataTable66_2
   \   000003D8   0x68C9             LDR      R1,[R1, #+12]
   \   000003DA   0x.... 0x....      LDR.W    R2,??DataTable65_1
   \   000003DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003E0   0x2303             MOVS     R3,#+3
   \   000003E2   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000003E6   0x7812             LDRB     R2,[R2, #+0]
   \   000003E8   0x.... 0x....      LDR.W    R3,??DataTable66_2
   \   000003EC   0x691B             LDR      R3,[R3, #+16]
   \   000003EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003F0   0x1C44             ADDS     R4,R0,#+1
   \   000003F2   0x4363             MULS     R3,R4,R3
   \   000003F4   0xFB02 0x3101      MLA      R1,R2,R1,R3
   \   000003F8   0x.... 0x....      LDR.W    R2,??DataTable66_2
   \   000003FC   0x6952             LDR      R2,[R2, #+20]
   \   000003FE   0x1851             ADDS     R1,R2,R1
   \   00000400   0x.... 0x....      LDR.W    R2,??DataTable66_2
   \   00000404   0x6992             LDR      R2,[R2, #+24]
   \   00000406   0x....             LDR.N    R3,??DataTable65_1
   \   00000408   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000040A   0x2403             MOVS     R4,#+3
   \   0000040C   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   00000410   0x781B             LDRB     R3,[R3, #+0]
   \   00000412   0x.... 0x....      LDR.W    R4,??DataTable66_2
   \   00000416   0x69E4             LDR      R4,[R4, #+28]
   \   00000418   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000041A   0x1C45             ADDS     R5,R0,#+1
   \   0000041C   0x436C             MULS     R4,R5,R4
   \   0000041E   0xFB03 0x4202      MLA      R2,R3,R2,R4
   \   00000422   0xF512 0x727A      ADDS     R2,R2,#+1000
   \   00000426   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   0000042A   0x.... 0x....      LDR.W    R2,??DataTable66_4
   \   0000042E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000430   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   00000434   0x6051             STR      R1,[R2, #+4]
   \   00000436   0xE05E             B.N      ??BlackUdis_10
  12490                  }
  12491                  //远处的行
  12492                  else
  12493                  {
  12494                    //列
  12495                    BlackUdisRightLocation[row].x  = (BlackUdisMatrixFar[0] * BlackRightLoc[row][0] + BlackUdisMatrixFar[1] * (row + 1) + BlackUdisMatrixFar[2]) 
  12496                                                   / (BlackUdisMatrixFar[6] * BlackRightLoc[row][0] + BlackUdisMatrixFar[7] * (row + 1) + 1000);
   \                     ??BlackUdis_11: (+1)
   \   00000438   0x.... 0x....      LDR.W    R1,??DataTable66_3
   \   0000043C   0x6809             LDR      R1,[R1, #+0]
   \   0000043E   0x....             LDR.N    R2,??DataTable65_1
   \   00000440   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000442   0x2303             MOVS     R3,#+3
   \   00000444   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000448   0x7812             LDRB     R2,[R2, #+0]
   \   0000044A   0x.... 0x....      LDR.W    R3,??DataTable66_3
   \   0000044E   0x685B             LDR      R3,[R3, #+4]
   \   00000450   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000452   0x1C44             ADDS     R4,R0,#+1
   \   00000454   0x4363             MULS     R3,R4,R3
   \   00000456   0xFB02 0x3101      MLA      R1,R2,R1,R3
   \   0000045A   0x.... 0x....      LDR.W    R2,??DataTable66_3
   \   0000045E   0x6892             LDR      R2,[R2, #+8]
   \   00000460   0x1851             ADDS     R1,R2,R1
   \   00000462   0x.... 0x....      LDR.W    R2,??DataTable66_3
   \   00000466   0x6992             LDR      R2,[R2, #+24]
   \   00000468   0x....             LDR.N    R3,??DataTable65_1
   \   0000046A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000046C   0x2403             MOVS     R4,#+3
   \   0000046E   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   00000472   0x781B             LDRB     R3,[R3, #+0]
   \   00000474   0x.... 0x....      LDR.W    R4,??DataTable66_3
   \   00000478   0x69E4             LDR      R4,[R4, #+28]
   \   0000047A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000047C   0x1C45             ADDS     R5,R0,#+1
   \   0000047E   0x436C             MULS     R4,R5,R4
   \   00000480   0xFB03 0x4202      MLA      R2,R3,R2,R4
   \   00000484   0xF512 0x727A      ADDS     R2,R2,#+1000
   \   00000488   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   0000048C   0x.... 0x....      LDR.W    R2,??DataTable66_4
   \   00000490   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000492   0xF842 0x1030      STR      R1,[R2, R0, LSL #+3]
  12497                    //行
  12498                    BlackUdisRightLocation[row].y  = (BlackUdisMatrixFar[3] * BlackRightLoc[row][0] + BlackUdisMatrixFar[4] * (row + 1) + BlackUdisMatrixFar[5]) 
  12499                                                   / (BlackUdisMatrixFar[6] * BlackRightLoc[row][0] + BlackUdisMatrixFar[7] * (row + 1) + 1000);          
   \   00000496   0x.... 0x....      LDR.W    R1,??DataTable66_3
   \   0000049A   0x68C9             LDR      R1,[R1, #+12]
   \   0000049C   0x....             LDR.N    R2,??DataTable65_1
   \   0000049E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004A0   0x2303             MOVS     R3,#+3
   \   000004A2   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000004A6   0x7812             LDRB     R2,[R2, #+0]
   \   000004A8   0x.... 0x....      LDR.W    R3,??DataTable66_3
   \   000004AC   0x691B             LDR      R3,[R3, #+16]
   \   000004AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004B0   0x1C44             ADDS     R4,R0,#+1
   \   000004B2   0x4363             MULS     R3,R4,R3
   \   000004B4   0xFB02 0x3101      MLA      R1,R2,R1,R3
   \   000004B8   0x.... 0x....      LDR.W    R2,??DataTable66_3
   \   000004BC   0x6952             LDR      R2,[R2, #+20]
   \   000004BE   0x1851             ADDS     R1,R2,R1
   \   000004C0   0x.... 0x....      LDR.W    R2,??DataTable66_3
   \   000004C4   0x6992             LDR      R2,[R2, #+24]
   \   000004C6   0x....             LDR.N    R3,??DataTable65_1
   \   000004C8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004CA   0x2403             MOVS     R4,#+3
   \   000004CC   0xFB04 0x3300      MLA      R3,R4,R0,R3
   \   000004D0   0x781B             LDRB     R3,[R3, #+0]
   \   000004D2   0x.... 0x....      LDR.W    R4,??DataTable66_3
   \   000004D6   0x69E4             LDR      R4,[R4, #+28]
   \   000004D8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004DA   0x1C45             ADDS     R5,R0,#+1
   \   000004DC   0x436C             MULS     R4,R5,R4
   \   000004DE   0xFB03 0x4202      MLA      R2,R3,R2,R4
   \   000004E2   0xF512 0x727A      ADDS     R2,R2,#+1000
   \   000004E6   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \   000004EA   0x.... 0x....      LDR.W    R2,??DataTable66_4
   \   000004EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004F0   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   000004F4   0x6051             STR      R1,[R2, #+4]
  12500                  }       
  12501                }
  12502                
  12503                if(row == BlackRightHeadLine) break;
   \                     ??BlackUdis_10: (+1)
   \   000004F6   0x.... 0x....      LDR.W    R1,??DataTable67
   \   000004FA   0x7809             LDRB     R1,[R1, #+0]
   \   000004FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004FE   0x4288             CMP      R0,R1
   \   00000500   0xF47F 0xAECC      BNE.W    ??BlackUdis_8
  12504              }
  12505            }
  12506            else
  12507            {
  12508            }
  12509            
  12510            return 1;
   \                     ??BlackUdis_6: (+1)
   \   00000504   0x2001             MOVS     R0,#+1
   \   00000506   0xBC30             POP      {R4,R5}
   \   00000508   0x4770             BX       LR               ;; return
  12511          }
  12512          
  12513          
  12514          //直角弯时，对中心线的特殊处理函数。
  12515          //放在ImgProSucceedDeal()函数里有DeviFuse更新函数的后面，强制修改DeviFuse的值，不影响CenterLineLoc[]数组。
  12516          //直角弯锁存或特殊控制时，CenterLineLoc[]数组一直是无效值。

   \                                 In section .text, align 2, keep-with-next
  12517          uint8 AngleSpeDealCen(uint8 dir)
  12518          {
  12519            //左直角弯
  12520            if(dir == 0)
   \                     AngleSpeDealCen: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD119             BNE.N    ??AngleSpeDealCen_0
  12521            {
  12522              //对DeviNow的特殊赋值。影响舵机控制。
  12523              DeviFuse = AngleSpeDealDeviNow[AngleSpeDealBackCountNum-AngleSpeDealBackCount-1];
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable67_1
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable67_2
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x4249             RSBS     R1,R1,#+0
   \   00000012   0xEB10 0x0041      ADDS     R0,R0,R1, LSL #+1
   \   00000016   0xF9B0 0x001C      LDRSH    R0,[R0, #+28]
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable67_3
   \   0000001E   0x6008             STR      R0,[R1, #+0]
  12524              //对DeviNowLevel的特殊赋值。影响舵机和电机控制。
  12525              //DeviNowLevel = AngleSpeDealDeviNowLevel[AngleSpeDealBackCountNum-AngleSpeDealBackCount-1];
  12526              ////对SlopeC的特殊赋值。影响SlopeCLevel。影响电机控制。
  12527              SlopeC = AngleSpeDealSlopeC[AngleSpeDealBackCountNum-AngleSpeDealBackCount-1];
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable67_4
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable67_2
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0x4249             RSBS     R1,R1,#+0
   \   0000002C   0xEB10 0x0081      ADDS     R0,R0,R1, LSL #+2
   \   00000030   0x6B80             LDR      R0,[R0, #+56]
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable67_5
   \   00000036   0x6008             STR      R0,[R1, #+0]
   \   00000038   0xE01C             B.N      ??AngleSpeDealCen_1
  12528            }
  12529            //右直角弯
  12530            else if(dir == 1)
   \                     ??AngleSpeDealCen_0: (+1)
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xD119             BNE.N    ??AngleSpeDealCen_1
  12531            {
  12532              //对DeviNow的特殊赋值。影响舵机控制。
  12533              DeviFuse = 0 - AngleSpeDealDeviNow[AngleSpeDealBackCountNum-AngleSpeDealBackCount-1];
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable67_1
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable67_2
   \   00000048   0x7809             LDRB     R1,[R1, #+0]
   \   0000004A   0x4249             RSBS     R1,R1,#+0
   \   0000004C   0xEB10 0x0041      ADDS     R0,R0,R1, LSL #+1
   \   00000050   0xF9B0 0x001C      LDRSH    R0,[R0, #+28]
   \   00000054   0x4240             RSBS     R0,R0,#+0
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable67_3
   \   0000005A   0x6008             STR      R0,[R1, #+0]
  12534              //对DeviNowLevel的特殊赋值。影响舵机和电机控制。
  12535              //DeviNowLevel = AngleSpeDealDeviNowLevel[AngleSpeDealBackCountNum-AngleSpeDealBackCount-1];
  12536              //对SlopeC的特殊赋值。影响SlopeCLevel。影响电机控制。
  12537              SlopeC = AngleSpeDealSlopeC[AngleSpeDealBackCountNum-AngleSpeDealBackCount-1];    
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable67_4
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable67_2
   \   00000064   0x7809             LDRB     R1,[R1, #+0]
   \   00000066   0x4249             RSBS     R1,R1,#+0
   \   00000068   0xEB10 0x0081      ADDS     R0,R0,R1, LSL #+2
   \   0000006C   0x6B80             LDR      R0,[R0, #+56]
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable67_5
   \   00000072   0x6008             STR      R0,[R1, #+0]
  12538            }
  12539            //错误
  12540            else
  12541            {    
  12542            }
  12543            
  12544            return 1;
   \                     ??AngleSpeDealCen_1: (+1)
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x4770             BX       LR               ;; return
  12545          }
  12546          
  12547          
  12548          //出直角弯判断，1已出，0未出

   \                                 In section .text, align 2, keep-with-next
  12549          uint8 AngleSpeDealExitJudge(void)
  12550          {
   \                     AngleSpeDealExitJudge: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  12551            //至少要进行AngleSpeDealBackCountMin次强制控制。
  12552            if(AngleSpeDealBackCountNum - AngleSpeDealBackCount < AngleSpeDealBackCountMin)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable67_2
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xF1D0 0x000F      RSBS     R0,R0,#+15
   \   0000000C   0x2808             CMP      R0,#+8
   \   0000000E   0xDA01             BGE.N    ??AngleSpeDealExitJudge_0
  12553            {
  12554              return 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE01C             B.N      ??AngleSpeDealExitJudge_1
  12555            }
  12556            else
  12557            {
  12558            }
  12559            
  12560            //退出强制控制的条件，左右线均成功，均左右线斜率绝对值小于一定值。
  12561            if(
  12562               (BlackLeftDone == 1)
  12563             &&(BlackRightDone == 1)
  12564             &&(AbsInt(SlopeL) < AngelSpeDealExitSlope)
  12565             &&(AbsInt(SlopeR) < AngelSpeDealExitSlope)
  12566               )
   \                     ??AngleSpeDealExitJudge_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable65_2
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD117             BNE.N    ??AngleSpeDealExitJudge_2
   \   0000001C   0x....             LDR.N    R0,??DataTable65_3
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD113             BNE.N    ??AngleSpeDealExitJudge_2
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable67_6
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x.... 0x....      BL       AbsInt
   \   0000002E   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xDA0A             BGE.N    ??AngleSpeDealExitJudge_2
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable67_7
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x.... 0x....      BL       AbsInt
   \   00000040   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xDA01             BGE.N    ??AngleSpeDealExitJudge_2
  12567            {
  12568              return 1;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xE000             B.N      ??AngleSpeDealExitJudge_1
  12569            }
  12570            else
  12571            {
  12572              return 0;
   \                     ??AngleSpeDealExitJudge_2: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??AngleSpeDealExitJudge_1: (+1)
   \   0000004E   0xBD02             POP      {R1,PC}          ;; return
  12573            }
  12574            
  12575            /*
  12576            //看到了2条线，可以判断已经出了直角弯。
  12577            if(BlackLeftDone == 1 && BlackRightDone == 1)
  12578            {
  12579              return 1;
  12580            }
  12581            else
  12582            {
  12583            }
  12584            
  12585            //AngleSpeDealDir所在线的斜率超过了AngelSpeDealExitSlope，也可以把控制权交给常规控制了。
  12586            if(AngleSpeDealDir == 0)
  12587            {
  12588              //左直角弯。
  12589              if(SlopeR >= AngelSpeDealExitSlope)
  12590              {
  12591                return 1;
  12592              }
  12593              else
  12594              {
  12595              }
  12596            }
  12597            else if(AngleSpeDealDir == 1)
  12598            {
  12599              //右直角弯。
  12600              if(SlopeL >= AngelSpeDealExitSlope)
  12601              {
  12602                return 1;
  12603              }
  12604              else
  12605              {
  12606              }    
  12607            }
  12608            else
  12609            {
  12610            }
  12611          
  12612            return 0;
  12613            */
  12614          }
  12615          
  12616          //直角弯确认函数。确认多次能才确认是直角弯，并作相应操作。

   \                                 In section .text, align 2, keep-with-next
  12617          uint8 AngleStep2Confirm(void)
  12618          {          
   \                     AngleStep2Confirm: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  12619            uint8 i;
  12620            
  12621            //用的是上一次的实时速度等级值，虽然没用这一次的，但也应该差别不大。
  12622            //QuadSpeedLevel共10个等级，0低速9高速。目前确认次数只分2级。可以继续细分。
  12623            /*
  12624            if(QuadSpeedLevel >= 5)
  12625            {
  12626              //高速，确认次数相对较少 。
  12627              realConfirmNum = 5;
  12628            }
  12629            else
  12630            {
  12631              //低速，确认次数相对较多。
  12632              realConfirmNum = 10;
  12633            }
  12634            */
  12635            ///////////////////////////////////暂时先不用。等测试值出来了再用。
  12636          
  12637            //A次计数内有B次直角成功，则判断为直角弯。先入先出队列。
  12638            //直角锁存没被置位时，才直角计数，若已被置位，不用直角计数。
  12639            if(AngleConfirmLockFlag == 0)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable67_8
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD138             BNE.N    ??AngleStep2Confirm_0
  12640            {
  12641              for(i = 0; ; i++)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE000             B.N      ??AngleStep2Confirm_1
   \                     ??AngleStep2Confirm_2: (+1)
   \   00000010   0x1C40             ADDS     R0,R0,#+1
  12642              {
  12643                AngleConfirmMat[i] = AngleConfirmMat[i + 1];
   \                     ??AngleStep2Confirm_1: (+1)
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable67_9
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x1841             ADDS     R1,R0,R1
   \   0000001A   0x7849             LDRB     R1,[R1, #+1]
   \   0000001C   0x.... 0x....      LDR.W    R2,??DataTable67_9
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x5481             STRB     R1,[R0, R2]
  12644                if(i == AngleConfirmMatNum - 2) break;
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x2804             CMP      R0,#+4
   \   00000028   0xD1F2             BNE.N    ??AngleStep2Confirm_2
  12645              }
  12646              //成功
  12647              if(PathType == PathTypeAngleL || PathType == PathTypeAngleR)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable67_10
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x2804             CMP      R0,#+4
   \   00000032   0xD004             BEQ.N    ??AngleStep2Confirm_3
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable67_10
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x2805             CMP      R0,#+5
   \   0000003C   0xD104             BNE.N    ??AngleStep2Confirm_4
  12648              {
  12649                //判定为直角则新来的值置1。
  12650                AngleConfirmMat[AngleConfirmMatNum - 1] = 1;
   \                     ??AngleStep2Confirm_3: (+1)
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable67_9
   \   00000044   0x7148             STRB     R0,[R1, #+5]
   \   00000046   0xE003             B.N      ??AngleStep2Confirm_5
  12651              }
  12652              else
  12653              {
  12654                //判定为非直角则新来的值置0.
  12655                AngleConfirmMat[AngleConfirmMatNum - 1] = 0;
   \                     ??AngleStep2Confirm_4: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable67_9
   \   0000004E   0x7148             STRB     R0,[R1, #+5]
  12656              }
  12657              //收集AngleConfirmMat数组里1的个数。
  12658              AngleConfirmMatCollect = 0;
   \                     ??AngleStep2Confirm_5: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable67_11
   \   00000056   0x7008             STRB     R0,[R1, #+0]
  12659              for(i = 0; ; i++)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE000             B.N      ??AngleStep2Confirm_6
   \                     ??AngleStep2Confirm_7: (+1)
   \   0000005C   0x1C40             ADDS     R0,R0,#+1
  12660              {
  12661                if(AngleConfirmMat[i] == 1) AngleConfirmMatCollect++;
   \                     ??AngleStep2Confirm_6: (+1)
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable67_9
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0x5C41             LDRB     R1,[R0, R1]
   \   00000066   0x2901             CMP      R1,#+1
   \   00000068   0xD106             BNE.N    ??AngleStep2Confirm_8
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable67_11
   \   0000006E   0x7809             LDRB     R1,[R1, #+0]
   \   00000070   0x1C49             ADDS     R1,R1,#+1
   \   00000072   0x.... 0x....      LDR.W    R2,??DataTable67_11
   \   00000076   0x7011             STRB     R1,[R2, #+0]
  12662                
  12663                if(i == AngleConfirmMatNum - 1) break;
   \                     ??AngleStep2Confirm_8: (+1)
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0x2805             CMP      R0,#+5
   \   0000007C   0xD1EE             BNE.N    ??AngleStep2Confirm_7
  12664              }
  12665            }
  12666            //直角锁存标志位已被置位，不用直角计数。
  12667            else
  12668            {
  12669            }
  12670            
  12671            //大于若干次，则锁存为直角。
  12672            if(AngleConfirmMatCollect >= AngleConfirmMatLimit)
   \                     ??AngleStep2Confirm_0: (+1)
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable67_11
   \   00000082   0x7800             LDRB     R0,[R0, #+0]
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable67_12
   \   00000088   0x7809             LDRB     R1,[R1, #+0]
   \   0000008A   0x4288             CMP      R0,R1
   \   0000008C   0xD321             BCC.N    ??AngleStep2Confirm_9
  12673            {
  12674              //锁存标志位置位。
  12675              AngleConfirmLockFlag = 1;
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable67_8
   \   00000094   0x7008             STRB     R0,[R1, #+0]
  12676              //数组清空，防止重复锁存。
  12677              for(i = 0; ; i++)
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xE000             B.N      ??AngleStep2Confirm_10
   \                     ??AngleStep2Confirm_11: (+1)
   \   0000009A   0x1C40             ADDS     R0,R0,#+1
  12678              {
  12679                AngleConfirmMat[i] = 0;
   \                     ??AngleStep2Confirm_10: (+1)
   \   0000009C   0x2100             MOVS     R1,#+0
   \   0000009E   0x.... 0x....      LDR.W    R2,??DataTable67_9
   \   000000A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A4   0x5481             STRB     R1,[R0, R2]
  12680                if(i == AngleConfirmMatNum - 1) break;
   \   000000A6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A8   0x2805             CMP      R0,#+5
   \   000000AA   0xD1F6             BNE.N    ??AngleStep2Confirm_11
  12681              }
  12682              //确认直角弯的方向。
  12683              if(PathType == PathTypeAngleL)
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable67_10
   \   000000B0   0x7800             LDRB     R0,[R0, #+0]
   \   000000B2   0x2804             CMP      R0,#+4
   \   000000B4   0xD104             BNE.N    ??AngleStep2Confirm_12
  12684              {
  12685                AngleSpeDealDir = 0;             //左直角弯
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable67_13
   \   000000BC   0x7008             STRB     R0,[R1, #+0]
   \   000000BE   0xE008             B.N      ??AngleStep2Confirm_9
  12686              }
  12687              else if(PathType == PathTypeAngleR)
   \                     ??AngleStep2Confirm_12: (+1)
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable67_10
   \   000000C4   0x7800             LDRB     R0,[R0, #+0]
   \   000000C6   0x2805             CMP      R0,#+5
   \   000000C8   0xD103             BNE.N    ??AngleStep2Confirm_9
  12688              {
  12689                AngleSpeDealDir = 1;             //右直角弯
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable67_13
   \   000000D0   0x7008             STRB     R0,[R1, #+0]
  12690              }
  12691              else
  12692              {
  12693                //AngleSpeDealDir = 2;             //错误
  12694              }
  12695            }
  12696            else
  12697            {
  12698            }
  12699            
  12700            //若直角弯锁存标志位置位，则等待矮线的线头够低后开始直角弯处理。
  12701            if(AngleConfirmLockFlag == 1)
   \                     ??AngleStep2Confirm_9: (+1)
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable67_8
   \   000000D6   0x7800             LDRB     R0,[R0, #+0]
   \   000000D8   0x2801             CMP      R0,#+1
   \   000000DA   0xD126             BNE.N    ??AngleStep2Confirm_13
  12702            {
  12703              //直角黑块锁存标志位清零。但因为直角锁存置位，所以直角黑块不会进行检测。
  12704              AngleZoneConfirmLockFlag = 0;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable67_14
   \   000000E2   0x7008             STRB     R0,[R1, #+0]
  12705              
  12706              //左直角弯
  12707              if(AngleSpeDealDir == 0)
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable67_13
   \   000000E8   0x7800             LDRB     R0,[R0, #+0]
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD10C             BNE.N    ??AngleStep2Confirm_14
  12708              {
  12709                if(BlackLeftHeadLine >= AngleSpeDealStartHeadLine || BlackLeftHeadLine == MaxValUint8)
   \   000000EE   0x....             LDR.N    R0,??DataTable65_4
   \   000000F0   0x7800             LDRB     R0,[R0, #+0]
   \   000000F2   0x2828             CMP      R0,#+40
   \   000000F4   0xDA03             BGE.N    ??AngleStep2Confirm_15
   \   000000F6   0x....             LDR.N    R0,??DataTable65_4
   \   000000F8   0x7800             LDRB     R0,[R0, #+0]
   \   000000FA   0x28FF             CMP      R0,#+255
   \   000000FC   0xD115             BNE.N    ??AngleStep2Confirm_13
  12710                {
  12711                  //左线头够矮（快到直角弯）或者左线头无效（已经过了直角弯），则开始直角弯特殊处理。
  12712                  AngleSpeDealBackCount = AngleSpeDealBackCountNum;
   \                     ??AngleStep2Confirm_15: (+1)
   \   000000FE   0x200F             MOVS     R0,#+15
   \   00000100   0x.... 0x....      LDR.W    R1,??DataTable67_2
   \   00000104   0x7008             STRB     R0,[R1, #+0]
   \   00000106   0xE010             B.N      ??AngleStep2Confirm_13
  12713                }
  12714                else
  12715                {
  12716                  //还没满足条件，再等等。
  12717                }
  12718              }
  12719              //右直角弯
  12720              else if(AngleSpeDealDir == 1)
   \                     ??AngleStep2Confirm_14: (+1)
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable67_13
   \   0000010C   0x7800             LDRB     R0,[R0, #+0]
   \   0000010E   0x2801             CMP      R0,#+1
   \   00000110   0xD10B             BNE.N    ??AngleStep2Confirm_13
  12721              {
  12722                if(BlackRightHeadLine >= AngleSpeDealStartHeadLine || BlackRightHeadLine == MaxValUint8)
   \   00000112   0x....             LDR.N    R0,??DataTable65_8
   \   00000114   0x7800             LDRB     R0,[R0, #+0]
   \   00000116   0x2828             CMP      R0,#+40
   \   00000118   0xDA03             BGE.N    ??AngleStep2Confirm_16
   \   0000011A   0x....             LDR.N    R0,??DataTable65_8
   \   0000011C   0x7800             LDRB     R0,[R0, #+0]
   \   0000011E   0x28FF             CMP      R0,#+255
   \   00000120   0xD103             BNE.N    ??AngleStep2Confirm_13
  12723                {
  12724                  //右线头够矮（快到直角弯）或者右线头无效（已经过了直角弯），则开始直角弯特殊处理。
  12725                  AngleSpeDealBackCount = AngleSpeDealBackCountNum;
   \                     ??AngleStep2Confirm_16: (+1)
   \   00000122   0x200F             MOVS     R0,#+15
   \   00000124   0x.... 0x....      LDR.W    R1,??DataTable67_2
   \   00000128   0x7008             STRB     R0,[R1, #+0]
  12726                }
  12727                else
  12728                {
  12729                  //还没满足条件，再等等。
  12730                }
  12731              }
  12732              else
  12733              {
  12734              }
  12735            }
  12736            else
  12737            {
  12738            }
  12739          
  12740            //退出直角特殊处理的判断。
  12741            AngleSpeDealExitJudgeFlag = AngleSpeDealExitJudge();
   \                     ??AngleStep2Confirm_13: (+1)
   \   0000012A   0x.... 0x....      BL       AngleSpeDealExitJudge
   \   0000012E   0x.... 0x....      LDR.W    R1,??DataTable67_15
   \   00000132   0x7008             STRB     R0,[R1, #+0]
  12742            
  12743            //有了倒数次数后，就开始每次倒数，直到为0或判断已经出了直角。并持续亮灯。
  12744            if(AngleSpeDealBackCount != 0 && AngleSpeDealExitJudgeFlag == 0)
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable67_2
   \   00000138   0x7800             LDRB     R0,[R0, #+0]
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD01D             BEQ.N    ??AngleStep2Confirm_17
   \   0000013E   0x.... 0x....      LDR.W    R0,??DataTable67_15
   \   00000142   0x7800             LDRB     R0,[R0, #+0]
   \   00000144   0x2800             CMP      R0,#+0
   \   00000146   0xD118             BNE.N    ??AngleStep2Confirm_17
  12745            {
  12746              AngleConfirmLockFlag = 0;    //直角弯判断成功锁存标志位清零。
   \   00000148   0x2000             MOVS     R0,#+0
   \   0000014A   0x.... 0x....      LDR.W    R1,??DataTable67_8
   \   0000014E   0x7008             STRB     R0,[R1, #+0]
  12747              
  12748              //倒数值减1。
  12749              AngleSpeDealBackCount--;
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable67_2
   \   00000154   0x7800             LDRB     R0,[R0, #+0]
   \   00000156   0x1E40             SUBS     R0,R0,#+1
   \   00000158   0x.... 0x....      LDR.W    R1,??DataTable67_2
   \   0000015C   0x7008             STRB     R0,[R1, #+0]
  12750              //对中心线的特殊处理函数，还剩AngleSpeDealBackCount次。
  12751              AngleSpeDealCen(AngleSpeDealDir);
   \   0000015E   0x.... 0x....      LDR.W    R0,??DataTable67_13
   \   00000162   0x7800             LDRB     R0,[R0, #+0]
   \   00000164   0x.... 0x....      BL       AngleSpeDealCen
  12752              //标志位说明进行了直角弯的特殊处理。
  12753              AngleSpeDealFlag = 1;
   \   00000168   0x2001             MOVS     R0,#+1
   \   0000016A   0x.... 0x....      LDR.W    R1,??DataTable67_16
   \   0000016E   0x7008             STRB     R0,[R1, #+0]
  12754              
  12755              //直角黑块锁存标志位清零。但因为直角锁存置位，所以直角黑块不会进行检测。
  12756              AngleZoneConfirmLockFlag = 0;    
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0x.... 0x....      LDR.W    R1,??DataTable67_14
   \   00000176   0x7008             STRB     R0,[R1, #+0]
   \   00000178   0xE007             B.N      ??AngleStep2Confirm_18
  12757            }
  12758            else
  12759            {
  12760              //倒数次数清零，防止再次启动直角弯特殊处理。
  12761              AngleSpeDealBackCount = 0;
   \                     ??AngleStep2Confirm_17: (+1)
   \   0000017A   0x2000             MOVS     R0,#+0
   \   0000017C   0x.... 0x....      LDR.W    R1,??DataTable67_2
   \   00000180   0x7008             STRB     R0,[R1, #+0]
  12762              
  12763              //标志位说明没有进行直角弯的特殊处理。
  12764              AngleSpeDealFlag = 0;
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable67_16
   \   00000188   0x7008             STRB     R0,[R1, #+0]
  12765            }
  12766            
  12767            return 1;
   \                     ??AngleStep2Confirm_18: (+1)
   \   0000018A   0x2001             MOVS     R0,#+1
   \   0000018C   0xBD02             POP      {R1,PC}          ;; return
  12768          }
  12769          
  12770          
  12771          
  12772          
  12773          
  12774          
  12775          
  12776          
  12777          
  12778          //赛道类型判断中的直道判断
  12779          //1是直道，0不是直道

   \                                 In section .text, align 2, keep-with-next
  12780          uint8 PathJudgeNewStraight(void)
  12781          {
   \                     PathJudgeNewStraight: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  12782            uint8 templ, tempr;
  12783            uint8 i;
  12784            uint8 errorcount;
  12785            
  12786            
  12787            //直道判断
  12788            //1. 直道的判断很严格，必须左右线均成功，且整个小5点斜率数组均很小。
  12789            if(BlackLeftDone == 1 && BlackRightDone == 1)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable67_17
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xF040 0x8165      BNE.W    ??PathJudgeNewStraight_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable67_18
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xF040 0x815F      BNE.W    ??PathJudgeNewStraight_0
  12790            {
  12791              //2. 直道还必须要求，线头为最低行。考虑到第56-59行会先找单线，不一定能成功，所以非起始扫描线放宽到第55行。
  12792              if(BlackGetPreDir == 0 || BlackGetPreDir == 2)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable67_19
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD004             BEQ.N    ??PathJudgeNewStraight_1
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable67_19
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x2802             CMP      R0,#+2
   \   0000002C   0xD10B             BNE.N    ??PathJudgeNewStraight_2
  12793              {
  12794                if(BlackLeftStep1ScanRow == CameraHight - 1 && BlackRightStep1ScanRow >= CameraHight - 5)
   \                     ??PathJudgeNewStraight_1: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable67_20
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x283B             CMP      R0,#+59
   \   00000036   0xD104             BNE.N    ??PathJudgeNewStraight_3
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable67_21
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x2837             CMP      R0,#+55
   \   00000040   0xDA0D             BGE.N    ??PathJudgeNewStraight_4
  12795                {
  12796                }
  12797                else
  12798                {
  12799                  return 0;
   \                     ??PathJudgeNewStraight_3: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE14D             B.N      ??PathJudgeNewStraight_5
  12800                }
  12801              }
  12802              else
  12803              {
  12804                if (BlackLeftStep1ScanRow >= CameraHight - 5 && BlackRightStep1ScanRow == CameraHight - 1)
   \                     ??PathJudgeNewStraight_2: (+1)
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable67_20
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x2837             CMP      R0,#+55
   \   0000004E   0xDB04             BLT.N    ??PathJudgeNewStraight_6
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable67_21
   \   00000054   0x7800             LDRB     R0,[R0, #+0]
   \   00000056   0x283B             CMP      R0,#+59
   \   00000058   0xD001             BEQ.N    ??PathJudgeNewStraight_4
  12805                {
  12806                }
  12807                else
  12808                {
  12809                  return 0;
   \                     ??PathJudgeNewStraight_6: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xE141             B.N      ??PathJudgeNewStraight_5
  12810                }
  12811              }
  12812              //3. PathJudgeNewStraightChoose为0表示判断直道要用到所有的点，而不是掐头。
  12813              //此种方法比较严格，会减小直道判断成功率，但不容易将其它赛道误判成直道。
  12814              if(PathJudgeNewStraightChoose == 0)
  12815              {
  12816                errorcount = 0;
  12817                //左线
  12818                //搜索小5点斜率数组的末端
  12819                templ = BlackLeft5SlopeIndex - 1;
  12820                //if(templ <= 10) return 0;
  12821                
  12822                //逐个判断小5点斜率是否满足条件
  12823                for(i = 0; ; i++)
  12824                {
  12825                  if(BlackLeft5Slope[i] > 0 || BlackLeft5Slope[i] < 0 - PathJudgeStraightSlopeLimit) //右上到左下的斜率是负的。 
  12826                  {
  12827                    errorcount++;
  12828                    if(errorcount > 3) break;   //允许有若干个点斜率超出范围
  12829                  }
  12830                  
  12831                  //if(i == templ - 10) break;
  12832                  if(i == templ) break;
  12833                }
  12834                //if(i != templ - 10) 
  12835                if(i != templ)
  12836                {
  12837                  flag000 = 3;
  12838                  flag111 = BlackLeft5Slope[i];
  12839                  return 0;
  12840                }
  12841                
  12842                errorcount = 0;
  12843                //右线
  12844                //搜索小5点斜率数组的末端
  12845                tempr = BlackRight5SlopeIndex - 1;
  12846                //if(tempr <= 10) return 0;
  12847                
  12848                //逐个判断小5点斜率是否满足条件
  12849                for(i = 0; ; i++)
  12850                {
  12851                  if(BlackRight5Slope[i] < 0 || BlackRight5Slope[i] > PathJudgeStraightSlopeLimit) //左上到右下的斜率是正的。
  12852                  {
  12853                    errorcount++;
  12854                    if(errorcount > 3) break;   //允许有若干个点斜率超出范围
  12855                  }
  12856                  
  12857                  //if(i == tempr - 10) break;
  12858                  if(i == tempr) break;
  12859                }
  12860                //if(i != tempr - 10)
  12861                if(i != tempr)
  12862                {
  12863                  flag111 = BlackRight5Slope[i];
  12864                  flag000 = 5;
  12865                  return 0;
  12866                }
  12867                
  12868                //走到这里说明判断直道成功。
  12869                flag000 = 0;
  12870                PathType = PathTypeStraight;
  12871                return 1;
  12872              
  12873              }
  12874              //3. PathJudgeNewStraightChoose为1表示判断直道时掐掉线头开始往近行的10行，再判断。
  12875              //此种方法能增加直道判断成功率，但容易将其它赛道误判成直道。
  12876              else if(PathJudgeNewStraightChoose == 1)
  12877              {
  12878                errorcount = 0;
  12879                //左线
  12880                //搜索小5点斜率数组的末端
  12881                templ = BlackLeft5SlopeIndex - 1;
  12882                if(templ <= 10) return 0; //
  12883                
  12884                //逐个判断小5点斜率是否满足条件
  12885                for(i = 0; ; i++)
  12886                {
  12887                  if(BlackLeft5Slope[i] > 0 || BlackLeft5Slope[i] < 0 - PathJudgeStraightSlopeLimit) //右上到左下的斜率是负的。 
  12888                  {
  12889                    errorcount++;
  12890                    if(errorcount > 3) break;   //允许有若干个点斜率超出范围
  12891                  }
  12892                  
  12893                  if(i == templ - 10) break;
  12894                  //if(i == templ) break;
  12895                }
  12896                if(i != templ - 10) 
  12897                //if(i != templ)
  12898                {
  12899                  flag000 = 3;
  12900                  flag111 = BlackLeft5Slope[i];
  12901                  return 0;
  12902                }
  12903                
  12904                errorcount = 0;
  12905                //右线
  12906                //搜索小5点斜率数组的末端
  12907                tempr = BlackRight5SlopeIndex - 1;
  12908                if(tempr <= 10) return 0;  //
  12909                
  12910                //逐个判断小5点斜率是否满足条件
  12911                for(i = 0; ; i++)
  12912                {
  12913                  if(BlackRight5Slope[i] < 0 || BlackRight5Slope[i] > PathJudgeStraightSlopeLimit) //左上到右下的斜率是正的。
  12914                  {
  12915                    errorcount++;
  12916                    if(errorcount > 3) break;   //允许有若干个点斜率超出范围
  12917                  }
  12918                  
  12919                  if(i == tempr - 10) break;
  12920                  //if(i == tempr) break;
  12921                }
  12922                if(i != tempr - 10) 
  12923                //if(i != tempr)
  12924                {
  12925                  flag111 = BlackRight5Slope[i];
  12926                  flag000 = 5;
  12927                  return 0;
  12928                }
  12929                
  12930                //走到这里说明判断直道成功。
  12931                flag000 = 0;
  12932                PathType = PathTypeStraight;
  12933                return 1;      
  12934              }
  12935              //3. PathJudgeNewStraightChoose为2表示判断直道要用到所有的点，而不是掐头。
  12936              //此种方法比较严格，会减小直道判断成功率，但不容易将其它赛道误判成直道。
  12937              //这种方法的厉害之处在于考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
  12938              else
  12939              {
  12940                //不是单线的情况
  12941                if(SingleBlackAllFlag == 0)
   \                     ??PathJudgeNewStraight_4: (+1)
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable67_22
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xF040 0x809B      BNE.W    ??PathJudgeNewStraight_7
  12942                {
  12943                  errorcount = 0;
   \   0000006A   0x2400             MOVS     R4,#+0
  12944                  //左线
  12945                  //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
  12946                  if(BlackLeftEndLine - BlackLeftHeadLine - 4 < 0 || BlackLeft5SlopeIndex - 1 < 0)
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable67_23
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable67_24
   \   00000076   0x7809             LDRB     R1,[R1, #+0]
   \   00000078   0x1A40             SUBS     R0,R0,R1
   \   0000007A   0x1F00             SUBS     R0,R0,#+4
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD405             BMI.N    ??PathJudgeNewStraight_8
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable67_25
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x1E40             SUBS     R0,R0,#+1
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD501             BPL.N    ??PathJudgeNewStraight_9
  12947                  {
  12948                    return 0;
   \                     ??PathJudgeNewStraight_8: (+1)
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xE128             B.N      ??PathJudgeNewStraight_5
  12949                  }
  12950                  else
  12951                  {        
  12952                  }
  12953                  templ = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 4, BlackLeft5SlopeIndex - 1);
   \                     ??PathJudgeNewStraight_9: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable67_25
   \   00000094   0x7800             LDRB     R0,[R0, #+0]
   \   00000096   0x1E41             SUBS     R1,R0,#+1
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable67_23
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x.... 0x....      LDR.W    R2,??DataTable67_24
   \   000000A2   0x7812             LDRB     R2,[R2, #+0]
   \   000000A4   0x1A80             SUBS     R0,R0,R2
   \   000000A6   0x1F00             SUBS     R0,R0,#+4
   \   000000A8   0x.... 0x....      BL       MinRe
  12954                  //if(templ <= 10) return 0;
  12955                  
  12956                  //逐个判断小5点斜率是否满足条件
  12957                  for(i = 0; ; i++)
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0xE000             B.N      ??PathJudgeNewStraight_10
   \                     ??PathJudgeNewStraight_11: (+1)
   \   000000B0   0x1C49             ADDS     R1,R1,#+1
  12958                  {
  12959                    if(BlackLeft5Slope[i] > 0 || BlackLeft5Slope[i] < 0 - PathJudgeStraightSlopeLimit) //右上到左下的斜率是负的。 
   \                     ??PathJudgeNewStraight_10: (+1)
   \   000000B2   0x.... 0x....      LDR.W    R2,??DataTable67_26
   \   000000B6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B8   0xF852 0x2021      LDR      R2,[R2, R1, LSL #+2]
   \   000000BC   0xF602 0x0234      ADDW     R2,R2,#+2100
   \   000000C0   0xF640 0x0335      MOVW     R3,#+2101
   \   000000C4   0x429A             CMP      R2,R3
   \   000000C6   0xD303             BCC.N    ??PathJudgeNewStraight_12
  12960                    {
  12961                      errorcount++;
   \   000000C8   0x1C64             ADDS     R4,R4,#+1
  12962                      if(errorcount > 3) break;   //允许有若干个点斜率超出范围
   \   000000CA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CC   0x2C04             CMP      R4,#+4
   \   000000CE   0xDA03             BGE.N    ??PathJudgeNewStraight_13
  12963                    }
  12964                    
  12965                    //if(i == templ - 10) break;
  12966                    if(i == templ) break;
   \                     ??PathJudgeNewStraight_12: (+1)
   \   000000D0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D4   0x4281             CMP      R1,R0
   \   000000D6   0xD1EB             BNE.N    ??PathJudgeNewStraight_11
  12967                  }
  12968                  //if(i != templ - 10) 
  12969                  if(i != templ)
   \                     ??PathJudgeNewStraight_13: (+1)
   \   000000D8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000DA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DC   0x4281             CMP      R1,R0
   \   000000DE   0xD00D             BEQ.N    ??PathJudgeNewStraight_14
  12970                  {
  12971                    flag000 = 3;
   \   000000E0   0x2003             MOVS     R0,#+3
   \   000000E2   0x.... 0x....      LDR.W    R2,??DataTable67_27
   \   000000E6   0x7010             STRB     R0,[R2, #+0]
  12972                    flag111 = BlackLeft5Slope[i];
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable67_26
   \   000000EC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000EE   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable67_28
   \   000000F6   0x6008             STR      R0,[R1, #+0]
  12973                    return 0;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xE0F2             B.N      ??PathJudgeNewStraight_5
  12974                  }
  12975                  
  12976                  errorcount = 0;
   \                     ??PathJudgeNewStraight_14: (+1)
   \   000000FC   0x2400             MOVS     R4,#+0
  12977                  
  12978                  //右线
  12979                  //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
  12980                  if(BlackRightEndLine - BlackRightHeadLine - 4 < 0 || BlackRight5SlopeIndex - 1 < 0)
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable67_29
   \   00000102   0x7800             LDRB     R0,[R0, #+0]
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable67
   \   00000108   0x7809             LDRB     R1,[R1, #+0]
   \   0000010A   0x1A40             SUBS     R0,R0,R1
   \   0000010C   0x1F00             SUBS     R0,R0,#+4
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD405             BMI.N    ??PathJudgeNewStraight_15
   \   00000112   0x.... 0x....      LDR.W    R0,??DataTable67_30
   \   00000116   0x7800             LDRB     R0,[R0, #+0]
   \   00000118   0x1E40             SUBS     R0,R0,#+1
   \   0000011A   0x2800             CMP      R0,#+0
   \   0000011C   0xD501             BPL.N    ??PathJudgeNewStraight_16
  12981                  {
  12982                    return 0;
   \                     ??PathJudgeNewStraight_15: (+1)
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0xE0DF             B.N      ??PathJudgeNewStraight_5
  12983                  }
  12984                  else
  12985                  {
  12986                  }
  12987                  tempr = MinRe(BlackRightEndLine - BlackRightHeadLine - 4, BlackRight5SlopeIndex - 1);
   \                     ??PathJudgeNewStraight_16: (+1)
   \   00000122   0x.... 0x....      LDR.W    R0,??DataTable67_30
   \   00000126   0x7800             LDRB     R0,[R0, #+0]
   \   00000128   0x1E41             SUBS     R1,R0,#+1
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable67_29
   \   0000012E   0x7800             LDRB     R0,[R0, #+0]
   \   00000130   0x.... 0x....      LDR.W    R2,??DataTable67
   \   00000134   0x7812             LDRB     R2,[R2, #+0]
   \   00000136   0x1A80             SUBS     R0,R0,R2
   \   00000138   0x1F00             SUBS     R0,R0,#+4
   \   0000013A   0x.... 0x....      BL       MinRe
  12988                  //if(tempr <= 10) return 0;
  12989                  
  12990                  //逐个判断小5点斜率是否满足条件
  12991                  for(i = 0; ; i++)
   \   0000013E   0x2100             MOVS     R1,#+0
   \   00000140   0xE000             B.N      ??PathJudgeNewStraight_17
   \                     ??PathJudgeNewStraight_18: (+1)
   \   00000142   0x1C49             ADDS     R1,R1,#+1
  12992                  {
  12993                    if(BlackRight5Slope[i] < 0 || BlackRight5Slope[i] > PathJudgeStraightSlopeLimit) //左上到右下的斜率是正的。
   \                     ??PathJudgeNewStraight_17: (+1)
   \   00000144   0x.... 0x....      LDR.W    R2,??DataTable67_31
   \   00000148   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000014A   0xF852 0x2021      LDR      R2,[R2, R1, LSL #+2]
   \   0000014E   0x1E12             SUBS     R2,R2,#+0
   \   00000150   0xF640 0x0335      MOVW     R3,#+2101
   \   00000154   0x429A             CMP      R2,R3
   \   00000156   0xD303             BCC.N    ??PathJudgeNewStraight_19
  12994                    {
  12995                      errorcount++;
   \   00000158   0x1C64             ADDS     R4,R4,#+1
  12996                      if(errorcount > 3) break;   //允许有若干个点斜率超出范围
   \   0000015A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000015C   0x2C04             CMP      R4,#+4
   \   0000015E   0xDA03             BGE.N    ??PathJudgeNewStraight_20
  12997                    }
  12998                    
  12999                    //if(i == tempr - 10) break;
  13000                    if(i == tempr) break;
   \                     ??PathJudgeNewStraight_19: (+1)
   \   00000160   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000162   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000164   0x4281             CMP      R1,R0
   \   00000166   0xD1EC             BNE.N    ??PathJudgeNewStraight_18
  13001                  }
  13002                  //if(i != tempr - 10)
  13003                  if(i != tempr)
   \                     ??PathJudgeNewStraight_20: (+1)
   \   00000168   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000016A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000016C   0x4281             CMP      R1,R0
   \   0000016E   0xD00D             BEQ.N    ??PathJudgeNewStraight_21
  13004                  {
  13005                    flag111 = BlackRight5Slope[i];
   \   00000170   0x.... 0x....      LDR.W    R0,??DataTable67_31
   \   00000174   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000176   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   0000017A   0x.... 0x....      LDR.W    R1,??DataTable67_28
   \   0000017E   0x6008             STR      R0,[R1, #+0]
  13006                    flag000 = 5;
   \   00000180   0x2005             MOVS     R0,#+5
   \   00000182   0x.... 0x....      LDR.W    R1,??DataTable67_27
   \   00000186   0x7008             STRB     R0,[R1, #+0]
  13007                    return 0;
   \   00000188   0x2000             MOVS     R0,#+0
   \   0000018A   0xE0AA             B.N      ??PathJudgeNewStraight_5
  13008                  }
  13009                  
  13010                  //走到这里说明判断直道成功。
  13011                  flag000 = 0;
   \                     ??PathJudgeNewStraight_21: (+1)
   \   0000018C   0x2000             MOVS     R0,#+0
   \   0000018E   0x.... 0x....      LDR.W    R1,??DataTable67_27
   \   00000192   0x7008             STRB     R0,[R1, #+0]
  13012                  PathType = PathTypeStraight;
   \   00000194   0x2001             MOVS     R0,#+1
   \   00000196   0x.... 0x....      LDR.W    R1,??DataTable67_10
   \   0000019A   0x7008             STRB     R0,[R1, #+0]
  13013                  return 1;   
   \   0000019C   0x2001             MOVS     R0,#+1
   \   0000019E   0xE0A0             B.N      ??PathJudgeNewStraight_5
  13014                }
  13015                //单线的情况
  13016                else
  13017                {
  13018                  errorcount = 0;
   \                     ??PathJudgeNewStraight_7: (+1)
   \   000001A0   0x2400             MOVS     R4,#+0
  13019                  //左线
  13020                  //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
  13021                  if(BlackLeftEndLine - BlackLeftHeadLine - 4 < 0 || BlackLeft5SlopeIndex - 1 < 0)
   \   000001A2   0x.... 0x....      LDR.W    R0,??DataTable67_23
   \   000001A6   0x7800             LDRB     R0,[R0, #+0]
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable67_24
   \   000001AC   0x7809             LDRB     R1,[R1, #+0]
   \   000001AE   0x1A40             SUBS     R0,R0,R1
   \   000001B0   0x1F00             SUBS     R0,R0,#+4
   \   000001B2   0x2800             CMP      R0,#+0
   \   000001B4   0xD405             BMI.N    ??PathJudgeNewStraight_22
   \   000001B6   0x.... 0x....      LDR.W    R0,??DataTable67_25
   \   000001BA   0x7800             LDRB     R0,[R0, #+0]
   \   000001BC   0x1E40             SUBS     R0,R0,#+1
   \   000001BE   0x2800             CMP      R0,#+0
   \   000001C0   0xD501             BPL.N    ??PathJudgeNewStraight_23
  13022                  {
  13023                    return 0;
   \                     ??PathJudgeNewStraight_22: (+1)
   \   000001C2   0x2000             MOVS     R0,#+0
   \   000001C4   0xE08D             B.N      ??PathJudgeNewStraight_5
  13024                  }
  13025                  else
  13026                  {        
  13027                  }
  13028                  templ = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 4, BlackLeft5SlopeIndex - 1);
   \                     ??PathJudgeNewStraight_23: (+1)
   \   000001C6   0x.... 0x....      LDR.W    R0,??DataTable67_25
   \   000001CA   0x7800             LDRB     R0,[R0, #+0]
   \   000001CC   0x1E41             SUBS     R1,R0,#+1
   \   000001CE   0x.... 0x....      LDR.W    R0,??DataTable67_23
   \   000001D2   0x7800             LDRB     R0,[R0, #+0]
   \   000001D4   0x.... 0x....      LDR.W    R2,??DataTable67_24
   \   000001D8   0x7812             LDRB     R2,[R2, #+0]
   \   000001DA   0x1A80             SUBS     R0,R0,R2
   \   000001DC   0x1F00             SUBS     R0,R0,#+4
   \   000001DE   0x.... 0x....      BL       MinRe
  13029                  //if(templ <= 10) return 0;
  13030                  
  13031                  //逐个判断小5点斜率是否满足条件
  13032                  for(i = 0; ; i++)
   \   000001E2   0x2100             MOVS     R1,#+0
   \   000001E4   0xE000             B.N      ??PathJudgeNewStraight_24
   \                     ??PathJudgeNewStraight_25: (+1)
   \   000001E6   0x1C49             ADDS     R1,R1,#+1
  13033                  {
  13034                    if(BlackLeft5Slope[i] > 1001 || BlackLeft5Slope[i] < 0 - 1000) //右上到左下的斜率是负的。 
   \                     ??PathJudgeNewStraight_24: (+1)
   \   000001E8   0x.... 0x....      LDR.W    R2,??DataTable67_26
   \   000001EC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001EE   0xF852 0x2021      LDR      R2,[R2, R1, LSL #+2]
   \   000001F2   0xF512 0x727A      ADDS     R2,R2,#+1000
   \   000001F6   0xF240 0x73D2      MOVW     R3,#+2002
   \   000001FA   0x429A             CMP      R2,R3
   \   000001FC   0xD303             BCC.N    ??PathJudgeNewStraight_26
  13035                    {
  13036                      errorcount++;
   \   000001FE   0x1C64             ADDS     R4,R4,#+1
  13037                      if(errorcount > 3) break;   //允许有若干个点斜率超出范围
   \   00000200   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000202   0x2C04             CMP      R4,#+4
   \   00000204   0xDA03             BGE.N    ??PathJudgeNewStraight_27
  13038                    }
  13039                    
  13040                    //if(i == templ - 10) break;
  13041                    if(i == templ) break;
   \                     ??PathJudgeNewStraight_26: (+1)
   \   00000206   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000208   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000020A   0x4281             CMP      R1,R0
   \   0000020C   0xD1EB             BNE.N    ??PathJudgeNewStraight_25
  13042                  }
  13043                  //if(i != templ - 10) 
  13044                  if(i != templ)
   \                     ??PathJudgeNewStraight_27: (+1)
   \   0000020E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000210   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000212   0x4281             CMP      R1,R0
   \   00000214   0xD00D             BEQ.N    ??PathJudgeNewStraight_28
  13045                  {
  13046                    flag000 = 3;
   \   00000216   0x2003             MOVS     R0,#+3
   \   00000218   0x.... 0x....      LDR.W    R2,??DataTable67_27
   \   0000021C   0x7010             STRB     R0,[R2, #+0]
  13047                    flag111 = BlackLeft5Slope[i];
   \   0000021E   0x.... 0x....      LDR.W    R0,??DataTable67_26
   \   00000222   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000224   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000228   0x.... 0x....      LDR.W    R1,??DataTable67_28
   \   0000022C   0x6008             STR      R0,[R1, #+0]
  13048                    return 0;
   \   0000022E   0x2000             MOVS     R0,#+0
   \   00000230   0xE057             B.N      ??PathJudgeNewStraight_5
  13049                  }
  13050                  
  13051                  errorcount = 0;
   \                     ??PathJudgeNewStraight_28: (+1)
   \   00000232   0x2400             MOVS     R4,#+0
  13052                  
  13053                  //右线
  13054                  //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
  13055                  if(BlackRightEndLine - BlackRightHeadLine - 4 < 0 || BlackRight5SlopeIndex - 1 < 0)
   \   00000234   0x.... 0x....      LDR.W    R0,??DataTable67_29
   \   00000238   0x7800             LDRB     R0,[R0, #+0]
   \   0000023A   0x.... 0x....      LDR.W    R1,??DataTable67
   \   0000023E   0x7809             LDRB     R1,[R1, #+0]
   \   00000240   0x1A40             SUBS     R0,R0,R1
   \   00000242   0x1F00             SUBS     R0,R0,#+4
   \   00000244   0x2800             CMP      R0,#+0
   \   00000246   0xD405             BMI.N    ??PathJudgeNewStraight_29
   \   00000248   0x.... 0x....      LDR.W    R0,??DataTable67_30
   \   0000024C   0x7800             LDRB     R0,[R0, #+0]
   \   0000024E   0x1E40             SUBS     R0,R0,#+1
   \   00000250   0x2800             CMP      R0,#+0
   \   00000252   0xD501             BPL.N    ??PathJudgeNewStraight_30
  13056                  {
  13057                    return 0;
   \                     ??PathJudgeNewStraight_29: (+1)
   \   00000254   0x2000             MOVS     R0,#+0
   \   00000256   0xE044             B.N      ??PathJudgeNewStraight_5
  13058                  }
  13059                  else
  13060                  {
  13061                  }
  13062                  tempr = MinRe(BlackRightEndLine - BlackRightHeadLine - 4, BlackRight5SlopeIndex - 1);
   \                     ??PathJudgeNewStraight_30: (+1)
   \   00000258   0x.... 0x....      LDR.W    R0,??DataTable67_30
   \   0000025C   0x7800             LDRB     R0,[R0, #+0]
   \   0000025E   0x1E41             SUBS     R1,R0,#+1
   \   00000260   0x.... 0x....      LDR.W    R0,??DataTable67_29
   \   00000264   0x7800             LDRB     R0,[R0, #+0]
   \   00000266   0x.... 0x....      LDR.W    R2,??DataTable67
   \   0000026A   0x7812             LDRB     R2,[R2, #+0]
   \   0000026C   0x1A80             SUBS     R0,R0,R2
   \   0000026E   0x1F00             SUBS     R0,R0,#+4
   \   00000270   0x.... 0x....      BL       MinRe
  13063                  //if(tempr <= 10) return 0;
  13064                  
  13065                  //逐个判断小5点斜率是否满足条件
  13066                  for(i = 0; ; i++)
   \   00000274   0x2100             MOVS     R1,#+0
   \   00000276   0xE000             B.N      ??PathJudgeNewStraight_31
   \                     ??PathJudgeNewStraight_32: (+1)
   \   00000278   0x1C49             ADDS     R1,R1,#+1
  13067                  {
  13068                    if(BlackRight5Slope[i] < 0 - 1001 || BlackRight5Slope[i] > 1000) //左上到右下的斜率是正的。
   \                     ??PathJudgeNewStraight_31: (+1)
   \   0000027A   0x.... 0x....      LDR.W    R2,??DataTable67_31
   \   0000027E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000280   0xF852 0x2021      LDR      R2,[R2, R1, LSL #+2]
   \   00000284   0xF202 0x32E9      ADDW     R2,R2,#+1001
   \   00000288   0xF240 0x73D2      MOVW     R3,#+2002
   \   0000028C   0x429A             CMP      R2,R3
   \   0000028E   0xD303             BCC.N    ??PathJudgeNewStraight_33
  13069                    {
  13070                      errorcount++;
   \   00000290   0x1C64             ADDS     R4,R4,#+1
  13071                      if(errorcount > 3) break;   //允许有若干个点斜率超出范围
   \   00000292   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000294   0x2C04             CMP      R4,#+4
   \   00000296   0xDA03             BGE.N    ??PathJudgeNewStraight_34
  13072                    }
  13073                    
  13074                    //if(i == tempr - 10) break;
  13075                    if(i == tempr) break;
   \                     ??PathJudgeNewStraight_33: (+1)
   \   00000298   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000029A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000029C   0x4281             CMP      R1,R0
   \   0000029E   0xD1EB             BNE.N    ??PathJudgeNewStraight_32
  13076                  }
  13077                  //if(i != tempr - 10)
  13078                  if(i != tempr)
   \                     ??PathJudgeNewStraight_34: (+1)
   \   000002A0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002A4   0x4281             CMP      R1,R0
   \   000002A6   0xD00D             BEQ.N    ??PathJudgeNewStraight_35
  13079                  {
  13080                    flag111 = BlackRight5Slope[i];
   \   000002A8   0x.... 0x....      LDR.W    R0,??DataTable67_31
   \   000002AC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002AE   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   000002B2   0x.... 0x....      LDR.W    R1,??DataTable67_28
   \   000002B6   0x6008             STR      R0,[R1, #+0]
  13081                    flag000 = 5;
   \   000002B8   0x2005             MOVS     R0,#+5
   \   000002BA   0x.... 0x....      LDR.W    R1,??DataTable67_27
   \   000002BE   0x7008             STRB     R0,[R1, #+0]
  13082                    return 0;
   \   000002C0   0x2000             MOVS     R0,#+0
   \   000002C2   0xE00E             B.N      ??PathJudgeNewStraight_5
  13083                  }
  13084                  
  13085                  //走到这里说明判断直道成功。
  13086                  flag000 = 0;
   \                     ??PathJudgeNewStraight_35: (+1)
   \   000002C4   0x2000             MOVS     R0,#+0
   \   000002C6   0x.... 0x....      LDR.W    R1,??DataTable67_27
   \   000002CA   0x7008             STRB     R0,[R1, #+0]
  13087                  PathType = PathTypeStraight;
   \   000002CC   0x2001             MOVS     R0,#+1
   \   000002CE   0x.... 0x....      LDR.W    R1,??DataTable67_10
   \   000002D2   0x7008             STRB     R0,[R1, #+0]
  13088                  return 1;           
   \   000002D4   0x2001             MOVS     R0,#+1
   \   000002D6   0xE004             B.N      ??PathJudgeNewStraight_5
  13089                }
  13090              }
  13091            }
  13092            else
  13093            {
  13094              flag000 = 1;
   \                     ??PathJudgeNewStraight_0: (+1)
   \   000002D8   0x2001             MOVS     R0,#+1
   \   000002DA   0x.... 0x....      LDR.W    R1,??DataTable67_27
   \   000002DE   0x7008             STRB     R0,[R1, #+0]
  13095              //两线若有什么任何一线不成功，则不可能是直道，直接返回0.
  13096              return 0;
   \   000002E0   0x2000             MOVS     R0,#+0
   \                     ??PathJudgeNewStraight_5: (+1)
   \   000002E2   0xBD10             POP      {R4,PC}          ;; return
  13097            }
  13098            
  13099          }
  13100          
  13101          //障碍判断
  13102          //进来的前提是赛道类型为直道

   \                                 In section .text, align 2, keep-with-next
  13103          uint8 BrickJudge(void)
  13104          {
   \                     BrickJudge: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
  13105            uint8 row;
  13106            uint8 col;
  13107            uint8 count1, count2, count3;
  13108              
  13109            int32 a0, a1;
  13110            uint8 i, index, tempend;
  13111            
  13112            uint8 x[BrickSlopeRowNum];   //取多少个点在一开始有定义。
  13113            uint8 y[BrickSlopeRowNum];
  13114            
  13115            if(BlackLeftDone == 1 && BlackRightDone == 1)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable67_17
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD104             BNE.N    ??BrickJudge_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable67_18
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD001             BEQ.N    ??BrickJudge_1
  13116            {
  13117            }
  13118            else
  13119            {
  13120              return 0;
   \                     ??BrickJudge_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE28F             B.N      ??BrickJudge_2
  13121            }
  13122            
  13123            
  13124            //左障碍查找，先看看满不满足基本条件。
  13125            if(
  13126              (BlackRightHeadLine > BrickHeadRow)                                         //右线头太近
  13127            ||(BlackRightCrossDone != 0 && BlackRightRow1RealLastLine  > BrickHeadRow)    //右线开启了十字再检测，且第1段黑线起始行太近。
  13128              )
   \                     ??BrickJudge_1: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable67
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2810             CMP      R0,#+16
   \   00000024   0xF280 0x8143      BGE.W    ??BrickJudge_3
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable67_32
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD005             BEQ.N    ??BrickJudge_4
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable67_33
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x2810             CMP      R0,#+16
   \   0000003A   0xF280 0x8138      BGE.W    ??BrickJudge_3
  13129            {
  13130              //不满足基本条件，更有可能是右障碍，直接跳过左障碍去检测右障碍。
  13131            }
  13132            else
  13133            {
  13134              //1.1 障碍边，最小二乘法计算扫描起始行和结束行的黑点所在列。
  13135              //取BrickSlopeRowNum个点作为最小二乘法的基准点。
  13136              //以左上角为原点，向下为x轴正方向，向右为y轴正方向
  13137              index = 0;    
   \                     ??BrickJudge_4: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
  13138              for(i = BrickEndRow + 1; ; i++)
   \   00000040   0x2124             MOVS     R1,#+36
   \   00000042   0xE000             B.N      ??BrickJudge_5
   \                     ??BrickJudge_6: (+1)
   \   00000044   0x1C49             ADDS     R1,R1,#+1
  13139              {
  13140                if(BlackLeftLoc[i][0] != MaxValUint8)
   \                     ??BrickJudge_5: (+1)
   \   00000046   0x.... 0x....      LDR.W    R2,??DataTable67_34
   \   0000004A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004C   0x2303             MOVS     R3,#+3
   \   0000004E   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000052   0x7812             LDRB     R2,[R2, #+0]
   \   00000054   0x2AFF             CMP      R2,#+255
   \   00000056   0xD00D             BEQ.N    ??BrickJudge_7
  13141                {
  13142                  y[index] = BlackLeftLoc[i][0];
   \   00000058   0x.... 0x....      LDR.W    R2,??DataTable67_34
   \   0000005C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005E   0x2303             MOVS     R3,#+3
   \   00000060   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000064   0x7812             LDRB     R2,[R2, #+0]
   \   00000066   0xAB00             ADD      R3,SP,#+0
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0x54C2             STRB     R2,[R0, R3]
  13143                  x[index] = i;
   \   0000006C   0xAA02             ADD      R2,SP,#+8
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0x5481             STRB     R1,[R0, R2]
  13144                  index++;
   \   00000072   0x1C40             ADDS     R0,R0,#+1
  13145                }
  13146                if(index == BrickSlopeRowNum)
   \                     ??BrickJudge_7: (+1)
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0x2808             CMP      R0,#+8
   \   00000078   0xD10D             BNE.N    ??BrickJudge_8
  13147                {
  13148                  break;  
  13149                }
  13150                if(i == CameraHight - 1)
  13151                {
  13152                  return 0;
  13153                }
  13154              }
  13155              
  13156              //最小二乘法
  13157              //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
  13158              a1 = LeastSquarea1(x, y, BrickSlopeRowNum);
   \   0000007A   0x2208             MOVS     R2,#+8
   \   0000007C   0xA900             ADD      R1,SP,#+0
   \   0000007E   0xA802             ADD      R0,SP,#+8
   \   00000080   0x.... 0x....      BL       LeastSquarea1
   \   00000084   0x0004             MOVS     R4,R0
  13159              //左边，斜率应该是-PathJudgeStraightSlopeLimit~0,否则斜率不对，返回失败。
  13160              if(a1 < 0 && a1 + PathJudgeStraightSlopeLimit > 0)
   \   00000086   0x2C00             CMP      R4,#+0
   \   00000088   0xD503             BPL.N    ??BrickJudge_9
   \   0000008A   0xF604 0x0034      ADDW     R0,R4,#+2100
   \   0000008E   0x2801             CMP      R0,#+1
   \   00000090   0xDA06             BGE.N    ??BrickJudge_10
  13161              {
  13162              }
  13163              else
  13164              {
  13165                return 0;
   \                     ??BrickJudge_9: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0xE252             B.N      ??BrickJudge_2
  13166              }
   \                     ??BrickJudge_8: (+1)
   \   00000096   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000098   0x293B             CMP      R1,#+59
   \   0000009A   0xD1D3             BNE.N    ??BrickJudge_6
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xE24D             B.N      ??BrickJudge_2
  13167              a0 = LeastSquarea0(x, y, a1, BrickSlopeRowNum);
   \                     ??BrickJudge_10: (+1)
   \   000000A0   0x2308             MOVS     R3,#+8
   \   000000A2   0x0022             MOVS     R2,R4
   \   000000A4   0xA900             ADD      R1,SP,#+0
   \   000000A6   0xA802             ADD      R0,SP,#+8
   \   000000A8   0x.... 0x....      BL       LeastSquarea0
   \   000000AC   0x0005             MOVS     R5,R0
  13168              //直角梯形的两个突出顶点所在列
  13169              //起始行（近行）黑点所在列。
  13170              BrickEndColL = (a0 + a1 * BrickEndRow) / LeastSquareMulti + BrickColCom;
   \   000000AE   0x2023             MOVS     R0,#+35
   \   000000B0   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   000000B4   0xF44F 0x717A      MOV      R1,#+1000
   \   000000B8   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000BC   0x1D40             ADDS     R0,R0,#+5
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable68
   \   000000C2   0x7008             STRB     R0,[R1, #+0]
  13171              //结束行（远行）黑点所在列
  13172              BrickHeadColL = (a0 + a1 * BrickHeadRow) / LeastSquareMulti + BrickColCom;
   \   000000C4   0x200F             MOVS     R0,#+15
   \   000000C6   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   000000CA   0xF44F 0x717A      MOV      R1,#+1000
   \   000000CE   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000D2   0x1D40             ADDS     R0,R0,#+5
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable68_1
   \   000000D8   0x7008             STRB     R0,[R1, #+0]
  13173              //直角梯形的直角边所在列。左障碍扫描的右边界。稍微限幅一下。
  13174              //不能超过图像右边界
  13175              BrickBorderColL = MinRe(CameraRealWidth - 1, BrickEndColL + BrickScanColNum);
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable68
   \   000000DE   0x7800             LDRB     R0,[R0, #+0]
   \   000000E0   0xF110 0x013C      ADDS     R1,R0,#+60
   \   000000E4   0x20F9             MOVS     R0,#+249
   \   000000E6   0x.... 0x....      BL       MinRe
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable68_2
   \   000000EE   0x7008             STRB     R0,[R1, #+0]
  13176              //不能超过该行右线黑点。
  13177              if(BlackRightLoc[BrickEndRow][0] != MaxValUint8)
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable68_3
   \   000000F4   0xF890 0x0069      LDRB     R0,[R0, #+105]
   \   000000F8   0x28FF             CMP      R0,#+255
   \   000000FA   0xD00B             BEQ.N    ??BrickJudge_11
  13178              {
  13179                BrickBorderColL = MinRe(BrickBorderColL, BlackRightLoc[BrickEndRow][0]);
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable68_3
   \   00000100   0xF890 0x1069      LDRB     R1,[R0, #+105]
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable68_2
   \   00000108   0x7800             LDRB     R0,[R0, #+0]
   \   0000010A   0x.... 0x....      BL       MinRe
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable68_2
   \   00000112   0x7008             STRB     R0,[R1, #+0]
  13180              }
  13181              else
  13182              {
  13183              }
  13184              
  13185              //1.2 障碍边，开始扫描
  13186              count2 = 0;
   \                     ??BrickJudge_11: (+1)
   \   00000114   0x2100             MOVS     R1,#+0
  13187              for(row = BrickHeadRow; ; row++)
   \   00000116   0x260F             MOVS     R6,#+15
   \   00000118   0xE000             B.N      ??BrickJudge_12
   \                     ??BrickJudge_13: (+1)
   \   0000011A   0x1C76             ADDS     R6,R6,#+1
  13188              {
  13189                //对某一行的处理。
  13190                //该行黑点计数，从右往左扫描。
  13191                count1 = 0;
   \                     ??BrickJudge_12: (+1)
   \   0000011C   0x2200             MOVS     R2,#+0
  13192                //当前行的扫描左边界。
  13193                tempend = (a0 + a1 * row) / LeastSquareMulti + BrickColCom;   //记得除以增加的倍数
   \   0000011E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000120   0xFB06 0x5004      MLA      R0,R6,R4,R5
   \   00000124   0xF44F 0x737A      MOV      R3,#+1000
   \   00000128   0xFB90 0xF0F3      SDIV     R0,R0,R3
   \   0000012C   0x1D40             ADDS     R0,R0,#+5
  13194                for(col = BrickBorderColL; ; col--)
   \   0000012E   0x.... 0x....      LDR.W    R3,??DataTable68_2
   \   00000132   0x781B             LDRB     R3,[R3, #+0]
   \   00000134   0xE000             B.N      ??BrickJudge_14
   \                     ??BrickJudge_15: (+1)
   \   00000136   0x1E5B             SUBS     R3,R3,#+1
  13195                {
  13196                  if(ImgNew[row][col] < LimitLeftB)  //够黑
   \                     ??BrickJudge_14: (+1)
   \   00000138   0x.... 0x....      LDR.W    R7,??DataTable68_4
   \   0000013C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000013E   0xF05F 0x0CFA      MOVS     R12,#+250
   \   00000142   0xFB0C 0x7706      MLA      R7,R12,R6,R7
   \   00000146   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000148   0x5DDF             LDRB     R7,[R3, R7]
   \   0000014A   0x.... 0x....      LDR.W    R12,??DataTable68_5
   \   0000014E   0xF89C 0xC000      LDRB     R12,[R12, #+0]
   \   00000152   0x4567             CMP      R7,R12
   \   00000154   0xD200             BCS.N    ??BrickJudge_16
  13197                  {
  13198                    count1++;
   \   00000156   0x1C52             ADDS     R2,R2,#+1
  13199                  }
  13200                  else
  13201                  {
  13202                  }
  13203                  //向左扫描至边界。
  13204                  if(col <= tempend || col == 0) break;
   \                     ??BrickJudge_16: (+1)
   \   00000158   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000015C   0x4298             CMP      R0,R3
   \   0000015E   0xD202             BCS.N    ??BrickJudge_17
   \   00000160   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000162   0x2B00             CMP      R3,#+0
   \   00000164   0xD1E7             BNE.N    ??BrickJudge_15
  13205                }
  13206                //该行黑点个数大于BrickLineBlackCountNum个时，则行计数加1.
  13207                if(count1 > BrickLineBlackCountNum) 
   \                     ??BrickJudge_17: (+1)
   \   00000166   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000168   0x2A15             CMP      R2,#+21
   \   0000016A   0xDB06             BLT.N    ??BrickJudge_18
  13208                {
  13209                  count2++;
   \   0000016C   0x1C49             ADDS     R1,R1,#+1
  13210                  BrickLineCountNumRecord = count2;
   \   0000016E   0x.... 0x....      LDR.W    R0,??DataTable68_6
   \   00000172   0x7001             STRB     R1,[R0, #+0]
  13211                  //满足黑点个数的行有BrickLineCountNum个时，则初步判断为左障碍。
  13212                  if(count2 > BrickLineCountNum) 
   \   00000174   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000176   0x2904             CMP      R1,#+4
   \   00000178   0xDA02             BGE.N    ??BrickJudge_19
  13213                  {
  13214                    //不能直接返回成功，还需要对右边进行检测。
  13215                    break;
  13216                  }
  13217                  else
  13218                  {      
  13219                  }
  13220                }
  13221                else
  13222                {
  13223                }
  13224                if(row == BrickEndRow) break;
   \                     ??BrickJudge_18: (+1)
   \   0000017A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000017C   0x2E23             CMP      R6,#+35
   \   0000017E   0xD1CC             BNE.N    ??BrickJudge_13
  13225              }
  13226              
  13227              //2. 非障碍边确认
  13228              if(row != BrickEndRow)
   \                     ??BrickJudge_19: (+1)
   \   00000180   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000182   0x2E23             CMP      R6,#+35
   \   00000184   0xF000 0x8093      BEQ.W    ??BrickJudge_3
  13229              {
  13230                //2. 1 非障碍边最小二乘法
  13231                index = 0;    
   \   00000188   0x2000             MOVS     R0,#+0
  13232                for(i = BrickEndRow + 1; ; i++)
   \   0000018A   0x2124             MOVS     R1,#+36
   \   0000018C   0xE000             B.N      ??BrickJudge_20
   \                     ??BrickJudge_21: (+1)
   \   0000018E   0x1C49             ADDS     R1,R1,#+1
  13233                {
  13234                  if(BlackRightLoc[i][0] != MaxValUint8)
   \                     ??BrickJudge_20: (+1)
   \   00000190   0x.... 0x....      LDR.W    R2,??DataTable68_3
   \   00000194   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000196   0x2303             MOVS     R3,#+3
   \   00000198   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   0000019C   0x7812             LDRB     R2,[R2, #+0]
   \   0000019E   0x2AFF             CMP      R2,#+255
   \   000001A0   0xD00D             BEQ.N    ??BrickJudge_22
  13235                  {
  13236                    y[index] = BlackRightLoc[i][0];
   \   000001A2   0x.... 0x....      LDR.W    R2,??DataTable68_3
   \   000001A6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001A8   0x2303             MOVS     R3,#+3
   \   000001AA   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   000001AE   0x7812             LDRB     R2,[R2, #+0]
   \   000001B0   0xAB00             ADD      R3,SP,#+0
   \   000001B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B4   0x54C2             STRB     R2,[R0, R3]
  13237                    x[index] = i;
   \   000001B6   0xAA02             ADD      R2,SP,#+8
   \   000001B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001BA   0x5481             STRB     R1,[R0, R2]
  13238                    index++;
   \   000001BC   0x1C40             ADDS     R0,R0,#+1
  13239                  }
  13240                  if(index == BrickSlopeRowNum)
   \                     ??BrickJudge_22: (+1)
   \   000001BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001C0   0x2808             CMP      R0,#+8
   \   000001C2   0xD10C             BNE.N    ??BrickJudge_23
  13241                  {
  13242                    break;  
  13243                  }
  13244                  if(i == CameraHight - 1)
  13245                  {
  13246                    return 0;
  13247                  }
  13248                }
  13249                
  13250                //最小二乘法
  13251                //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
  13252                a1 = LeastSquarea1(x, y, BrickSlopeRowNum);
   \   000001C4   0x2208             MOVS     R2,#+8
   \   000001C6   0xA900             ADD      R1,SP,#+0
   \   000001C8   0xA802             ADD      R0,SP,#+8
   \   000001CA   0x.... 0x....      BL       LeastSquarea1
   \   000001CE   0x0004             MOVS     R4,R0
  13253                //右边，斜率应该是0~PathJudgeStraightSlopeLimit,否则斜率不对，返回失败。
  13254                if(a1 > 0 && a1 < PathJudgeStraightSlopeLimit)
   \   000001D0   0x1E60             SUBS     R0,R4,#+1
   \   000001D2   0xF640 0x0133      MOVW     R1,#+2099
   \   000001D6   0x4288             CMP      R0,R1
   \   000001D8   0xD306             BCC.N    ??BrickJudge_24
  13255                {
  13256                }
  13257                else
  13258                {
  13259                  return 0;
   \   000001DA   0x2000             MOVS     R0,#+0
   \   000001DC   0xE1AE             B.N      ??BrickJudge_2
  13260                }
   \                     ??BrickJudge_23: (+1)
   \   000001DE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001E0   0x293B             CMP      R1,#+59
   \   000001E2   0xD1D4             BNE.N    ??BrickJudge_21
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0xE1A9             B.N      ??BrickJudge_2
  13261                a0 = LeastSquarea0(x, y, a1, BrickSlopeRowNum);
   \                     ??BrickJudge_24: (+1)
   \   000001E8   0x2308             MOVS     R3,#+8
   \   000001EA   0x0022             MOVS     R2,R4
   \   000001EC   0xA900             ADD      R1,SP,#+0
   \   000001EE   0xA802             ADD      R0,SP,#+8
   \   000001F0   0x.... 0x....      BL       LeastSquarea0
   \   000001F4   0x0005             MOVS     R5,R0
  13262                //直角梯形的两个突出顶点所在列
  13263                //起始行（近行）黑点所在列。
  13264                BrickEndColR = (a0 + a1 * BrickEndRow) / LeastSquareMulti - BrickColCom;
   \   000001F6   0x2023             MOVS     R0,#+35
   \   000001F8   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   000001FC   0xF44F 0x717A      MOV      R1,#+1000
   \   00000200   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000204   0x1F40             SUBS     R0,R0,#+5
   \   00000206   0x.... 0x....      LDR.W    R1,??DataTable68_7
   \   0000020A   0x7008             STRB     R0,[R1, #+0]
  13265                //结束行（远行）黑点所在列
  13266                BrickHeadColR = (a0 + a1 * BrickHeadRow) / LeastSquareMulti - BrickColCom;
   \   0000020C   0x200F             MOVS     R0,#+15
   \   0000020E   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   00000212   0xF44F 0x717A      MOV      R1,#+1000
   \   00000216   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000021A   0x1F40             SUBS     R0,R0,#+5
   \   0000021C   0x.... 0x....      LDR.W    R1,??DataTable68_8
   \   00000220   0x7008             STRB     R0,[R1, #+0]
  13267                //直角梯形的直角边所在列。左障碍的非障碍边，也就是右边直角梯形的直角边。不能比左直角梯形的直角边还小。
  13268                BrickBorderColR = MaxRe(BrickEndColR - BrickScanColNum / 2, BrickBorderColL);
   \   00000222   0x.... 0x....      LDR.W    R0,??DataTable68_2
   \   00000226   0x7801             LDRB     R1,[R0, #+0]
   \   00000228   0x.... 0x....      LDR.W    R0,??DataTable68_7
   \   0000022C   0x7800             LDRB     R0,[R0, #+0]
   \   0000022E   0x381E             SUBS     R0,R0,#+30
   \   00000230   0x.... 0x....      BL       MaxRe
   \   00000234   0x.... 0x....      LDR.W    R1,??DataTable68_9
   \   00000238   0x7008             STRB     R0,[R1, #+0]
  13269             
  13270                //2.2 非障碍边，开始扫描，找到黑点过多的行，则左障碍确认失败。进行右障碍扫描。
  13271                for(row = BrickHeadRow; ; row++)
   \   0000023A   0x260F             MOVS     R6,#+15
   \   0000023C   0xE000             B.N      ??BrickJudge_25
   \                     ??BrickJudge_26: (+1)
   \   0000023E   0x1C76             ADDS     R6,R6,#+1
  13272                {
  13273                  //对某一行的处理。
  13274                  //该行黑点计数，从左往右扫描。
  13275                  count3 = 0;
   \                     ??BrickJudge_25: (+1)
   \   00000240   0x2700             MOVS     R7,#+0
  13276                  //当前行的扫描的右边界。
  13277                  tempend = (a0 + a1 * row) / LeastSquareMulti - BrickColCom;   //记得除以增加的倍数
   \   00000242   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000244   0xFB06 0x5004      MLA      R0,R6,R4,R5
   \   00000248   0xF44F 0x717A      MOV      R1,#+1000
   \   0000024C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000250   0x1F40             SUBS     R0,R0,#+5
  13278                  //限幅。
  13279                  tempend = MaxRe(tempend, BrickBorderColR);
   \   00000252   0x.... 0x....      LDR.W    R1,??DataTable68_9
   \   00000256   0x7809             LDRB     R1,[R1, #+0]
   \   00000258   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000025A   0x.... 0x....      BL       MaxRe
  13280                  //黑点扫描。
  13281                  for(col = BrickBorderColR; ; col++)
   \   0000025E   0x.... 0x....      LDR.W    R1,??DataTable68_9
   \   00000262   0x780B             LDRB     R3,[R1, #+0]
   \   00000264   0xE000             B.N      ??BrickJudge_27
   \                     ??BrickJudge_28: (+1)
   \   00000266   0x1C5B             ADDS     R3,R3,#+1
  13282                  {
  13283                    if(ImgNew[row][col] < LimitRightB)  //够黑
   \                     ??BrickJudge_27: (+1)
   \   00000268   0x.... 0x....      LDR.W    R1,??DataTable68_4
   \   0000026C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000026E   0x22FA             MOVS     R2,#+250
   \   00000270   0xFB02 0x1106      MLA      R1,R2,R6,R1
   \   00000274   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000276   0x5C59             LDRB     R1,[R3, R1]
   \   00000278   0x.... 0x....      LDR.W    R2,??DataTable68_10
   \   0000027C   0x7812             LDRB     R2,[R2, #+0]
   \   0000027E   0x4291             CMP      R1,R2
   \   00000280   0xD200             BCS.N    ??BrickJudge_29
  13284                    {
  13285                      count3++;
   \   00000282   0x1C7F             ADDS     R7,R7,#+1
  13286                    }
  13287                    else
  13288                    {
  13289                    }
  13290                    //向右扫描至边界
  13291                    if(col >= tempend || col == CameraRealWidth - 1) break;
   \                     ??BrickJudge_29: (+1)
   \   00000284   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000286   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000288   0x4283             CMP      R3,R0
   \   0000028A   0xD202             BCS.N    ??BrickJudge_30
   \   0000028C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000028E   0x2BF9             CMP      R3,#+249
   \   00000290   0xD1E9             BNE.N    ??BrickJudge_28
  13292                  }
  13293                  //该行黑点个数大于BrickLineBlackCountNum个时，则行计数加1.
  13294                  if(count3 > BrickLineBlackCountNum) 
   \                     ??BrickJudge_30: (+1)
   \   00000292   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000294   0x2F15             CMP      R7,#+21
   \   00000296   0xDA02             BGE.N    ??BrickJudge_31
  13295                  {
  13296                    //存在有行黑点过多，则直接跳出。
  13297                    break;
  13298                  }
  13299                  else
  13300                  {
  13301                  }
  13302                  
  13303                  if(row == BrickEndRow) break;
   \                     ??BrickJudge_32: (+1)
   \   00000298   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000029A   0x2E23             CMP      R6,#+35
   \   0000029C   0xD1CF             BNE.N    ??BrickJudge_26
  13304                }
  13305                
  13306                //3. 最终确认
  13307                if(row == BrickEndRow)
   \                     ??BrickJudge_31: (+1)
   \   0000029E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000002A0   0x2E23             CMP      R6,#+35
   \   000002A2   0xD104             BNE.N    ??BrickJudge_3
  13308                {
  13309                  //置左障碍标志
  13310                  PathType = PathBrickLeft;
   \   000002A4   0x2008             MOVS     R0,#+8
   \   000002A6   0x....             LDR.N    R1,??DataTable67_10
   \   000002A8   0x7008             STRB     R0,[R1, #+0]
  13311                  return 1;
   \   000002AA   0x2001             MOVS     R0,#+1
   \   000002AC   0xE146             B.N      ??BrickJudge_2
  13312                }
  13313                else
  13314                {
  13315                }
  13316              }
  13317              //有效行不够，不用进行右边的确认，直接进入右障碍检测。
  13318              else
  13319              {
  13320              }
  13321          
  13322            }
  13323            
  13324            
  13325            //左障碍查找不成功或不需要查找，则开始右障碍查找。先看看是否满足基本条件。
  13326            if(
  13327              (BlackLeftHeadLine > BrickHeadRow)                                         //左线头太近
  13328            ||(BlackLeftCrossDone != 0 && BlackLeftRow1RealLastLine  > BrickHeadRow)    //左线开启了十字再检测，且第1段黑线起始行太近。
  13329              )
   \                     ??BrickJudge_3: (+1)
   \   000002AE   0x....             LDR.N    R0,??DataTable67_24
   \   000002B0   0x7800             LDRB     R0,[R0, #+0]
   \   000002B2   0x2810             CMP      R0,#+16
   \   000002B4   0xDA09             BGE.N    ??BrickJudge_33
   \   000002B6   0x.... 0x....      LDR.W    R0,??DataTable69
   \   000002BA   0x7800             LDRB     R0,[R0, #+0]
   \   000002BC   0x2800             CMP      R0,#+0
   \   000002BE   0xD006             BEQ.N    ??BrickJudge_34
   \   000002C0   0x.... 0x....      LDR.W    R0,??DataTable69_1
   \   000002C4   0x7800             LDRB     R0,[R0, #+0]
   \   000002C6   0x2810             CMP      R0,#+16
   \   000002C8   0xDB01             BLT.N    ??BrickJudge_34
  13330            {
  13331              //不满足基本条件，左右障碍都不可能，不用任何检测。直接返回失败。
  13332              return 0;
   \                     ??BrickJudge_33: (+1)
   \   000002CA   0x2000             MOVS     R0,#+0
   \   000002CC   0xE136             B.N      ??BrickJudge_2
  13333            }
  13334            else
  13335            {
  13336              //1.1 障碍边，右边。最小二乘法计算扫描起始行和结束行的黑点所在列。
  13337              //取BrickSlopeRowNum个点作为最小二乘法的基准点。
  13338              //以左上角为原点，向下为x轴正方向，向右为y轴正方向
  13339              index = 0;    
   \                     ??BrickJudge_34: (+1)
   \   000002CE   0x2000             MOVS     R0,#+0
  13340              for(i = BrickEndRow + 1; ; i++)
   \   000002D0   0x2124             MOVS     R1,#+36
   \   000002D2   0xE000             B.N      ??BrickJudge_35
   \                     ??BrickJudge_36: (+1)
   \   000002D4   0x1C49             ADDS     R1,R1,#+1
  13341              {
  13342                if(BlackRightLoc[i][0] != MaxValUint8)
   \                     ??BrickJudge_35: (+1)
   \   000002D6   0x.... 0x....      LDR.W    R2,??DataTable68_3
   \   000002DA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002DC   0x2303             MOVS     R3,#+3
   \   000002DE   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   000002E2   0x7812             LDRB     R2,[R2, #+0]
   \   000002E4   0x2AFF             CMP      R2,#+255
   \   000002E6   0xD00D             BEQ.N    ??BrickJudge_37
  13343                {
  13344                  y[index] = BlackRightLoc[i][0];
   \   000002E8   0x.... 0x....      LDR.W    R2,??DataTable68_3
   \   000002EC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002EE   0x2303             MOVS     R3,#+3
   \   000002F0   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   000002F4   0x7812             LDRB     R2,[R2, #+0]
   \   000002F6   0xAB00             ADD      R3,SP,#+0
   \   000002F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002FA   0x54C2             STRB     R2,[R0, R3]
  13345                  x[index] = i;
   \   000002FC   0xAA02             ADD      R2,SP,#+8
   \   000002FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000300   0x5481             STRB     R1,[R0, R2]
  13346                  index++;
   \   00000302   0x1C40             ADDS     R0,R0,#+1
  13347                }
  13348                if(index == BrickSlopeRowNum)
   \                     ??BrickJudge_37: (+1)
   \   00000304   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000306   0x2808             CMP      R0,#+8
   \   00000308   0xD10C             BNE.N    ??BrickJudge_38
  13349                {
  13350                  break;  
  13351                }
  13352                if(i == CameraHight - 1)
  13353                {
  13354                  return 0;
  13355                }
  13356              }
  13357              
  13358              //最小二乘法
  13359              //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
  13360              a1 = LeastSquarea1(x, y, BrickSlopeRowNum);
   \   0000030A   0x2208             MOVS     R2,#+8
   \   0000030C   0xA900             ADD      R1,SP,#+0
   \   0000030E   0xA802             ADD      R0,SP,#+8
   \   00000310   0x.... 0x....      BL       LeastSquarea1
   \   00000314   0x0004             MOVS     R4,R0
  13361              //右边，斜率应该是0~PathJudgeStraightSlopeLimit,否则斜率不对，返回失败。
  13362              if(a1 > 0 && a1 < PathJudgeStraightSlopeLimit)
   \   00000316   0x1E60             SUBS     R0,R4,#+1
   \   00000318   0xF640 0x0133      MOVW     R1,#+2099
   \   0000031C   0x4288             CMP      R0,R1
   \   0000031E   0xD306             BCC.N    ??BrickJudge_39
  13363              {
  13364              }
  13365              else
  13366              {
  13367                return 0;
   \   00000320   0x2000             MOVS     R0,#+0
   \   00000322   0xE10B             B.N      ??BrickJudge_2
  13368              }
   \                     ??BrickJudge_38: (+1)
   \   00000324   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000326   0x293B             CMP      R1,#+59
   \   00000328   0xD1D4             BNE.N    ??BrickJudge_36
   \   0000032A   0x2000             MOVS     R0,#+0
   \   0000032C   0xE106             B.N      ??BrickJudge_2
  13369              a0 = LeastSquarea0(x, y, a1, BrickSlopeRowNum);
   \                     ??BrickJudge_39: (+1)
   \   0000032E   0x2308             MOVS     R3,#+8
   \   00000330   0x0022             MOVS     R2,R4
   \   00000332   0xA900             ADD      R1,SP,#+0
   \   00000334   0xA802             ADD      R0,SP,#+8
   \   00000336   0x.... 0x....      BL       LeastSquarea0
   \   0000033A   0x0005             MOVS     R5,R0
  13370              //直角梯形的两个突出顶点所在列
  13371              //起始行（近行）黑点所在列。
  13372              BrickEndColR = (a0 + a1 * BrickEndRow) / LeastSquareMulti - BrickColCom;
   \   0000033C   0x2023             MOVS     R0,#+35
   \   0000033E   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   00000342   0xF44F 0x717A      MOV      R1,#+1000
   \   00000346   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000034A   0x1F40             SUBS     R0,R0,#+5
   \   0000034C   0x.... 0x....      LDR.W    R1,??DataTable68_7
   \   00000350   0x7008             STRB     R0,[R1, #+0]
  13373              //结束行（远行）黑点所在列
  13374              BrickHeadColR = (a0 + a1 * BrickHeadRow) / LeastSquareMulti - BrickColCom;
   \   00000352   0x200F             MOVS     R0,#+15
   \   00000354   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   00000358   0xF44F 0x717A      MOV      R1,#+1000
   \   0000035C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000360   0x1F40             SUBS     R0,R0,#+5
   \   00000362   0x.... 0x....      LDR.W    R1,??DataTable68_8
   \   00000366   0x7008             STRB     R0,[R1, #+0]
  13375              //直角梯形的直角边所在列。右障碍扫描的左边界。稍微限幅一下。
  13376              //不能超过图像左边界
  13377              BrickBorderColR = MaxRe(0, BrickEndColR - BrickScanColNum);
   \   00000368   0x.... 0x....      LDR.W    R0,??DataTable68_7
   \   0000036C   0x7800             LDRB     R0,[R0, #+0]
   \   0000036E   0xF1B0 0x013C      SUBS     R1,R0,#+60
   \   00000372   0x2000             MOVS     R0,#+0
   \   00000374   0x.... 0x....      BL       MaxRe
   \   00000378   0x.... 0x....      LDR.W    R1,??DataTable68_9
   \   0000037C   0x7008             STRB     R0,[R1, #+0]
  13378              //不能超过该行左线黑点。
  13379              if(BlackLeftLoc[BrickEndRow][0] != MaxValUint8)
   \   0000037E   0x....             LDR.N    R0,??DataTable67_34
   \   00000380   0xF890 0x0069      LDRB     R0,[R0, #+105]
   \   00000384   0x28FF             CMP      R0,#+255
   \   00000386   0xD00A             BEQ.N    ??BrickJudge_40
  13380              {
  13381                BrickBorderColR = MaxRe(BrickBorderColR, BlackLeftLoc[BrickEndRow][0]);
   \   00000388   0x....             LDR.N    R0,??DataTable67_34
   \   0000038A   0xF890 0x1069      LDRB     R1,[R0, #+105]
   \   0000038E   0x.... 0x....      LDR.W    R0,??DataTable68_9
   \   00000392   0x7800             LDRB     R0,[R0, #+0]
   \   00000394   0x.... 0x....      BL       MaxRe
   \   00000398   0x.... 0x....      LDR.W    R1,??DataTable68_9
   \   0000039C   0x7008             STRB     R0,[R1, #+0]
  13382              }
  13383              else
  13384              {
  13385              }
  13386              
  13387              //1.2 障碍边，开始扫描
  13388              count2 = 0;
   \                     ??BrickJudge_40: (+1)
   \   0000039E   0x2100             MOVS     R1,#+0
  13389              for(row = BrickHeadRow; ; row++)
   \   000003A0   0x260F             MOVS     R6,#+15
   \   000003A2   0xE000             B.N      ??BrickJudge_41
   \                     ??BrickJudge_42: (+1)
   \   000003A4   0x1C76             ADDS     R6,R6,#+1
  13390              {
  13391                //对某一行的处理。
  13392                //该行黑点计数
  13393                count1 = 0;
   \                     ??BrickJudge_41: (+1)
   \   000003A6   0x2200             MOVS     R2,#+0
  13394                //从左往右扫描。
  13395                tempend = (a0 + a1 * row) / LeastSquareMulti - BrickColCom;   //记得除以增加的倍数
   \   000003A8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000003AA   0xFB06 0x5004      MLA      R0,R6,R4,R5
   \   000003AE   0xF44F 0x737A      MOV      R3,#+1000
   \   000003B2   0xFB90 0xF0F3      SDIV     R0,R0,R3
   \   000003B6   0x1F40             SUBS     R0,R0,#+5
  13396                for(col = BrickBorderColR; ; col++)
   \   000003B8   0x.... 0x....      LDR.W    R3,??DataTable68_9
   \   000003BC   0x781B             LDRB     R3,[R3, #+0]
   \   000003BE   0xE000             B.N      ??BrickJudge_43
   \                     ??BrickJudge_44: (+1)
   \   000003C0   0x1C5B             ADDS     R3,R3,#+1
  13397                {
  13398                  if(ImgNew[row][col] < LimitRightB)  //够黑
   \                     ??BrickJudge_43: (+1)
   \   000003C2   0x.... 0x....      LDR.W    R7,??DataTable68_4
   \   000003C6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000003C8   0xF05F 0x0CFA      MOVS     R12,#+250
   \   000003CC   0xFB0C 0x7706      MLA      R7,R12,R6,R7
   \   000003D0   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000003D2   0x5DDF             LDRB     R7,[R3, R7]
   \   000003D4   0x.... 0x....      LDR.W    R12,??DataTable68_10
   \   000003D8   0xF89C 0xC000      LDRB     R12,[R12, #+0]
   \   000003DC   0x4567             CMP      R7,R12
   \   000003DE   0xD200             BCS.N    ??BrickJudge_45
  13399                  {
  13400                    count1++;
   \   000003E0   0x1C52             ADDS     R2,R2,#+1
  13401                  }
  13402                  else
  13403                  {
  13404                  }
  13405                  //向右扫描至边界。
  13406                  if(col >= tempend || col == CameraRealWidth - 1) break;
   \                     ??BrickJudge_45: (+1)
   \   000003E2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000003E4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003E6   0x4283             CMP      R3,R0
   \   000003E8   0xD202             BCS.N    ??BrickJudge_46
   \   000003EA   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000003EC   0x2BF9             CMP      R3,#+249
   \   000003EE   0xD1E7             BNE.N    ??BrickJudge_44
  13407                }
  13408                //该行黑点个数大于BrickLineBlackCountNum个时，则行计数加1.
  13409                if(count1 > BrickLineBlackCountNum) 
   \                     ??BrickJudge_46: (+1)
   \   000003F0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000003F2   0x2A15             CMP      R2,#+21
   \   000003F4   0xDB06             BLT.N    ??BrickJudge_47
  13410                {
  13411                  count2++;
   \   000003F6   0x1C49             ADDS     R1,R1,#+1
  13412                  BrickLineCountNumRecord = count2;
   \   000003F8   0x.... 0x....      LDR.W    R0,??DataTable68_6
   \   000003FC   0x7001             STRB     R1,[R0, #+0]
  13413                  //满足黑点个数的行有BrickLineCountNum个时，则初步判断为右障碍。
  13414                  if(count2 > BrickLineCountNum) 
   \   000003FE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000400   0x2904             CMP      R1,#+4
   \   00000402   0xDA02             BGE.N    ??BrickJudge_48
  13415                  {
  13416                    //不能直接返回成功，还需要对左边进行检测。
  13417                    break;
  13418                  }
  13419                  else
  13420                  {      
  13421                  }
  13422                }
  13423                else
  13424                {
  13425                }
  13426                if(row == BrickEndRow) break;
   \                     ??BrickJudge_47: (+1)
   \   00000404   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000406   0x2E23             CMP      R6,#+35
   \   00000408   0xD1CC             BNE.N    ??BrickJudge_42
  13427              }
  13428              
  13429              //2. 非障碍边确认，左边。
  13430              if(row != BrickEndRow)
   \                     ??BrickJudge_48: (+1)
   \   0000040A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000040C   0x2E23             CMP      R6,#+35
   \   0000040E   0xF000 0x8094      BEQ.W    ??BrickJudge_49
  13431              {
  13432                //2. 1 非障碍边最小二乘法
  13433                index = 0;    
   \   00000412   0x2000             MOVS     R0,#+0
  13434                for(i = BrickEndRow + 1; ; i++)
   \   00000414   0x2124             MOVS     R1,#+36
   \   00000416   0xE000             B.N      ??BrickJudge_50
   \                     ??BrickJudge_51: (+1)
   \   00000418   0x1C49             ADDS     R1,R1,#+1
  13435                {
  13436                  if(BlackLeftLoc[i][0] != MaxValUint8)
   \                     ??BrickJudge_50: (+1)
   \   0000041A   0x....             LDR.N    R2,??DataTable67_34
   \   0000041C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000041E   0x2303             MOVS     R3,#+3
   \   00000420   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000424   0x7812             LDRB     R2,[R2, #+0]
   \   00000426   0x2AFF             CMP      R2,#+255
   \   00000428   0xD00C             BEQ.N    ??BrickJudge_52
  13437                  {
  13438                    y[index] = BlackLeftLoc[i][0];
   \   0000042A   0x....             LDR.N    R2,??DataTable67_34
   \   0000042C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000042E   0x2303             MOVS     R3,#+3
   \   00000430   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000434   0x7812             LDRB     R2,[R2, #+0]
   \   00000436   0xAB00             ADD      R3,SP,#+0
   \   00000438   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000043A   0x54C2             STRB     R2,[R0, R3]
  13439                    x[index] = i;
   \   0000043C   0xAA02             ADD      R2,SP,#+8
   \   0000043E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000440   0x5481             STRB     R1,[R0, R2]
  13440                    index++;
   \   00000442   0x1C40             ADDS     R0,R0,#+1
  13441                  }
  13442                  if(index == BrickSlopeRowNum)
   \                     ??BrickJudge_52: (+1)
   \   00000444   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000446   0x2808             CMP      R0,#+8
   \   00000448   0xD10D             BNE.N    ??BrickJudge_53
  13443                  {
  13444                    break;  
  13445                  }
  13446                  if(i == CameraHight - 1)
  13447                  {
  13448                    return 0;
  13449                  }
  13450                }
  13451                
  13452                //最小二乘法
  13453                //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
  13454                a1 = LeastSquarea1(x, y, BrickSlopeRowNum);
   \   0000044A   0x2208             MOVS     R2,#+8
   \   0000044C   0xA900             ADD      R1,SP,#+0
   \   0000044E   0xA802             ADD      R0,SP,#+8
   \   00000450   0x.... 0x....      BL       LeastSquarea1
   \   00000454   0x0004             MOVS     R4,R0
  13455                //左边，斜率应该是-PathJudgeStraightSlopeLimit~0,否则斜率不对，返回失败。
  13456                if(a1 < 0 && a1 + PathJudgeStraightSlopeLimit > 0)
   \   00000456   0x2C00             CMP      R4,#+0
   \   00000458   0xD503             BPL.N    ??BrickJudge_54
   \   0000045A   0xF604 0x0034      ADDW     R0,R4,#+2100
   \   0000045E   0x2801             CMP      R0,#+1
   \   00000460   0xDA06             BGE.N    ??BrickJudge_55
  13457                {
  13458                }
  13459                else
  13460                {
  13461                  return 0;
   \                     ??BrickJudge_54: (+1)
   \   00000462   0x2000             MOVS     R0,#+0
   \   00000464   0xE06A             B.N      ??BrickJudge_2
  13462                }
   \                     ??BrickJudge_53: (+1)
   \   00000466   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000468   0x293B             CMP      R1,#+59
   \   0000046A   0xD1D5             BNE.N    ??BrickJudge_51
   \   0000046C   0x2000             MOVS     R0,#+0
   \   0000046E   0xE065             B.N      ??BrickJudge_2
  13463                a0 = LeastSquarea0(x, y, a1, BrickSlopeRowNum);
   \                     ??BrickJudge_55: (+1)
   \   00000470   0x2308             MOVS     R3,#+8
   \   00000472   0x0022             MOVS     R2,R4
   \   00000474   0xA900             ADD      R1,SP,#+0
   \   00000476   0xA802             ADD      R0,SP,#+8
   \   00000478   0x.... 0x....      BL       LeastSquarea0
   \   0000047C   0x0005             MOVS     R5,R0
  13464                //直角梯形的两个突出顶点所在列
  13465                //起始行（近行）黑点所在列。
  13466                BrickEndColL = (a0 + a1 * BrickEndRow) / LeastSquareMulti + BrickColCom;
   \   0000047E   0x2023             MOVS     R0,#+35
   \   00000480   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   00000484   0xF44F 0x717A      MOV      R1,#+1000
   \   00000488   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000048C   0x1D40             ADDS     R0,R0,#+5
   \   0000048E   0x.... 0x....      LDR.W    R1,??DataTable68
   \   00000492   0x7008             STRB     R0,[R1, #+0]
  13467                //结束行（远行）黑点所在列
  13468                BrickHeadColL = (a0 + a1 * BrickHeadRow) / LeastSquareMulti + BrickColCom;
   \   00000494   0x200F             MOVS     R0,#+15
   \   00000496   0xFB00 0x5004      MLA      R0,R0,R4,R5
   \   0000049A   0xF44F 0x717A      MOV      R1,#+1000
   \   0000049E   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000004A2   0x1D40             ADDS     R0,R0,#+5
   \   000004A4   0x.... 0x....      LDR.W    R1,??DataTable68_1
   \   000004A8   0x7008             STRB     R0,[R1, #+0]
  13469                //直角梯形的直角边所在列。右障碍的非障碍边，也就是左边直角梯形的直角边。不能比右直角梯形的直角边还大。
  13470                BrickBorderColL = MinRe(BrickEndColL + BrickScanColNum / 2, BrickBorderColR);
   \   000004AA   0x.... 0x....      LDR.W    R0,??DataTable68_9
   \   000004AE   0x7801             LDRB     R1,[R0, #+0]
   \   000004B0   0x.... 0x....      LDR.W    R0,??DataTable68
   \   000004B4   0x7800             LDRB     R0,[R0, #+0]
   \   000004B6   0x301E             ADDS     R0,R0,#+30
   \   000004B8   0x.... 0x....      BL       MinRe
   \   000004BC   0x.... 0x....      LDR.W    R1,??DataTable68_2
   \   000004C0   0x7008             STRB     R0,[R1, #+0]
  13471             
  13472                //2.2 非障碍边，开始扫描，找到黑点过多的行，则右障碍确认失败。
  13473                for(row = BrickHeadRow; ; row++)
   \   000004C2   0x260F             MOVS     R6,#+15
   \   000004C4   0xE000             B.N      ??BrickJudge_56
   \                     ??BrickJudge_57: (+1)
   \   000004C6   0x1C76             ADDS     R6,R6,#+1
  13474                {
  13475                  //对某一行的处理。
  13476                  //该行黑点计数
  13477                  count3 = 0;
   \                     ??BrickJudge_56: (+1)
   \   000004C8   0x2700             MOVS     R7,#+0
  13478                  //从右往左扫描。
  13479                  tempend = (a0 + a1 * row) / LeastSquareMulti + BrickColCom;   //记得除以增加的倍数
   \   000004CA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000004CC   0xFB06 0x5004      MLA      R0,R6,R4,R5
   \   000004D0   0xF44F 0x717A      MOV      R1,#+1000
   \   000004D4   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000004D8   0x1D40             ADDS     R0,R0,#+5
  13480                  //限幅。
  13481                  tempend = MinRe(tempend, BrickBorderColL);
   \   000004DA   0x.... 0x....      LDR.W    R1,??DataTable68_2
   \   000004DE   0x7809             LDRB     R1,[R1, #+0]
   \   000004E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004E2   0x.... 0x....      BL       MinRe
  13482                  //黑点扫描。
  13483                  for(col = BrickBorderColL; ; col--)
   \   000004E6   0x.... 0x....      LDR.W    R1,??DataTable68_2
   \   000004EA   0x780B             LDRB     R3,[R1, #+0]
   \   000004EC   0xE000             B.N      ??BrickJudge_58
   \                     ??BrickJudge_59: (+1)
   \   000004EE   0x1E5B             SUBS     R3,R3,#+1
  13484                  {
  13485                    if(ImgNew[row][col] < LimitLeftB)  //够黑
   \                     ??BrickJudge_58: (+1)
   \   000004F0   0x.... 0x....      LDR.W    R1,??DataTable68_4
   \   000004F4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000004F6   0x22FA             MOVS     R2,#+250
   \   000004F8   0xFB02 0x1106      MLA      R1,R2,R6,R1
   \   000004FC   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000004FE   0x5C59             LDRB     R1,[R3, R1]
   \   00000500   0x.... 0x....      LDR.W    R2,??DataTable68_5
   \   00000504   0x7812             LDRB     R2,[R2, #+0]
   \   00000506   0x4291             CMP      R1,R2
   \   00000508   0xD200             BCS.N    ??BrickJudge_60
  13486                    {
  13487                      count3++;
   \   0000050A   0x1C7F             ADDS     R7,R7,#+1
  13488                    }
  13489                    else
  13490                    {
  13491                    }
  13492                    //向左扫描至边界
  13493                    if(col <= tempend || col == 0) break;
   \                     ??BrickJudge_60: (+1)
   \   0000050C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000050E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000510   0x4298             CMP      R0,R3
   \   00000512   0xD202             BCS.N    ??BrickJudge_61
   \   00000514   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000516   0x2B00             CMP      R3,#+0
   \   00000518   0xD1E9             BNE.N    ??BrickJudge_59
  13494                  }
  13495                  //该行黑点个数大于BrickLineBlackCountNum个时，则行计数加1.
  13496                  if(count3 > BrickLineBlackCountNum) 
   \                     ??BrickJudge_61: (+1)
   \   0000051A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000051C   0x2F15             CMP      R7,#+21
   \   0000051E   0xDA02             BGE.N    ??BrickJudge_62
  13497                  {
  13498                    //存在有行黑点过多，则直接跳出。
  13499                    break;
  13500                  }
  13501                  else
  13502                  {
  13503                  }
  13504                  
  13505                  if(row == BrickEndRow) break;
   \                     ??BrickJudge_63: (+1)
   \   00000520   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000522   0x2E23             CMP      R6,#+35
   \   00000524   0xD1CF             BNE.N    ??BrickJudge_57
  13506                }
  13507                
  13508                //3. 最终确认
  13509                if(row == BrickEndRow)
   \                     ??BrickJudge_62: (+1)
   \   00000526   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000528   0x2E23             CMP      R6,#+35
   \   0000052A   0xD104             BNE.N    ??BrickJudge_64
  13510                {
  13511                  //置右障碍标志
  13512                  PathType = PathBrickRight;
   \   0000052C   0x2009             MOVS     R0,#+9
   \   0000052E   0x....             LDR.N    R1,??DataTable67_10
   \   00000530   0x7008             STRB     R0,[R1, #+0]
  13513                  return 1;
   \   00000532   0x2001             MOVS     R0,#+1
   \   00000534   0xE002             B.N      ??BrickJudge_2
  13514                }
  13515                else
  13516                {
  13517                  return 0;
   \                     ??BrickJudge_64: (+1)
   \   00000536   0x2000             MOVS     R0,#+0
   \   00000538   0xE000             B.N      ??BrickJudge_2
  13518                }
  13519              }
  13520              //有效行不够，不用进行右边的确认，直接返回失败。
  13521              else
  13522              {
  13523                return 0;
   \                     ??BrickJudge_49: (+1)
   \   0000053A   0x2000             MOVS     R0,#+0
   \                     ??BrickJudge_2: (+1)
   \   0000053C   0xB005             ADD      SP,SP,#+20
   \   0000053E   0xBDF0             POP      {R4-R7,PC}       ;; return
  13524              }
  13525            }
  13526            
  13527          }
  13528          
  13529          
  13530          
  13531          //直角黑块检测。0未检测到，1检测到。
  13532          //直角黑块有可能被误判成障碍，但障碍不可能被误判成直角黑块，所以先检测直角黑块。
  13533          //判断条件为，两线头差在4以内，且都在第25行到第40行，则找最远线头再往远4行、5行的这两行，最小二乘法估出来每行两个点，
  13534          //往内减去5列左右的裕量，然后看两点之间是不是都小于黑点阈值，若是，则判断成功。

   \                                 In section .text, align 2, keep-with-next
  13535          uint8 AngleZoneJudge(void)
  13536          {
   \                     AngleZoneJudge: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
  13537            uint8 countcol, count1, count2;
  13538            
  13539            int32 a0, a1;
  13540            uint8 i, index;
  13541            
  13542            uint8 x[BrickSlopeRowNum];   //取多少个点在一开始有定义。
  13543            uint8 y[BrickSlopeRowNum];
  13544            uint8 col;
  13545            
  13546            //线尾不用作判断，不科学。
  13547            
  13548            if(
  13549              (BlackLeftDone == 1 && BlackRightDone == 1)
  13550            &&(AbsInt(BlackLeftHeadLine - BlackRightHeadLine) <= AngleZoneHeadLineNum)      //线头差必须在8以内
  13551            &&(BlackLeftHeadLine < AngleZoneJudgeRowNear && BlackLeftHeadLine > AngleZoneJudgeRowFar)  //线头必须在某两行之间的区域，大概是25-40行之间
  13552            &&(BlackRightHeadLine < AngleZoneJudgeRowNear && BlackRightHeadLine > AngleZoneJudgeRowFar)  //线头必须在某两行之间的区域，大概是25-40行之间  
  13553              )
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable71
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD11B             BNE.N    ??AngleZoneJudge_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable71_1
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD116             BNE.N    ??AngleZoneJudge_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable72
   \   00000022   0x7809             LDRB     R1,[R1, #+0]
   \   00000024   0x1A40             SUBS     R0,R0,R1
   \   00000026   0x.... 0x....      BL       AbsInt
   \   0000002A   0x2810             CMP      R0,#+16
   \   0000002C   0xDA0B             BGE.N    ??AngleZoneJudge_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x380F             SUBS     R0,R0,#+15
   \   00000036   0x2823             CMP      R0,#+35
   \   00000038   0xD205             BCS.N    ??AngleZoneJudge_0
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable72
   \   0000003E   0x7800             LDRB     R0,[R0, #+0]
   \   00000040   0x380F             SUBS     R0,R0,#+15
   \   00000042   0x2823             CMP      R0,#+35
   \   00000044   0xD301             BCC.N    ??AngleZoneJudge_1
  13554            {
  13555            }
  13556            else
  13557            {
  13558              return 0;
   \                     ??AngleZoneJudge_0: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xE38D             B.N      ??AngleZoneJudge_2
  13559            }
  13560            
  13561            //最终大跳变检测，发现左线有大跳变。或右线头比左线头高。
  13562            //则右线检测多一些黑块，左线检测少一些黑块。
  13563            if(BlackBigChangeFinalCheckFlag == 1 || BlackRightHeadLine <= BlackLeftHeadLine)
   \                     ??AngleZoneJudge_1: (+1)
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable71_3
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xD008             BEQ.N    ??AngleZoneJudge_3
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable72
   \   0000005E   0x7809             LDRB     R1,[R1, #+0]
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xF0C0 0x81BC      BCC.W    ??AngleZoneJudge_4
  13564            {
  13565              //1. 右线。检测多一些黑块。
  13566              //1.1 取右线头往远处5行左右。
  13567              for(i = 0; ; i++)
   \                     ??AngleZoneJudge_3: (+1)
   \   00000066   0x2100             MOVS     R1,#+0
   \   00000068   0xE000             B.N      ??AngleZoneJudge_5
   \                     ??AngleZoneJudge_6: (+1)
   \   0000006A   0x1C49             ADDS     R1,R1,#+1
  13568              {
  13569                AngleZoneJudgeRowR[i] = BlackRightHeadLine - i - 1;
   \                     ??AngleZoneJudge_5: (+1)
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable72
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x1A40             SUBS     R0,R0,R1
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \   00000076   0x.... 0x....      LDR.W    R2,??DataTable71_4
   \   0000007A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007C   0x5488             STRB     R0,[R1, R2]
  13570                  
  13571                if(i == AngleZoneJudgeRowNum - 1) break;
   \   0000007E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000080   0x2904             CMP      R1,#+4
   \   00000082   0xD1F2             BNE.N    ??AngleZoneJudge_6
  13572              }
  13573              //1.2 最小二乘法
  13574              //取AngleZoneSlopeRowNum个点作为最小二乘法的基准点。
  13575              //以左上角为原点，向下为x轴正方向，向右为y轴正方向
  13576              //考虑到直角黑块大跳变现在基本可以滤除掉了，所以直角黑块定位的时候，采用线头左右开始往近处的8行，而不是最近的8行。
  13577              index = 0;
   \   00000084   0x2000             MOVS     R0,#+0
  13578              for(i = BlackRightHeadLine + 2; ; i++)
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable72
   \   0000008A   0x7809             LDRB     R1,[R1, #+0]
   \   0000008C   0x1C89             ADDS     R1,R1,#+2
   \   0000008E   0xE000             B.N      ??AngleZoneJudge_7
   \                     ??AngleZoneJudge_8: (+1)
   \   00000090   0x1C49             ADDS     R1,R1,#+1
  13579              {
  13580                if(BlackRightLoc[i][0] != MaxValUint8)
   \                     ??AngleZoneJudge_7: (+1)
   \   00000092   0x.... 0x....      LDR.W    R2,??DataTable68_3
   \   00000096   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000098   0x2303             MOVS     R3,#+3
   \   0000009A   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   0000009E   0x7812             LDRB     R2,[R2, #+0]
   \   000000A0   0x2AFF             CMP      R2,#+255
   \   000000A2   0xD00D             BEQ.N    ??AngleZoneJudge_9
  13581                {
  13582                  y[index] = BlackRightLoc[i][0];
   \   000000A4   0x.... 0x....      LDR.W    R2,??DataTable68_3
   \   000000A8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000AA   0x2303             MOVS     R3,#+3
   \   000000AC   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   000000B0   0x7812             LDRB     R2,[R2, #+0]
   \   000000B2   0xAB00             ADD      R3,SP,#+0
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0x54C2             STRB     R2,[R0, R3]
  13583                  x[index] = i;
   \   000000B8   0xAA02             ADD      R2,SP,#+8
   \   000000BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BC   0x5481             STRB     R1,[R0, R2]
  13584                  index++;
   \   000000BE   0x1C40             ADDS     R0,R0,#+1
  13585                }
  13586                if(index == AngleJudgeSlopeRowNum)
   \                     ??AngleZoneJudge_9: (+1)
   \   000000C0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C2   0x2808             CMP      R0,#+8
   \   000000C4   0xD10C             BNE.N    ??AngleZoneJudge_10
  13587                {
  13588                  break;  
  13589                }
  13590                
  13591                if(i == CameraHight - 1) return 0;
  13592              }
  13593              //最小二乘法
  13594              //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
  13595              a1 = LeastSquarea1(x, y, AngleJudgeSlopeRowNum);
   \   000000C6   0x2208             MOVS     R2,#+8
   \   000000C8   0xA900             ADD      R1,SP,#+0
   \   000000CA   0xA802             ADD      R0,SP,#+8
   \   000000CC   0x.... 0x....      BL       LeastSquarea1
   \   000000D0   0x0004             MOVS     R4,R0
  13596              //右边，斜率应该是0~PathJudgeStraightSlopeLimit,否则斜率不对，返回失败。
  13597              if(a1 > 0 && a1 < PathJudgeStraightSlopeLimit)
   \   000000D2   0x1E60             SUBS     R0,R4,#+1
   \   000000D4   0xF640 0x0133      MOVW     R1,#+2099
   \   000000D8   0x4288             CMP      R0,R1
   \   000000DA   0xD306             BCC.N    ??AngleZoneJudge_11
  13598              {
  13599              }
  13600              else
  13601              {
  13602                return 0;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0xE342             B.N      ??AngleZoneJudge_2
  13603              }
   \                     ??AngleZoneJudge_10: (+1)
   \   000000E0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000E2   0x293B             CMP      R1,#+59
   \   000000E4   0xD1D4             BNE.N    ??AngleZoneJudge_8
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0xE33D             B.N      ??AngleZoneJudge_2
  13604              a0 = LeastSquarea0(x, y, a1, AngleJudgeSlopeRowNum);
   \                     ??AngleZoneJudge_11: (+1)
   \   000000EA   0x2308             MOVS     R3,#+8
   \   000000EC   0x0022             MOVS     R2,R4
   \   000000EE   0xA900             ADD      R1,SP,#+0
   \   000000F0   0xA802             ADD      R0,SP,#+8
   \   000000F2   0x.... 0x....      BL       LeastSquarea0
  13605              //1.3 计算给定5行的右边界。标志位清零。
  13606              //要往中间留AngleZoneCheckRowCom列的裕量。
  13607              for(i = 0; ; i++)
   \   000000F6   0x2100             MOVS     R1,#+0
   \   000000F8   0xE000             B.N      ??AngleZoneJudge_12
   \                     ??AngleZoneJudge_13: (+1)
   \   000000FA   0x1C49             ADDS     R1,R1,#+1
  13608              {
  13609                //根据线头几行来最小二乘法还是比较准的，不用修正太多列。
  13610                AngleZoneJudgeColR[i] = (a0 + a1 * AngleZoneJudgeRowR[i]) / LeastSquareMulti - AngleZoneJudgeRowCom;  
   \                     ??AngleZoneJudge_12: (+1)
   \   000000FC   0x.... 0x....      LDR.W    R2,??DataTable71_4
   \   00000100   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000102   0x5C8A             LDRB     R2,[R1, R2]
   \   00000104   0xFB02 0x0204      MLA      R2,R2,R4,R0
   \   00000108   0xF44F 0x737A      MOV      R3,#+1000
   \   0000010C   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \   00000110   0x1E92             SUBS     R2,R2,#+2
   \   00000112   0x.... 0x....      LDR.W    R3,??DataTable71_5
   \   00000116   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000118   0x54CA             STRB     R2,[R1, R3]
  13611                AngleZoneJudgeColRFlag[i] = 0;
   \   0000011A   0x2200             MOVS     R2,#+0
   \   0000011C   0x.... 0x....      LDR.W    R3,??DataTable71_6
   \   00000120   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000122   0x54CA             STRB     R2,[R1, R3]
  13612                
  13613                if(i == AngleZoneJudgeRowNum - 1) break;
   \   00000124   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000126   0x2904             CMP      R1,#+4
   \   00000128   0xD1E7             BNE.N    ??AngleZoneJudge_13
  13614              }
  13615              //1.4 右边界确定后，往左一个赛道宽度内，只有有若干列都是黑点，则该行直角黑块判断成功。2行左右即可最终确认右线OK。
  13616              for(i = 0; ; i++)
   \   0000012A   0x2100             MOVS     R1,#+0
   \   0000012C   0xE000             B.N      ??AngleZoneJudge_14
   \                     ??AngleZoneJudge_15: (+1)
   \   0000012E   0x1C49             ADDS     R1,R1,#+1
  13617              {
  13618                //每行的列黑点计数清零。
  13619                countcol = 0;
   \                     ??AngleZoneJudge_14: (+1)
   \   00000130   0x2000             MOVS     R0,#+0
  13620                //从左往右扫一个赛道宽度。赛道宽度预定为70列左右。
  13621                if(AngleZoneJudgeColR[i] - AngleZoneJudgeRoadWidth < 0)
   \   00000132   0x.... 0x....      LDR.W    R2,??DataTable71_5
   \   00000136   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000138   0x5C8A             LDRB     R2,[R1, R2]
   \   0000013A   0x3A46             SUBS     R2,R2,#+70
   \   0000013C   0x2A00             CMP      R2,#+0
   \   0000013E   0xD501             BPL.N    ??AngleZoneJudge_16
  13622                {
  13623                  return 0;
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0xE310             B.N      ??AngleZoneJudge_2
  13624                }
  13625                else
  13626                {
  13627                }      
  13628                for(col = AngleZoneJudgeColR[i] - AngleZoneJudgeRoadWidth; ; col++)
   \                     ??AngleZoneJudge_16: (+1)
   \   00000144   0x.... 0x....      LDR.W    R2,??DataTable71_5
   \   00000148   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000014A   0x5C8A             LDRB     R2,[R1, R2]
   \   0000014C   0x3A46             SUBS     R2,R2,#+70
   \   0000014E   0xE000             B.N      ??AngleZoneJudge_17
   \                     ??AngleZoneJudge_18: (+1)
   \   00000150   0x1C52             ADDS     R2,R2,#+1
  13629                {
  13630                  //检测到有效黑点，计数加1.
  13631                  if(ImgNew[AngleZoneJudgeRowR[i]][col] < LimitRightB) countcol++;
   \                     ??AngleZoneJudge_17: (+1)
   \   00000152   0x.... 0x....      LDR.W    R3,??DataTable68_4
   \   00000156   0x.... 0x....      LDR.W    R4,??DataTable71_4
   \   0000015A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000015C   0x5D0C             LDRB     R4,[R1, R4]
   \   0000015E   0x25FA             MOVS     R5,#+250
   \   00000160   0xFB05 0x3304      MLA      R3,R5,R4,R3
   \   00000164   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000166   0x5CD3             LDRB     R3,[R2, R3]
   \   00000168   0x.... 0x....      LDR.W    R4,??DataTable68_10
   \   0000016C   0x7824             LDRB     R4,[R4, #+0]
   \   0000016E   0x42A3             CMP      R3,R4
   \   00000170   0xD200             BCS.N    ??AngleZoneJudge_19
   \   00000172   0x1C40             ADDS     R0,R0,#+1
  13632                  //该行右黑点够多。置标志位。跳出。
  13633                  if(countcol >= AngleZoneJudgeBlackNumP)  //优势边取45列左右，比障碍多
   \                     ??AngleZoneJudge_19: (+1)
   \   00000174   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000176   0x282D             CMP      R0,#+45
   \   00000178   0xDB05             BLT.N    ??AngleZoneJudge_20
  13634                  {
  13635                    AngleZoneJudgeColRFlag[i] = 1;
   \   0000017A   0x2201             MOVS     R2,#+1
   \   0000017C   0x.... 0x....      LDR.W    R3,??DataTable71_6
   \   00000180   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000182   0x54CA             STRB     R2,[R1, R3]
  13636                    break;
   \   00000184   0xE006             B.N      ??AngleZoneJudge_21
  13637                  }
  13638                  //直到第70列也没有凑够黑点数，跳出。
  13639                  if(col == AngleZoneJudgeColR[i]) break;
   \                     ??AngleZoneJudge_20: (+1)
   \   00000186   0x.... 0x....      LDR.W    R3,??DataTable71_5
   \   0000018A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000018C   0x5CCB             LDRB     R3,[R1, R3]
   \   0000018E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000190   0x429A             CMP      R2,R3
   \   00000192   0xD1DD             BNE.N    ??AngleZoneJudge_18
  13640                }
  13641                //记录该行的有效黑点数，以供确定合适的阈值。
  13642                AngleZoneJudgeCountColR[i] = countcol;
   \                     ??AngleZoneJudge_21: (+1)
   \   00000194   0x.... 0x....      LDR.W    R2,??DataTable71_7
   \   00000198   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000019A   0x5488             STRB     R0,[R1, R2]
  13643                  
  13644                //到最后一行了，退出。
  13645                if(i == AngleZoneJudgeRowNum - 1) break;
   \   0000019C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000019E   0x2904             CMP      R1,#+4
   \   000001A0   0xD1C5             BNE.N    ??AngleZoneJudge_15
  13646              }
  13647              //1.5 检测是不是至少有2行满足条件。若有，则继续检测左线，若无，则直接返回失败。
  13648              count1 = 0;
   \   000001A2   0x2400             MOVS     R4,#+0
  13649              for(i = 0; ; i++)
   \   000001A4   0x2100             MOVS     R1,#+0
   \   000001A6   0xE000             B.N      ??AngleZoneJudge_22
   \                     ??AngleZoneJudge_23: (+1)
   \   000001A8   0x1C49             ADDS     R1,R1,#+1
  13650              {
  13651                if(AngleZoneJudgeColRFlag[i] == 1) count1++;
   \                     ??AngleZoneJudge_22: (+1)
   \   000001AA   0x.... 0x....      LDR.W    R0,??DataTable71_6
   \   000001AE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001B0   0x5C08             LDRB     R0,[R1, R0]
   \   000001B2   0x2801             CMP      R0,#+1
   \   000001B4   0xD100             BNE.N    ??AngleZoneJudge_24
   \   000001B6   0x1C64             ADDS     R4,R4,#+1
  13652                
  13653                if(i == AngleZoneJudgeRowNum - 1) break;
   \                     ??AngleZoneJudge_24: (+1)
   \   000001B8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001BA   0x2904             CMP      R1,#+4
   \   000001BC   0xD1F4             BNE.N    ??AngleZoneJudge_23
  13654              }
  13655              //反时限特性。两线头差值较大时，优势边的45列只要求一行。否则要求2行。
  13656              if(AbsInt(BlackLeftHeadLine - BlackRightHeadLine) > 5)
   \   000001BE   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   000001C2   0x7800             LDRB     R0,[R0, #+0]
   \   000001C4   0x.... 0x....      LDR.W    R1,??DataTable72
   \   000001C8   0x7809             LDRB     R1,[R1, #+0]
   \   000001CA   0x1A40             SUBS     R0,R0,R1
   \   000001CC   0x.... 0x....      BL       AbsInt
   \   000001D0   0x2806             CMP      R0,#+6
   \   000001D2   0xDB04             BLT.N    ??AngleZoneJudge_25
  13657              {
  13658                if(count1 >= 1)
   \   000001D4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001D6   0x2C00             CMP      R4,#+0
   \   000001D8   0xD106             BNE.N    ??AngleZoneJudge_26
  13659                {
  13660                }
  13661                else
  13662                {
  13663                  return 0;
   \   000001DA   0x2000             MOVS     R0,#+0
   \   000001DC   0xE2C3             B.N      ??AngleZoneJudge_2
  13664                }
  13665              }
  13666              else
  13667              {
  13668                if(count1 >= 2)
   \                     ??AngleZoneJudge_25: (+1)
   \   000001DE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001E0   0x2C02             CMP      R4,#+2
   \   000001E2   0xDA01             BGE.N    ??AngleZoneJudge_26
  13669                {
  13670                }
  13671                else
  13672                {
  13673                  return 0;
   \   000001E4   0x2000             MOVS     R0,#+0
   \   000001E6   0xE2BE             B.N      ??AngleZoneJudge_2
  13674                }
  13675              }
  13676              
  13677              //2. 左线。检测少一些黑块。
  13678              //2.1 取左线头往远处5行左右。劣势边线头过去的第一行一般是不可能有那么多黑点的，所以要再过去一行。
  13679              for(i = 0; ; i++)
   \                     ??AngleZoneJudge_26: (+1)
   \   000001E8   0x2100             MOVS     R1,#+0
   \   000001EA   0xE000             B.N      ??AngleZoneJudge_27
   \                     ??AngleZoneJudge_28: (+1)
   \   000001EC   0x1C49             ADDS     R1,R1,#+1
  13680              {
  13681                AngleZoneJudgeRowL[i] = BlackLeftHeadLine - i - 1 - 1;
   \                     ??AngleZoneJudge_27: (+1)
   \   000001EE   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   000001F2   0x7800             LDRB     R0,[R0, #+0]
   \   000001F4   0x1A40             SUBS     R0,R0,R1
   \   000001F6   0x1E80             SUBS     R0,R0,#+2
   \   000001F8   0x.... 0x....      LDR.W    R2,??DataTable71_8
   \   000001FC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001FE   0x5488             STRB     R0,[R1, R2]
  13682                  
  13683                if(i == AngleZoneJudgeRowNum - 1) break;
   \   00000200   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000202   0x2904             CMP      R1,#+4
   \   00000204   0xD1F2             BNE.N    ??AngleZoneJudge_28
  13684              }
  13685              //2.2 最小二乘法
  13686              //取AngleZoneSlopeRowNum个点作为最小二乘法的基准点。
  13687              //以左上角为原点，向下为x轴正方向，向右为y轴正方向
  13688              //考虑到直角黑块大跳变现在基本可以滤除掉了，所以直角黑块定位的时候，采用线头左右开始往近处的8行，而不是最近的8行。
  13689              index = 0;
   \   00000206   0x2000             MOVS     R0,#+0
  13690              for(i = BlackLeftHeadLine + 2; ; i++)
   \   00000208   0x.... 0x....      LDR.W    R1,??DataTable71_2
   \   0000020C   0x7809             LDRB     R1,[R1, #+0]
   \   0000020E   0x1C89             ADDS     R1,R1,#+2
   \   00000210   0xE000             B.N      ??AngleZoneJudge_29
   \                     ??AngleZoneJudge_30: (+1)
   \   00000212   0x1C49             ADDS     R1,R1,#+1
  13691              {
  13692                if(BlackLeftLoc[i][0] != MaxValUint8)
   \                     ??AngleZoneJudge_29: (+1)
   \   00000214   0x.... 0x....      LDR.W    R2,??DataTable71_9
   \   00000218   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000021A   0x2303             MOVS     R3,#+3
   \   0000021C   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000220   0x7812             LDRB     R2,[R2, #+0]
   \   00000222   0x2AFF             CMP      R2,#+255
   \   00000224   0xD00D             BEQ.N    ??AngleZoneJudge_31
  13693                {
  13694                  y[index] = BlackLeftLoc[i][0];
   \   00000226   0x.... 0x....      LDR.W    R2,??DataTable71_9
   \   0000022A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000022C   0x2303             MOVS     R3,#+3
   \   0000022E   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000232   0x7812             LDRB     R2,[R2, #+0]
   \   00000234   0xAB00             ADD      R3,SP,#+0
   \   00000236   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000238   0x54C2             STRB     R2,[R0, R3]
  13695                  x[index] = i;
   \   0000023A   0xAA02             ADD      R2,SP,#+8
   \   0000023C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000023E   0x5481             STRB     R1,[R0, R2]
  13696                  index++;
   \   00000240   0x1C40             ADDS     R0,R0,#+1
  13697                }
  13698                if(index == AngleJudgeSlopeRowNum)
   \                     ??AngleZoneJudge_31: (+1)
   \   00000242   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000244   0x2808             CMP      R0,#+8
   \   00000246   0xD10D             BNE.N    ??AngleZoneJudge_32
  13699                {
  13700                  break;  
  13701                }
  13702                
  13703                if(i == CameraHight - 1) return 0;
  13704              }
  13705              //最小二乘法
  13706              //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
  13707              a1 = LeastSquarea1(x, y, AngleJudgeSlopeRowNum);
   \   00000248   0x2208             MOVS     R2,#+8
   \   0000024A   0xA900             ADD      R1,SP,#+0
   \   0000024C   0xA802             ADD      R0,SP,#+8
   \   0000024E   0x.... 0x....      BL       LeastSquarea1
   \   00000252   0x0004             MOVS     R4,R0
  13708              //左边，斜率应该是-PathJudgeStraightSlopeLimit~0,否则斜率不对，返回失败。
  13709              if(a1 < 0 && a1 + PathJudgeStraightSlopeLimit > 0)
   \   00000254   0x2C00             CMP      R4,#+0
   \   00000256   0xD503             BPL.N    ??AngleZoneJudge_33
   \   00000258   0xF604 0x0034      ADDW     R0,R4,#+2100
   \   0000025C   0x2801             CMP      R0,#+1
   \   0000025E   0xDA06             BGE.N    ??AngleZoneJudge_34
  13710              {
  13711              }
  13712              else
  13713              {
  13714                return 0;
   \                     ??AngleZoneJudge_33: (+1)
   \   00000260   0x2000             MOVS     R0,#+0
   \   00000262   0xE280             B.N      ??AngleZoneJudge_2
  13715              }
   \                     ??AngleZoneJudge_32: (+1)
   \   00000264   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000266   0x293B             CMP      R1,#+59
   \   00000268   0xD1D3             BNE.N    ??AngleZoneJudge_30
   \   0000026A   0x2000             MOVS     R0,#+0
   \   0000026C   0xE27B             B.N      ??AngleZoneJudge_2
  13716              a0 = LeastSquarea0(x, y, a1, AngleJudgeSlopeRowNum);
   \                     ??AngleZoneJudge_34: (+1)
   \   0000026E   0x2308             MOVS     R3,#+8
   \   00000270   0x0022             MOVS     R2,R4
   \   00000272   0xA900             ADD      R1,SP,#+0
   \   00000274   0xA802             ADD      R0,SP,#+8
   \   00000276   0x.... 0x....      BL       LeastSquarea0
  13717              //2.3 计算给定5行的左边界。标志位清零。
  13718              //要往中间留AngleZoneCheckRowCom列的裕量。
  13719              for(i = 0; ; i++)
   \   0000027A   0x2100             MOVS     R1,#+0
   \   0000027C   0xE000             B.N      ??AngleZoneJudge_35
   \                     ??AngleZoneJudge_36: (+1)
   \   0000027E   0x1C49             ADDS     R1,R1,#+1
  13720              {
  13721                //根据线头几行来最小二乘法还是比较准的，不用修正太多列。
  13722                AngleZoneJudgeColL[i] = (a0 + a1 * AngleZoneJudgeRowL[i]) / LeastSquareMulti + AngleZoneJudgeRowCom;  
   \                     ??AngleZoneJudge_35: (+1)
   \   00000280   0x.... 0x....      LDR.W    R2,??DataTable71_8
   \   00000284   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000286   0x5C8A             LDRB     R2,[R1, R2]
   \   00000288   0xFB02 0x0204      MLA      R2,R2,R4,R0
   \   0000028C   0xF44F 0x737A      MOV      R3,#+1000
   \   00000290   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \   00000294   0x1C92             ADDS     R2,R2,#+2
   \   00000296   0x.... 0x....      LDR.W    R3,??DataTable72_1
   \   0000029A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000029C   0x54CA             STRB     R2,[R1, R3]
  13723                AngleZoneJudgeColLFlag[i] = 0;
   \   0000029E   0x2200             MOVS     R2,#+0
   \   000002A0   0x.... 0x....      LDR.W    R3,??DataTable72_2
   \   000002A4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002A6   0x54CA             STRB     R2,[R1, R3]
  13724                
  13725                if(i == AngleZoneJudgeRowNum - 1) break;
   \   000002A8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002AA   0x2904             CMP      R1,#+4
   \   000002AC   0xD1E7             BNE.N    ??AngleZoneJudge_36
  13726              }
  13727              //2.4 左边界确定后，往右一个赛道宽度内，只有有若干列都是黑点，则该行直角黑块判断成功。2行左右即可最终确认右线OK。
  13728              for(i = 0; ; i++)
   \   000002AE   0x2100             MOVS     R1,#+0
   \   000002B0   0xE000             B.N      ??AngleZoneJudge_37
   \                     ??AngleZoneJudge_38: (+1)
   \   000002B2   0x1C49             ADDS     R1,R1,#+1
  13729              {
  13730                //每行的列黑点计数清零。
  13731                countcol = 0;
   \                     ??AngleZoneJudge_37: (+1)
   \   000002B4   0x2000             MOVS     R0,#+0
  13732                //从右往左扫半个赛道宽度。赛道宽度预定为70列左右。
  13733                if(AngleZoneJudgeColL[i] + AngleZoneJudgeRoadWidth / 2 > CameraRealWidth - 1) //劣势边只允许扫描半个赛道宽度。防止障碍被误判成直角黑块。
   \   000002B6   0x.... 0x....      LDR.W    R2,??DataTable72_1
   \   000002BA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002BC   0x5C8A             LDRB     R2,[R1, R2]
   \   000002BE   0x3223             ADDS     R2,R2,#+35
   \   000002C0   0x2AFA             CMP      R2,#+250
   \   000002C2   0xDB01             BLT.N    ??AngleZoneJudge_39
  13734                {
  13735                  return 0;
   \   000002C4   0x2000             MOVS     R0,#+0
   \   000002C6   0xE24E             B.N      ??AngleZoneJudge_2
  13736                }
  13737                else
  13738                {
  13739                }
  13740                for(col = AngleZoneJudgeColL[i] + AngleZoneJudgeRoadWidth /2 ; ; col--) //劣势边只允许扫描半个赛道宽度。防止障碍被误判成直角黑块。
   \                     ??AngleZoneJudge_39: (+1)
   \   000002C8   0x.... 0x....      LDR.W    R2,??DataTable72_1
   \   000002CC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002CE   0x5C8A             LDRB     R2,[R1, R2]
   \   000002D0   0x3223             ADDS     R2,R2,#+35
   \   000002D2   0xE000             B.N      ??AngleZoneJudge_40
   \                     ??AngleZoneJudge_41: (+1)
   \   000002D4   0x1E52             SUBS     R2,R2,#+1
  13741                {
  13742                  //检测到有效黑点，计数加1.
  13743                  if(ImgNew[AngleZoneJudgeRowL[i]][col] < LimitLeftB) countcol++;
   \                     ??AngleZoneJudge_40: (+1)
   \   000002D6   0x.... 0x....      LDR.W    R3,??DataTable68_4
   \   000002DA   0x.... 0x....      LDR.W    R4,??DataTable71_8
   \   000002DE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002E0   0x5D0C             LDRB     R4,[R1, R4]
   \   000002E2   0x25FA             MOVS     R5,#+250
   \   000002E4   0xFB05 0x3304      MLA      R3,R5,R4,R3
   \   000002E8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000002EA   0x5CD3             LDRB     R3,[R2, R3]
   \   000002EC   0x.... 0x....      LDR.W    R4,??DataTable68_5
   \   000002F0   0x7824             LDRB     R4,[R4, #+0]
   \   000002F2   0x42A3             CMP      R3,R4
   \   000002F4   0xD200             BCS.N    ??AngleZoneJudge_42
   \   000002F6   0x1C40             ADDS     R0,R0,#+1
  13744                  //该行右黑点够多。置标志位。跳出。
  13745                  if(countcol >= AngleZoneJudgeBlackNumN)  //劣势边取20列左右，比单线宽度多。
   \                     ??AngleZoneJudge_42: (+1)
   \   000002F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002FA   0x2814             CMP      R0,#+20
   \   000002FC   0xDB05             BLT.N    ??AngleZoneJudge_43
  13746                  {
  13747                    AngleZoneJudgeColLFlag[i] = 1;
   \   000002FE   0x2201             MOVS     R2,#+1
   \   00000300   0x.... 0x....      LDR.W    R3,??DataTable72_2
   \   00000304   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000306   0x54CA             STRB     R2,[R1, R3]
  13748                    break;
   \   00000308   0xE006             B.N      ??AngleZoneJudge_44
  13749                  }
  13750                  //直到第70列也没有凑够黑点数，跳出。
  13751                  if(col == AngleZoneJudgeColL[i]) break;
   \                     ??AngleZoneJudge_43: (+1)
   \   0000030A   0x.... 0x....      LDR.W    R3,??DataTable72_1
   \   0000030E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000310   0x5CCB             LDRB     R3,[R1, R3]
   \   00000312   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000314   0x429A             CMP      R2,R3
   \   00000316   0xD1DD             BNE.N    ??AngleZoneJudge_41
  13752                }
  13753                //记录该行的有效黑点数，以供确定合适的阈值。
  13754                AngleZoneJudgeCountColL[i] = countcol;
   \                     ??AngleZoneJudge_44: (+1)
   \   00000318   0x.... 0x....      LDR.W    R2,??DataTable72_3
   \   0000031C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000031E   0x5488             STRB     R0,[R1, R2]
  13755                  
  13756                //到最后一行了，退出。
  13757                if(i == AngleZoneJudgeRowNum - 1) break;
   \   00000320   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000322   0x2904             CMP      R1,#+4
   \   00000324   0xD1C5             BNE.N    ??AngleZoneJudge_38
  13758              }
  13759              //2.5 检测是不是至少有2行满足条件。若有，则确认这幅图像是直角黑块，更新赛道类型、线头、返回成功。若无，则返回失败。
  13760              count2 = 0;
   \   00000326   0x2400             MOVS     R4,#+0
  13761              for(i = 0; ; i++)
   \   00000328   0x2100             MOVS     R1,#+0
   \   0000032A   0xE000             B.N      ??AngleZoneJudge_45
   \                     ??AngleZoneJudge_46: (+1)
   \   0000032C   0x1C49             ADDS     R1,R1,#+1
  13762              {
  13763                if(AngleZoneJudgeColLFlag[i] == 1) count2++;
   \                     ??AngleZoneJudge_45: (+1)
   \   0000032E   0x.... 0x....      LDR.W    R0,??DataTable72_2
   \   00000332   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000334   0x5C08             LDRB     R0,[R1, R0]
   \   00000336   0x2801             CMP      R0,#+1
   \   00000338   0xD100             BNE.N    ??AngleZoneJudge_47
   \   0000033A   0x1C64             ADDS     R4,R4,#+1
  13764                
  13765                if(i == AngleZoneJudgeRowNum - 1) break;
   \                     ??AngleZoneJudge_47: (+1)
   \   0000033C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000033E   0x2904             CMP      R1,#+4
   \   00000340   0xD1F4             BNE.N    ??AngleZoneJudge_46
  13766              }
  13767              if(count2 >= 2)
   \   00000342   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000344   0x2C02             CMP      R4,#+2
   \   00000346   0xDB48             BLT.N    ??AngleZoneJudge_48
  13768              {
  13769                //赛道类型，直角黑色区域。
  13770                PathType = PathAngleZone; 
   \   00000348   0x200A             MOVS     R0,#+10
   \   0000034A   0x.... 0x....      LDR.W    R1,??DataTable72_4
   \   0000034E   0x7008             STRB     R0,[R1, #+0]
  13771                
  13772                //对线头作处理，远线头拉到近线头处来。使远处的行不至于太偏。
  13773                //线头相同，不用处理。
  13774                if(BlackLeftHeadLine == BlackRightHeadLine)
   \   00000350   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   00000354   0x7800             LDRB     R0,[R0, #+0]
   \   00000356   0x.... 0x....      LDR.W    R1,??DataTable72
   \   0000035A   0x7809             LDRB     R1,[R1, #+0]
   \   0000035C   0x4288             CMP      R0,R1
   \   0000035E   0xD03A             BEQ.N    ??AngleZoneJudge_49
  13775                {
  13776                }
  13777                //左线头更远
  13778                else if(BlackLeftHeadLine < BlackRightHeadLine)
   \   00000360   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   00000364   0x7800             LDRB     R0,[R0, #+0]
   \   00000366   0x.... 0x....      LDR.W    R1,??DataTable72
   \   0000036A   0x7809             LDRB     R1,[R1, #+0]
   \   0000036C   0x4288             CMP      R0,R1
   \   0000036E   0xD219             BCS.N    ??AngleZoneJudge_50
  13779                {
  13780                  //删掉左线头超出右线头的部分。
  13781                  for(i = BlackLeftHeadLine; ; i++)
   \   00000370   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   00000374   0x7801             LDRB     R1,[R0, #+0]
   \   00000376   0xE008             B.N      ??AngleZoneJudge_51
  13782                  {
  13783                    if(i == BlackRightHeadLine) break;
  13784                    
  13785                    BlackLeftLoc[i][0] = MaxValUint8;
   \                     ??AngleZoneJudge_52: (+1)
   \   00000378   0x20FF             MOVS     R0,#+255
   \   0000037A   0x.... 0x....      LDR.W    R2,??DataTable71_9
   \   0000037E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000380   0x2303             MOVS     R3,#+3
   \   00000382   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000386   0x7010             STRB     R0,[R2, #+0]
   \   00000388   0x1C49             ADDS     R1,R1,#+1
   \                     ??AngleZoneJudge_51: (+1)
   \   0000038A   0x.... 0x....      LDR.W    R0,??DataTable72
   \   0000038E   0x7800             LDRB     R0,[R0, #+0]
   \   00000390   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000392   0x4281             CMP      R1,R0
   \   00000394   0xD1F0             BNE.N    ??AngleZoneJudge_52
  13786                  }
  13787                  //左线头的值更新。
  13788                  BlackLeftHeadLine = BlackRightHeadLine;
   \   00000396   0x.... 0x....      LDR.W    R0,??DataTable72
   \   0000039A   0x7800             LDRB     R0,[R0, #+0]
   \   0000039C   0x.... 0x....      LDR.W    R1,??DataTable71_2
   \   000003A0   0x7008             STRB     R0,[R1, #+0]
   \   000003A2   0xE018             B.N      ??AngleZoneJudge_49
  13789                }
  13790                //右线头更远
  13791                else
  13792                {
  13793                  //删掉右线头超出左线头的部分。
  13794                  for(i = BlackRightHeadLine; ; i++)
   \                     ??AngleZoneJudge_50: (+1)
   \   000003A4   0x.... 0x....      LDR.W    R0,??DataTable72
   \   000003A8   0x7801             LDRB     R1,[R0, #+0]
   \   000003AA   0xE008             B.N      ??AngleZoneJudge_53
  13795                  {
  13796                    if(i == BlackLeftHeadLine) break;
  13797                    
  13798                    BlackRightLoc[i][0] = MaxValUint8;
   \                     ??AngleZoneJudge_54: (+1)
   \   000003AC   0x20FF             MOVS     R0,#+255
   \   000003AE   0x.... 0x....      LDR.W    R2,??DataTable68_3
   \   000003B2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000003B4   0x2303             MOVS     R3,#+3
   \   000003B6   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   000003BA   0x7010             STRB     R0,[R2, #+0]
   \   000003BC   0x1C49             ADDS     R1,R1,#+1
   \                     ??AngleZoneJudge_53: (+1)
   \   000003BE   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   000003C2   0x7800             LDRB     R0,[R0, #+0]
   \   000003C4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000003C6   0x4281             CMP      R1,R0
   \   000003C8   0xD1F0             BNE.N    ??AngleZoneJudge_54
  13799                  }
  13800                  //右线头的值更新。
  13801                  BlackRightHeadLine = BlackLeftHeadLine;        
   \   000003CA   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   000003CE   0x7800             LDRB     R0,[R0, #+0]
   \   000003D0   0x.... 0x....      LDR.W    R1,??DataTable72
   \   000003D4   0x7008             STRB     R0,[R1, #+0]
  13802                }
  13803                      
  13804                return 1;
   \                     ??AngleZoneJudge_49: (+1)
   \   000003D6   0x2001             MOVS     R0,#+1
   \   000003D8   0xE1C5             B.N      ??AngleZoneJudge_2
  13805              }
  13806              else
  13807              {
  13808                return 0;
   \                     ??AngleZoneJudge_48: (+1)
   \   000003DA   0x2000             MOVS     R0,#+0
   \   000003DC   0xE1C3             B.N      ??AngleZoneJudge_2
  13809              }
  13810          
  13811            }
  13812            //最终大跳变检测，发现右线有大跳变。或左线头比右线头高。
  13813            //则左线检测多一些黑块，右线检测少一些黑块。
  13814            else if(BlackBigChangeFinalCheckFlag == 2  || BlackLeftHeadLine < BlackRightHeadLine)
   \                     ??AngleZoneJudge_4: (+1)
   \   000003DE   0x.... 0x....      LDR.W    R0,??DataTable71_3
   \   000003E2   0x7800             LDRB     R0,[R0, #+0]
   \   000003E4   0x2802             CMP      R0,#+2
   \   000003E6   0xD008             BEQ.N    ??AngleZoneJudge_55
   \   000003E8   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   000003EC   0x7800             LDRB     R0,[R0, #+0]
   \   000003EE   0x.... 0x....      LDR.W    R1,??DataTable72
   \   000003F2   0x7809             LDRB     R1,[R1, #+0]
   \   000003F4   0x4288             CMP      R0,R1
   \   000003F6   0xF080 0x81B5      BCS.W    ??AngleZoneJudge_56
  13815            {
  13816              //1. 左线。检测多一些黑块。
  13817              //2.1 取左线头往远处5行左右。
  13818              for(i = 0; ; i++)
   \                     ??AngleZoneJudge_55: (+1)
   \   000003FA   0x2100             MOVS     R1,#+0
   \   000003FC   0xE000             B.N      ??AngleZoneJudge_57
   \                     ??AngleZoneJudge_58: (+1)
   \   000003FE   0x1C49             ADDS     R1,R1,#+1
  13819              {
  13820                AngleZoneJudgeRowL[i] = BlackLeftHeadLine - i - 1;
   \                     ??AngleZoneJudge_57: (+1)
   \   00000400   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   00000404   0x7800             LDRB     R0,[R0, #+0]
   \   00000406   0x1A40             SUBS     R0,R0,R1
   \   00000408   0x1E40             SUBS     R0,R0,#+1
   \   0000040A   0x.... 0x....      LDR.W    R2,??DataTable71_8
   \   0000040E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000410   0x5488             STRB     R0,[R1, R2]
  13821                  
  13822                if(i == AngleZoneJudgeRowNum - 1) break;
   \   00000412   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000414   0x2904             CMP      R1,#+4
   \   00000416   0xD1F2             BNE.N    ??AngleZoneJudge_58
  13823              }
  13824              //1.2 最小二乘法
  13825              //取AngleZoneSlopeRowNum个点作为最小二乘法的基准点。
  13826              //以左上角为原点，向下为x轴正方向，向右为y轴正方向
  13827              //考虑到直角黑块大跳变现在基本可以滤除掉了，所以直角黑块定位的时候，采用线头左右开始往近处的8行，而不是最近的8行。
  13828              index = 0;
   \   00000418   0x2000             MOVS     R0,#+0
  13829              for(i = BlackLeftHeadLine + 2; ; i++)
   \   0000041A   0x.... 0x....      LDR.W    R1,??DataTable71_2
   \   0000041E   0x7809             LDRB     R1,[R1, #+0]
   \   00000420   0x1C89             ADDS     R1,R1,#+2
   \   00000422   0xE000             B.N      ??AngleZoneJudge_59
   \                     ??AngleZoneJudge_60: (+1)
   \   00000424   0x1C49             ADDS     R1,R1,#+1
  13830              {
  13831                if(BlackLeftLoc[i][0] != MaxValUint8)
   \                     ??AngleZoneJudge_59: (+1)
   \   00000426   0x.... 0x....      LDR.W    R2,??DataTable71_9
   \   0000042A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000042C   0x2303             MOVS     R3,#+3
   \   0000042E   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000432   0x7812             LDRB     R2,[R2, #+0]
   \   00000434   0x2AFF             CMP      R2,#+255
   \   00000436   0xD00D             BEQ.N    ??AngleZoneJudge_61
  13832                {
  13833                  y[index] = BlackLeftLoc[i][0];
   \   00000438   0x.... 0x....      LDR.W    R2,??DataTable71_9
   \   0000043C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000043E   0x2303             MOVS     R3,#+3
   \   00000440   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000444   0x7812             LDRB     R2,[R2, #+0]
   \   00000446   0xAB00             ADD      R3,SP,#+0
   \   00000448   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000044A   0x54C2             STRB     R2,[R0, R3]
  13834                  x[index] = i;
   \   0000044C   0xAA02             ADD      R2,SP,#+8
   \   0000044E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000450   0x5481             STRB     R1,[R0, R2]
  13835                  index++;
   \   00000452   0x1C40             ADDS     R0,R0,#+1
  13836                }
  13837                if(index == AngleJudgeSlopeRowNum)
   \                     ??AngleZoneJudge_61: (+1)
   \   00000454   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000456   0x2808             CMP      R0,#+8
   \   00000458   0xD10D             BNE.N    ??AngleZoneJudge_62
  13838                {
  13839                  break;  
  13840                }
  13841                
  13842                if(i == CameraHight - 1) return 0;
  13843              }
  13844              //最小二乘法
  13845              //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
  13846              a1 = LeastSquarea1(x, y, AngleJudgeSlopeRowNum);
   \   0000045A   0x2208             MOVS     R2,#+8
   \   0000045C   0xA900             ADD      R1,SP,#+0
   \   0000045E   0xA802             ADD      R0,SP,#+8
   \   00000460   0x.... 0x....      BL       LeastSquarea1
   \   00000464   0x0004             MOVS     R4,R0
  13847              //左边，斜率应该是-PathJudgeStraightSlopeLimit~0,否则斜率不对，返回失败。
  13848              if(a1 < 0 && a1 + PathJudgeStraightSlopeLimit > 0)
   \   00000466   0x2C00             CMP      R4,#+0
   \   00000468   0xD503             BPL.N    ??AngleZoneJudge_63
   \   0000046A   0xF604 0x0034      ADDW     R0,R4,#+2100
   \   0000046E   0x2801             CMP      R0,#+1
   \   00000470   0xDA06             BGE.N    ??AngleZoneJudge_64
  13849              {
  13850              }
  13851              else
  13852              {
  13853                return 0;
   \                     ??AngleZoneJudge_63: (+1)
   \   00000472   0x2000             MOVS     R0,#+0
   \   00000474   0xE177             B.N      ??AngleZoneJudge_2
  13854              }
   \                     ??AngleZoneJudge_62: (+1)
   \   00000476   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000478   0x293B             CMP      R1,#+59
   \   0000047A   0xD1D3             BNE.N    ??AngleZoneJudge_60
   \   0000047C   0x2000             MOVS     R0,#+0
   \   0000047E   0xE172             B.N      ??AngleZoneJudge_2
  13855              a0 = LeastSquarea0(x, y, a1, AngleJudgeSlopeRowNum);
   \                     ??AngleZoneJudge_64: (+1)
   \   00000480   0x2308             MOVS     R3,#+8
   \   00000482   0x0022             MOVS     R2,R4
   \   00000484   0xA900             ADD      R1,SP,#+0
   \   00000486   0xA802             ADD      R0,SP,#+8
   \   00000488   0x.... 0x....      BL       LeastSquarea0
  13856              //1.3 计算给定5行的左边界。标志位清零。
  13857              //要往中间留AngleZoneCheckRowCom列的裕量。
  13858              for(i = 0; ; i++)
   \   0000048C   0x2100             MOVS     R1,#+0
   \   0000048E   0xE000             B.N      ??AngleZoneJudge_65
   \                     ??AngleZoneJudge_66: (+1)
   \   00000490   0x1C49             ADDS     R1,R1,#+1
  13859              {
  13860                //根据线头几行来最小二乘法还是比较准的，不用修正太多列。
  13861                AngleZoneJudgeColL[i] = (a0 + a1 * AngleZoneJudgeRowL[i]) / LeastSquareMulti + AngleZoneJudgeRowCom;  
   \                     ??AngleZoneJudge_65: (+1)
   \   00000492   0x.... 0x....      LDR.W    R2,??DataTable71_8
   \   00000496   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000498   0x5C8A             LDRB     R2,[R1, R2]
   \   0000049A   0xFB02 0x0204      MLA      R2,R2,R4,R0
   \   0000049E   0xF44F 0x737A      MOV      R3,#+1000
   \   000004A2   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \   000004A6   0x1C92             ADDS     R2,R2,#+2
   \   000004A8   0x.... 0x....      LDR.W    R3,??DataTable72_1
   \   000004AC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000004AE   0x54CA             STRB     R2,[R1, R3]
  13862                AngleZoneJudgeColLFlag[i] = 0;
   \   000004B0   0x2200             MOVS     R2,#+0
   \   000004B2   0x.... 0x....      LDR.W    R3,??DataTable72_2
   \   000004B6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000004B8   0x54CA             STRB     R2,[R1, R3]
  13863                
  13864                if(i == AngleZoneJudgeRowNum - 1) break;
   \   000004BA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000004BC   0x2904             CMP      R1,#+4
   \   000004BE   0xD1E7             BNE.N    ??AngleZoneJudge_66
  13865              }
  13866              //1.4 左边界确定后，往右一个赛道宽度内，只有有若干列都是黑点，则该行直角黑块判断成功。2行左右即可最终确认右线OK。
  13867              for(i = 0; ; i++)
   \   000004C0   0x2100             MOVS     R1,#+0
   \   000004C2   0xE000             B.N      ??AngleZoneJudge_67
   \                     ??AngleZoneJudge_68: (+1)
   \   000004C4   0x1C49             ADDS     R1,R1,#+1
  13868              {
  13869                //每行的列黑点计数清零。
  13870                countcol = 0;
   \                     ??AngleZoneJudge_67: (+1)
   \   000004C6   0x2000             MOVS     R0,#+0
  13871                //从右往左扫一个赛道宽度。赛道宽度预定为70列左右。
  13872                if(AngleZoneJudgeColL[i] + AngleZoneJudgeRoadWidth > CameraRealWidth - 1)
   \   000004C8   0x.... 0x....      LDR.W    R2,??DataTable72_1
   \   000004CC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000004CE   0x5C8A             LDRB     R2,[R1, R2]
   \   000004D0   0x3246             ADDS     R2,R2,#+70
   \   000004D2   0x2AFA             CMP      R2,#+250
   \   000004D4   0xDB01             BLT.N    ??AngleZoneJudge_69
  13873                {
  13874                  return 0;
   \   000004D6   0x2000             MOVS     R0,#+0
   \   000004D8   0xE145             B.N      ??AngleZoneJudge_2
  13875                }
  13876                else
  13877                {
  13878                }
  13879                for(col = AngleZoneJudgeColL[i] + AngleZoneJudgeRoadWidth; ; col--)
   \                     ??AngleZoneJudge_69: (+1)
   \   000004DA   0x.... 0x....      LDR.W    R2,??DataTable72_1
   \   000004DE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000004E0   0x5C8A             LDRB     R2,[R1, R2]
   \   000004E2   0x3246             ADDS     R2,R2,#+70
   \   000004E4   0xE000             B.N      ??AngleZoneJudge_70
   \                     ??AngleZoneJudge_71: (+1)
   \   000004E6   0x1E52             SUBS     R2,R2,#+1
  13880                {
  13881                  //检测到有效黑点，计数加1.
  13882                  if(ImgNew[AngleZoneJudgeRowL[i]][col] < LimitLeftB) countcol++;
   \                     ??AngleZoneJudge_70: (+1)
   \   000004E8   0x....             LDR.N    R3,??DataTable68_4
   \   000004EA   0x.... 0x....      LDR.W    R4,??DataTable71_8
   \   000004EE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000004F0   0x5D0C             LDRB     R4,[R1, R4]
   \   000004F2   0x25FA             MOVS     R5,#+250
   \   000004F4   0xFB05 0x3304      MLA      R3,R5,R4,R3
   \   000004F8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000004FA   0x5CD3             LDRB     R3,[R2, R3]
   \   000004FC   0x....             LDR.N    R4,??DataTable68_5
   \   000004FE   0x7824             LDRB     R4,[R4, #+0]
   \   00000500   0x42A3             CMP      R3,R4
   \   00000502   0xD200             BCS.N    ??AngleZoneJudge_72
   \   00000504   0x1C40             ADDS     R0,R0,#+1
  13883                  //该行右黑点够多。置标志位。跳出。
  13884                  if(countcol >= AngleZoneJudgeBlackNumP)  //优势边取45列左右，比障碍多。
   \                     ??AngleZoneJudge_72: (+1)
   \   00000506   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000508   0x282D             CMP      R0,#+45
   \   0000050A   0xDB05             BLT.N    ??AngleZoneJudge_73
  13885                  {
  13886                    AngleZoneJudgeColLFlag[i] = 1;
   \   0000050C   0x2201             MOVS     R2,#+1
   \   0000050E   0x.... 0x....      LDR.W    R3,??DataTable72_2
   \   00000512   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000514   0x54CA             STRB     R2,[R1, R3]
  13887                    break;
   \   00000516   0xE006             B.N      ??AngleZoneJudge_74
  13888                  }
  13889                  //直到第70列也没有凑够黑点数，跳出。
  13890                  if(col == AngleZoneJudgeColL[i]) break;
   \                     ??AngleZoneJudge_73: (+1)
   \   00000518   0x.... 0x....      LDR.W    R3,??DataTable72_1
   \   0000051C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000051E   0x5CCB             LDRB     R3,[R1, R3]
   \   00000520   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000522   0x429A             CMP      R2,R3
   \   00000524   0xD1DF             BNE.N    ??AngleZoneJudge_71
  13891                }
  13892                //记录该行的有效黑点数，以供确定合适的阈值。
  13893                AngleZoneJudgeCountColL[i] = countcol;
   \                     ??AngleZoneJudge_74: (+1)
   \   00000526   0x.... 0x....      LDR.W    R2,??DataTable72_3
   \   0000052A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000052C   0x5488             STRB     R0,[R1, R2]
  13894                  
  13895                //到最后一行了，退出。
  13896                if(i == AngleZoneJudgeRowNum - 1) break;
   \   0000052E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000530   0x2904             CMP      R1,#+4
   \   00000532   0xD1C7             BNE.N    ??AngleZoneJudge_68
  13897              }
  13898              //1.5 检测是不是至少有2行满足条件。若有，则继续检测左线，若无，则直接返回失败。
  13899              count2 = 0;
   \   00000534   0x2400             MOVS     R4,#+0
  13900              for(i = 0; ; i++)
   \   00000536   0x2100             MOVS     R1,#+0
   \   00000538   0xE000             B.N      ??AngleZoneJudge_75
   \                     ??AngleZoneJudge_76: (+1)
   \   0000053A   0x1C49             ADDS     R1,R1,#+1
  13901              {
  13902                if(AngleZoneJudgeColLFlag[i] == 1) count2++;
   \                     ??AngleZoneJudge_75: (+1)
   \   0000053C   0x.... 0x....      LDR.W    R0,??DataTable72_2
   \   00000540   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000542   0x5C08             LDRB     R0,[R1, R0]
   \   00000544   0x2801             CMP      R0,#+1
   \   00000546   0xD100             BNE.N    ??AngleZoneJudge_77
   \   00000548   0x1C64             ADDS     R4,R4,#+1
  13903                
  13904                if(i == AngleZoneJudgeRowNum - 1) break;
   \                     ??AngleZoneJudge_77: (+1)
   \   0000054A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000054C   0x2904             CMP      R1,#+4
   \   0000054E   0xD1F4             BNE.N    ??AngleZoneJudge_76
  13905              }
  13906              //反时限特性。两线头差值较大时，优势边的45列只要求一行。否则要求2行。
  13907              if(AbsInt(BlackLeftHeadLine - BlackRightHeadLine) > 5)
   \   00000550   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   00000554   0x7800             LDRB     R0,[R0, #+0]
   \   00000556   0x.... 0x....      LDR.W    R1,??DataTable72
   \   0000055A   0x7809             LDRB     R1,[R1, #+0]
   \   0000055C   0x1A40             SUBS     R0,R0,R1
   \   0000055E   0x.... 0x....      BL       AbsInt
   \   00000562   0x2806             CMP      R0,#+6
   \   00000564   0xDB04             BLT.N    ??AngleZoneJudge_78
  13908              {
  13909                if(count2 >= 1)
   \   00000566   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000568   0x2C00             CMP      R4,#+0
   \   0000056A   0xD106             BNE.N    ??AngleZoneJudge_79
  13910                {
  13911                }
  13912                else
  13913                {
  13914                  return 0;
   \   0000056C   0x2000             MOVS     R0,#+0
   \   0000056E   0xE0FA             B.N      ??AngleZoneJudge_2
  13915                }
  13916              }
  13917              else
  13918              {
  13919                if(count2 >= 2)
   \                     ??AngleZoneJudge_78: (+1)
   \   00000570   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000572   0x2C02             CMP      R4,#+2
   \   00000574   0xDA01             BGE.N    ??AngleZoneJudge_79
  13920                {
  13921                }
  13922                else
  13923                {
  13924                  return 0;
   \   00000576   0x2000             MOVS     R0,#+0
   \   00000578   0xE0F5             B.N      ??AngleZoneJudge_2
  13925                }
  13926              }
  13927                 
  13928              //2. 右线。检测少一些黑块。
  13929              //2.1 取右线头往远处5行左右。劣势边线头过去的第一行一般是不可能有那么多黑点的，所以要再过去一行。
  13930              for(i = 0; ; i++)
   \                     ??AngleZoneJudge_79: (+1)
   \   0000057A   0x2100             MOVS     R1,#+0
   \   0000057C   0xE000             B.N      ??AngleZoneJudge_80
   \                     ??AngleZoneJudge_81: (+1)
   \   0000057E   0x1C49             ADDS     R1,R1,#+1
  13931              {
  13932                AngleZoneJudgeRowR[i] = BlackRightHeadLine - i - 1 - 1;
   \                     ??AngleZoneJudge_80: (+1)
   \   00000580   0x.... 0x....      LDR.W    R0,??DataTable72
   \   00000584   0x7800             LDRB     R0,[R0, #+0]
   \   00000586   0x1A40             SUBS     R0,R0,R1
   \   00000588   0x1E80             SUBS     R0,R0,#+2
   \   0000058A   0x.... 0x....      LDR.W    R2,??DataTable71_4
   \   0000058E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000590   0x5488             STRB     R0,[R1, R2]
  13933                  
  13934                if(i == AngleZoneJudgeRowNum - 1) break;
   \   00000592   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000594   0x2904             CMP      R1,#+4
   \   00000596   0xD1F2             BNE.N    ??AngleZoneJudge_81
  13935              }
  13936              //2.2 最小二乘法
  13937              //取AngleZoneSlopeRowNum个点作为最小二乘法的基准点。
  13938              //以左上角为原点，向下为x轴正方向，向右为y轴正方向
  13939              //考虑到直角黑块大跳变现在基本可以滤除掉了，所以直角黑块定位的时候，采用线头左右开始往近处的8行，而不是最近的8行。
  13940              index = 0;
   \   00000598   0x2000             MOVS     R0,#+0
  13941              for(i = BlackRightHeadLine + 2; ; i++)
   \   0000059A   0x.... 0x....      LDR.W    R1,??DataTable72
   \   0000059E   0x7809             LDRB     R1,[R1, #+0]
   \   000005A0   0x1C89             ADDS     R1,R1,#+2
   \   000005A2   0xE000             B.N      ??AngleZoneJudge_82
   \                     ??AngleZoneJudge_83: (+1)
   \   000005A4   0x1C49             ADDS     R1,R1,#+1
  13942              {
  13943                if(BlackRightLoc[i][0] != MaxValUint8)
   \                     ??AngleZoneJudge_82: (+1)
   \   000005A6   0x....             LDR.N    R2,??DataTable68_3
   \   000005A8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000005AA   0x2303             MOVS     R3,#+3
   \   000005AC   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   000005B0   0x7812             LDRB     R2,[R2, #+0]
   \   000005B2   0x2AFF             CMP      R2,#+255
   \   000005B4   0xD00C             BEQ.N    ??AngleZoneJudge_84
  13944                {
  13945                  y[index] = BlackRightLoc[i][0];
   \   000005B6   0x....             LDR.N    R2,??DataTable68_3
   \   000005B8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000005BA   0x2303             MOVS     R3,#+3
   \   000005BC   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   000005C0   0x7812             LDRB     R2,[R2, #+0]
   \   000005C2   0xAB00             ADD      R3,SP,#+0
   \   000005C4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005C6   0x54C2             STRB     R2,[R0, R3]
  13946                  x[index] = i;
   \   000005C8   0xAA02             ADD      R2,SP,#+8
   \   000005CA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005CC   0x5481             STRB     R1,[R0, R2]
  13947                  index++;
   \   000005CE   0x1C40             ADDS     R0,R0,#+1
  13948                }
  13949                if(index == AngleJudgeSlopeRowNum)
   \                     ??AngleZoneJudge_84: (+1)
   \   000005D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005D2   0x2808             CMP      R0,#+8
   \   000005D4   0xD10C             BNE.N    ??AngleZoneJudge_85
  13950                {
  13951                  break;  
  13952                }
  13953                
  13954                if(i == CameraHight - 1) return 0;
  13955              }
  13956              //最小二乘法
  13957              //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
  13958              a1 = LeastSquarea1(x, y, AngleJudgeSlopeRowNum);
   \   000005D6   0x2208             MOVS     R2,#+8
   \   000005D8   0xA900             ADD      R1,SP,#+0
   \   000005DA   0xA802             ADD      R0,SP,#+8
   \   000005DC   0x.... 0x....      BL       LeastSquarea1
   \   000005E0   0x0004             MOVS     R4,R0
  13959              //右边，斜率应该是0~PathJudgeStraightSlopeLimit,否则斜率不对，返回失败。
  13960              if(a1 > 0 && a1 < PathJudgeStraightSlopeLimit)
   \   000005E2   0x1E60             SUBS     R0,R4,#+1
   \   000005E4   0xF640 0x0133      MOVW     R1,#+2099
   \   000005E8   0x4288             CMP      R0,R1
   \   000005EA   0xD306             BCC.N    ??AngleZoneJudge_86
  13961              {
  13962              }
  13963              else
  13964              {
  13965                return 0;
   \   000005EC   0x2000             MOVS     R0,#+0
   \   000005EE   0xE0BA             B.N      ??AngleZoneJudge_2
  13966              }
   \                     ??AngleZoneJudge_85: (+1)
   \   000005F0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000005F2   0x293B             CMP      R1,#+59
   \   000005F4   0xD1D6             BNE.N    ??AngleZoneJudge_83
   \   000005F6   0x2000             MOVS     R0,#+0
   \   000005F8   0xE0B5             B.N      ??AngleZoneJudge_2
  13967              a0 = LeastSquarea0(x, y, a1, AngleJudgeSlopeRowNum);
   \                     ??AngleZoneJudge_86: (+1)
   \   000005FA   0x2308             MOVS     R3,#+8
   \   000005FC   0x0022             MOVS     R2,R4
   \   000005FE   0xA900             ADD      R1,SP,#+0
   \   00000600   0xA802             ADD      R0,SP,#+8
   \   00000602   0x.... 0x....      BL       LeastSquarea0
  13968              //2.3 计算给定5行的右边界。标志位清零。
  13969              //要往中间留AngleZoneCheckRowCom列的裕量。
  13970              for(i = 0; ; i++)
   \   00000606   0x2100             MOVS     R1,#+0
   \   00000608   0xE000             B.N      ??AngleZoneJudge_87
   \                     ??AngleZoneJudge_88: (+1)
   \   0000060A   0x1C49             ADDS     R1,R1,#+1
  13971              {
  13972                //根据线头几行来最小二乘法还是比较准的，不用修正太多列。
  13973                AngleZoneJudgeColR[i] = (a0 + a1 * AngleZoneJudgeRowR[i]) / LeastSquareMulti - AngleZoneJudgeRowCom;  
   \                     ??AngleZoneJudge_87: (+1)
   \   0000060C   0x.... 0x....      LDR.W    R2,??DataTable71_4
   \   00000610   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000612   0x5C8A             LDRB     R2,[R1, R2]
   \   00000614   0xFB02 0x0204      MLA      R2,R2,R4,R0
   \   00000618   0xF44F 0x737A      MOV      R3,#+1000
   \   0000061C   0xFB92 0xF2F3      SDIV     R2,R2,R3
   \   00000620   0x1E92             SUBS     R2,R2,#+2
   \   00000622   0x.... 0x....      LDR.W    R3,??DataTable71_5
   \   00000626   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000628   0x54CA             STRB     R2,[R1, R3]
  13974                AngleZoneJudgeColRFlag[i] = 0;
   \   0000062A   0x2200             MOVS     R2,#+0
   \   0000062C   0x.... 0x....      LDR.W    R3,??DataTable71_6
   \   00000630   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000632   0x54CA             STRB     R2,[R1, R3]
  13975                
  13976                if(i == AngleZoneJudgeRowNum - 1) break;
   \   00000634   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000636   0x2904             CMP      R1,#+4
   \   00000638   0xD1E7             BNE.N    ??AngleZoneJudge_88
  13977              }
  13978              //2.4 右边界确定后，往左一个赛道宽度内，只有有若干列都是黑点，则该行直角黑块判断成功。2行左右即可最终确认右线OK。
  13979              for(i = 0; ; i++)
   \   0000063A   0x2100             MOVS     R1,#+0
   \   0000063C   0xE000             B.N      ??AngleZoneJudge_89
   \                     ??AngleZoneJudge_90: (+1)
   \   0000063E   0x1C49             ADDS     R1,R1,#+1
  13980              {
  13981                //每行的列黑点计数清零。
  13982                countcol = 0;
   \                     ??AngleZoneJudge_89: (+1)
   \   00000640   0x2000             MOVS     R0,#+0
  13983                //从左往右扫半个赛道宽度。赛道宽度预定为70列左右。
  13984                if(AngleZoneJudgeColR[i] - AngleZoneJudgeRoadWidth / 2 < 0) //劣势边只允许扫描半个赛道宽度。防止障碍被误判成直角黑块。
   \   00000642   0x.... 0x....      LDR.W    R2,??DataTable71_5
   \   00000646   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000648   0x5C8A             LDRB     R2,[R1, R2]
   \   0000064A   0x3A23             SUBS     R2,R2,#+35
   \   0000064C   0x2A00             CMP      R2,#+0
   \   0000064E   0xD501             BPL.N    ??AngleZoneJudge_91
  13985                {
  13986                  return 0;
   \   00000650   0x2000             MOVS     R0,#+0
   \   00000652   0xE088             B.N      ??AngleZoneJudge_2
  13987                }
  13988                else
  13989                {
  13990                }      
  13991                for(col = AngleZoneJudgeColR[i] - AngleZoneJudgeRoadWidth / 2; ; col++) //劣势边只允许扫描半个赛道宽度。防止障碍被误判成直角黑块。
   \                     ??AngleZoneJudge_91: (+1)
   \   00000654   0x.... 0x....      LDR.W    R2,??DataTable71_5
   \   00000658   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000065A   0x5C8A             LDRB     R2,[R1, R2]
   \   0000065C   0x3A23             SUBS     R2,R2,#+35
   \   0000065E   0xE000             B.N      ??AngleZoneJudge_92
   \                     ??AngleZoneJudge_93: (+1)
   \   00000660   0x1C52             ADDS     R2,R2,#+1
  13992                {
  13993                  //检测到有效黑点，计数加1.
  13994                  if(ImgNew[AngleZoneJudgeRowR[i]][col] < LimitRightB) countcol++;
   \                     ??AngleZoneJudge_92: (+1)
   \   00000662   0x....             LDR.N    R3,??DataTable68_4
   \   00000664   0x.... 0x....      LDR.W    R4,??DataTable71_4
   \   00000668   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000066A   0x5D0C             LDRB     R4,[R1, R4]
   \   0000066C   0x25FA             MOVS     R5,#+250
   \   0000066E   0xFB05 0x3304      MLA      R3,R5,R4,R3
   \   00000672   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000674   0x5CD3             LDRB     R3,[R2, R3]
   \   00000676   0x....             LDR.N    R4,??DataTable68_10
   \   00000678   0x7824             LDRB     R4,[R4, #+0]
   \   0000067A   0x42A3             CMP      R3,R4
   \   0000067C   0xD200             BCS.N    ??AngleZoneJudge_94
   \   0000067E   0x1C40             ADDS     R0,R0,#+1
  13995                  //该行右黑点够多。置标志位。跳出。
  13996                  if(countcol >= AngleZoneJudgeBlackNumN)  //劣势边取20列左右，比单线宽度多
   \                     ??AngleZoneJudge_94: (+1)
   \   00000680   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000682   0x2814             CMP      R0,#+20
   \   00000684   0xDB05             BLT.N    ??AngleZoneJudge_95
  13997                  {
  13998                    AngleZoneJudgeColRFlag[i] = 1;
   \   00000686   0x2201             MOVS     R2,#+1
   \   00000688   0x.... 0x....      LDR.W    R3,??DataTable71_6
   \   0000068C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000068E   0x54CA             STRB     R2,[R1, R3]
  13999                    break;
   \   00000690   0xE006             B.N      ??AngleZoneJudge_96
  14000                  }
  14001                  //直到第70列也没有凑够黑点数，跳出。
  14002                  if(col == AngleZoneJudgeColR[i]) break;
   \                     ??AngleZoneJudge_95: (+1)
   \   00000692   0x.... 0x....      LDR.W    R3,??DataTable71_5
   \   00000696   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000698   0x5CCB             LDRB     R3,[R1, R3]
   \   0000069A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000069C   0x429A             CMP      R2,R3
   \   0000069E   0xD1DF             BNE.N    ??AngleZoneJudge_93
  14003                }
  14004                //记录该行的有效黑点数，以供确定合适的阈值。
  14005                AngleZoneJudgeCountColR[i] = countcol;      
   \                     ??AngleZoneJudge_96: (+1)
   \   000006A0   0x.... 0x....      LDR.W    R2,??DataTable71_7
   \   000006A4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000006A6   0x5488             STRB     R0,[R1, R2]
  14006                  
  14007                //到最后一行了，退出。
  14008                if(i == AngleZoneJudgeRowNum - 1) break;
   \   000006A8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000006AA   0x2904             CMP      R1,#+4
   \   000006AC   0xD1C7             BNE.N    ??AngleZoneJudge_90
  14009              }
  14010              //2.5 检测是不是至少有2行满足条件。若有，则确认这幅图像是直角黑块，更新赛道类型、线头、返回成功。若无，则返回失败。
  14011              count1 = 0;
   \   000006AE   0x2400             MOVS     R4,#+0
  14012              for(i = 0; ; i++)
   \   000006B0   0x2100             MOVS     R1,#+0
   \   000006B2   0xE000             B.N      ??AngleZoneJudge_97
   \                     ??AngleZoneJudge_98: (+1)
   \   000006B4   0x1C49             ADDS     R1,R1,#+1
  14013              {
  14014                if(AngleZoneJudgeColRFlag[i] == 1) count1++;
   \                     ??AngleZoneJudge_97: (+1)
   \   000006B6   0x.... 0x....      LDR.W    R0,??DataTable71_6
   \   000006BA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000006BC   0x5C08             LDRB     R0,[R1, R0]
   \   000006BE   0x2801             CMP      R0,#+1
   \   000006C0   0xD100             BNE.N    ??AngleZoneJudge_99
   \   000006C2   0x1C64             ADDS     R4,R4,#+1
  14015                
  14016                if(i == AngleZoneJudgeRowNum - 1) break;
   \                     ??AngleZoneJudge_99: (+1)
   \   000006C4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000006C6   0x2904             CMP      R1,#+4
   \   000006C8   0xD1F4             BNE.N    ??AngleZoneJudge_98
  14017              }
  14018              if(count1 >= 2)
   \   000006CA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000006CC   0x2C02             CMP      R4,#+2
   \   000006CE   0xDB47             BLT.N    ??AngleZoneJudge_100
  14019              {
  14020                //赛道类型，直角黑色区域。
  14021                PathType = PathAngleZone; 
   \   000006D0   0x200A             MOVS     R0,#+10
   \   000006D2   0x.... 0x....      LDR.W    R1,??DataTable72_4
   \   000006D6   0x7008             STRB     R0,[R1, #+0]
  14022                
  14023                //对线头作处理，远线头拉到近线头处来。使远处的行不至于太偏。
  14024                //线头相同，不用处理。
  14025                if(BlackLeftHeadLine == BlackRightHeadLine)
   \   000006D8   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   000006DC   0x7800             LDRB     R0,[R0, #+0]
   \   000006DE   0x.... 0x....      LDR.W    R1,??DataTable72
   \   000006E2   0x7809             LDRB     R1,[R1, #+0]
   \   000006E4   0x4288             CMP      R0,R1
   \   000006E6   0xD039             BEQ.N    ??AngleZoneJudge_101
  14026                {
  14027                }
  14028                //左线头更远
  14029                else if(BlackLeftHeadLine < BlackRightHeadLine)
   \   000006E8   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   000006EC   0x7800             LDRB     R0,[R0, #+0]
   \   000006EE   0x.... 0x....      LDR.W    R1,??DataTable72
   \   000006F2   0x7809             LDRB     R1,[R1, #+0]
   \   000006F4   0x4288             CMP      R0,R1
   \   000006F6   0xD219             BCS.N    ??AngleZoneJudge_102
  14030                {
  14031                  //删掉左线头超出右线头的部分。
  14032                  for(i = BlackLeftHeadLine; ; i++)
   \   000006F8   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   000006FC   0x7801             LDRB     R1,[R0, #+0]
   \   000006FE   0xE008             B.N      ??AngleZoneJudge_103
  14033                  {
  14034                    if(i == BlackRightHeadLine) break;
  14035                    
  14036                    BlackLeftLoc[i][0] = MaxValUint8;
   \                     ??AngleZoneJudge_104: (+1)
   \   00000700   0x20FF             MOVS     R0,#+255
   \   00000702   0x.... 0x....      LDR.W    R2,??DataTable71_9
   \   00000706   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000708   0x2303             MOVS     R3,#+3
   \   0000070A   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   0000070E   0x7010             STRB     R0,[R2, #+0]
   \   00000710   0x1C49             ADDS     R1,R1,#+1
   \                     ??AngleZoneJudge_103: (+1)
   \   00000712   0x.... 0x....      LDR.W    R0,??DataTable72
   \   00000716   0x7800             LDRB     R0,[R0, #+0]
   \   00000718   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000071A   0x4281             CMP      R1,R0
   \   0000071C   0xD1F0             BNE.N    ??AngleZoneJudge_104
  14037                  }
  14038                  //左线头的值更新。
  14039                  BlackLeftHeadLine = BlackRightHeadLine;
   \   0000071E   0x.... 0x....      LDR.W    R0,??DataTable72
   \   00000722   0x7800             LDRB     R0,[R0, #+0]
   \   00000724   0x.... 0x....      LDR.W    R1,??DataTable71_2
   \   00000728   0x7008             STRB     R0,[R1, #+0]
   \   0000072A   0xE017             B.N      ??AngleZoneJudge_101
  14040                }
  14041                //右线头更远
  14042                else
  14043                {
  14044                  //删掉右线头超出左线头的部分。
  14045                  for(i = BlackRightHeadLine; ; i++)
   \                     ??AngleZoneJudge_102: (+1)
   \   0000072C   0x.... 0x....      LDR.W    R0,??DataTable72
   \   00000730   0x7801             LDRB     R1,[R0, #+0]
   \   00000732   0xE007             B.N      ??AngleZoneJudge_105
  14046                  {
  14047                    if(i == BlackLeftHeadLine) break;
  14048                    
  14049                    BlackRightLoc[i][0] = MaxValUint8;
   \                     ??AngleZoneJudge_106: (+1)
   \   00000734   0x20FF             MOVS     R0,#+255
   \   00000736   0x....             LDR.N    R2,??DataTable68_3
   \   00000738   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000073A   0x2303             MOVS     R3,#+3
   \   0000073C   0xFB03 0x2201      MLA      R2,R3,R1,R2
   \   00000740   0x7010             STRB     R0,[R2, #+0]
   \   00000742   0x1C49             ADDS     R1,R1,#+1
   \                     ??AngleZoneJudge_105: (+1)
   \   00000744   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   00000748   0x7800             LDRB     R0,[R0, #+0]
   \   0000074A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000074C   0x4281             CMP      R1,R0
   \   0000074E   0xD1F1             BNE.N    ??AngleZoneJudge_106
  14050                  }
  14051                  //右线头的值更新。
  14052                  BlackRightHeadLine = BlackLeftHeadLine;        
   \   00000750   0x.... 0x....      LDR.W    R0,??DataTable71_2
   \   00000754   0x7800             LDRB     R0,[R0, #+0]
   \   00000756   0x.... 0x....      LDR.W    R1,??DataTable72
   \   0000075A   0x7008             STRB     R0,[R1, #+0]
  14053                }
  14054                      
  14055                return 1;      
   \                     ??AngleZoneJudge_101: (+1)
   \   0000075C   0x2001             MOVS     R0,#+1
   \   0000075E   0xE002             B.N      ??AngleZoneJudge_2
  14056              }
  14057              else
  14058              {
  14059                return 0;
   \                     ??AngleZoneJudge_100: (+1)
   \   00000760   0x2000             MOVS     R0,#+0
   \   00000762   0xE000             B.N      ??AngleZoneJudge_2
  14060              }
  14061              
  14062            }
  14063            //理论上不会走到这里，左右线头一定有个高低。
  14064            else
  14065            {
  14066            }
  14067            
  14068            //常态是检测失败。
  14069            return 0;
   \                     ??AngleZoneJudge_56: (+1)
   \   00000764   0x2000             MOVS     R0,#+0
   \                     ??AngleZoneJudge_2: (+1)
   \   00000766   0xB005             ADD      SP,SP,#+20
   \   00000768   0xBD30             POP      {R4,R5,PC}       ;; return
  14070          }
  14071          
  14072          
  14073          //直角黑块确认函数

   \                                 In section .text, align 2, keep-with-next
  14074          uint8 AngleZoneConfirm(void)
  14075          {
   \                     AngleZoneConfirm: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  14076            
  14077            uint8 i;
  14078            
  14079            //直角黑块锁存标志没有被置位的时候才进行直角黑块计数，若已被置位，则不用进行直角黑块计数。
  14080            if(AngleZoneConfirmLockFlag == 0)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable76
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD14E             BNE.N    ??AngleZoneConfirm_0
  14081            {
  14082              //A次计数内有B次直角黑块成功，则判断为直角黑块。先入先出队列。
  14083              for(i = 0; ; i++)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE000             B.N      ??AngleZoneConfirm_1
   \                     ??AngleZoneConfirm_2: (+1)
   \   00000010   0x1C40             ADDS     R0,R0,#+1
  14084              {
  14085                AngleZoneConfirmMat[i] = AngleZoneConfirmMat[i + 1];
   \                     ??AngleZoneConfirm_1: (+1)
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable74
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x1841             ADDS     R1,R0,R1
   \   0000001A   0x7849             LDRB     R1,[R1, #+1]
   \   0000001C   0x.... 0x....      LDR.W    R2,??DataTable74
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x5481             STRB     R1,[R0, R2]
  14086                if(i == AngleZoneConfirmMatNum - 2) break;
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x2804             CMP      R0,#+4
   \   00000028   0xD1F2             BNE.N    ??AngleZoneConfirm_2
  14087              }
  14088              //成功
  14089              if(PathType == PathAngleZone)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable72_4
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x280A             CMP      R0,#+10
   \   00000032   0xD104             BNE.N    ??AngleZoneConfirm_3
  14090              {
  14091                //判定为直角黑块则新来的值置1。
  14092                AngleZoneConfirmMat[AngleZoneConfirmMatNum - 1] = 1;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable74
   \   0000003A   0x7148             STRB     R0,[R1, #+5]
   \   0000003C   0xE003             B.N      ??AngleZoneConfirm_4
  14093              }
  14094              else
  14095              {
  14096                //判定为非直角黑块则新来的值置0.
  14097                AngleZoneConfirmMat[AngleZoneConfirmMatNum - 1] = 0;
   \                     ??AngleZoneConfirm_3: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable74
   \   00000044   0x7148             STRB     R0,[R1, #+5]
  14098              }
  14099              //收集AngleZoneConfirmMat数组里1的个数。
  14100              AngleZoneConfirmMatCollect = 0;
   \                     ??AngleZoneConfirm_4: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable74_1
   \   0000004C   0x7008             STRB     R0,[R1, #+0]
  14101              for(i = 0; ; i++)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE000             B.N      ??AngleZoneConfirm_5
   \                     ??AngleZoneConfirm_6: (+1)
   \   00000052   0x1C40             ADDS     R0,R0,#+1
  14102              {
  14103                if(AngleZoneConfirmMat[i] == 1) AngleZoneConfirmMatCollect++;
   \                     ??AngleZoneConfirm_5: (+1)
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable74
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x5C41             LDRB     R1,[R0, R1]
   \   0000005C   0x2901             CMP      R1,#+1
   \   0000005E   0xD106             BNE.N    ??AngleZoneConfirm_7
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable74_1
   \   00000064   0x7809             LDRB     R1,[R1, #+0]
   \   00000066   0x1C49             ADDS     R1,R1,#+1
   \   00000068   0x.... 0x....      LDR.W    R2,??DataTable74_1
   \   0000006C   0x7011             STRB     R1,[R2, #+0]
  14104                
  14105                if(i == AngleZoneConfirmMatNum - 1) break;
   \                     ??AngleZoneConfirm_7: (+1)
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0x2805             CMP      R0,#+5
   \   00000072   0xD1EE             BNE.N    ??AngleZoneConfirm_6
  14106              }
  14107              //大于若干次，则锁存为直角黑块。
  14108              if(AngleZoneConfirmMatCollect >= AngleZoneConfirmMatLimit)
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable74_1
   \   00000078   0x7800             LDRB     R0,[R0, #+0]
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable74_2
   \   0000007E   0x7809             LDRB     R1,[R1, #+0]
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xD312             BCC.N    ??AngleZoneConfirm_0
  14109              {
  14110                //锁存标志位置位。
  14111                AngleZoneConfirmLockFlag = 1;
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable76
   \   0000008A   0x7008             STRB     R0,[R1, #+0]
  14112                //锁存标志位置位时，同时把1米距离内的计数值清零。
  14113                AngleZoneConfirmLockMeterCount = 0;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable75
   \   00000092   0x7008             STRB     R0,[R1, #+0]
  14114                //数组清空，防止重复锁存。
  14115                for(i = 0; ; i++)
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xE000             B.N      ??AngleZoneConfirm_8
   \                     ??AngleZoneConfirm_9: (+1)
   \   00000098   0x1C40             ADDS     R0,R0,#+1
  14116                {
  14117                  AngleZoneConfirmMat[i] = 0;
   \                     ??AngleZoneConfirm_8: (+1)
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0x.... 0x....      LDR.W    R2,??DataTable74
   \   000000A0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A2   0x5481             STRB     R1,[R0, R2]
  14118                  if(i == AngleZoneConfirmMatNum - 1) break;
   \   000000A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A6   0x2805             CMP      R0,#+5
   \   000000A8   0xD1F6             BNE.N    ??AngleZoneConfirm_9
  14119                }
  14120          
  14121                //PatyType在AngleZoneJudge中已经更新。
  14122              }
  14123              else
  14124              {
  14125              }
  14126            }
  14127            //直角黑块锁存已被置位，则不用进行直角黑块计数。
  14128            else
  14129            {
  14130            }
  14131            
  14132            //若直角黑块锁存标志位置位，则对1米的距离内保持锁存，若检测到不到线头高度差，则释放。
  14133            //按2 m/s速度，跑1米大概需要0.5s，也就是30个16ms，3m/s对应20个16ms.所以应取30个以上。
  14134            if(AngleZoneConfirmLockFlag == 1)
   \                     ??AngleZoneConfirm_0: (+1)
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable76
   \   000000AE   0x7800             LDRB     R0,[R0, #+0]
   \   000000B0   0x2801             CMP      R0,#+1
   \   000000B2   0xD173             BNE.N    ??AngleZoneConfirm_10
  14135            {
  14136              //直角黑块锁存期间，若线头差小于4，则远处线头删至近处线头。
  14137              if(AbsInt(BlackLeftHeadLine - BlackRightHeadLine) < 4)
   \   000000B4   0x....             LDR.N    R0,??DataTable71_2
   \   000000B6   0x7800             LDRB     R0,[R0, #+0]
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable72
   \   000000BC   0x7809             LDRB     R1,[R1, #+0]
   \   000000BE   0x1A40             SUBS     R0,R0,R1
   \   000000C0   0x.... 0x....      BL       AbsInt
   \   000000C4   0x2804             CMP      R0,#+4
   \   000000C6   0xDA3B             BGE.N    ??AngleZoneConfirm_11
  14138              {
  14139                //线头相同，不用处理。
  14140                if(BlackLeftHeadLine == BlackRightHeadLine)
   \   000000C8   0x....             LDR.N    R0,??DataTable71_2
   \   000000CA   0x7800             LDRB     R0,[R0, #+0]
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable72
   \   000000D0   0x7809             LDRB     R1,[R1, #+0]
   \   000000D2   0x4288             CMP      R0,R1
   \   000000D4   0xD034             BEQ.N    ??AngleZoneConfirm_11
  14141                {
  14142                }
  14143                //左线头更远
  14144                else if(BlackLeftHeadLine < BlackRightHeadLine)
   \   000000D6   0x....             LDR.N    R0,??DataTable71_2
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0x.... 0x....      LDR.W    R1,??DataTable72
   \   000000DE   0x7809             LDRB     R1,[R1, #+0]
   \   000000E0   0x4288             CMP      R0,R1
   \   000000E2   0xD216             BCS.N    ??AngleZoneConfirm_12
  14145                {   
  14146                  //删掉左线头超出右线头的部分。
  14147                  for(i = BlackLeftHeadLine; ; i++)
   \   000000E4   0x....             LDR.N    R0,??DataTable71_2
   \   000000E6   0x7800             LDRB     R0,[R0, #+0]
   \   000000E8   0xE007             B.N      ??AngleZoneConfirm_13
  14148                  {
  14149                    if(i == BlackRightHeadLine) break;
  14150                    
  14151                    BlackLeftLoc[i][0] = MaxValUint8;
   \                     ??AngleZoneConfirm_14: (+1)
   \   000000EA   0x21FF             MOVS     R1,#+255
   \   000000EC   0x....             LDR.N    R2,??DataTable71_9
   \   000000EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F0   0x2303             MOVS     R3,#+3
   \   000000F2   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000F6   0x7011             STRB     R1,[R2, #+0]
   \   000000F8   0x1C40             ADDS     R0,R0,#+1
   \                     ??AngleZoneConfirm_13: (+1)
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable72
   \   000000FE   0x7809             LDRB     R1,[R1, #+0]
   \   00000100   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000102   0x4288             CMP      R0,R1
   \   00000104   0xD1F1             BNE.N    ??AngleZoneConfirm_14
  14152                  }
  14153                  //左线头的值更新。
  14154                  BlackLeftHeadLine = BlackRightHeadLine;
   \   00000106   0x.... 0x....      LDR.W    R0,??DataTable72
   \   0000010A   0x7800             LDRB     R0,[R0, #+0]
   \   0000010C   0x....             LDR.N    R1,??DataTable71_2
   \   0000010E   0x7008             STRB     R0,[R1, #+0]
   \   00000110   0xE016             B.N      ??AngleZoneConfirm_11
  14155                }
  14156                //右线头更远
  14157                else
  14158                {
  14159                  //删掉右线头超出左线头的部分。
  14160                  for(i = BlackRightHeadLine; ; i++)
   \                     ??AngleZoneConfirm_12: (+1)
   \   00000112   0x.... 0x....      LDR.W    R0,??DataTable72
   \   00000116   0x7800             LDRB     R0,[R0, #+0]
   \   00000118   0xE008             B.N      ??AngleZoneConfirm_15
  14161                  {
  14162                    if(i == BlackLeftHeadLine) break;
  14163                    
  14164                    BlackRightLoc[i][0] = MaxValUint8;
   \                     ??AngleZoneConfirm_16: (+1)
   \   0000011A   0x21FF             MOVS     R1,#+255
   \   0000011C   0x.... 0x....      LDR.W    R2,??DataTable75_1
   \   00000120   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000122   0x2303             MOVS     R3,#+3
   \   00000124   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000128   0x7011             STRB     R1,[R2, #+0]
   \   0000012A   0x1C40             ADDS     R0,R0,#+1
   \                     ??AngleZoneConfirm_15: (+1)
   \   0000012C   0x....             LDR.N    R1,??DataTable71_2
   \   0000012E   0x7809             LDRB     R1,[R1, #+0]
   \   00000130   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000132   0x4288             CMP      R0,R1
   \   00000134   0xD1F1             BNE.N    ??AngleZoneConfirm_16
  14165                  }
  14166                  //右线头的值更新。
  14167                  BlackRightHeadLine = BlackLeftHeadLine;        
   \   00000136   0x....             LDR.N    R0,??DataTable71_2
   \   00000138   0x7800             LDRB     R0,[R0, #+0]
   \   0000013A   0x.... 0x....      LDR.W    R1,??DataTable72
   \   0000013E   0x7008             STRB     R0,[R1, #+0]
  14168                }
  14169              }
  14170              else
  14171              {
  14172              }
  14173              
  14174              //Count的意义：
  14175              //1. 直角黑块锁存确认后，Count清零。
  14176              //2. 直角黑块锁存期间：2.1. 若没有检测到 障碍 或者 直角线头差，则计数加1。若连续计数直至达到阈值，则觉得应该是出直角的直角黑块，则计数清零，允许再次检测直角。
  14177              //                     2.2. 若检测到了，则计数清零
  14178              //3. 直角黑块非锁存期间：不做对计数做任何处理。
  14179              if(AngleZoneConfirmLockFlag == 1)
   \                     ??AngleZoneConfirm_11: (+1)
   \   00000140   0x.... 0x....      LDR.W    R0,??DataTable76
   \   00000144   0x7800             LDRB     R0,[R0, #+0]
   \   00000146   0x2801             CMP      R0,#+1
   \   00000148   0xD128             BNE.N    ??AngleZoneConfirm_10
  14180              {
  14181                if(PathType == PathTypeAngleL || PathType == PathTypeAngleR || PathType == PathBrickLeft || PathType == PathBrickRight)
   \   0000014A   0x.... 0x....      LDR.W    R0,??DataTable72_4
   \   0000014E   0x7800             LDRB     R0,[R0, #+0]
   \   00000150   0x2804             CMP      R0,#+4
   \   00000152   0xD00E             BEQ.N    ??AngleZoneConfirm_17
   \   00000154   0x.... 0x....      LDR.W    R0,??DataTable72_4
   \   00000158   0x7800             LDRB     R0,[R0, #+0]
   \   0000015A   0x2805             CMP      R0,#+5
   \   0000015C   0xD009             BEQ.N    ??AngleZoneConfirm_17
   \   0000015E   0x.... 0x....      LDR.W    R0,??DataTable72_4
   \   00000162   0x7800             LDRB     R0,[R0, #+0]
   \   00000164   0x2808             CMP      R0,#+8
   \   00000166   0xD004             BEQ.N    ??AngleZoneConfirm_17
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable72_4
   \   0000016C   0x7800             LDRB     R0,[R0, #+0]
   \   0000016E   0x2809             CMP      R0,#+9
   \   00000170   0xD104             BNE.N    ??AngleZoneConfirm_18
  14182                {
  14183                  //计数清零
  14184                  AngleZoneConfirmLockMeterCount = 0;
   \                     ??AngleZoneConfirm_17: (+1)
   \   00000172   0x2000             MOVS     R0,#+0
   \   00000174   0x.... 0x....      LDR.W    R1,??DataTable75
   \   00000178   0x7008             STRB     R0,[R1, #+0]
   \   0000017A   0xE00F             B.N      ??AngleZoneConfirm_10
  14185                }
  14186                else
  14187                {
  14188                  AngleZoneConfirmLockMeterCount++;
   \                     ??AngleZoneConfirm_18: (+1)
   \   0000017C   0x.... 0x....      LDR.W    R0,??DataTable75
   \   00000180   0x7800             LDRB     R0,[R0, #+0]
   \   00000182   0x1C40             ADDS     R0,R0,#+1
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable75
   \   00000188   0x7008             STRB     R0,[R1, #+0]
  14189                  if(AngleZoneConfirmLockMeterCount > AngleZoneConfirmLockMeterCountLimit)
   \   0000018A   0x.... 0x....      LDR.W    R0,??DataTable75
   \   0000018E   0x7800             LDRB     R0,[R0, #+0]
   \   00000190   0x2829             CMP      R0,#+41
   \   00000192   0xDB03             BLT.N    ??AngleZoneConfirm_10
  14190                  {
  14191                    //1米左右的距离仍没有检测到高度差，释放锁存标志位，再次检测直角黑块。
  14192                    AngleZoneConfirmLockFlag = 0;
   \   00000194   0x2000             MOVS     R0,#+0
   \   00000196   0x.... 0x....      LDR.W    R1,??DataTable76
   \   0000019A   0x7008             STRB     R0,[R1, #+0]
  14193                  }
  14194                  else
  14195                  {      
  14196                  }
  14197                }
  14198              }
  14199              else
  14200              {
  14201              }
  14202            }
  14203            else
  14204            {
  14205            }
  14206          
  14207            
  14208            return 1;
   \                     ??AngleZoneConfirm_10: (+1)
   \   0000019C   0x2001             MOVS     R0,#+1
   \   0000019E   0xBD02             POP      {R1,PC}          ;; return
  14209          
  14210            
  14211            
  14212          }
  14213          
  14214          
  14215          //赛道类型判断
  14216          //返回0出错，1正常。

   \                                 In section .text, align 2, keep-with-next
  14217          uint8 PathJudgeNew(void)
  14218          {
   \                     PathJudgeNew: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  14219            
  14220            //0. 默认赛道类型未知。
  14221            PathType = PathTypeUnknown;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable72_4
   \   00000006   0x7008             STRB     R0,[R1, #+0]
  14222            
  14223          
  14224            //1. 直角线头差 、 障碍 的 锁存 或 特殊控制 期间，不进行直角、直角黑块、障碍的检测 以及 直道 的检测。
  14225            if(
  14226              (AngleConfirmLockFlag == 1)   //直角锁存期间
  14227            ||(AngleSpeDealFlag == 1)       //直角强制控制期间
  14228            ||(BrickConfirmLockFlag == 1)   //障碍锁存期间
  14229            ||(BrickSpeDealFlag == 1)       //障碍特殊控制期间
  14230            ||(GyroResultForbidFlag == 1)   //坡道禁止赛道类型判断期间
  14231              )
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable76_1
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD013             BEQ.N    ??PathJudgeNew_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable76_2
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD00E             BEQ.N    ??PathJudgeNew_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable76_3
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD009             BEQ.N    ??PathJudgeNew_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable76_4
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD004             BEQ.N    ??PathJudgeNew_0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable76_5
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD108             BNE.N    ??PathJudgeNew_1
  14232            {
  14233              //连续长直道计数清零。
  14234              PathRealStraightCount = 0;
   \                     ??PathJudgeNew_0: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable77
   \   00000040   0x7008             STRB     R0,[R1, #+0]
  14235              //锁存或特殊控制期间，说明障碍或直角已经判断成功，可以将直角黑块锁存标志复位，允许判断直角黑块。
  14236              AngleZoneConfirmLockFlag = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable76
   \   00000048   0x7008             STRB     R0,[R1, #+0]
   \   0000004A   0xE00F             B.N      ??PathJudgeNew_2
  14237            }
  14238            else
  14239            {
  14240              //判断停车线
  14241              //if(StopLineCheck()){StopLineCheckFlag = 1;}
  14242              //十字的二重判定
  14243              //if(ShiZhiCheck()) { ShiZhiFlag = 1; } else {ShiZhiFlag = 0;}
  14244              //2.1 直角黑块未锁存期间，检测直角黑块 或 障碍物 或 直道， 不检测直角线头差。
  14245              if(AngleZoneConfirmLockFlag == 0)
   \                     ??PathJudgeNew_1: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable76
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD108             BNE.N    ??PathJudgeNew_3
  14246              {
  14247                //2.1.1. 判断直道。
  14248                if(PathJudgeNewStraight() == 1)
   \   00000056   0x.... 0x....      BL       PathJudgeNewStraight
  14249                {
  14250                }
  14251                else
  14252                {
  14253                }
  14254          
  14255                //2.1.2. 先检测直角黑块检测    //这届不检测了
  14256                //AngleZoneJudge();
  14257                //2.1.3. 若直角黑块检测不成功，再检测障碍物。
  14258                if(PathType != PathAngleZone)
   \   0000005A   0x....             LDR.N    R0,??DataTable72_4
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x280A             CMP      R0,#+10
   \   00000060   0xD004             BEQ.N    ??PathJudgeNew_2
  14259                {
  14260                  BrickJudge();
   \   00000062   0x.... 0x....      BL       BrickJudge
   \   00000066   0xE001             B.N      ??PathJudgeNew_2
  14261                }
  14262                //直角黑块检测成功，就不用检测障碍物了。
  14263                else
  14264                {
  14265          
  14266                }    
  14267              }
  14268              //2.2 直角黑块锁存期间，检测障碍物 和 直角线头差。不检测直角黑块 和 直道。
  14269              else
  14270              {
  14271                //2.2.1锁存期间，先检测障碍物。
  14272                BrickJudge();
   \                     ??PathJudgeNew_3: (+1)
   \   00000068   0x.... 0x....      BL       BrickJudge
  14273                //2.2.2 障碍物未检测成功，则检测直角线头差。 
  14274                if(PathType != PathBrickLeft && PathType != PathBrickRight)
  14275                {
  14276                  //AngleStep1Judge();
  14277                  
  14278                }
  14279                //确认为障碍，不进行直角线头差的检测。为了避免错误，直角线头差中还必须包括对黑块的扫描。
  14280                else
  14281                {
  14282                }      
  14283                
  14284              }
  14285            }
  14286          
  14287            //3. 长直道判断
  14288            if(PathType == PathTypeStraight)
   \                     ??PathJudgeNew_2: (+1)
   \   0000006C   0x....             LDR.N    R0,??DataTable72_4
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0x2801             CMP      R0,#+1
   \   00000072   0xD121             BNE.N    ??PathJudgeNew_4
  14289            {
  14290              //新加入的停车线的检测，在直角和障碍均检测不到时检测
  14291              //if(StopLineCheck()){StopLineCheckFlag = 1;light_control(PORTE, 26, Light_ON);}
  14292              
  14293              //连续长直道计数加1。
  14294              PathRealStraightCount++;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable77
   \   00000078   0x7800             LDRB     R0,[R0, #+0]
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable77
   \   00000080   0x7008             STRB     R0,[R1, #+0]
  14295              //连续计数达到阈值
  14296              if(PathRealStraightCount > PathRealStraightCountLimit)
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable78
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable77
   \   0000008C   0x7809             LDRB     R1,[R1, #+0]
   \   0000008E   0x4288             CMP      R0,R1
   \   00000090   0xD208             BCS.N    ??PathJudgeNew_5
  14297              {
  14298                //长直道标志置1.
  14299                PathRealStraightFlag = 1;
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable78_1
   \   00000098   0x7008             STRB     R0,[R1, #+0]
  14300                //计数清零
  14301                PathRealStraightCount = 0;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable77
   \   000000A0   0x7008             STRB     R0,[R1, #+0]
   \   000000A2   0xE015             B.N      ??PathJudgeNew_6
  14302              }
  14303              else if(PathRealStraightCount > 5)
   \                     ??PathJudgeNew_5: (+1)
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable77
   \   000000A8   0x7800             LDRB     R0,[R0, #+0]
   \   000000AA   0x2806             CMP      R0,#+6
   \   000000AC   0xDB10             BLT.N    ??PathJudgeNew_6
  14304              {
  14305                  xiaoZhiDaoFlag = 1;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable78_2
   \   000000B4   0x7008             STRB     R0,[R1, #+0]
   \   000000B6   0xE00B             B.N      ??PathJudgeNew_6
  14306              }
  14307              else
  14308              {
  14309              }
  14310              
  14311            }
  14312            else
  14313            {
  14314              //一旦检测到非直道，则计数清零。
  14315              PathRealStraightCount = 0;
   \                     ??PathJudgeNew_4: (+1)
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable77
   \   000000BE   0x7008             STRB     R0,[R1, #+0]
  14316              //一旦检测到非直道，则长直道标志复位。
  14317              PathRealStraightFlag = 0;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable78_1
   \   000000C6   0x7008             STRB     R0,[R1, #+0]
  14318              xiaoZhiDaoFlag = 0;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable78_2
   \   000000CE   0x7008             STRB     R0,[R1, #+0]
  14319            }
  14320            
  14321            
  14322            
  14323            
  14324            
  14325          //  //1. 判断直道。
  14326          //  if(PathJudgeNewStraight() == 1)
  14327          //  {
  14328          //    //2. 直角锁存或特殊控制、障碍锁存或特殊控制期间，不进行直角、直角黑块、障碍的检测。
  14329          //    if(AngleConfirmLockFlag == 1 || AngleSpeDealFlag == 1 || BrickConfirmLockFlag == 1 || BrickSpeDealFlag == 1)
  14330          //    {
  14331          //    }
  14332          //    else
  14333          //    {
  14334          //      //3. 直角黑块未锁存期间，检测直角黑块 或 障碍物，不检测直角线头差。
  14335          //      if(AngleZoneConfirmLockFlag == 0)
  14336          //      {
  14337          //        //4. 先检测直角黑块检测
  14338          //        AngleZoneJudge();
  14339          //        //5. 若直角黑块检测不成功，再检测障碍物。
  14340          //        if(PathType != PathAngleZone)
  14341          //        {
  14342          //          BrickJudge();
  14343          //        }
  14344          //        //直角黑块检测成功，就不用检测障碍物了。
  14345          //        else
  14346          //        {
  14347          //        }    
  14348          //      }
  14349          //      //直角黑块锁存期间，检测直角线头差。不检测直角黑块 和 障碍物。
  14350          //      else
  14351          //      {
  14352          //        AngleStep1Judge();
  14353          //      }
  14354          //    }
  14355          //  }
  14356          //  //不是直道，直接退出。
  14357          //  else
  14358          //  {
  14359          //  }      
  14360                
  14361                
  14362                
  14363                
  14364          //  //判断直道。
  14365          //  if(PathJudgeNewStraight() == 1)
  14366          //  {
  14367          //    //障碍或直角的锁存和强制控制期间，不需要进行障碍或直角检测，以免误判 或 重复锁存。
  14368          //    if(AngleConfirmLockFlag == 0 && AngleSpeDealFlag == 0
  14369          //    && BrickConfirmLockFlag == 0 && BrickSpeDealFlag == 0)
  14370          //    {
  14371          //      //障碍判断
  14372          //      BrickJudge();
  14373          //      if(PathType != PathBrickLeft && PathType != PathBrickRight)
  14374          //      {
  14375          //        //如果不是障碍，则可以进一步判断是不是直角弯。
  14376          //        //直角先去掉，专门测砖块。   //AngleStep1Judge();
  14377          //      }
  14378          //      else
  14379          //      {
  14380          //      }
  14381          //    }
  14382          //    else
  14383          //    {
  14384          //    }
  14385          //  }
  14386          //  else
  14387          //  {
  14388          //  }
  14389            
  14390            return 1;
   \                     ??PathJudgeNew_6: (+1)
   \   000000D0   0x2001             MOVS     R0,#+1
   \   000000D2   0xBD02             POP      {R1,PC}          ;; return
  14391          }
  14392          
  14393          
  14394          //各种变量的初始化赋值函数

   \                                 In section .text, align 2, keep-with-next
  14395          uint8 VariablesInit(void)
  14396          {
  14397            uint8 i;
  14398            
  14399            LimitLeftWB = LimitLeftWBMin;    //黑白像素点的差值，两个点的差必须要大于这个值，才能认为有跳变。
   \                     VariablesInit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable78_3
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable78_4
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
  14400            LimitLeftW  = LimitLeftWMin;      //白点必须要大于此值
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable78_5
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable78_6
   \   00000016   0x7008             STRB     R0,[R1, #+0]
  14401            LimitLeftB  = LimitLeftBMax;      //黑点必须要小于此值
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable78_7
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable78_8
   \   00000022   0x7008             STRB     R0,[R1, #+0]
  14402          
  14403            //每幅有效图像的左线线头对应的3个阈值，单独储存，每幅有效图像刷新一次。
  14404            LimitLeftHeadWB = LimitLeftWBMin;    
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable78_3
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable78_9
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
  14405            LimitLeftHeadW  = LimitLeftWMin;      
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable78_5
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable78_10
   \   0000003A   0x7008             STRB     R0,[R1, #+0]
  14406            LimitLeftHeadB  = LimitLeftBMax;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable78_7
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable78_11
   \   00000046   0x7008             STRB     R0,[R1, #+0]
  14407            
  14408            LimitRightWB = LimitRightWBMin;    //黑白像素点的差值，两个点的差必须要大于这个值，才能认为有跳变。
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable78_12
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable78_13
   \   00000052   0x7008             STRB     R0,[R1, #+0]
  14409            LimitRightW  = LimitRightWMin;      //白点必须要大于此值
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable78_14
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable78_15
   \   0000005E   0x7008             STRB     R0,[R1, #+0]
  14410            LimitRightB  = LimitRightBMax;      //黑点必须要小于此值
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable78_16
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable78_17
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
  14411          
  14412            //每幅有效图像的左线线头对应的3个阈值，单独储存，每幅有效图像刷新一次。
  14413            LimitRightHeadWB = LimitRightWBMin;    
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable78_12
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable78_18
   \   00000076   0x7008             STRB     R0,[R1, #+0]
  14414            LimitRightHeadW = LimitRightWMin;      
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable78_14
   \   0000007C   0x7800             LDRB     R0,[R0, #+0]
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable78_19
   \   00000082   0x7008             STRB     R0,[R1, #+0]
  14415            LimitRightHeadB = LimitRightBMax;  
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable78_16
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable78_20
   \   0000008E   0x7008             STRB     R0,[R1, #+0]
  14416            
  14417            //左右黑线跳变沿检测的起始列。需要考虑中间单线的宽度。
  14418            BlackLeftLastEdgeStartCol = CameraRealWidth/2 + SingleBlackWidthMax[CameraHight-1];
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable78_21
   \   00000094   0xF890 0x003B      LDRB     R0,[R0, #+59]
   \   00000098   0x307D             ADDS     R0,R0,#+125
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable78_22
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
  14419            BlackLeftEdgeStartCol = CameraRealWidth/2 + SingleBlackWidthMax[CameraHight-1];
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable78_21
   \   000000A4   0xF890 0x003B      LDRB     R0,[R0, #+59]
   \   000000A8   0x307D             ADDS     R0,R0,#+125
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable78_23
   \   000000AE   0x7008             STRB     R0,[R1, #+0]
  14420            
  14421            BlackRightLastEdgeStartCol = CameraRealWidth/2 - SingleBlackWidthMax[CameraHight-1]; 
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable78_21
   \   000000B4   0xF890 0x003B      LDRB     R0,[R0, #+59]
   \   000000B8   0xF1D0 0x007D      RSBS     R0,R0,#+125
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable78_24
   \   000000C0   0x7008             STRB     R0,[R1, #+0]
  14422            BlackRightEdgeStartCol = CameraRealWidth/2 - SingleBlackWidthMax[CameraHight-1];
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable78_21
   \   000000C6   0xF890 0x003B      LDRB     R0,[R0, #+59]
   \   000000CA   0xF1D0 0x007D      RSBS     R0,R0,#+125
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable78_25
   \   000000D2   0x7008             STRB     R0,[R1, #+0]
  14423            
  14424            //中心线获取时的赛道半宽，针对单线的情况。初始化为一个最大黑线宽度。
  14425            RoadHalfWidthSingle = SingleBlackWidthMax[CameraHight - 1];
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable78_21
   \   000000D8   0xF890 0x003B      LDRB     R0,[R0, #+59]
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable78_26
   \   000000E0   0x7008             STRB     R0,[R1, #+0]
  14426            
  14427            //直角弯标志存储数组，初始化为均不是直角。
  14428            for(i = 0; ; i++)
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0xE000             B.N      ??VariablesInit_0
   \                     ??VariablesInit_1: (+1)
   \   000000E6   0x1C40             ADDS     R0,R0,#+1
  14429            {
  14430              AngleConfirmMat[i] = 0;
   \                     ??VariablesInit_0: (+1)
   \   000000E8   0x2100             MOVS     R1,#+0
   \   000000EA   0x.... 0x....      LDR.W    R2,??DataTable78_27
   \   000000EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F0   0x5481             STRB     R1,[R0, R2]
  14431              if(i == AngleConfirmMatNum - 1) break;
   \   000000F2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F4   0x2805             CMP      R0,#+5
   \   000000F6   0xD1F6             BNE.N    ??VariablesInit_1
  14432            }
  14433            
  14434            //双线半宽
  14435            RoadHalfWidth = 100;
   \   000000F8   0x2064             MOVS     R0,#+100
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable78_28
   \   000000FE   0x7008             STRB     R0,[R1, #+0]
  14436            RoadHalfWidthLast = RoadHalfWidth;
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable78_28
   \   00000104   0x7800             LDRB     R0,[R0, #+0]
   \   00000106   0x.... 0x....      LDR.W    R1,??DataTable78_29
   \   0000010A   0x7008             STRB     R0,[R1, #+0]
  14437            
  14438            return 1;
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0x4770             BX       LR               ;; return
  14439          }
  14440          
  14441          
  14442          
  14443          
  14444          
  14445          
  14446          
  14447          
  14448          
  14449          //======================================================================
  14450          //函数名：ImageProParaInit
  14451          //功  能：每幅图像处理之前的参数初始化函数
  14452          //参  数：
  14453          //返  回：
  14454          //影  响：
  14455          //说  明：
  14456          //      
  14457          //             
  14458          //======================================================================

   \                                 In section .text, align 2, keep-with-next
  14459          uint8 ImageProParaInit(void)
  14460          {
  14461            uint8 i;
  14462            
  14463            //图像处理成功标志位，默认置1.
  14464            ImgBlackSucceedFlag = 1;
   \                     ImageProParaInit: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable78_30
   \   00000006   0x7008             STRB     R0,[R1, #+0]
  14465            ImgCenterSucceedFlag = 1;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable78_31
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
  14466            //小S弯判断标志初始化为失败。
  14467            PathSmallSDoneFlag = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable78_32
   \   00000016   0x7008             STRB     R0,[R1, #+0]
  14468             
  14469            //中心线数组赋无效值。
  14470            for(i = 0; ; i++)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE000             B.N      ??ImageProParaInit_0
   \                     ??ImageProParaInit_1: (+1)
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
  14471            {
  14472              CenterLineLoc[i] = MaxValInt16;
   \                     ??ImageProParaInit_0: (+1)
   \   0000001E   0xF647 0x71FF      MOVW     R1,#+32767
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable78_33
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
  14473              if(i == CameraHight - 1) break;
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x283B             CMP      R0,#+59
   \   00000030   0xD1F4             BNE.N    ??ImageProParaInit_1
  14474            }
  14475          
  14476            //赛道半宽记录值
  14477            for(i = 0; ; i++)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE000             B.N      ??ImageProParaInit_2
   \                     ??ImageProParaInit_3: (+1)
   \   00000036   0x1C40             ADDS     R0,R0,#+1
  14478            {
  14479              RoadHalfWidthRecord[i] = MaxValUint8;
   \                     ??ImageProParaInit_2: (+1)
   \   00000038   0x21FF             MOVS     R1,#+255
   \   0000003A   0x.... 0x....      LDR.W    R2,??DataTable78_34
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0x5481             STRB     R1,[R0, R2]
  14480              if(i == CameraHight - 1) break;
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x283B             CMP      R0,#+59
   \   00000046   0xD1F6             BNE.N    ??ImageProParaInit_3
  14481            }
  14482            
  14483            //通过赛道半宽判断出来的单线错误标志，初始化为未进入。
  14484            RoadHalfWidthWrongFlag = 2;
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable78_35
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
  14485            
  14486            //单线地板变量的处理。
  14487            SingleDoneFlag = 0;       
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable78_36
   \   00000056   0x7008             STRB     R0,[R1, #+0]
  14488            SingleFloorFlag = 0;            
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable78_37
   \   0000005E   0x7008             STRB     R0,[R1, #+0]
  14489            SingleFloorConfirmCount = 0;     
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable78_38
   \   00000066   0x7008             STRB     R0,[R1, #+0]
  14490            SingleFloorConfirmCountMax = 0;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable78_39
   \   0000006E   0x7008             STRB     R0,[R1, #+0]
  14491          
  14492            //每行的单线确认标志初始化为失败。
  14493            for(i = 0; ; i++)
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xE000             B.N      ??ImageProParaInit_4
   \                     ??ImageProParaInit_5: (+1)
   \   00000074   0x1C40             ADDS     R0,R0,#+1
  14494            {
  14495              SingleBlackFlag[i] = 0;
   \                     ??ImageProParaInit_4: (+1)
   \   00000076   0x2100             MOVS     R1,#+0
   \   00000078   0x.... 0x....      LDR.W    R2,??DataTable78_40
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x5481             STRB     R1,[R0, R2]
  14496              if(i == CameraHight - 1) break;
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0x283B             CMP      R0,#+59
   \   00000084   0xD1F6             BNE.N    ??ImageProParaInit_5
  14497            }
  14498            //总幅图像的单线标志，先存上一次的标志，再初始化为0.
  14499            SingleBlackLastAllFlag = SingleBlackAllFlag;
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable78_41
   \   0000008A   0x7800             LDRB     R0,[R0, #+0]
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable78_42
   \   00000090   0x7008             STRB     R0,[R1, #+0]
  14500            SingleBlackAllFlag = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable78_41
   \   00000098   0x7008             STRB     R0,[R1, #+0]
  14501            
  14502            //单线错误标志。0没错误，1有错误。每幅图初始化为0.
  14503            BlackSingleFlag = 0;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable78_43
   \   000000A0   0x7008             STRB     R0,[R1, #+0]
  14504            
  14505            flag222 = 0;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable78_44
   \   000000A8   0x6008             STR      R0,[R1, #+0]
  14506            
  14507            BrickLineCountNumRecord = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable78_45
   \   000000B0   0x7008             STRB     R0,[R1, #+0]
  14508            
  14509            //最终大跳变检测标志位
  14510            BlackBigChangeFinalCheckFlag = 0;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable78_46
   \   000000B8   0x7008             STRB     R0,[R1, #+0]
  14511            
  14512            //直角黑块
  14513            for(i = 0; ; i++)
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xE000             B.N      ??ImageProParaInit_6
   \                     ??ImageProParaInit_7: (+1)
   \   000000BE   0x1C40             ADDS     R0,R0,#+1
  14514            {
  14515              AngleZoneJudgeRowL[i] = 0;  //直角黑块，根据线头选中的要检测的左线行。
   \                     ??ImageProParaInit_6: (+1)
   \   000000C0   0x2100             MOVS     R1,#+0
   \   000000C2   0x.... 0x....      LDR.W    R2,??DataTable78_47
   \   000000C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C8   0x5481             STRB     R1,[R0, R2]
  14516              AngleZoneJudgeRowR[i] = 0;  //直角黑块，根据线头选中的要检测的右线行。
   \   000000CA   0x2100             MOVS     R1,#+0
   \   000000CC   0x.... 0x....      LDR.W    R2,??DataTable78_48
   \   000000D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D2   0x5481             STRB     R1,[R0, R2]
  14517              AngleZoneJudgeColL[i] = 0;  //直角黑块，左线定位的所在列。
   \   000000D4   0x2100             MOVS     R1,#+0
   \   000000D6   0x....             LDR.N    R2,??DataTable72_1
   \   000000D8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DA   0x5481             STRB     R1,[R0, R2]
  14518              AngleZoneJudgeCountColL[i] = 0;
   \   000000DC   0x2100             MOVS     R1,#+0
   \   000000DE   0x....             LDR.N    R2,??DataTable72_3
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0x5481             STRB     R1,[R0, R2]
  14519              AngleZoneJudgeColLFlag[i] = 0; //直角黑块，左线该行的有效黑点满足要求时置位。
   \   000000E4   0x2100             MOVS     R1,#+0
   \   000000E6   0x....             LDR.N    R2,??DataTable72_2
   \   000000E8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EA   0x5481             STRB     R1,[R0, R2]
  14520              AngleZoneJudgeColR[i] = 0;  //直角黑块，右线定位的所在列。
   \   000000EC   0x2100             MOVS     R1,#+0
   \   000000EE   0x.... 0x....      LDR.W    R2,??DataTable78_49
   \   000000F2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F4   0x5481             STRB     R1,[R0, R2]
  14521              AngleZoneJudgeColRFlag[i] = 0; //直角黑块，右线该行的有效黑点满足要求时置位。 
   \   000000F6   0x2100             MOVS     R1,#+0
   \   000000F8   0x.... 0x....      LDR.W    R2,??DataTable78_50
   \   000000FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000FE   0x5481             STRB     R1,[R0, R2]
  14522              AngleZoneJudgeCountColR[i] = 0;
   \   00000100   0x2100             MOVS     R1,#+0
   \   00000102   0x.... 0x....      LDR.W    R2,??DataTable78_51
   \   00000106   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000108   0x5481             STRB     R1,[R0, R2]
  14523              
  14524              if(i == AngleZoneJudgeRowNum - 1) break;   
   \   0000010A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010C   0x2804             CMP      R0,#+4
   \   0000010E   0xD1D6             BNE.N    ??ImageProParaInit_7
  14525            }
  14526            
  14527            //障碍
  14528            BrickEndColL = 0;    //障碍物，左直角梯形，起始行（近行）黑点所在列。
   \   00000110   0x2000             MOVS     R0,#+0
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable78_52
   \   00000116   0x7008             STRB     R0,[R1, #+0]
  14529            BrickHeadColL = 0;   //障碍物，左直角梯形，结束行（远行）黑点所在列。
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable78_53
   \   0000011E   0x7008             STRB     R0,[R1, #+0]
  14530            BrickBorderColL = 0; //障碍物，左直角梯形，直角边所在列。
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0x.... 0x....      LDR.W    R1,??DataTable78_54
   \   00000126   0x7008             STRB     R0,[R1, #+0]
  14531            BrickEndColR = 0;    //障碍物，右直角梯形，起始行（近行）黑点所在列。
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0x.... 0x....      LDR.W    R1,??DataTable78_55
   \   0000012E   0x7008             STRB     R0,[R1, #+0]
  14532            BrickHeadColR = 0;   //障碍物，右直角梯形，结束行（远行）黑点所在列。
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable78_56
   \   00000136   0x7008             STRB     R0,[R1, #+0]
  14533            BrickBorderColR = 0; //障碍物，右直角梯形，直角边所在列。  
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0x.... 0x....      LDR.W    R1,??DataTable78_57
   \   0000013E   0x7008             STRB     R0,[R1, #+0]
  14534            BrickSpeDealCenFlag = 1;
   \   00000140   0x2001             MOVS     R0,#+1
   \   00000142   0x.... 0x....      LDR.W    R1,??DataTable78_58
   \   00000146   0x7008             STRB     R0,[R1, #+0]
  14535            
  14536            return 1;
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0x4770             BX       LR               ;; return
  14537            
  14538          }
  14539          
  14540          //图像成功后的处理。
  14541          //只有图像处理成功了，才会进行赛道类型判断，才会进行偏差获取，舵机电机控制值才会更新。

   \                                 In section .text, align 2, keep-with-next
  14542          uint8 ImgProSucceedDeal(void)
  14543          {
   \                     ImgProSucceedDeal: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  14544            uint8 startline;
  14545            
  14546            //上一幅图最终的赛道半宽，图像成功才会切换。
  14547            RoadHalfWidthLast = RoadHalfWidth;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable78_28
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable78_29
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
  14548            
  14549            /*
  14550            //赛道类型判断
  14551            //到这里时，中心线提取成功，左右黑线至少有一个提取成功。
  14552            PathJudgeDone = 1; //赛道类型判断标志位，默认成功
  14553            if(!PathJudge())
  14554            {
  14555              PathJudgeDone = 0;  //赛道类型判断标志位，判断失败。
  14556              PathType = 0;       //赛道类型置为未知。
  14557              //uart_sendN(UART0, (uint8 *)"\nPathJudge Failed!", 18);
  14558              //return 0;         //赛道类型判断失败了还能继续，不用返回0.
  14559            }
  14560            else
  14561            {
  14562            }
  14563            */
  14564            
  14565            //发送中心线数组，不用发送float型的数据，同样的处理可以由上位机完成。
  14566            //SendCenterLineLoc(CenterLineLoc);
  14567            
  14568            //SendImage(ImgNew);  
  14569            
  14570            //因为采用多行控制，所以把小S弯对偏差的特殊处理去掉了。
  14571            /*
  14572            //对小S弯的特殊处理。
  14573            if(PathType == PathTypeSmallSL || PathType == PathTypeSmallSR)
  14574            {
  14575              //若为小S弯，则特殊处理。
  14576              PathTypeSmallDeal();
  14577            }
  14578            else
  14579            {
  14580              //若不为小S弯，则正常求取偏差
  14581              DeviationGet();        
  14582            }
  14583            */
  14584                 
  14585             //多行偏差算法。
  14586            //BiasFuse();
  14587            DeviationFuse();
   \   0000000E   0x.... 0x....      BL       DeviationFuse
  14588            MtrGet();//计算DeviFuse,DeviFuse_dot的隶属度
   \   00000012   0x.... 0x....      BL       MtrGet
  14589            
  14590            EmergencyStopCount = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable78_59
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
  14591            
  14592            //下一幅图像的黑线起始扫描列更新，
  14593            ////////////必须保证第CameraHight - 1行有效。
  14594            BlackLeftLastEdgeStartCol = BlackLeftEdgeStartCol;
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable78_23
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable78_22
   \   00000028   0x7008             STRB     R0,[R1, #+0]
  14595            BlackRightLastEdgeStartCol = BlackRightEdgeStartCol;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable78_25
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable78_24
   \   00000034   0x7008             STRB     R0,[R1, #+0]
  14596          
  14597          //  //障碍特殊控制期间，不需要更新扫描起点。
  14598          //  if(BrickSpeDealFlag == 1)
  14599          //  {
  14600          //    startline = BlackCenEdgeStartCol;
  14601          //  }
  14602          //  //不是障碍特殊控制，则正常取扫描起点。
  14603          //  else
  14604          //  {
  14605              //若第CameraHight-1行的中心线数组有效，则取它。
  14606              if(CenterLineLoc[CameraHight-1] != MaxValInt16)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable78_33
   \   0000003A   0xF9B0 0x0076      LDRSH    R0,[R0, #+118]
   \   0000003E   0xF647 0x71FF      MOVW     R1,#+32767
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD004             BEQ.N    ??ImgProSucceedDeal_0
  14607              {
  14608                startline = CenterLineLoc[CameraHight-1];
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable78_33
   \   0000004A   0xF8B0 0x0076      LDRH     R0,[R0, #+118]
   \   0000004E   0xE002             B.N      ??ImgProSucceedDeal_1
  14609              }
  14610              //若无效，则取第CameraHight-7(大于5行才能根据斜率来算)行对应的矫正行的BiasCal的计算值（根据斜率估算）
  14611              else
  14612              {
  14613                //startline = CameraRealWidth / 2 - BiasCal(BlackUdisLeftLocation[CameraHight-7].y);
  14614                //这种情况一般是十字，这时不用根据BiasCal来计算，直接用上一幅图的就好。否则会算得很乱。 
  14615                startline = BlackCenEdgeStartCol;
   \                     ??ImgProSucceedDeal_0: (+1)
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable78_60
   \   00000054   0x7800             LDRB     R0,[R0, #+0]
  14616              }
  14617          //  }
  14618            
  14619            //扫描起点的定位点
  14620            BlackCenEdgeStartCol = BoundaryLimitRe(startline,
  14621                                                   BlackCenEdgeStartColLimitL,
  14622                                                   BlackCenEdgeStartColLimitR
  14623                                                   );
   \                     ??ImgProSucceedDeal_1: (+1)
   \   00000056   0x22DC             MOVS     R2,#+220
   \   00000058   0x211E             MOVS     R1,#+30
   \   0000005A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005C   0x.... 0x....      BL       BoundaryLimitRe
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable78_60
   \   00000064   0x7008             STRB     R0,[R1, #+0]
  14624            //若上一幅图是单线，则左右两边放宽，2个单线宽度。
  14625            if(SingleBlackLastAllFlag == 1)
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable78_42
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0x2801             CMP      R0,#+1
   \   0000006E   0xD126             BNE.N    ??ImgProSucceedDeal_2
  14626            {
  14627              //BlackLeftEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] + SingleBlackWidthMax[CameraHight-1],
  14628              //左扫描起点等于定位点向右2个单线宽度。
  14629              BlackLeftEdgeStartCol = BoundaryLimitRe(MinRe(CameraRealWidth - 1, BlackCenEdgeStartCol + 2 * SingleBlackWidthMax[CameraHight-1]),
  14630                                                      0,
  14631                                                      CameraRealWidth-1
  14632                                                      );
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable78_60
   \   00000074   0x7800             LDRB     R0,[R0, #+0]
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable78_21
   \   0000007A   0xF891 0x103B      LDRB     R1,[R1, #+59]
   \   0000007E   0x0049             LSLS     R1,R1,#+1
   \   00000080   0x1809             ADDS     R1,R1,R0
   \   00000082   0x20F9             MOVS     R0,#+249
   \   00000084   0x.... 0x....      BL       MinRe
   \   00000088   0x22F9             MOVS     R2,#+249
   \   0000008A   0x2100             MOVS     R1,#+0
   \   0000008C   0x.... 0x....      BL       BoundaryLimitRe
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable78_23
   \   00000094   0x7008             STRB     R0,[R1, #+0]
  14633              //BlackRightEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] - SingleBlackWidthMax[CameraHight-1],
  14634              //右扫描起点等于定位点向左2个单线宽度。
  14635              BlackRightEdgeStartCol = BoundaryLimitRe(MaxRe(0, BlackCenEdgeStartCol - 2 * SingleBlackWidthMax[CameraHight-1]),
  14636                                                       0,
  14637                                                       CameraRealWidth-1
  14638                                                      );        
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable78_60
   \   0000009A   0x7800             LDRB     R0,[R0, #+0]
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable78_21
   \   000000A0   0xF891 0x103B      LDRB     R1,[R1, #+59]
   \   000000A4   0xEBB0 0x0141      SUBS     R1,R0,R1, LSL #+1
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x.... 0x....      BL       MaxRe
   \   000000AE   0x22F9             MOVS     R2,#+249
   \   000000B0   0x2100             MOVS     R1,#+0
   \   000000B2   0x.... 0x....      BL       BoundaryLimitRe
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable78_25
   \   000000BA   0x7008             STRB     R0,[R1, #+0]
   \   000000BC   0xE0AD             B.N      ??ImgProSucceedDeal_3
  14639            }
  14640            //上一幅图不是单线，双线正常处理。
  14641            else
  14642            {
  14643              //不是障碍特殊处理阶段。左右各取1个单线宽度。
  14644              if(BrickSpeDealFlag == 0)
   \                     ??ImgProSucceedDeal_2: (+1)
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable76_4
   \   000000C2   0x7800             LDRB     R0,[R0, #+0]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD124             BNE.N    ??ImgProSucceedDeal_4
  14645              {
  14646                //BlackLeftEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] + SingleBlackWidthMax[CameraHight-1],
  14647                //左扫描起点等于定位点向右1个单线宽度。
  14648                BlackLeftEdgeStartCol = BoundaryLimitRe(MinRe(CameraRealWidth - 1, BlackCenEdgeStartCol + SingleBlackWidthMax[CameraHight-1]),
  14649                                                        0,
  14650                                                        CameraRealWidth-1
  14651                                                        );
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable78_60
   \   000000CC   0x7800             LDRB     R0,[R0, #+0]
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable78_21
   \   000000D2   0xF891 0x103B      LDRB     R1,[R1, #+59]
   \   000000D6   0x1809             ADDS     R1,R1,R0
   \   000000D8   0x20F9             MOVS     R0,#+249
   \   000000DA   0x.... 0x....      BL       MinRe
   \   000000DE   0x22F9             MOVS     R2,#+249
   \   000000E0   0x2100             MOVS     R1,#+0
   \   000000E2   0x.... 0x....      BL       BoundaryLimitRe
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable78_23
   \   000000EA   0x7008             STRB     R0,[R1, #+0]
  14652                //BlackRightEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] - SingleBlackWidthMax[CameraHight-1],
  14653                //右扫描起点等于定位点向左1个单线宽度。
  14654                BlackRightEdgeStartCol = BoundaryLimitRe(MaxRe(0, BlackCenEdgeStartCol - SingleBlackWidthMax[CameraHight-1]),
  14655                                                         0,
  14656                                                         CameraRealWidth-1
  14657                                                        );    
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable78_60
   \   000000F0   0x7800             LDRB     R0,[R0, #+0]
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable78_21
   \   000000F6   0xF891 0x103B      LDRB     R1,[R1, #+59]
   \   000000FA   0x1A41             SUBS     R1,R0,R1
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0x.... 0x....      BL       MaxRe
   \   00000102   0x22F9             MOVS     R2,#+249
   \   00000104   0x2100             MOVS     R1,#+0
   \   00000106   0x.... 0x....      BL       BoundaryLimitRe
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable78_25
   \   0000010E   0x7008             STRB     R0,[R1, #+0]
   \   00000110   0xE083             B.N      ??ImgProSucceedDeal_3
  14658              }
  14659              //障碍特殊处理阶段
  14660              else
  14661              {
  14662                //左障碍，右线扫描起点向左一个单线宽度，左线扫描起点就取中心线处。
  14663                if(BrickSpeDealDir == 0)
   \                     ??ImgProSucceedDeal_4: (+1)
   \   00000112   0x.... 0x....      LDR.W    R0,??DataTable78_61
   \   00000116   0x7800             LDRB     R0,[R0, #+0]
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD13F             BNE.N    ??ImgProSucceedDeal_5
  14664                {
  14665                  //BlackLeftEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] + SingleBlackWidthMax[CameraHight-1],
  14666                  //左扫描起点取定位点。
  14667                  BlackLeftEdgeStartCol = BoundaryLimitRe(MinRe(CameraRealWidth - 1, BlackCenEdgeStartCol + 1),
  14668                                                          0,
  14669                                                          CameraRealWidth-1
  14670                                                          );
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable78_60
   \   00000120   0x7800             LDRB     R0,[R0, #+0]
   \   00000122   0x1C41             ADDS     R1,R0,#+1
   \   00000124   0x20F9             MOVS     R0,#+249
   \   00000126   0x.... 0x....      BL       MinRe
   \   0000012A   0x22F9             MOVS     R2,#+249
   \   0000012C   0x2100             MOVS     R1,#+0
   \   0000012E   0x.... 0x....      BL       BoundaryLimitRe
   \   00000132   0x.... 0x....      LDR.W    R1,??DataTable78_23
   \   00000136   0x7008             STRB     R0,[R1, #+0]
  14671                  //BlackRightEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] - SingleBlackWidthMax[CameraHight-1],
  14672                  //右扫描起点等于定位点向左3个单线宽度。
  14673                  BlackRightEdgeStartCol = BoundaryLimitRe(MaxRe(0, BlackCenEdgeStartCol - 3 * SingleBlackWidthMax[CameraHight-1]),
  14674                                                           0,
  14675                                                           CameraRealWidth-1
  14676                                                          );
   \   00000138   0x.... 0x....      LDR.W    R0,??DataTable78_60
   \   0000013C   0x7800             LDRB     R0,[R0, #+0]
   \   0000013E   0x.... 0x....      LDR.W    R1,??DataTable78_21
   \   00000142   0xF891 0x103B      LDRB     R1,[R1, #+59]
   \   00000146   0x2203             MOVS     R2,#+3
   \   00000148   0xFB02 0x0111      MLS      R1,R2,R1,R0
   \   0000014C   0x2000             MOVS     R0,#+0
   \   0000014E   0x.... 0x....      BL       MaxRe
   \   00000152   0x22F9             MOVS     R2,#+249
   \   00000154   0x2100             MOVS     R1,#+0
   \   00000156   0x.... 0x....      BL       BoundaryLimitRe
   \   0000015A   0x.... 0x....      LDR.W    R1,??DataTable78_25
   \   0000015E   0x7008             STRB     R0,[R1, #+0]
  14677                  //右扫描起点必须至少在右线左边3个单线宽度。
  14678                  if(BlackRightLoc[CameraHight - 1][0] != MaxValUint8)
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable75_1
   \   00000164   0xF890 0x00B1      LDRB     R0,[R0, #+177]
   \   00000168   0x28FF             CMP      R0,#+255
   \   0000016A   0xD056             BEQ.N    ??ImgProSucceedDeal_3
  14679                  {
  14680                    BlackRightEdgeStartCol = BoundaryLimitRe(MinRe(BlackRightEdgeStartCol, BlackRightLoc[CameraHight - 1][0] - 3 * SingleBlackWidthMax[CameraHight-1]),
  14681                                                            0,
  14682                                                            CameraRealWidth-1
  14683                                                            );
   \   0000016C   0x.... 0x....      LDR.W    R0,??DataTable75_1
   \   00000170   0xF890 0x00B1      LDRB     R0,[R0, #+177]
   \   00000174   0x.... 0x....      LDR.W    R1,??DataTable78_21
   \   00000178   0xF891 0x103B      LDRB     R1,[R1, #+59]
   \   0000017C   0x2203             MOVS     R2,#+3
   \   0000017E   0xFB02 0x0111      MLS      R1,R2,R1,R0
   \   00000182   0x.... 0x....      LDR.W    R0,??DataTable78_25
   \   00000186   0x7800             LDRB     R0,[R0, #+0]
   \   00000188   0x.... 0x....      BL       MinRe
   \   0000018C   0x22F9             MOVS     R2,#+249
   \   0000018E   0x2100             MOVS     R1,#+0
   \   00000190   0x.... 0x....      BL       BoundaryLimitRe
   \   00000194   0x.... 0x....      LDR.W    R1,??DataTable78_25
   \   00000198   0x7008             STRB     R0,[R1, #+0]
   \   0000019A   0xE03E             B.N      ??ImgProSucceedDeal_3
  14684                  }
  14685                  else
  14686                  {
  14687                  }        
  14688                }
  14689                //右障碍，左线扫描起点向右一个单线宽度，右线扫描起点就取中心线处。
  14690                else
  14691                {
  14692                  //BlackLeftEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] + SingleBlackWidthMax[CameraHight-1],
  14693                  //左扫描起点等于定位点向右3个单线宽度
  14694                  BlackLeftEdgeStartCol = BoundaryLimitRe(MinRe(CameraRealWidth - 1, BlackCenEdgeStartCol + 3 * SingleBlackWidthMax[CameraHight-1]),
  14695                                                          0,
  14696                                                          CameraRealWidth-1
  14697                                                          );
   \                     ??ImgProSucceedDeal_5: (+1)
   \   0000019C   0x.... 0x....      LDR.W    R0,??DataTable78_60
   \   000001A0   0x7800             LDRB     R0,[R0, #+0]
   \   000001A2   0x.... 0x....      LDR.W    R1,??DataTable78_21
   \   000001A6   0xF891 0x103B      LDRB     R1,[R1, #+59]
   \   000001AA   0x2203             MOVS     R2,#+3
   \   000001AC   0x4351             MULS     R1,R2,R1
   \   000001AE   0x1809             ADDS     R1,R1,R0
   \   000001B0   0x20F9             MOVS     R0,#+249
   \   000001B2   0x.... 0x....      BL       MinRe
   \   000001B6   0x22F9             MOVS     R2,#+249
   \   000001B8   0x2100             MOVS     R1,#+0
   \   000001BA   0x.... 0x....      BL       BoundaryLimitRe
   \   000001BE   0x.... 0x....      LDR.W    R1,??DataTable78_23
   \   000001C2   0x7008             STRB     R0,[R1, #+0]
  14698                  //BlackRightEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] - SingleBlackWidthMax[CameraHight-1],
  14699                  //右扫描起点取定位点。
  14700                  BlackRightEdgeStartCol = BoundaryLimitRe(MaxRe(0, BlackCenEdgeStartCol - 1),
  14701                                                           0,
  14702                                                           CameraRealWidth-1
  14703                                                          );
   \   000001C4   0x.... 0x....      LDR.W    R0,??DataTable78_60
   \   000001C8   0x7800             LDRB     R0,[R0, #+0]
   \   000001CA   0x1E41             SUBS     R1,R0,#+1
   \   000001CC   0x2000             MOVS     R0,#+0
   \   000001CE   0x.... 0x....      BL       MaxRe
   \   000001D2   0x22F9             MOVS     R2,#+249
   \   000001D4   0x2100             MOVS     R1,#+0
   \   000001D6   0x.... 0x....      BL       BoundaryLimitRe
   \   000001DA   0x.... 0x....      LDR.W    R1,??DataTable78_25
   \   000001DE   0x7008             STRB     R0,[R1, #+0]
  14704                  
  14705                  //左扫描起点必须至少在左线右边3个单线宽度。
  14706                  if(BlackLeftLoc[CameraHight - 1][0] != MaxValUint8)
   \   000001E0   0x.... 0x....      LDR.W    R0,??DataTable78_62
   \   000001E4   0xF890 0x00B1      LDRB     R0,[R0, #+177]
   \   000001E8   0x28FF             CMP      R0,#+255
   \   000001EA   0xD016             BEQ.N    ??ImgProSucceedDeal_3
  14707                  {
  14708                    BlackLeftEdgeStartCol = BoundaryLimitRe(MaxRe(BlackLeftEdgeStartCol, BlackLeftLoc[CameraHight - 1][0] + 3 * SingleBlackWidthMax[CameraHight-1]),
  14709                                                            0,
  14710                                                            CameraRealWidth-1
  14711                                                            );
   \   000001EC   0x.... 0x....      LDR.W    R0,??DataTable78_62
   \   000001F0   0xF890 0x00B1      LDRB     R0,[R0, #+177]
   \   000001F4   0x.... 0x....      LDR.W    R1,??DataTable78_21
   \   000001F8   0xF891 0x103B      LDRB     R1,[R1, #+59]
   \   000001FC   0x2203             MOVS     R2,#+3
   \   000001FE   0x4351             MULS     R1,R2,R1
   \   00000200   0x1809             ADDS     R1,R1,R0
   \   00000202   0x.... 0x....      LDR.W    R0,??DataTable78_23
   \   00000206   0x7800             LDRB     R0,[R0, #+0]
   \   00000208   0x.... 0x....      BL       MaxRe
   \   0000020C   0x22F9             MOVS     R2,#+249
   \   0000020E   0x2100             MOVS     R1,#+0
   \   00000210   0x.... 0x....      BL       BoundaryLimitRe
   \   00000214   0x.... 0x....      LDR.W    R1,??DataTable78_23
   \   00000218   0x7008             STRB     R0,[R1, #+0]
  14712                  }
  14713                  else
  14714                  {
  14715                  }
  14716                }
  14717              }
  14718            }
  14719            
  14720          
  14721            
  14722            //右线扫描起点必须在左线扫描起点左边
  14723            BlackRightEdgeStartCol = MinRe(BlackRightEdgeStartCol, BlackLeftEdgeStartCol);
   \                     ??ImgProSucceedDeal_3: (+1)
   \   0000021A   0x.... 0x....      LDR.W    R0,??DataTable78_23
   \   0000021E   0x7801             LDRB     R1,[R0, #+0]
   \   00000220   0x.... 0x....      LDR.W    R0,??DataTable78_25
   \   00000224   0x7800             LDRB     R0,[R0, #+0]
   \   00000226   0x.... 0x....      BL       MinRe
   \   0000022A   0x.... 0x....      LDR.W    R1,??DataTable78_25
   \   0000022E   0x7008             STRB     R0,[R1, #+0]
  14724          
  14725            return 1;
   \   00000230   0x2001             MOVS     R0,#+1
   \   00000232   0xBD02             POP      {R1,PC}          ;; return
  14726          }
  14727          
  14728          
  14729          //图像失败后的处理。

   \                                 In section .text, align 2, keep-with-next
  14730          uint8 ImgProFailDeal(void)
  14731          {
   \                     ImgProFailDeal: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  14732            uint8 startline;
  14733            int tempB, tempW, tempWB;
  14734            
  14735            
  14736            //图像失败，偏差仍更新
  14737            /*
  14738            DeviPrePrePre=DeviPrePre;
  14739            DeviPrePre=DeviPre;
  14740            DeviPre=DeviFuse;
  14741            DeviFuse=DeviPre+((DeviPre-DeviPrePre)*7+(DeviPrePre-DeviPrePrePre)*3)/10;
  14742            MtrGet();//计算DeviFuse,DeviFuse_dot的隶属度
  14743            */
  14744            
  14745            //紧急停车很危险，容易造成程序死循环，所以要慎用。用开关控制用不用。
  14746            if(EmergencyStopSwitch == 1)
  14747            {
  14748              //图像处理失败计数，用作紧急停车。
  14749              EmergencyStopCount++;
  14750              if(EmergencyStopCount > EmergencyStopCountNum)
  14751              {
  14752                //计数器清零。
  14753                EmergencyStopCount = 0;
  14754                //紧急停车标志位。
  14755                EmergencyStopFlag = 1;
  14756                
  14757                //紧急停车处理，电机输出0，并死循环，等待掉电。
  14758                FTM0_C4V = 0;
  14759                FTM0_C5V = 0;
  14760                FTM0_C6V = 0;
  14761                FTM0_C7V = 0;
  14762                //死循环
  14763                while(1) ;
  14764              }
  14765              else
  14766              {
  14767                
  14768              }
  14769            }
  14770            else
  14771            {
  14772              
  14773            }
  14774            
  14775            //赛道半宽判断出的单线错误标志置位时，扫描起点复位。直角弯不允许更新。
  14776            if(RoadHalfWidthWrongFlag == 1 && AngleSpeDealFlag == 0)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable78_35
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD16C             BNE.N    ??ImgProFailDeal_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable76_2
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD167             BNE.N    ??ImgProFailDeal_0
  14777            {
  14778              //左线悬空
  14779              if(RoadHalfWidthWrongDir == 0)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable78_63
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD116             BNE.N    ??ImgProFailDeal_1
  14780              {
  14781                //左线最有可能是单线。
  14782                if(BlackLeftLoc[BlackLeftStep1ScanRow][0] != MaxValUint8)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable78_62
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable78_64
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0x2203             MOVS     R2,#+3
   \   0000002C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x28FF             CMP      R0,#+255
   \   00000034   0xD009             BEQ.N    ??ImgProFailDeal_2
  14783                {
  14784                  startline = BlackLeftLoc[BlackLeftStep1ScanRow][0];
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable78_62
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable78_64
   \   0000003E   0x7809             LDRB     R1,[R1, #+0]
   \   00000040   0x2203             MOVS     R2,#+3
   \   00000042   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0xE01C             B.N      ??ImgProFailDeal_3
  14785                }
  14786                else
  14787                {
  14788                  startline = CameraRealWidth / 2;
   \                     ??ImgProFailDeal_2: (+1)
   \   0000004A   0x207D             MOVS     R0,#+125
   \   0000004C   0xE01A             B.N      ??ImgProFailDeal_3
  14789                }
  14790              }
  14791              //右线悬空
  14792              else if(RoadHalfWidthWrongDir == 1)
   \                     ??ImgProFailDeal_1: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable78_63
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x2801             CMP      R0,#+1
   \   00000056   0xD114             BNE.N    ??ImgProFailDeal_4
  14793              {
  14794                //右线最有可能是单线。
  14795                if(BlackRightLoc[BlackRightStep1ScanRow][0] != MaxValUint8)
   \   00000058   0x....             LDR.N    R0,??DataTable75_1
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable78_65
   \   0000005E   0x7809             LDRB     R1,[R1, #+0]
   \   00000060   0x2203             MOVS     R2,#+3
   \   00000062   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000066   0x7800             LDRB     R0,[R0, #+0]
   \   00000068   0x28FF             CMP      R0,#+255
   \   0000006A   0xD008             BEQ.N    ??ImgProFailDeal_5
  14796                {
  14797                  startline = BlackRightLoc[BlackRightStep1ScanRow][0];
   \   0000006C   0x....             LDR.N    R0,??DataTable75_1
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable78_65
   \   00000072   0x7809             LDRB     R1,[R1, #+0]
   \   00000074   0x2203             MOVS     R2,#+3
   \   00000076   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0xE002             B.N      ??ImgProFailDeal_3
  14798                }
  14799                else
  14800                {
  14801                  startline = CameraRealWidth / 2;
   \                     ??ImgProFailDeal_5: (+1)
   \   0000007E   0x207D             MOVS     R0,#+125
   \   00000080   0xE000             B.N      ??ImgProFailDeal_3
  14802                }            
  14803              }
  14804              else 
  14805              {    
  14806                //理论上不可能走到这里。
  14807                startline = CameraRealWidth / 2;
   \                     ??ImgProFailDeal_4: (+1)
   \   00000082   0x207D             MOVS     R0,#+125
  14808              }
  14809              
  14810              //扫描起点的定位点
  14811              BlackCenEdgeStartCol = BoundaryLimitRe(startline,
  14812                                                     BlackCenEdgeStartColLimitL,
  14813                                                     BlackCenEdgeStartColLimitR
  14814                                                     );
   \                     ??ImgProFailDeal_3: (+1)
   \   00000084   0x22DC             MOVS     R2,#+220
   \   00000086   0x211E             MOVS     R1,#+30
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0x.... 0x....      BL       BoundaryLimitRe
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable78_60
   \   00000092   0x7008             STRB     R0,[R1, #+0]
  14815              
  14816              
  14817              //BlackLeftEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] + SingleBlackWidthMax[CameraHight-1],
  14818              //左扫描起点等于定位点向左1个单线宽度。
  14819              BlackLeftEdgeStartCol = BoundaryLimitRe(BlackCenEdgeStartCol + SingleBlackWidthMax[CameraHight-1],
  14820                                                      0,
  14821                                                      CameraRealWidth-1
  14822                                                      );
   \   00000094   0x22F9             MOVS     R2,#+249
   \   00000096   0x2100             MOVS     R1,#+0
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable78_60
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x.... 0x....      LDR.W    R3,??DataTable78_21
   \   000000A2   0xF893 0x303B      LDRB     R3,[R3, #+59]
   \   000000A6   0x1818             ADDS     R0,R3,R0
   \   000000A8   0x.... 0x....      BL       BoundaryLimitRe
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable78_23
   \   000000B0   0x7008             STRB     R0,[R1, #+0]
  14823              //BlackRightEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] - SingleBlackWidthMax[CameraHight-1],
  14824              //右扫描起点等于定位点向右1个单线宽度。
  14825              BlackRightEdgeStartCol = BoundaryLimitRe(BlackCenEdgeStartCol - SingleBlackWidthMax[CameraHight-1],
  14826                                                       0,
  14827                                                       CameraRealWidth-1
  14828                                                      );
   \   000000B2   0x22F9             MOVS     R2,#+249
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable78_60
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0x.... 0x....      LDR.W    R3,??DataTable78_21
   \   000000C0   0xF893 0x303B      LDRB     R3,[R3, #+59]
   \   000000C4   0x1AC0             SUBS     R0,R0,R3
   \   000000C6   0x.... 0x....      BL       BoundaryLimitRe
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable78_25
   \   000000CE   0x7008             STRB     R0,[R1, #+0]
  14829              
  14830              //右线扫描起点必须在左线扫描起点左边
  14831              BlackRightEdgeStartCol = MinRe(BlackRightEdgeStartCol, BlackLeftEdgeStartCol);
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable78_23
   \   000000D4   0x7801             LDRB     R1,[R0, #+0]
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable78_25
   \   000000DA   0x7800             LDRB     R0,[R0, #+0]
   \   000000DC   0x.... 0x....      BL       MinRe
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable78_25
   \   000000E4   0x7008             STRB     R0,[R1, #+0]
  14832            }
  14833            else
  14834            {    
  14835            }
  14836            
  14837            //只要不是直角弯导致的图像失败，则猜测可能是图像线头阈值太严格。线头阈值放宽一点点。 
  14838            if(AngleSpeDealFlag == 0)
   \                     ??ImgProFailDeal_0: (+1)
   \   000000E6   0x....             LDR.N    R0,??DataTable76_2
   \   000000E8   0x7800             LDRB     R0,[R0, #+0]
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xF040 0x808F      BNE.W    ??ImgProFailDeal_6
  14839            {
  14840              //左线线头阈值放宽一点点。
  14841              //差值的处理，留有裕度，且有上下界。放宽一半裕度。
  14842              tempWB = LimitLeftHeadWB - LimitLeftWBMargin / 2; 
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable78_9
   \   000000F4   0x7800             LDRB     R0,[R0, #+0]
   \   000000F6   0x380A             SUBS     R0,R0,#+10
  14843              if(tempWB < LimitLeftWBMin) tempWB = LimitLeftWBMin;
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable78_3
   \   000000FC   0x7809             LDRB     R1,[R1, #+0]
   \   000000FE   0x4288             CMP      R0,R1
   \   00000100   0xDA03             BGE.N    ??ImgProFailDeal_7
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable78_3
   \   00000106   0x7800             LDRB     R0,[R0, #+0]
   \   00000108   0xE007             B.N      ??ImgProFailDeal_8
  14844              else if(tempWB > LimitLeftWBMax) tempWB = LimitLeftWBMax;
   \                     ??ImgProFailDeal_7: (+1)
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable78_66
   \   0000010E   0x7809             LDRB     R1,[R1, #+0]
   \   00000110   0x4281             CMP      R1,R0
   \   00000112   0xDA02             BGE.N    ??ImgProFailDeal_8
   \   00000114   0x.... 0x....      LDR.W    R0,??DataTable78_66
   \   00000118   0x7800             LDRB     R0,[R0, #+0]
  14845              else ;
  14846              LimitLeftHeadWB = tempWB;
   \                     ??ImgProFailDeal_8: (+1)
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable78_9
   \   0000011E   0x7008             STRB     R0,[R1, #+0]
  14847              
  14848              //白点的处理，留有裕度，且有上下界。放宽一半裕度。
  14849              tempW = LimitLeftHeadW - LimitLeftWMargin / 2;
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable78_10
   \   00000124   0x7800             LDRB     R0,[R0, #+0]
   \   00000126   0x3814             SUBS     R0,R0,#+20
  14850              if(tempW < LimitLeftWMin) tempW = LimitLeftWMin;
   \   00000128   0x.... 0x....      LDR.W    R1,??DataTable78_5
   \   0000012C   0x7809             LDRB     R1,[R1, #+0]
   \   0000012E   0x4288             CMP      R0,R1
   \   00000130   0xDA03             BGE.N    ??ImgProFailDeal_9
   \   00000132   0x.... 0x....      LDR.W    R0,??DataTable78_5
   \   00000136   0x7800             LDRB     R0,[R0, #+0]
   \   00000138   0xE007             B.N      ??ImgProFailDeal_10
  14851              else if(tempW > LimitLeftWMax) tempW = LimitLeftWMax;
   \                     ??ImgProFailDeal_9: (+1)
   \   0000013A   0x.... 0x....      LDR.W    R1,??DataTable78_67
   \   0000013E   0x7809             LDRB     R1,[R1, #+0]
   \   00000140   0x4281             CMP      R1,R0
   \   00000142   0xDA02             BGE.N    ??ImgProFailDeal_10
   \   00000144   0x.... 0x....      LDR.W    R0,??DataTable78_67
   \   00000148   0x7800             LDRB     R0,[R0, #+0]
  14852              else ;
  14853              LimitLeftHeadW = tempW;
   \                     ??ImgProFailDeal_10: (+1)
   \   0000014A   0x.... 0x....      LDR.W    R1,??DataTable78_10
   \   0000014E   0x7008             STRB     R0,[R1, #+0]
  14854              
  14855              //黑点的处理，留有裕度，且有上下界。放宽一半裕度。
  14856              tempB = LimitLeftHeadB + LimitLeftBMargin / 2;
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable78_11
   \   00000154   0x7800             LDRB     R0,[R0, #+0]
   \   00000156   0x3011             ADDS     R0,R0,#+17
  14857              if(tempB < LimitLeftBMin) tempB = LimitLeftBMin;
   \   00000158   0x.... 0x....      LDR.W    R1,??DataTable78_68
   \   0000015C   0x7809             LDRB     R1,[R1, #+0]
   \   0000015E   0x4288             CMP      R0,R1
   \   00000160   0xDA03             BGE.N    ??ImgProFailDeal_11
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable78_68
   \   00000166   0x7800             LDRB     R0,[R0, #+0]
   \   00000168   0xE005             B.N      ??ImgProFailDeal_12
  14858              else if(tempB > LimitLeftBMax) tempB = LimitLeftBMax;
   \                     ??ImgProFailDeal_11: (+1)
   \   0000016A   0x....             LDR.N    R1,??DataTable78_7
   \   0000016C   0x7809             LDRB     R1,[R1, #+0]
   \   0000016E   0x4281             CMP      R1,R0
   \   00000170   0xDA01             BGE.N    ??ImgProFailDeal_12
   \   00000172   0x....             LDR.N    R0,??DataTable78_7
   \   00000174   0x7800             LDRB     R0,[R0, #+0]
  14859              else ;
  14860              //黑色阈值不能超过白色
  14861              if(tempB >= LimitLeftHeadW)
   \                     ??ImgProFailDeal_12: (+1)
   \   00000176   0x....             LDR.N    R1,??DataTable78_10
   \   00000178   0x7809             LDRB     R1,[R1, #+0]
   \   0000017A   0x4288             CMP      R0,R1
   \   0000017C   0xDB02             BLT.N    ??ImgProFailDeal_13
  14862              {
  14863                tempB = LimitLeftHeadW - 1;
   \   0000017E   0x....             LDR.N    R0,??DataTable78_10
   \   00000180   0x7800             LDRB     R0,[R0, #+0]
   \   00000182   0x1E40             SUBS     R0,R0,#+1
  14864              }
  14865              else
  14866              {
  14867              }             
  14868              LimitLeftHeadB = tempB;  
   \                     ??ImgProFailDeal_13: (+1)
   \   00000184   0x....             LDR.N    R1,??DataTable78_11
   \   00000186   0x7008             STRB     R0,[R1, #+0]
  14869              
  14870              
  14871              //右线线头阈值放宽一点点。
  14872              //差值的处理，留有裕度，且有上下界。放宽一半裕度。
  14873              tempWB = LimitRightHeadWB - LimitRightWBMargin / 2; 
   \   00000188   0x....             LDR.N    R0,??DataTable78_18
   \   0000018A   0x7800             LDRB     R0,[R0, #+0]
   \   0000018C   0x380A             SUBS     R0,R0,#+10
  14874              if(tempWB < LimitRightWBMin) tempWB = LimitRightWBMin;
   \   0000018E   0x....             LDR.N    R1,??DataTable78_12
   \   00000190   0x7809             LDRB     R1,[R1, #+0]
   \   00000192   0x4288             CMP      R0,R1
   \   00000194   0xDA02             BGE.N    ??ImgProFailDeal_14
   \   00000196   0x....             LDR.N    R0,??DataTable78_12
   \   00000198   0x7800             LDRB     R0,[R0, #+0]
   \   0000019A   0xE007             B.N      ??ImgProFailDeal_15
  14875              else if(tempWB > LimitRightWBMax) tempWB = LimitRightWBMax;
   \                     ??ImgProFailDeal_14: (+1)
   \   0000019C   0x.... 0x....      LDR.W    R1,??DataTable78_69
   \   000001A0   0x7809             LDRB     R1,[R1, #+0]
   \   000001A2   0x4281             CMP      R1,R0
   \   000001A4   0xDA02             BGE.N    ??ImgProFailDeal_15
   \   000001A6   0x.... 0x....      LDR.W    R0,??DataTable78_69
   \   000001AA   0x7800             LDRB     R0,[R0, #+0]
  14876              else ;
  14877              LimitRightHeadWB = tempWB;
   \                     ??ImgProFailDeal_15: (+1)
   \   000001AC   0x....             LDR.N    R1,??DataTable78_18
   \   000001AE   0x7008             STRB     R0,[R1, #+0]
  14878              
  14879              //白点的处理，留有裕度，且有上下界。放宽一半裕度。
  14880              tempW = LimitRightHeadW - LimitRightWMargin / 2;
   \   000001B0   0x....             LDR.N    R0,??DataTable78_19
   \   000001B2   0x7800             LDRB     R0,[R0, #+0]
   \   000001B4   0x3814             SUBS     R0,R0,#+20
  14881              if(tempW < LimitRightWMin) tempW = LimitRightWMin;
   \   000001B6   0x....             LDR.N    R1,??DataTable78_14
   \   000001B8   0x7809             LDRB     R1,[R1, #+0]
   \   000001BA   0x4288             CMP      R0,R1
   \   000001BC   0xDA02             BGE.N    ??ImgProFailDeal_16
   \   000001BE   0x....             LDR.N    R0,??DataTable78_14
   \   000001C0   0x7800             LDRB     R0,[R0, #+0]
   \   000001C2   0xE007             B.N      ??ImgProFailDeal_17
  14882              else if(tempW > LimitRightWMax) tempW = LimitRightWMax;
   \                     ??ImgProFailDeal_16: (+1)
   \   000001C4   0x.... 0x....      LDR.W    R1,??DataTable78_70
   \   000001C8   0x7809             LDRB     R1,[R1, #+0]
   \   000001CA   0x4281             CMP      R1,R0
   \   000001CC   0xDA02             BGE.N    ??ImgProFailDeal_17
   \   000001CE   0x.... 0x....      LDR.W    R0,??DataTable78_70
   \   000001D2   0x7800             LDRB     R0,[R0, #+0]
  14883              else ;
  14884              LimitRightHeadW = tempW;
   \                     ??ImgProFailDeal_17: (+1)
   \   000001D4   0x....             LDR.N    R1,??DataTable78_19
   \   000001D6   0x7008             STRB     R0,[R1, #+0]
  14885              
  14886              //黑点的处理，留有裕度，且有上下界。放宽一半裕度。
  14887              tempB = LimitRightHeadB + LimitRightBMargin / 2;
   \   000001D8   0x....             LDR.N    R0,??DataTable78_20
   \   000001DA   0x7800             LDRB     R0,[R0, #+0]
   \   000001DC   0x3011             ADDS     R0,R0,#+17
  14888              if(tempB < LimitRightBMin) tempB = LimitRightBMin;
   \   000001DE   0x.... 0x....      LDR.W    R1,??DataTable78_71
   \   000001E2   0x7809             LDRB     R1,[R1, #+0]
   \   000001E4   0x4288             CMP      R0,R1
   \   000001E6   0xDA03             BGE.N    ??ImgProFailDeal_18
   \   000001E8   0x.... 0x....      LDR.W    R0,??DataTable78_71
   \   000001EC   0x7800             LDRB     R0,[R0, #+0]
   \   000001EE   0xE005             B.N      ??ImgProFailDeal_19
  14889              else if(tempB > LimitRightBMax) tempB = LimitRightBMax;
   \                     ??ImgProFailDeal_18: (+1)
   \   000001F0   0x....             LDR.N    R1,??DataTable78_16
   \   000001F2   0x7809             LDRB     R1,[R1, #+0]
   \   000001F4   0x4281             CMP      R1,R0
   \   000001F6   0xDA01             BGE.N    ??ImgProFailDeal_19
   \   000001F8   0x....             LDR.N    R0,??DataTable78_16
   \   000001FA   0x7800             LDRB     R0,[R0, #+0]
  14890              else ;
  14891              //黑色阈值不能超过白色
  14892              if(tempB >= LimitRightHeadW)
   \                     ??ImgProFailDeal_19: (+1)
   \   000001FC   0x....             LDR.N    R1,??DataTable78_19
   \   000001FE   0x7809             LDRB     R1,[R1, #+0]
   \   00000200   0x4288             CMP      R0,R1
   \   00000202   0xDB02             BLT.N    ??ImgProFailDeal_20
  14893              {
  14894                tempB = LimitRightHeadW - 1;
   \   00000204   0x....             LDR.N    R0,??DataTable78_19
   \   00000206   0x7800             LDRB     R0,[R0, #+0]
   \   00000208   0x1E40             SUBS     R0,R0,#+1
  14895              }
  14896              else
  14897              {
  14898              }             
  14899              LimitRightHeadB = tempB;  
   \                     ??ImgProFailDeal_20: (+1)
   \   0000020A   0x....             LDR.N    R1,??DataTable78_20
   \   0000020C   0x7008             STRB     R0,[R1, #+0]
  14900            }
  14901            else
  14902            {
  14903            }
  14904            
  14905            
  14906            
  14907            //下一幅图像的黑线起始扫描列更新，暂时保持不变。
  14908            BlackLeftLastEdgeStartCol = BlackLeftEdgeStartCol;
   \                     ??ImgProFailDeal_6: (+1)
   \   0000020E   0x....             LDR.N    R0,??DataTable78_23
   \   00000210   0x7800             LDRB     R0,[R0, #+0]
   \   00000212   0x....             LDR.N    R1,??DataTable78_22
   \   00000214   0x7008             STRB     R0,[R1, #+0]
  14909            BlackRightLastEdgeStartCol = BlackRightEdgeStartCol;
   \   00000216   0x....             LDR.N    R0,??DataTable78_25
   \   00000218   0x7800             LDRB     R0,[R0, #+0]
   \   0000021A   0x....             LDR.N    R1,??DataTable78_24
   \   0000021C   0x7008             STRB     R0,[R1, #+0]
  14910          //  BlackLeftEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] + SingleBlackWidthMax[CameraHight-1],
  14911          //                                          0,
  14912          //                                          CameraRealWidth-1
  14913          //                                          );
  14914          //  BlackRightEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] - SingleBlackWidthMax[CameraHight-1],
  14915          //                                           0,
  14916          //                                           CameraRealWidth-1
  14917          //                                          );
  14918            
  14919            return 1;
   \   0000021E   0x2001             MOVS     R0,#+1
   \   00000220   0xBD02             POP      {R1,PC}          ;; return
  14920          }
  14921          
  14922          
  14923          
  14924          //坡道禁止赛道类型判断期间的线头平齐

   \                                 In section .text, align 2, keep-with-next
  14925          uint8 GyroResultForbidSpeDeal(void)
  14926          {
  14927            uint8 row;
  14928            
  14929            //标志置位期间，将线头平齐。
  14930            if(GyroResultForbidFlag == 1 && BlackLeftDone == 1 && BlackRightDone == 1 && BlackLeftHeadLine != MaxValUint8 && BlackRightHeadLine != MaxValUint8)
   \                     GyroResultForbidSpeDeal: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable76_5
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD152             BNE.N    ??GyroResultForbidSpeDeal_0
   \   00000008   0x....             LDR.N    R0,??DataTable78_72
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD14E             BNE.N    ??GyroResultForbidSpeDeal_0
   \   00000010   0x....             LDR.N    R0,??DataTable78_73
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD14A             BNE.N    ??GyroResultForbidSpeDeal_0
   \   00000018   0x....             LDR.N    R0,??DataTable78_74
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x28FF             CMP      R0,#+255
   \   0000001E   0xD046             BEQ.N    ??GyroResultForbidSpeDeal_0
   \   00000020   0x....             LDR.N    R0,??DataTable75_2
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x28FF             CMP      R0,#+255
   \   00000026   0xD042             BEQ.N    ??GyroResultForbidSpeDeal_0
  14931            {
  14932              //右线头高，且两线头差别不大时。
  14933              if(BlackLeftHeadLine > BlackRightHeadLine && BlackLeftHeadLine <= BlackRightHeadLine + 5)
   \   00000028   0x....             LDR.N    R0,??DataTable75_2
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x....             LDR.N    R1,??DataTable78_74
   \   0000002E   0x7809             LDRB     R1,[R1, #+0]
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD21B             BCS.N    ??GyroResultForbidSpeDeal_1
   \   00000034   0x....             LDR.N    R0,??DataTable75_2
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x1D40             ADDS     R0,R0,#+5
   \   0000003A   0x....             LDR.N    R1,??DataTable78_74
   \   0000003C   0x7809             LDRB     R1,[R1, #+0]
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xDB14             BLT.N    ??GyroResultForbidSpeDeal_1
  14934              {
  14935                //对右线头削顶。
  14936                for(row = BlackRightHeadLine; ; row++)
   \   00000042   0x....             LDR.N    R0,??DataTable75_2
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0xE000             B.N      ??GyroResultForbidSpeDeal_2
   \                     ??GyroResultForbidSpeDeal_3: (+1)
   \   00000048   0x1C40             ADDS     R0,R0,#+1
  14937                {
  14938                  BlackRightLoc[row][0] = MaxValUint8;
   \                     ??GyroResultForbidSpeDeal_2: (+1)
   \   0000004A   0x21FF             MOVS     R1,#+255
   \   0000004C   0x....             LDR.N    R2,??DataTable75_1
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x2303             MOVS     R3,#+3
   \   00000052   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000056   0x7011             STRB     R1,[R2, #+0]
  14939                  
  14940                  if(row == BlackLeftHeadLine) break;
   \   00000058   0x....             LDR.N    R1,??DataTable78_74
   \   0000005A   0x7809             LDRB     R1,[R1, #+0]
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xD1F2             BNE.N    ??GyroResultForbidSpeDeal_3
  14941                }
  14942                //更新右线头
  14943                BlackRightHeadLine = BlackLeftHeadLine;
   \   00000062   0x....             LDR.N    R0,??DataTable78_74
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x....             LDR.N    R1,??DataTable75_2
   \   00000068   0x7008             STRB     R0,[R1, #+0]
   \   0000006A   0xE020             B.N      ??GyroResultForbidSpeDeal_0
  14944              }
  14945              //左线头高，且两线头差别不大时。
  14946              else if(BlackRightHeadLine > BlackLeftHeadLine && BlackRightHeadLine <= BlackLeftHeadLine + 5)
   \                     ??GyroResultForbidSpeDeal_1: (+1)
   \   0000006C   0x....             LDR.N    R0,??DataTable78_74
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0x....             LDR.N    R1,??DataTable75_2
   \   00000072   0x7809             LDRB     R1,[R1, #+0]
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xD21A             BCS.N    ??GyroResultForbidSpeDeal_0
   \   00000078   0x....             LDR.N    R0,??DataTable78_74
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0x1D40             ADDS     R0,R0,#+5
   \   0000007E   0x....             LDR.N    R1,??DataTable75_2
   \   00000080   0x7809             LDRB     R1,[R1, #+0]
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xDB13             BLT.N    ??GyroResultForbidSpeDeal_0
  14947              {
  14948                //对左线头削顶。
  14949                for(row = BlackLeftHeadLine; ; row++)
   \   00000086   0x....             LDR.N    R0,??DataTable78_74
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0xE000             B.N      ??GyroResultForbidSpeDeal_4
   \                     ??GyroResultForbidSpeDeal_5: (+1)
   \   0000008C   0x1C40             ADDS     R0,R0,#+1
  14950                {
  14951                  BlackLeftLoc[row][0] = MaxValUint8;
   \                     ??GyroResultForbidSpeDeal_4: (+1)
   \   0000008E   0x21FF             MOVS     R1,#+255
   \   00000090   0x....             LDR.N    R2,??DataTable78_62
   \   00000092   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000094   0x2303             MOVS     R3,#+3
   \   00000096   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000009A   0x7011             STRB     R1,[R2, #+0]
  14952                  
  14953                  if(row == BlackRightHeadLine) break;
   \   0000009C   0x....             LDR.N    R1,??DataTable75_2
   \   0000009E   0x7809             LDRB     R1,[R1, #+0]
   \   000000A0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A2   0x4288             CMP      R0,R1
   \   000000A4   0xD1F2             BNE.N    ??GyroResultForbidSpeDeal_5
  14954                }
  14955                //更新左线头
  14956                BlackLeftHeadLine = BlackRightHeadLine;
   \   000000A6   0x....             LDR.N    R0,??DataTable75_2
   \   000000A8   0x7800             LDRB     R0,[R0, #+0]
   \   000000AA   0x....             LDR.N    R1,??DataTable78_74
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
  14957              }
  14958              //否则不做线头平齐处理。
  14959              else
  14960              {
  14961              }
  14962            }
  14963            else
  14964            {
  14965            }
  14966            
  14967            
  14968            return 1;
   \                     ??GyroResultForbidSpeDeal_0: (+1)
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0x4770             BX       LR               ;; return
  14969          }
  14970          
  14971          
  14972          //======================================================================
  14973          //函数名：ImagePro
  14974          //功  能：图像处理函数。图像尺寸缩减，黑线提取，中心线提取。
  14975          //参  数：无
  14976          //返  回：1成功 0失败
  14977          //影  响：
  14978          //说  明：1. 黑线提取失败后，不会执行中心线提取函数。返回失败。
  14979          //        2. 黑线提取失败后，后面的运动控制的参数不用更改，延用上一次的参数。
  14980          //             
  14981          //======================================================================

   \                                 In section .text, align 2, keep-with-next
  14982          uint8 ImagePro(void)
  14983          {
   \                     ImagePro: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  14984              ErrorCountNow5++;
   \   00000002   0x....             LDR.N    R0,??DataTable78_75
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable78_75
   \   0000000A   0x8008             STRH     R0,[R1, #+0]
  14985            
  14986              //图像取需要的列，重新赋值是为了后面的编程方便。
  14987              ImgPut();
   \   0000000C   0x.... 0x....      BL       ImgPut
  14988          
  14989              //图像处理之前的参数初始化。
  14990              ImageProParaInit();
   \   00000010   0x.... 0x....      BL       ImageProParaInit
  14991             
  14992              //黑线提取函数
  14993              if(BlackGet() == 0)
   \   00000014   0x.... 0x....      BL       BlackGet
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD10B             BNE.N    ??ImagePro_0
  14994              {
  14995                  //uart_sendN(UART0, (uint8 *)"\nBlackGet Failed!", 17);  
  14996                  CenterLineResult = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x....             LDR.N    R1,??DataTable78_76
   \   00000020   0x7008             STRB     R0,[R1, #+0]
  14997                  PathJudgeDone = 0;             //赛道类型判断失败。
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR.N    R1,??DataTable78_77
   \   00000026   0x7008             STRB     R0,[R1, #+0]
  14998                  PathType = PathTypeUnknown;    //赛道类型置为未知。
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x....             LDR.N    R1,??DataTable78_78
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
  14999                  ImgBlackSucceedFlag = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x....             LDR.N    R1,??DataTable78_30
   \   00000032   0x7008             STRB     R0,[R1, #+0]
  15000              }
  15001              //黑线提取成功后的处理。
  15002              else
  15003              {
  15004              }
  15005          
  15006              //赛道类型判断
  15007              //到这里时，左右黑线至少有一个提取成功，中心线还没有提取。
  15008              PathJudgeNew();
   \                     ??ImagePro_0: (+1)
   \   00000034   0x.... 0x....      BL       PathJudgeNew
  15009              
  15010              //直角黑块确认。//这届不使用
  15011              //AngleZoneConfirm();
  15012              
  15013              //障碍物确认 与 避障处理，会改变CenterLineLoc[]数组的值。
  15014              BrickAvoid();
   \   00000038   0x.... 0x....      BL       BrickAvoid
  15015              
  15016              //坡道禁止赛道类型判断期间的线头平齐
  15017              GyroResultForbidSpeDeal();
   \   0000003C   0x.... 0x....      BL       GyroResultForbidSpeDeal
  15018           
  15019              //中心线提取函数。里面有中心线的线头线尾查找。
  15020              //除非图像太差，否则该函数基本上不会返回0.
  15021              //黑线提取失败后，不允许中心线提取。
  15022              CenterLineResult = 1;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x....             LDR.N    R1,??DataTable78_76
   \   00000044   0x7008             STRB     R0,[R1, #+0]
  15023              if(ImgBlackSucceedFlag == 0 || CenterLineGetRaw() == 0)
   \   00000046   0x....             LDR.N    R0,??DataTable78_30
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD003             BEQ.N    ??ImagePro_1
   \   0000004E   0x.... 0x....      BL       CenterLineGetRaw
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD111             BNE.N    ??ImagePro_2
  15024              {
  15025                //uart_sendN(UART0, (uint8 *)"\nCenterLineGet Failed!", 22); 
  15026                CenterHeadLine = MaxValUint8;
   \                     ??ImagePro_1: (+1)
   \   00000056   0x20FF             MOVS     R0,#+255
   \   00000058   0x....             LDR.N    R1,??DataTable78_79
   \   0000005A   0x7008             STRB     R0,[R1, #+0]
  15027                CenterEndLine = MaxValUint8;
   \   0000005C   0x20FF             MOVS     R0,#+255
   \   0000005E   0x....             LDR.N    R1,??DataTable78_80
   \   00000060   0x7008             STRB     R0,[R1, #+0]
  15028                CenterLineResult = 0; //
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x....             LDR.N    R1,??DataTable78_76
   \   00000066   0x7008             STRB     R0,[R1, #+0]
  15029                PathJudgeDone = 0;   //赛道类型判断失败。
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x....             LDR.N    R1,??DataTable78_77
   \   0000006C   0x7008             STRB     R0,[R1, #+0]
  15030                PathType = 0;        //赛道类型置为未知。
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x....             LDR.N    R1,??DataTable78_78
   \   00000072   0x7008             STRB     R0,[R1, #+0]
  15031                ImgCenterSucceedFlag = 0;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x....             LDR.N    R1,??DataTable78_31
   \   00000078   0x7008             STRB     R0,[R1, #+0]
  15032              }
  15033              else
  15034              {
  15035              }
  15036              
  15037              //必须黑线和中心线都提取成功后才能视为图像处理成功。
  15038              if(ImgBlackSucceedFlag == 1 && ImgCenterSucceedFlag == 1)
   \                     ??ImagePro_2: (+1)
   \   0000007A   0x....             LDR.N    R0,??DataTable78_30
   \   0000007C   0x7800             LDRB     R0,[R0, #+0]
   \   0000007E   0x2801             CMP      R0,#+1
   \   00000080   0xD10D             BNE.N    ??ImagePro_3
   \   00000082   0x....             LDR.N    R0,??DataTable78_31
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x2801             CMP      R0,#+1
   \   00000088   0xD109             BNE.N    ??ImagePro_3
  15039              {
  15040                GPIO_PDOR_REG(PORTA) |= (1<<17);
   \   0000008A   0x....             LDR.N    R0,??DataTable78_81  ;; 0x400ff000
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   00000092   0x....             LDR.N    R1,??DataTable78_81  ;; 0x400ff000
   \   00000094   0x6008             STR      R0,[R1, #+0]
  15041                ImgProSucceedFlag = 1;
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0x....             LDR.N    R1,??DataTable78_82
   \   0000009A   0x7008             STRB     R0,[R1, #+0]
   \   0000009C   0xE008             B.N      ??ImagePro_4
  15042              }
  15043              else
  15044              {
  15045                GPIO_PDOR_REG(PORTA) &= ~(1<<17);
   \                     ??ImagePro_3: (+1)
   \   0000009E   0x....             LDR.N    R0,??DataTable78_81  ;; 0x400ff000
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0xF430 0x3000      BICS     R0,R0,#0x20000
   \   000000A6   0x....             LDR.N    R1,??DataTable78_81  ;; 0x400ff000
   \   000000A8   0x6008             STR      R0,[R1, #+0]
  15046                ImgProSucceedFlag = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x....             LDR.N    R1,??DataTable78_82
   \   000000AE   0x7008             STRB     R0,[R1, #+0]
  15047              }
  15048             
  15049              
  15050              if(ImgProSucceedFlag == 1)
   \                     ??ImagePro_4: (+1)
   \   000000B0   0x....             LDR.N    R0,??DataTable78_82
   \   000000B2   0x7800             LDRB     R0,[R0, #+0]
   \   000000B4   0x2801             CMP      R0,#+1
   \   000000B6   0xD102             BNE.N    ??ImagePro_5
  15051              {
  15052                //图像处理成功后的处理。
  15053                ImgProSucceedDeal();
   \   000000B8   0x.... 0x....      BL       ImgProSucceedDeal
   \   000000BC   0xE001             B.N      ??ImagePro_6
  15054              }
  15055              else
  15056              {
  15057                //图像处理失败后的处理。
  15058                ImgProFailDeal();
   \                     ??ImagePro_5: (+1)
   \   000000BE   0x.... 0x....      BL       ImgProFailDeal
  15059              }
  15060              
  15061              //判断是否跑出赛道，10次图像失败就认为跑出赛道（刚开始做车的阶段先注释掉）
  15062              /*if(CenterHeadLine==MaxValUint8 && CenterEndLine==MaxValUint8)
  15063              {
  15064                if(++ImgProFailCount > 10)
  15065                {
  15066                  RunOutFlag = 1;
  15067                }
  15068              }
  15069              else
  15070              {
  15071                  ImgProFailCount = 0;
  15072              }*/
  15073              
  15074              //偏差滤波。
  15075              //DeviNowFilter();
  15076              
  15077              //直角弯确认函数。在偏差求取后面，因为此时是绝对瞎眼。
  15078              //若干次直角弯确认后，才会最终确认为直角弯。
  15079              //最终确认后，会进行若干次的特殊处理。
  15080              //特殊处理时，不受图像成功标志位的影响。
  15081              //特殊处理时，会对几个Level和DeviNow进行特殊赋值。
  15082              //有想过针对最后一次有效的Devi进行分类的特殊处理，但似乎没有必要。
  15083              
  15084              //这届不需要确认直角弯
  15085              //AngleStep2Confirm();
  15086              
  15087              return ImgProSucceedFlag;
   \                     ??ImagePro_6: (+1)
   \   000000C2   0x....             LDR.N    R0,??DataTable78_82
   \   000000C4   0x7800             LDRB     R0,[R0, #+0]
   \   000000C6   0xBD02             POP      {R1,PC}          ;; return
  15088          }
  15089          
  15090          
  15091          
  15092          //发送图像时专用的图像数组更新。

   \                                 In section .text, align 2, keep-with-next
  15093          void ImgSendPut(void)
  15094          {
   \                     ImgSendPut: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
  15095              uint16 i, j, k, temp1, temp2;   
  15096              
  15097              temp1 = CameraRealLeftCol;
   \   00000002   0x....             LDR.N    R0,??DataTable78_83
   \   00000004   0x7803             LDRB     R3,[R0, #+0]
  15098              temp2 = CameraRealLeftCol + CameraRealWidth;
   \   00000006   0x....             LDR.N    R0,??DataTable78_83
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0xF110 0x04FA      ADDS     R4,R0,#+250
  15099              //temp1 = CameraWidth/2 - CameraRealWidth/2 - 1;
  15100              //temp2 = CameraWidth/2 + CameraRealWidth/2 - 1;
  15101              
  15102              for(i = 0; i < CameraHight; i++)
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE015             B.N      ??ImgSendPut_0
  15103              {
  15104                k = 0;
  15105                for(j = temp1; j < temp2; j++)
  15106                {
  15107                  ImgNew[i][k] = ImgRaw[i][j];
   \                     ??ImgSendPut_1: (+1)
   \   00000012   0x....             LDR.N    R5,??DataTable78_84
   \   00000014   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000016   0x26FA             MOVS     R6,#+250
   \   00000018   0xFB06 0x5500      MLA      R5,R6,R0,R5
   \   0000001C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001E   0x....             LDR.N    R6,??DataTable78_85
   \   00000020   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000022   0xF44F 0x77A0      MOV      R7,#+320
   \   00000026   0xFB07 0x6600      MLA      R6,R7,R0,R6
   \   0000002A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000002C   0x5D8E             LDRB     R6,[R1, R6]
   \   0000002E   0x5556             STRB     R6,[R2, R5]
  15108                  k++;
   \   00000030   0x1C52             ADDS     R2,R2,#+1
  15109                }
   \   00000032   0x1C49             ADDS     R1,R1,#+1
   \                     ??ImgSendPut_2: (+1)
   \   00000034   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000036   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000038   0x42A1             CMP      R1,R4
   \   0000003A   0xD3EA             BCC.N    ??ImgSendPut_1
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \                     ??ImgSendPut_0: (+1)
   \   0000003E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000040   0x283C             CMP      R0,#+60
   \   00000042   0xDA02             BGE.N    ??ImgSendPut_3
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x0019             MOVS     R1,R3
   \   00000048   0xE7F4             B.N      ??ImgSendPut_2
  15110              }
  15111          }
   \                     ??ImgSendPut_3: (+1)
   \   0000004A   0xBCF0             POP      {R4-R7}
   \   0000004C   0x4770             BX       LR               ;; return
  15112          
  15113          //图像发送模式专用函数

   \                                 In section .text, align 2, keep-with-next
  15114          uint8 ImageSend(void)
  15115          {
   \                     ImageSend: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  15116              //发送图像时专用的图像数组更新。
  15117              ImgPut();
   \   00000002   0x.... 0x....      BL       ImgPut
  15118              
  15119              //发送图像存储数组到上位机
  15120              SendImage(ImgNew);      
   \   00000006   0x....             LDR.N    R0,??DataTable78_84
   \   00000008   0x.... 0x....      BL       SendImage
  15121              
  15122              return 1;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
  15123          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     ShiZhiFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     BlackLeftDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     BlackRightDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     SlopeL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     SlopeR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     BlackRightCrossDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     BlackLeftCrossDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     BlackRightEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x........         DC32     BlackLeftEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x........         DC32     BlackRightHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x........         DC32     BlackLeftHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x........         DC32     ImgNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     LimitLeftB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     ShiZhiCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     StopLineCheckBeginFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     StopLineCheckTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     CURVEL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x........         DC32     CURVER

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x........         DC32     LimitLeftW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     LimitRightW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x........         DC32     limitStopLineBlackXiu

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_13:
   \   00000000   0x........         DC32     BlackLeftRealWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_14:
   \   00000000   0x........         DC32     BlackLeftRealW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_15:
   \   00000000   0x........         DC32     BlackLeftRealB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_16:
   \   00000000   0x........         DC32     SingleBlackAllFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_17:
   \   00000000   0x........         DC32     BlackLeftBigChangeNumy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_18:
   \   00000000   0x........         DC32     BlackLeftBigChangeJumpFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     BlackLeftBigChangeNumx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     BlackLeftBigChangeSlopeStore

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     BlackLeft5Slope

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     BlackLeft5SlopeIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     BlackLeft5SlopeRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     BlackLeftBigChangeFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     ImgNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     LimitLeftWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     LimitLeftWBAdjust

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     BlackLeftEdgeStartCol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     BlackGetPreDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     SingleBlackLastAllFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     SingleBlackWidthMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     BlackLeftPredictL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     BlackLeftPredictR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     LimitLeftW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     LimitLeftB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     SingleBlackAllFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     BlackLeftBigChangeNumy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     BlackLeftBigChangeJumpFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     BlackLeftBigChangeNumx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     SingleBlackFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     BlackLeftRealWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     BlackLeftRealW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     BlackLeftRealB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     BlackLeftBigChangeCheckRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     BlackLeftBigChangeCheckAllRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     LimitLeftWBMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     LimitLeftWBMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x........         DC32     LimitLeftWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     LimitLeftWMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x........         DC32     LimitLeftWMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x........         DC32     LimitLeftBMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x........         DC32     LimitLeftBMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x........         DC32     BlackLeftRealB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     SlopeR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     BlackRightHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     BlackGetPreDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     BlackLeftPredictL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     BlackLeftPredictR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x........         DC32     ImgNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     BlackLeftEdgeStartColOffset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     BlackLeftWinPredictStore1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     BlackLeftWinPredictStore0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x........         DC32     LimitLeftB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     BlackLeftWinPredictStore2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     BlackLeftCrossConfirmFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x........         DC32     BlackLeftRealWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     BlackLeftRealW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x........         DC32     LimitLeftW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x........         DC32     BlackLeftStep1ScanRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \   00000000   0x........         DC32     BlackLeft5Slope

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \   00000000   0x........         DC32     BlackLeftCrossTailFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_8:
   \   00000000   0x........         DC32     BlackLeftEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_9:
   \   00000000   0x........         DC32     BlackLeftHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_10:
   \   00000000   0x........         DC32     BlackLeft5SlopeIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_11:
   \   00000000   0x........         DC32     BlackLeft5SlopeRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_12:
   \   00000000   0x........         DC32     BlackLeftCrossTailEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_13:
   \   00000000   0x........         DC32     BlackLeftDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x........         DC32     SingleBlackAllFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0x........         DC32     SlopeL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   0x........         DC32     BlackLeftStep4Flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \   00000000   0x........         DC32     SingleBlackLastAllFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x........         DC32     BlackLeftContinueFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x........         DC32     BlackLeftCrossDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   0x........         DC32     BlackLeftRollCheckFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \   00000000   0x........         DC32     BlackLeftBigChangeJumpFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_4:
   \   00000000   0x........         DC32     BlackLeftBigChangeNumx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_5:
   \   00000000   0x........         DC32     BlackLeftBigChangeNumy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_6:
   \   00000000   0x........         DC32     BlackLeftBigChangeFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_7:
   \   00000000   0x........         DC32     BlackLeftBigChangeSlopeStore

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_8:
   \   00000000   0x........         DC32     BlackLeftBigChangeCheckRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_9:
   \   00000000   0x........         DC32     BlackLeftBigChangeCheckAllRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_10:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_11:
   \   00000000   0x........         DC32     BlackLeftPredictL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_12:
   \   00000000   0x........         DC32     BlackLeftPredictR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_13:
   \   00000000   0x........         DC32     BlackLeftWinPredictStore0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_14:
   \   00000000   0x........         DC32     BlackLeftWinPredictStore1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     BlackLeftStep4StartLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x........         DC32     BlackLeftCrossDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \   00000000   0x........         DC32     LimitLeftHeadWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \   00000000   0x........         DC32     LimitLeftWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_4:
   \   00000000   0x........         DC32     LimitLeftHeadW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_5:
   \   00000000   0x........         DC32     LimitLeftW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_6:
   \   00000000   0x........         DC32     LimitLeftHeadB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_7:
   \   00000000   0x........         DC32     LimitLeftB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_8:
   \   00000000   0x........         DC32     BlackLeftStep1ScanRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_9:
   \   00000000   0x........         DC32     BlackGetPreDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_10:
   \   00000000   0x........         DC32     BlackRightHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_11:
   \   00000000   0x........         DC32     BlackLeftWinPredictStore2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_12:
   \   00000000   0x........         DC32     BlackLeftRealWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_13:
   \   00000000   0x........         DC32     LimitLeftWBMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_14:
   \   00000000   0x........         DC32     LimitLeftWBMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_15:
   \   00000000   0x........         DC32     BlackLeftRealW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_16:
   \   00000000   0x........         DC32     LimitLeftWMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_17:
   \   00000000   0x........         DC32     LimitLeftWMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_18:
   \   00000000   0x........         DC32     BlackLeftRealB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_19:
   \   00000000   0x........         DC32     LimitLeftBMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_20:
   \   00000000   0x........         DC32     LimitLeftBMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_21:
   \   00000000   0x........         DC32     AngleZoneConfirmLockFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_22:
   \   00000000   0x........         DC32     BlackLeftRow1RealLastLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_23:
   \   00000000   0x........         DC32     BlackLeftCrossTooLowLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x........         DC32     BlackRightRealWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x........         DC32     BlackRightRealW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \   00000000   0x........         DC32     BlackRightRealB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \   00000000   0x........         DC32     BlackRightDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_4:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_5:
   \   00000000   0x........         DC32     BlackRightEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_6:
   \   00000000   0x........         DC32     BlackRightBigChangeNumy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x........         DC32     BlackRightBigChangeNumx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \   00000000   0x........         DC32     BlackRightBigChangeJumpFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \   00000000   0x........         DC32     BlackRightBigChangeSlopeStore

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_3:
   \   00000000   0x........         DC32     BlackRight5Slope

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_4:
   \   00000000   0x........         DC32     BlackRight5SlopeIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_5:
   \   00000000   0x........         DC32     BlackRight5SlopeRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_6:
   \   00000000   0x........         DC32     BlackRightBigChangeFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_7:
   \   00000000   0x........         DC32     ImgNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x........         DC32     LimitRightWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   0x........         DC32     LimitRightWBAdjust

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   0x........         DC32     LimitRightW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0x........         DC32     LimitRightB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_1:
   \   00000000   0x........         DC32     BlackRightEdgeStartCol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_2:
   \   00000000   0x........         DC32     BlackGetPreDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_3:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_4:
   \   00000000   0x........         DC32     SingleBlackLastAllFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_5:
   \   00000000   0x........         DC32     SingleBlackWidthMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_6:
   \   00000000   0x........         DC32     BlackRightPredictL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_7:
   \   00000000   0x........         DC32     BlackRightPredictR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   0x........         DC32     SingleBlackAllFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \   00000000   0x........         DC32     BlackRightBigChangeNumx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x........         DC32     SingleBlackFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \   00000000   0x........         DC32     BlackRightRealB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_2:
   \   00000000   0x........         DC32     BlackRightBigChangeCheckRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_3:
   \   00000000   0x........         DC32     BlackRightBigChangeCheckAllRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_4:
   \   00000000   0x........         DC32     BlackRightRealWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_5:
   \   00000000   0x........         DC32     BlackRightRealW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_1:
   \   00000000   0x........         DC32     LimitRightWBMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_2:
   \   00000000   0x........         DC32     LimitRightWBMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_3:
   \   00000000   0x........         DC32     LimitRightWMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_4:
   \   00000000   0x........         DC32     LimitRightWMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_5:
   \   00000000   0x........         DC32     LimitRightBMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_6:
   \   00000000   0x........         DC32     LimitRightBMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33_7:
   \   00000000   0x........         DC32     BlackRightBigChangeNumy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0x........         DC32     BlackRightBigChangeJumpFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_1:
   \   00000000   0x........         DC32     SlopeL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_2:
   \   00000000   0x........         DC32     BlackLeftHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_3:
   \   00000000   0x........         DC32     BlackGetPreDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_4:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_5:
   \   00000000   0x........         DC32     BlackRightPredictL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_6:
   \   00000000   0x........         DC32     BlackRightPredictR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_7:
   \   00000000   0x........         DC32     ImgNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \   00000000   0x........         DC32     BlackRightEdgeStartColOffset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \   00000000   0x........         DC32     BlackRightWinPredictStore1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_1:
   \   00000000   0x........         DC32     BlackRightWinPredictStore0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_2:
   \   00000000   0x........         DC32     LimitRightB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \   00000000   0x........         DC32     BlackRightWinPredictStore2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_1:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_2:
   \   00000000   0x........         DC32     BlackRightCrossConfirmFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_3:
   \   00000000   0x........         DC32     BlackRightRealWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_4:
   \   00000000   0x........         DC32     LimitRightWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_5:
   \   00000000   0x........         DC32     BlackRightRealW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_6:
   \   00000000   0x........         DC32     LimitRightW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_7:
   \   00000000   0x........         DC32     BlackRightRealB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_8:
   \   00000000   0x........         DC32     BlackRightStep1ScanRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_9:
   \   00000000   0x........         DC32     BlackRight5Slope

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_10:
   \   00000000   0x........         DC32     BlackRightCrossTailFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_11:
   \   00000000   0x........         DC32     BlackRightEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_12:
   \   00000000   0x........         DC32     BlackRightHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_13:
   \   00000000   0x........         DC32     BlackLeftEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_14:
   \   00000000   0x........         DC32     BlackRight5SlopeIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_15:
   \   00000000   0x........         DC32     BlackRight5SlopeRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_16:
   \   00000000   0x........         DC32     BlackRightCrossTailEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_17:
   \   00000000   0x........         DC32     BlackRightDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40:
   \   00000000   0x........         DC32     BlackRightContinueFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_1:
   \   00000000   0x........         DC32     SingleBlackAllFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_2:
   \   00000000   0x........         DC32     SlopeR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_3:
   \   00000000   0x........         DC32     BlackRightStep4Flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_4:
   \   00000000   0x........         DC32     SingleBlackLastAllFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_5:
   \   00000000   0x........         DC32     BlackRightCrossDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_6:
   \   00000000   0x........         DC32     BlackRightRollCheckFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_7:
   \   00000000   0x........         DC32     BlackRightBigChangeJumpFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_8:
   \   00000000   0x........         DC32     BlackRightBigChangeNumx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_9:
   \   00000000   0x........         DC32     BlackRightBigChangeNumy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_10:
   \   00000000   0x........         DC32     BlackRightBigChangeFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_11:
   \   00000000   0x........         DC32     BlackRightBigChangeSlopeStore

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_12:
   \   00000000   0x........         DC32     BlackRightBigChangeCheckRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_13:
   \   00000000   0x........         DC32     BlackRightBigChangeCheckAllRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_14:
   \   00000000   0x........         DC32     BlackRightPredictL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_15:
   \   00000000   0x........         DC32     BlackRightPredictR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_16:
   \   00000000   0x........         DC32     BlackRightWinPredictStore0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_17:
   \   00000000   0x........         DC32     BlackRightWinPredictStore1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_18:
   \   00000000   0x........         DC32     BlackRightStep4StartLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_19:
   \   00000000   0x........         DC32     LimitRightHeadWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_20:
   \   00000000   0x........         DC32     LimitRightWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_21:
   \   00000000   0x........         DC32     LimitRightHeadW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_22:
   \   00000000   0x........         DC32     LimitRightW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_23:
   \   00000000   0x........         DC32     LimitRightHeadB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_24:
   \   00000000   0x........         DC32     LimitRightB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_25:
   \   00000000   0x........         DC32     BlackRightStep1ScanRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_26:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_27:
   \   00000000   0x........         DC32     BlackRightWinPredictStore2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_28:
   \   00000000   0x........         DC32     BlackLeftHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_29:
   \   00000000   0x........         DC32     BlackRightRealWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_30:
   \   00000000   0x........         DC32     LimitRightWBMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_31:
   \   00000000   0x........         DC32     LimitRightWBMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_32:
   \   00000000   0x........         DC32     BlackRightRealW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_33:
   \   00000000   0x........         DC32     LimitRightWMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_34:
   \   00000000   0x........         DC32     LimitRightWMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_35:
   \   00000000   0x........         DC32     BlackRightRealB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_36:
   \   00000000   0x........         DC32     LimitRightBMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_37:
   \   00000000   0x........         DC32     LimitRightBMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_38:
   \   00000000   0x........         DC32     AngleZoneConfirmLockFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_39:
   \   00000000   0x........         DC32     BlackRightRow1RealLastLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_40:
   \   00000000   0x........         DC32     BlackRightCrossTooLowLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41:
   \   00000000   0x........         DC32     BrickSpeDealFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_1:
   \   00000000   0x........         DC32     BrickSpeDealDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_2:
   \   00000000   0x........         DC32     BlackGetPreDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_3:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_4:
   \   00000000   0x........         DC32     BlackLeftDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_5:
   \   00000000   0x........         DC32     BlackRightDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_6:
   \   00000000   0x........         DC32     BlackLeftStep1ScanRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \   00000000   0x........         DC32     BlackRightStep1ScanRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_1:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_2:
   \   00000000   0x........         DC32     SingleBlackWidthMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_3:
   \   00000000   0x........         DC32     ImgNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_4:
   \   00000000   0x........         DC32     BlackSingleFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_5:
   \   00000000   0x........         DC32     BlackSingleDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_6:
   \   00000000   0x........         DC32     BlackLeftHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43:
   \   00000000   0x........         DC32     BlackRightHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_1:
   \   00000000   0x........         DC32     BlackGetPreDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_2:
   \   00000000   0x........         DC32     BlackLeftDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_3:
   \   00000000   0x........         DC32     BlackLeftEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_4:
   \   00000000   0x........         DC32     BrickSpeDealFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_5:
   \   00000000   0x........         DC32     BrickSpeDealDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_6:
   \   00000000   0x........         DC32     BlackRightDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_7:
   \   00000000   0x........         DC32     CurveSlopeFlagL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_8:
   \   00000000   0x........         DC32     CurveSlopeFlagR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_9:
   \   00000000   0x........         DC32     BlackLeftRollCheckFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_10:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_11:
   \   00000000   0x........         DC32     BlackRightRollCheckFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_12:
   \   00000000   0x........         DC32     BlackRightEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_13:
   \   00000000   0x........         DC32     AngleConfirmLockFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_14:
   \   00000000   0x........         DC32     AngleSpeDealFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_15:
   \   00000000   0x........         DC32     BrickConfirmLockFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_16:
   \   00000000   0x........         DC32     CenterLineLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_17:
   \   00000000   0x........         DC32     RoadHalfWidthWrongDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_18:
   \   00000000   0x........         DC32     CenterHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_19:
   \   00000000   0x........         DC32     CenterEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_20:
   \   00000000   0x........         DC32     BlackUdisRightLocation

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_21:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_22:
   \   00000000   0x40690000         DC32     0x40690000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_23:
   \   00000000   0x........         DC32     RoadHalfWidth

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_24:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_25:
   \   00000000   0x........         DC32     BlackLeftHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_26:
   \   00000000   0x........         DC32     BlackUdisLeftLocation

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44:
   \   00000000   0x........         DC32     SingleBlackAllFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45:
   \   00000000   0x40690000         DC32     0x40690000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_1:
   \   00000000   0x........         DC32     RoadHalfWidthCompen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_2:
   \   00000000   0x........         DC32     RoadHalfWidthSwitch

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48:
   \   00000000   0x........         DC32     CenterLineLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_1:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_2:
   \   00000000   0x........         DC32     BlackLeftCrossDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_3:
   \   00000000   0x........         DC32     BlackRightCrossDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_4:
   \   00000000   0x........         DC32     buXianCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_5:
   \   00000000   0x........         DC32     BlackLeftHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_6:
   \   00000000   0x........         DC32     CURVEL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_7:
   \   00000000   0x........         DC32     CURVER

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_8:
   \   00000000   0x........         DC32     CenterEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_9:
   \   00000000   0x........         DC32     RoadHalfWidthSingle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_10:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_11:
   \   00000000   0x........         DC32     BrickSpeDealFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_12:
   \   00000000   0x........         DC32     BrickSpeDealCenFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_13:
   \   00000000   0x........         DC32     BrickSpeDealDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_14:
   \   00000000   0x........         DC32     ServoPIDInputVal

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_15:
   \   00000000   0x........         DC32     ImgBlackSucceedFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_16:
   \   00000000   0x........         DC32     BlackRightDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_17:
   \   00000000   0x........         DC32     CenterHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_18:
   \   00000000   0x........         DC32     BlackRightEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_19:
   \   00000000   0x........         DC32     BrickSpeDealBias

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_20:
   \   00000000   0x........         DC32     BrickSpeDealBackCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_21:
   \   00000000   0x........         DC32     BrickConfirmFinalColCom

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_22:
   \   00000000   0x........         DC32     BlackRightHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_23:
   \   00000000   0x........         DC32     BlackLeftDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_24:
   \   00000000   0x........         DC32     BlackLeftEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_25:
   \   00000000   0x........         DC32     BrickConfirmLockFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_26:
   \   00000000   0x........         DC32     BrickConfirmMat0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_27:
   \   00000000   0x........         DC32     BrickConfirmMat1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_28:
   \   00000000   0x........         DC32     PathType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_29:
   \   00000000   0x........         DC32     BrickConfirmMatCollect0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_30:
   \   00000000   0x........         DC32     BrickConfirmMatCollect1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_31:
   \   00000000   0x........         DC32     BrickConfirmMatLimit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_32:
   \   00000000   0x400FF0C0         DC32     0x400ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_33:
   \   00000000   0x........         DC32     BrickSpeDealExitJudgeFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_34:
   \   00000000   0x........         DC32     GyroResultForbidFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_35:
   \   00000000   0x........         DC32     GyroResultForbidBackCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_36:
   \   00000000   0x........         DC32     AngleConfirmLockFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48_37:
   \   00000000   0x........         DC32     AngleSpeDealFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49:
   \   00000000   0x........         DC32     SingleBlackAllFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50:
   \   00000000   0x........         DC32     RoadHalfWidthCompen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53:
   \   00000000   0x........         DC32     BlackUdisLeftLocation

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable53_1:
   \   00000000   0x........         DC32     RoadHalfWidthRecord

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable54:
   \   00000000   0x........         DC32     RoadHalfWidth

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable54_1:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable54_2:
   \   00000000   0x........         DC32     CenterLineLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable54_3:
   \   00000000   0x........         DC32     BlackUdisRightLocation

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56:
   \   00000000   0x........         DC32     CenterEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_1:
   \   00000000   0x........         DC32     RoadHalfWidthSingle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_2:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_3:
   \   00000000   0x........         DC32     CameraRealLeftCol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_4:
   \   00000000   0x........         DC32     ImgPresent

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_5:
   \   00000000   0x........         DC32     ImgNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_6:
   \   00000000   0x........         DC32     ImgStore2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57:
   \   00000000   0x........         DC32     ImgStore1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_1:
   \   00000000   0x........         DC32     ErrorGetSelf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_2:
   \   00000000   0x........         DC32     ErrorGetCen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_3:
   \   00000000   0x........         DC32     CurveLineChosenC1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_4:
   \   00000000   0x........         DC32     CurveLineChosenC2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_5:
   \   00000000   0x........         DC32     CurveLineChosenC3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_6:
   \   00000000   0x........         DC32     CenterHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_7:
   \   00000000   0x........         DC32     CURVEC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_8:
   \   00000000   0x........         DC32     SlopeC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_9:
   \   00000000   0x........         DC32     BlackLeftDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_10:
   \   00000000   0x........         DC32     CurveLineChosenL1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_11:
   \   00000000   0x........         DC32     CurveLineChosenL2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_12:
   \   00000000   0x........         DC32     CurveLineChosenL3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_13:
   \   00000000   0x........         DC32     BlackLeftHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_14:
   \   00000000   0x........         DC32     BlackLeftEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_15:
   \   00000000   0x........         DC32     CURVEL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_16:
   \   00000000   0x........         DC32     SlopeL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_17:
   \   00000000   0x........         DC32     BlackUdisLeftLocation

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_18:
   \   00000000   0x........         DC32     BlackRightDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_19:
   \   00000000   0x........         DC32     CurveLineChosenR1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_20:
   \   00000000   0x........         DC32     CurveLineChosenR2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_21:
   \   00000000   0x........         DC32     CurveLineChosenR3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_22:
   \   00000000   0x........         DC32     BlackRightHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57_23:
   \   00000000   0x........         DC32     BlackRightEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58:
   \   00000000   0x........         DC32     CURVER

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_1:
   \   00000000   0x........         DC32     SlopeR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_2:
   \   00000000   0x........         DC32     BlackUdisRightLocation

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_3:
   \   00000000   0x........         DC32     CurveSlopeFlagC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_4:
   \   00000000   0x........         DC32     CurveSlopeFlagL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_5:
   \   00000000   0x........         DC32     CurveSlopeFlagR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_6:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_7:
   \   00000000   0x........         DC32     AngleStep1NotBrickEndColL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_8:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_9:
   \   00000000   0x........         DC32     AngleStep1NotBrickBorderColL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_10:
   \   00000000   0x........         DC32     ImgNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_11:
   \   00000000   0x........         DC32     LimitLeftB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_12:
   \   00000000   0x........         DC32     AngleStep1NotBrickEndColR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_13:
   \   00000000   0x........         DC32     AngleStep1NotBrickBorderColR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59:
   \   00000000   0x........         DC32     LimitRightB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_1:
   \   00000000   0x........         DC32     BlackLeftDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_2:
   \   00000000   0x........         DC32     BlackRightDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_3:
   \   00000000   0x........         DC32     BlackRightHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_4:
   \   00000000   0x........         DC32     BlackLeftHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_5:
   \   00000000   0x........         DC32     AngleHeadLineNum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_6:
   \   00000000   0x........         DC32     BlackLeftCrossDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_7:
   \   00000000   0x........         DC32     BlackRightCrossDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable59_8:
   \   00000000   0x........         DC32     CURVEL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60:
   \   00000000   0x........         DC32     AngleLongHeadLineStrategy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_1:
   \   00000000   0x........         DC32     BlackLeftEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_2:
   \   00000000   0x........         DC32     BlackLeft5SlopeIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_3:
   \   00000000   0x........         DC32     BlackLeft5Slope

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_4:
   \   00000000   0x........         DC32     BlackRightEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_5:
   \   00000000   0x........         DC32     BlackRight5SlopeIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_6:
   \   00000000   0x........         DC32     BlackRight5Slope

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_7:
   \   00000000   0x........         DC32     flag222

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60_8:
   \   00000000   0x........         DC32     LimitRightW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61:
   \   00000000   0x........         DC32     PathType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61_1:
   \   00000000   0x........         DC32     LimitLeftW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61_2:
   \   00000000   0x........         DC32     SlopeC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61_3:
   \   00000000   0x........         DC32     CurveSlopeFlagL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61_4:
   \   00000000   0x........         DC32     CurveSlopeFlagR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61_5:
   \   00000000   0x........         DC32     CURVER

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61_6:
   \   00000000   0x........         DC32     SlopeL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable61_7:
   \   00000000   0x........         DC32     SlopeR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64:
   \   00000000   0x........         DC32     CURVEC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_1:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_2:
   \   00000000   0x........         DC32     BlackLeftDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_3:
   \   00000000   0x........         DC32     BlackRightDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_4:
   \   00000000   0x........         DC32     BlackLeftHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_5:
   \   00000000   0x........         DC32     BlackLeftEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_6:
   \   00000000   0x........         DC32     PathSmallSDoneFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_7:
   \   00000000   0x........         DC32     PathSmallSDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_8:
   \   00000000   0x........         DC32     BlackRightHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable65_9:
   \   00000000   0x........         DC32     BlackRightEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable66:
   \   00000000   0x........         DC32     BlackUdisMatrixLow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable66_1:
   \   00000000   0x........         DC32     BlackUdisLeftLocation

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable66_2:
   \   00000000   0x........         DC32     BlackUdisMatrixMiddle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable66_3:
   \   00000000   0x........         DC32     BlackUdisMatrixFar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable66_4:
   \   00000000   0x........         DC32     BlackUdisRightLocation

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67:
   \   00000000   0x........         DC32     BlackRightHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_1:
   \   00000000   0x........         DC32     AngleSpeDealDeviNow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_2:
   \   00000000   0x........         DC32     AngleSpeDealBackCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_3:
   \   00000000   0x........         DC32     DeviFuse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_4:
   \   00000000   0x........         DC32     AngleSpeDealSlopeC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_5:
   \   00000000   0x........         DC32     SlopeC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_6:
   \   00000000   0x........         DC32     SlopeL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_7:
   \   00000000   0x........         DC32     SlopeR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_8:
   \   00000000   0x........         DC32     AngleConfirmLockFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_9:
   \   00000000   0x........         DC32     AngleConfirmMat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_10:
   \   00000000   0x........         DC32     PathType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_11:
   \   00000000   0x........         DC32     AngleConfirmMatCollect

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_12:
   \   00000000   0x........         DC32     AngleConfirmMatLimit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_13:
   \   00000000   0x........         DC32     AngleSpeDealDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_14:
   \   00000000   0x........         DC32     AngleZoneConfirmLockFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_15:
   \   00000000   0x........         DC32     AngleSpeDealExitJudgeFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_16:
   \   00000000   0x........         DC32     AngleSpeDealFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_17:
   \   00000000   0x........         DC32     BlackLeftDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_18:
   \   00000000   0x........         DC32     BlackRightDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_19:
   \   00000000   0x........         DC32     BlackGetPreDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_20:
   \   00000000   0x........         DC32     BlackLeftStep1ScanRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_21:
   \   00000000   0x........         DC32     BlackRightStep1ScanRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_22:
   \   00000000   0x........         DC32     SingleBlackAllFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_23:
   \   00000000   0x........         DC32     BlackLeftEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_24:
   \   00000000   0x........         DC32     BlackLeftHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_25:
   \   00000000   0x........         DC32     BlackLeft5SlopeIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_26:
   \   00000000   0x........         DC32     BlackLeft5Slope

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_27:
   \   00000000   0x........         DC32     flag000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_28:
   \   00000000   0x........         DC32     flag111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_29:
   \   00000000   0x........         DC32     BlackRightEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_30:
   \   00000000   0x........         DC32     BlackRight5SlopeIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_31:
   \   00000000   0x........         DC32     BlackRight5Slope

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_32:
   \   00000000   0x........         DC32     BlackRightCrossDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_33:
   \   00000000   0x........         DC32     BlackRightRow1RealLastLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable67_34:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68:
   \   00000000   0x........         DC32     BrickEndColL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_1:
   \   00000000   0x........         DC32     BrickHeadColL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_2:
   \   00000000   0x........         DC32     BrickBorderColL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_3:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_4:
   \   00000000   0x........         DC32     ImgNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_5:
   \   00000000   0x........         DC32     LimitLeftB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_6:
   \   00000000   0x........         DC32     BrickLineCountNumRecord

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_7:
   \   00000000   0x........         DC32     BrickEndColR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_8:
   \   00000000   0x........         DC32     BrickHeadColR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_9:
   \   00000000   0x........         DC32     BrickBorderColR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable68_10:
   \   00000000   0x........         DC32     LimitRightB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69:
   \   00000000   0x........         DC32     BlackLeftCrossDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable69_1:
   \   00000000   0x........         DC32     BlackLeftRow1RealLastLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable71:
   \   00000000   0x........         DC32     BlackLeftDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable71_1:
   \   00000000   0x........         DC32     BlackRightDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable71_2:
   \   00000000   0x........         DC32     BlackLeftHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable71_3:
   \   00000000   0x........         DC32     BlackBigChangeFinalCheckFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable71_4:
   \   00000000   0x........         DC32     AngleZoneJudgeRowR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable71_5:
   \   00000000   0x........         DC32     AngleZoneJudgeColR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable71_6:
   \   00000000   0x........         DC32     AngleZoneJudgeColRFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable71_7:
   \   00000000   0x........         DC32     AngleZoneJudgeCountColR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable71_8:
   \   00000000   0x........         DC32     AngleZoneJudgeRowL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable71_9:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72:
   \   00000000   0x........         DC32     BlackRightHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_1:
   \   00000000   0x........         DC32     AngleZoneJudgeColL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_2:
   \   00000000   0x........         DC32     AngleZoneJudgeColLFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_3:
   \   00000000   0x........         DC32     AngleZoneJudgeCountColL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable72_4:
   \   00000000   0x........         DC32     PathType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable74:
   \   00000000   0x........         DC32     AngleZoneConfirmMat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable74_1:
   \   00000000   0x........         DC32     AngleZoneConfirmMatCollect

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable74_2:
   \   00000000   0x........         DC32     AngleZoneConfirmMatLimit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable75:
   \   00000000   0x........         DC32     AngleZoneConfirmLockMeterCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable75_1:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable75_2:
   \   00000000   0x........         DC32     BlackRightHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76:
   \   00000000   0x........         DC32     AngleZoneConfirmLockFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76_1:
   \   00000000   0x........         DC32     AngleConfirmLockFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76_2:
   \   00000000   0x........         DC32     AngleSpeDealFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76_3:
   \   00000000   0x........         DC32     BrickConfirmLockFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76_4:
   \   00000000   0x........         DC32     BrickSpeDealFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76_5:
   \   00000000   0x........         DC32     GyroResultForbidFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable77:
   \   00000000   0x........         DC32     PathRealStraightCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78:
   \   00000000   0x........         DC32     PathRealStraightCountLimit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_1:
   \   00000000   0x........         DC32     PathRealStraightFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_2:
   \   00000000   0x........         DC32     xiaoZhiDaoFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_3:
   \   00000000   0x........         DC32     LimitLeftWBMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_4:
   \   00000000   0x........         DC32     LimitLeftWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_5:
   \   00000000   0x........         DC32     LimitLeftWMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_6:
   \   00000000   0x........         DC32     LimitLeftW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_7:
   \   00000000   0x........         DC32     LimitLeftBMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_8:
   \   00000000   0x........         DC32     LimitLeftB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_9:
   \   00000000   0x........         DC32     LimitLeftHeadWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_10:
   \   00000000   0x........         DC32     LimitLeftHeadW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_11:
   \   00000000   0x........         DC32     LimitLeftHeadB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_12:
   \   00000000   0x........         DC32     LimitRightWBMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_13:
   \   00000000   0x........         DC32     LimitRightWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_14:
   \   00000000   0x........         DC32     LimitRightWMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_15:
   \   00000000   0x........         DC32     LimitRightW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_16:
   \   00000000   0x........         DC32     LimitRightBMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_17:
   \   00000000   0x........         DC32     LimitRightB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_18:
   \   00000000   0x........         DC32     LimitRightHeadWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_19:
   \   00000000   0x........         DC32     LimitRightHeadW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_20:
   \   00000000   0x........         DC32     LimitRightHeadB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_21:
   \   00000000   0x........         DC32     SingleBlackWidthMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_22:
   \   00000000   0x........         DC32     BlackLeftLastEdgeStartCol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_23:
   \   00000000   0x........         DC32     BlackLeftEdgeStartCol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_24:
   \   00000000   0x........         DC32     BlackRightLastEdgeStartCol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_25:
   \   00000000   0x........         DC32     BlackRightEdgeStartCol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_26:
   \   00000000   0x........         DC32     RoadHalfWidthSingle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_27:
   \   00000000   0x........         DC32     AngleConfirmMat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_28:
   \   00000000   0x........         DC32     RoadHalfWidth

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_29:
   \   00000000   0x........         DC32     RoadHalfWidthLast

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_30:
   \   00000000   0x........         DC32     ImgBlackSucceedFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_31:
   \   00000000   0x........         DC32     ImgCenterSucceedFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_32:
   \   00000000   0x........         DC32     PathSmallSDoneFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_33:
   \   00000000   0x........         DC32     CenterLineLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_34:
   \   00000000   0x........         DC32     RoadHalfWidthRecord

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_35:
   \   00000000   0x........         DC32     RoadHalfWidthWrongFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_36:
   \   00000000   0x........         DC32     SingleDoneFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_37:
   \   00000000   0x........         DC32     SingleFloorFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_38:
   \   00000000   0x........         DC32     SingleFloorConfirmCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_39:
   \   00000000   0x........         DC32     SingleFloorConfirmCountMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_40:
   \   00000000   0x........         DC32     SingleBlackFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_41:
   \   00000000   0x........         DC32     SingleBlackAllFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_42:
   \   00000000   0x........         DC32     SingleBlackLastAllFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_43:
   \   00000000   0x........         DC32     BlackSingleFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_44:
   \   00000000   0x........         DC32     flag222

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_45:
   \   00000000   0x........         DC32     BrickLineCountNumRecord

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_46:
   \   00000000   0x........         DC32     BlackBigChangeFinalCheckFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_47:
   \   00000000   0x........         DC32     AngleZoneJudgeRowL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_48:
   \   00000000   0x........         DC32     AngleZoneJudgeRowR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_49:
   \   00000000   0x........         DC32     AngleZoneJudgeColR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_50:
   \   00000000   0x........         DC32     AngleZoneJudgeColRFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_51:
   \   00000000   0x........         DC32     AngleZoneJudgeCountColR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_52:
   \   00000000   0x........         DC32     BrickEndColL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_53:
   \   00000000   0x........         DC32     BrickHeadColL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_54:
   \   00000000   0x........         DC32     BrickBorderColL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_55:
   \   00000000   0x........         DC32     BrickEndColR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_56:
   \   00000000   0x........         DC32     BrickHeadColR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_57:
   \   00000000   0x........         DC32     BrickBorderColR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_58:
   \   00000000   0x........         DC32     BrickSpeDealCenFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_59:
   \   00000000   0x........         DC32     EmergencyStopCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_60:
   \   00000000   0x........         DC32     BlackCenEdgeStartCol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_61:
   \   00000000   0x........         DC32     BrickSpeDealDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_62:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_63:
   \   00000000   0x........         DC32     RoadHalfWidthWrongDir

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_64:
   \   00000000   0x........         DC32     BlackLeftStep1ScanRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_65:
   \   00000000   0x........         DC32     BlackRightStep1ScanRow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_66:
   \   00000000   0x........         DC32     LimitLeftWBMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_67:
   \   00000000   0x........         DC32     LimitLeftWMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_68:
   \   00000000   0x........         DC32     LimitLeftBMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_69:
   \   00000000   0x........         DC32     LimitRightWBMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_70:
   \   00000000   0x........         DC32     LimitRightWMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_71:
   \   00000000   0x........         DC32     LimitRightBMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_72:
   \   00000000   0x........         DC32     BlackLeftDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_73:
   \   00000000   0x........         DC32     BlackRightDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_74:
   \   00000000   0x........         DC32     BlackLeftHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_75:
   \   00000000   0x........         DC32     ErrorCountNow5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_76:
   \   00000000   0x........         DC32     CenterLineResult

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_77:
   \   00000000   0x........         DC32     PathJudgeDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_78:
   \   00000000   0x........         DC32     PathType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_79:
   \   00000000   0x........         DC32     CenterHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_80:
   \   00000000   0x........         DC32     CenterEndLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_81:
   \   00000000   0x400FF000         DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_82:
   \   00000000   0x........         DC32     ImgProSucceedFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_83:
   \   00000000   0x........         DC32     CameraRealLeftCol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_84:
   \   00000000   0x........         DC32     ImgNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_85:
   \   00000000   0x........         DC32     ImgRaw

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x00 0xFF          DC8 0, 255, 1, 255
   \              0x01 0xFF    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x00 0xFF          DC8 0, 255, 1, 0
   \              0x01 0x00    
  15124          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AbsInt
       0   AbsRe
       0   AngleSpeDealCen
       8   AngleSpeDealExitJudge
         8   -> AbsInt
      24   AngleStep1Judge
        24   -> AbsInt
        24   -> AngleStep1JudgeNotBrick
        24   -> MaxRe
        24   -> MinRe
      40   AngleStep1JudgeNotBrick
        40   -> LeastSquarea0
        40   -> LeastSquarea1
        40   -> MaxRe
        40   -> MinRe
       8   AngleStep2Confirm
         8   -> AngleSpeDealCen
         8   -> AngleSpeDealExitJudge
       8   AngleZoneConfirm
         8   -> AbsInt
      32   AngleZoneJudge
        32   -> AbsInt
        32   -> LeastSquarea0
        32   -> LeastSquarea1
       0   BlackBigChangeFinalCheck
       8   BlackGet
         8   -> BlackBigChangeFinalCheck
         8   -> BlackGetLeft
         8   -> BlackGetPre
         8   -> BlackGetRight
         8   -> BlackLeftContinueAdd
         8   -> BlackLeftHeadEndSearch
         8   -> BlackLeftRollCheck
         8   -> BlackRightContinueAdd
         8   -> BlackRightHeadEndSearch
         8   -> BlackRightRollCheck
         8   -> BlackUdis
         8   -> CurveSlopeGetLeft
         8   -> CurveSlopeGetRight
      40   BlackGetLeft
        40   -> BlackGetLeftParaInit
        40   -> BlackGetLeftStep1Scan
        40   -> BlackGetLeftStep2Win
        40   -> BlackLeftAgainForCross
        40   -> BlackLeftStep4BackLine
        40   -> BlackLeftStep4ErrorCheck
        40   -> BoundaryLimitRe
        40   -> MaxRe
      24   BlackGetLeftCrossSpeScan
        24   -> BlackGetLeftCrossSpeWin
        24   -> BoundaryLimitRe
        24   -> MaxRe
      16   BlackGetLeftCrossSpeWin
        16   -> BlackGetLeftJustWin
        16   -> BlackLeftBigChangeCheck
        16   -> MinRe
      24   BlackGetLeftJustWin
        24   -> BoundaryLimitRe
       0   BlackGetLeftParaInit
      32   BlackGetLeftStep1Edge
        32   -> AbsInt
        32   -> BlackLeftBigChangeCheck
        32   -> BlackLeftRealClear
        32   -> MaxRe
        32   -> MinRe
      32   BlackGetLeftStep1Scan
        32   -> AbsRe
        32   -> BlackGetLeftStep1Edge
      24   BlackGetLeftStep2Win
        24   -> BlackGetLeftJustWin
        24   -> BlackLeftBigChangeCheck
        24   -> MinRe
       8   BlackGetPre
         8   -> AbsInt
         8   -> BlackGetLeftParaInit
         8   -> BlackGetLeftStep1Edge
         8   -> BlackGetRightParaInit
         8   -> BlackGetRightStep1Edge
      40   BlackGetRight
        40   -> BlackGetRightParaInit
        40   -> BlackGetRightStep1Scan
        40   -> BlackGetRightStep2Win
        40   -> BlackRightAgainForCross
        40   -> BlackRightStep4BackLine
        40   -> BlackRightStep4ErrorCheck
        40   -> BoundaryLimitRe
        40   -> MinRe
      24   BlackGetRightCrossSpeScan
        24   -> BlackGetRightCrossSpeWin
        24   -> BoundaryLimitRe
        24   -> MinRe
      16   BlackGetRightCrossSpeWin
        16   -> BlackGetRightJustWin
        16   -> BlackRightBigChangeCheck
        16   -> MaxRe
      16   BlackGetRightJustWin
        16   -> BoundaryLimitRe
       0   BlackGetRightParaInit
      24   BlackGetRightStep1Edge
        24   -> AbsInt
        24   -> BlackRightBigChangeCheck
        24   -> BlackRightRealClear
        24   -> MaxRe
        24   -> MinRe
      32   BlackGetRightStep1Scan
        32   -> AbsRe
        32   -> BlackGetRightStep1Edge
      24   BlackGetRightStep2Win
        24   -> BlackGetRightJustWin
        24   -> BlackRightBigChangeCheck
        24   -> MaxRe
      32   BlackLeftAgainForCross
        32   -> BlackGetLeftCrossSpeScan
        32   -> BlackGetLeftStep2Win
        32   -> BlackLeftCrossConfirm
        32   -> BlackLeftCrossStep3
        32   -> BoundaryLimitRe
      16   BlackLeftBigChangeCheck
      12   BlackLeftContinueAdd
      24   BlackLeftCrossConfirm
        24   -> LeastSquarea0
        24   -> LeastSquarea1
      16   BlackLeftCrossStep3
       0   BlackLeftHeadEndSearch
       0   BlackLeftRealClear
       0   BlackLeftRollCheck
      24   BlackLeftStep4BackLine
        24   -> AbsInt
        24   -> BlackLeftHeadEndSearch
        24   -> LeastSquarea0
        24   -> LeastSquarea1
        24   -> MaxRe
        24   -> MinRe
       8   BlackLeftStep4ErrorCheck
         8   -> AbsInt
      32   BlackRightAgainForCross
        32   -> BlackGetRightCrossSpeScan
        32   -> BlackGetRightStep2Win
        32   -> BlackRightCrossConfirm
        32   -> BlackRightCrossStep3
        32   -> BoundaryLimitRe
      16   BlackRightBigChangeCheck
      12   BlackRightContinueAdd
      24   BlackRightCrossConfirm
        24   -> LeastSquarea0
        24   -> LeastSquarea1
      16   BlackRightCrossStep3
       0   BlackRightHeadEndSearch
       0   BlackRightRealClear
       0   BlackRightRollCheck
      24   BlackRightStep4BackLine
        24   -> BlackRightHeadEndSearch
        24   -> LeastSquarea0
        24   -> LeastSquarea1
        24   -> MaxRe
        24   -> MinRe
       8   BlackRightStep4ErrorCheck
         8   -> AbsInt
      24   BlackSingleSpeCheck
        24   -> AbsInt
        24   -> BlackGetLeftJustWin
        24   -> BlackGetRightJustWin
        24   -> BlackLeftStep4BackLine
        24   -> BlackRightStep4BackLine
       8   BlackUdis
       0   BoundaryLimitRe
       8   BrickAvoid
         8   -> BrickSpeDealCen
         8   -> BrickSpeDealExitJudge
         8   -> BrickSpeDealStartJudge
         8   -> light_control
      40   BrickJudge
        40   -> LeastSquarea0
        40   -> LeastSquarea1
        40   -> MaxRe
        40   -> MinRe
       0   BrickSpeDealCen
       0   BrickSpeDealExitJudge
       0   BrickSpeDealServor
       0   BrickSpeDealStartJudge
      40   CenterLineGet
        40   -> LeastSquareInt16a0
        40   -> LeastSquareInt16a1
        40   -> MaxRe
        40   -> MinRe
        40   -> __aeabi_d2f
        40   -> __aeabi_d2iz
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fmul
        40   -> __aeabi_i2d
        40   -> __aeabi_i2f
        40   -> sqrt
      48   CenterLineGetNormal
        48   -> AbsInt
        48   -> LeastSquareInt16a0
        48   -> LeastSquareInt16a1
        48   -> LeastSquarea0
        48   -> LeastSquarea1
        48   -> MaxRe
        48   -> MinRe
        48   -> __aeabi_d2f
        48   -> __aeabi_d2iz
        48   -> __aeabi_ddiv
        48   -> __aeabi_dmul
        48   -> __aeabi_f2d
        48   -> __aeabi_fadd
        48   -> __aeabi_fmul
        48   -> __aeabi_i2d
        48   -> __aeabi_i2f
        48   -> sqrt
       8   CenterLineGetRaw
         8   -> CenterLineGetNormal
      40   CenterLineGetSingleWrongAdd
        40   -> LeastSquareInt16a0
        40   -> LeastSquareInt16a1
        40   -> MaxRe
        40   -> __aeabi_d2f
        40   -> __aeabi_d2iz
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fmul
        40   -> __aeabi_i2d
        40   -> sqrt
       0   CenterLineHalfWidthGet
      40   CurveGet
        40   -> MathSqrt
       8   CurveSlopeGet
         8   -> CurveSlopeGetCenter
      32   CurveSlopeGetCenter
        32   -> CurveGet
        32   -> LeastSquareInt16a1
      32   CurveSlopeGetLeft
        32   -> CurveGet
        32   -> LeastSquareInt16a1
      32   CurveSlopeGetRight
        32   -> CurveGet
        32   -> LeastSquareInt16a1
      24   ErrorGet
        24   -> AbsRe
        24   -> __aeabi_f2iz
        24   -> __aeabi_fadd
        24   -> __aeabi_fdiv
        24   -> __aeabi_i2f
        24   -> __aeabi_ui2f
       0   GyroResultForbidSpeDeal
       8   ImagePro
         8   -> BlackGet
         8   -> BrickAvoid
         8   -> CenterLineGetRaw
         8   -> GyroResultForbidSpeDeal
         8   -> ImageProParaInit
         8   -> ImgProFailDeal
         8   -> ImgProSucceedDeal
         8   -> ImgPut
         8   -> PathJudgeNew
       0   ImageProParaInit
       8   ImageSend
         8   -> ImgPut
         8   -> SendImage
       8   ImgProFailDeal
         8   -> BoundaryLimitRe
         8   -> MinRe
       8   ImgProSucceedDeal
         8   -> BoundaryLimitRe
         8   -> DeviationFuse
         8   -> MaxRe
         8   -> MinRe
         8   -> MtrGet
      16   ImgPut
      16   ImgReversePut
      16   ImgSendPut
      16   LeastSquareInt16a0
      20   LeastSquareInt16a1
      16   LeastSquarea0
      20   LeastSquarea1
       0   MathSqrt
       0   MaxRe
       0   MinRe
       8   PathJudge
         8   -> PathLCRAngle1Judge
       8   PathJudgeNew
         8   -> BrickJudge
         8   -> PathJudgeNewStraight
       8   PathJudgeNewStraight
         8   -> MinRe
      24   PathLCRAngle1Judge
        24   -> AbsInt
        24   -> AngleStep1Judge
        24   -> CurveSlopeGet
       8   PathSmallSJudgeStep1
         8   -> PathSmallSJudgeStep2
       0   PathSmallSJudgeStep2
       4   SABCGet
      16   SendCenterLineLoc
        16   -> uart_send1
        16   -> uart_sendN
      24   SendImage
        24   -> uart_send1
        24   -> uart_sendN
      16   ShiZhiCheck
        16   -> AbsInt
        16   -> MaxRe
        16   -> MinRe
      24   StopLineCheck
        24   -> AbsInt
       0   VariablesInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable17
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_10
       4  ??DataTable20_11
       4  ??DataTable20_12
       4  ??DataTable20_13
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable20_9
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_10
       4  ??DataTable24_11
       4  ??DataTable24_12
       4  ??DataTable24_13
       4  ??DataTable24_14
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
       4  ??DataTable24_9
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_10
       4  ??DataTable25_11
       4  ??DataTable25_12
       4  ??DataTable25_13
       4  ??DataTable25_14
       4  ??DataTable25_15
       4  ??DataTable25_16
       4  ??DataTable25_17
       4  ??DataTable25_18
       4  ??DataTable25_19
       4  ??DataTable25_2
       4  ??DataTable25_20
       4  ??DataTable25_21
       4  ??DataTable25_22
       4  ??DataTable25_23
       4  ??DataTable25_3
       4  ??DataTable25_4
       4  ??DataTable25_5
       4  ??DataTable25_6
       4  ??DataTable25_7
       4  ??DataTable25_8
       4  ??DataTable25_9
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ??DataTable26_5
       4  ??DataTable26_6
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       4  ??DataTable27_5
       4  ??DataTable27_6
       4  ??DataTable27_7
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_2
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_2
       4  ??DataTable29_3
       4  ??DataTable29_4
       4  ??DataTable29_5
       4  ??DataTable29_6
       4  ??DataTable29_7
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_2
       4  ??DataTable32_3
       4  ??DataTable32_4
       4  ??DataTable32_5
       4  ??DataTable33
       4  ??DataTable33_1
       4  ??DataTable33_2
       4  ??DataTable33_3
       4  ??DataTable33_4
       4  ??DataTable33_5
       4  ??DataTable33_6
       4  ??DataTable33_7
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_2
       4  ??DataTable34_3
       4  ??DataTable34_4
       4  ??DataTable34_5
       4  ??DataTable34_6
       4  ??DataTable34_7
       4  ??DataTable36
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable37_2
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_10
       4  ??DataTable38_11
       4  ??DataTable38_12
       4  ??DataTable38_13
       4  ??DataTable38_14
       4  ??DataTable38_15
       4  ??DataTable38_16
       4  ??DataTable38_17
       4  ??DataTable38_2
       4  ??DataTable38_3
       4  ??DataTable38_4
       4  ??DataTable38_5
       4  ??DataTable38_6
       4  ??DataTable38_7
       4  ??DataTable38_8
       4  ??DataTable38_9
       4  ??DataTable40
       4  ??DataTable40_1
       4  ??DataTable40_10
       4  ??DataTable40_11
       4  ??DataTable40_12
       4  ??DataTable40_13
       4  ??DataTable40_14
       4  ??DataTable40_15
       4  ??DataTable40_16
       4  ??DataTable40_17
       4  ??DataTable40_18
       4  ??DataTable40_19
       4  ??DataTable40_2
       4  ??DataTable40_20
       4  ??DataTable40_21
       4  ??DataTable40_22
       4  ??DataTable40_23
       4  ??DataTable40_24
       4  ??DataTable40_25
       4  ??DataTable40_26
       4  ??DataTable40_27
       4  ??DataTable40_28
       4  ??DataTable40_29
       4  ??DataTable40_3
       4  ??DataTable40_30
       4  ??DataTable40_31
       4  ??DataTable40_32
       4  ??DataTable40_33
       4  ??DataTable40_34
       4  ??DataTable40_35
       4  ??DataTable40_36
       4  ??DataTable40_37
       4  ??DataTable40_38
       4  ??DataTable40_39
       4  ??DataTable40_4
       4  ??DataTable40_40
       4  ??DataTable40_5
       4  ??DataTable40_6
       4  ??DataTable40_7
       4  ??DataTable40_8
       4  ??DataTable40_9
       4  ??DataTable41
       4  ??DataTable41_1
       4  ??DataTable41_2
       4  ??DataTable41_3
       4  ??DataTable41_4
       4  ??DataTable41_5
       4  ??DataTable41_6
       4  ??DataTable42
       4  ??DataTable42_1
       4  ??DataTable42_2
       4  ??DataTable42_3
       4  ??DataTable42_4
       4  ??DataTable42_5
       4  ??DataTable42_6
       4  ??DataTable43
       4  ??DataTable43_1
       4  ??DataTable43_10
       4  ??DataTable43_11
       4  ??DataTable43_12
       4  ??DataTable43_13
       4  ??DataTable43_14
       4  ??DataTable43_15
       4  ??DataTable43_16
       4  ??DataTable43_17
       4  ??DataTable43_18
       4  ??DataTable43_19
       4  ??DataTable43_2
       4  ??DataTable43_20
       4  ??DataTable43_21
       4  ??DataTable43_22
       4  ??DataTable43_23
       4  ??DataTable43_24
       4  ??DataTable43_25
       4  ??DataTable43_26
       4  ??DataTable43_3
       4  ??DataTable43_4
       4  ??DataTable43_5
       4  ??DataTable43_6
       4  ??DataTable43_7
       4  ??DataTable43_8
       4  ??DataTable43_9
       4  ??DataTable44
       4  ??DataTable45
       4  ??DataTable45_1
       4  ??DataTable45_2
       4  ??DataTable48
       4  ??DataTable48_1
       4  ??DataTable48_10
       4  ??DataTable48_11
       4  ??DataTable48_12
       4  ??DataTable48_13
       4  ??DataTable48_14
       4  ??DataTable48_15
       4  ??DataTable48_16
       4  ??DataTable48_17
       4  ??DataTable48_18
       4  ??DataTable48_19
       4  ??DataTable48_2
       4  ??DataTable48_20
       4  ??DataTable48_21
       4  ??DataTable48_22
       4  ??DataTable48_23
       4  ??DataTable48_24
       4  ??DataTable48_25
       4  ??DataTable48_26
       4  ??DataTable48_27
       4  ??DataTable48_28
       4  ??DataTable48_29
       4  ??DataTable48_3
       4  ??DataTable48_30
       4  ??DataTable48_31
       4  ??DataTable48_32
       4  ??DataTable48_33
       4  ??DataTable48_34
       4  ??DataTable48_35
       4  ??DataTable48_36
       4  ??DataTable48_37
       4  ??DataTable48_4
       4  ??DataTable48_5
       4  ??DataTable48_6
       4  ??DataTable48_7
       4  ??DataTable48_8
       4  ??DataTable48_9
       4  ??DataTable49
       4  ??DataTable50
       4  ??DataTable53
       4  ??DataTable53_1
       4  ??DataTable54
       4  ??DataTable54_1
       4  ??DataTable54_2
       4  ??DataTable54_3
       4  ??DataTable56
       4  ??DataTable56_1
       4  ??DataTable56_2
       4  ??DataTable56_3
       4  ??DataTable56_4
       4  ??DataTable56_5
       4  ??DataTable56_6
       4  ??DataTable57
       4  ??DataTable57_1
       4  ??DataTable57_10
       4  ??DataTable57_11
       4  ??DataTable57_12
       4  ??DataTable57_13
       4  ??DataTable57_14
       4  ??DataTable57_15
       4  ??DataTable57_16
       4  ??DataTable57_17
       4  ??DataTable57_18
       4  ??DataTable57_19
       4  ??DataTable57_2
       4  ??DataTable57_20
       4  ??DataTable57_21
       4  ??DataTable57_22
       4  ??DataTable57_23
       4  ??DataTable57_3
       4  ??DataTable57_4
       4  ??DataTable57_5
       4  ??DataTable57_6
       4  ??DataTable57_7
       4  ??DataTable57_8
       4  ??DataTable57_9
       4  ??DataTable58
       4  ??DataTable58_1
       4  ??DataTable58_10
       4  ??DataTable58_11
       4  ??DataTable58_12
       4  ??DataTable58_13
       4  ??DataTable58_2
       4  ??DataTable58_3
       4  ??DataTable58_4
       4  ??DataTable58_5
       4  ??DataTable58_6
       4  ??DataTable58_7
       4  ??DataTable58_8
       4  ??DataTable58_9
       4  ??DataTable59
       4  ??DataTable59_1
       4  ??DataTable59_2
       4  ??DataTable59_3
       4  ??DataTable59_4
       4  ??DataTable59_5
       4  ??DataTable59_6
       4  ??DataTable59_7
       4  ??DataTable59_8
       4  ??DataTable6
       4  ??DataTable60
       4  ??DataTable60_1
       4  ??DataTable60_2
       4  ??DataTable60_3
       4  ??DataTable60_4
       4  ??DataTable60_5
       4  ??DataTable60_6
       4  ??DataTable60_7
       4  ??DataTable60_8
       4  ??DataTable61
       4  ??DataTable61_1
       4  ??DataTable61_2
       4  ??DataTable61_3
       4  ??DataTable61_4
       4  ??DataTable61_5
       4  ??DataTable61_6
       4  ??DataTable61_7
       4  ??DataTable64
       4  ??DataTable65
       4  ??DataTable65_1
       4  ??DataTable65_2
       4  ??DataTable65_3
       4  ??DataTable65_4
       4  ??DataTable65_5
       4  ??DataTable65_6
       4  ??DataTable65_7
       4  ??DataTable65_8
       4  ??DataTable65_9
       4  ??DataTable66
       4  ??DataTable66_1
       4  ??DataTable66_2
       4  ??DataTable66_3
       4  ??DataTable66_4
       4  ??DataTable67
       4  ??DataTable67_1
       4  ??DataTable67_10
       4  ??DataTable67_11
       4  ??DataTable67_12
       4  ??DataTable67_13
       4  ??DataTable67_14
       4  ??DataTable67_15
       4  ??DataTable67_16
       4  ??DataTable67_17
       4  ??DataTable67_18
       4  ??DataTable67_19
       4  ??DataTable67_2
       4  ??DataTable67_20
       4  ??DataTable67_21
       4  ??DataTable67_22
       4  ??DataTable67_23
       4  ??DataTable67_24
       4  ??DataTable67_25
       4  ??DataTable67_26
       4  ??DataTable67_27
       4  ??DataTable67_28
       4  ??DataTable67_29
       4  ??DataTable67_3
       4  ??DataTable67_30
       4  ??DataTable67_31
       4  ??DataTable67_32
       4  ??DataTable67_33
       4  ??DataTable67_34
       4  ??DataTable67_4
       4  ??DataTable67_5
       4  ??DataTable67_6
       4  ??DataTable67_7
       4  ??DataTable67_8
       4  ??DataTable67_9
       4  ??DataTable68
       4  ??DataTable68_1
       4  ??DataTable68_10
       4  ??DataTable68_2
       4  ??DataTable68_3
       4  ??DataTable68_4
       4  ??DataTable68_5
       4  ??DataTable68_6
       4  ??DataTable68_7
       4  ??DataTable68_8
       4  ??DataTable68_9
       4  ??DataTable69
       4  ??DataTable69_1
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
       4  ??DataTable7
       4  ??DataTable71
       4  ??DataTable71_1
       4  ??DataTable71_2
       4  ??DataTable71_3
       4  ??DataTable71_4
       4  ??DataTable71_5
       4  ??DataTable71_6
       4  ??DataTable71_7
       4  ??DataTable71_8
       4  ??DataTable71_9
       4  ??DataTable72
       4  ??DataTable72_1
       4  ??DataTable72_2
       4  ??DataTable72_3
       4  ??DataTable72_4
       4  ??DataTable74
       4  ??DataTable74_1
       4  ??DataTable74_2
       4  ??DataTable75
       4  ??DataTable75_1
       4  ??DataTable75_2
       4  ??DataTable76
       4  ??DataTable76_1
       4  ??DataTable76_2
       4  ??DataTable76_3
       4  ??DataTable76_4
       4  ??DataTable76_5
       4  ??DataTable77
       4  ??DataTable78
       4  ??DataTable78_1
       4  ??DataTable78_10
       4  ??DataTable78_11
       4  ??DataTable78_12
       4  ??DataTable78_13
       4  ??DataTable78_14
       4  ??DataTable78_15
       4  ??DataTable78_16
       4  ??DataTable78_17
       4  ??DataTable78_18
       4  ??DataTable78_19
       4  ??DataTable78_2
       4  ??DataTable78_20
       4  ??DataTable78_21
       4  ??DataTable78_22
       4  ??DataTable78_23
       4  ??DataTable78_24
       4  ??DataTable78_25
       4  ??DataTable78_26
       4  ??DataTable78_27
       4  ??DataTable78_28
       4  ??DataTable78_29
       4  ??DataTable78_3
       4  ??DataTable78_30
       4  ??DataTable78_31
       4  ??DataTable78_32
       4  ??DataTable78_33
       4  ??DataTable78_34
       4  ??DataTable78_35
       4  ??DataTable78_36
       4  ??DataTable78_37
       4  ??DataTable78_38
       4  ??DataTable78_39
       4  ??DataTable78_4
       4  ??DataTable78_40
       4  ??DataTable78_41
       4  ??DataTable78_42
       4  ??DataTable78_43
       4  ??DataTable78_44
       4  ??DataTable78_45
       4  ??DataTable78_46
       4  ??DataTable78_47
       4  ??DataTable78_48
       4  ??DataTable78_49
       4  ??DataTable78_5
       4  ??DataTable78_50
       4  ??DataTable78_51
       4  ??DataTable78_52
       4  ??DataTable78_53
       4  ??DataTable78_54
       4  ??DataTable78_55
       4  ??DataTable78_56
       4  ??DataTable78_57
       4  ??DataTable78_58
       4  ??DataTable78_59
       4  ??DataTable78_6
       4  ??DataTable78_60
       4  ??DataTable78_61
       4  ??DataTable78_62
       4  ??DataTable78_63
       4  ??DataTable78_64
       4  ??DataTable78_65
       4  ??DataTable78_66
       4  ??DataTable78_67
       4  ??DataTable78_68
       4  ??DataTable78_69
       4  ??DataTable78_7
       4  ??DataTable78_70
       4  ??DataTable78_71
       4  ??DataTable78_72
       4  ??DataTable78_73
       4  ??DataTable78_74
       4  ??DataTable78_75
       4  ??DataTable78_76
       4  ??DataTable78_77
       4  ??DataTable78_78
       4  ??DataTable78_79
       4  ??DataTable78_8
       4  ??DataTable78_80
       4  ??DataTable78_81
       4  ??DataTable78_82
       4  ??DataTable78_83
       4  ??DataTable78_84
       4  ??DataTable78_85
       4  ??DataTable78_9
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_15
       4  ??DataTable7_16
       4  ??DataTable7_17
       4  ??DataTable7_18
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ?_0
       4  ?_1
       8  AbsInt
      12  AbsRe
       1  AngleConfirmCount
       2  AngleConfirmCountMax
       1  AngleConfirmLockFlag
       8  AngleConfirmMat
       1  AngleConfirmMatCollect
       1  AngleConfirmMatLimit
       1  AngleHeadLineNum
       1  AngleLongHeadLineStrategy
       1  AngleSpeDealBackCount
     120  AngleSpeDealCen
      32  AngleSpeDealDeviNow
       1  AngleSpeDealDir
      80  AngleSpeDealExitJudge
       1  AngleSpeDealExitJudgeFlag
       1  AngleSpeDealFlag
      60  AngleSpeDealSlopeC
    2028  AngleStep1Judge
     628  AngleStep1JudgeNotBrick
       1  AngleStep1NotBrickBorderColL
       1  AngleStep1NotBrickBorderColR
       1  AngleStep1NotBrickEndColL
       1  AngleStep1NotBrickEndColR
     398  AngleStep2Confirm
     416  AngleZoneConfirm
       1  AngleZoneConfirmCount
       1  AngleZoneConfirmLockFlag
       1  AngleZoneConfirmLockMeterCount
       8  AngleZoneConfirmMat
       1  AngleZoneConfirmMatCollect
       1  AngleZoneConfirmMatLimit
    1898  AngleZoneJudge
       8  AngleZoneJudgeColL
       8  AngleZoneJudgeColLFlag
       8  AngleZoneJudgeColR
       8  AngleZoneJudgeColRFlag
       8  AngleZoneJudgeCountColL
       8  AngleZoneJudgeCountColR
       8  AngleZoneJudgeRowL
       8  AngleZoneJudgeRowR
       1  BaseRowControlNum
       4  BlackBigChangeFinalCheck
       1  BlackBigChangeFinalCheckFlag
       1  BlackCenEdgeStartCol
     586  BlackGet
    1708  BlackGetLeft
     340  BlackGetLeftCrossSpeScan
     404  BlackGetLeftCrossSpeWin
     670  BlackGetLeftJustWin
     270  BlackGetLeftParaInit
    2052  BlackGetLeftStep1Edge
     566  BlackGetLeftStep1Scan
     436  BlackGetLeftStep2Win
     240  BlackGetPre
       1  BlackGetPreDir
    1608  BlackGetRight
     340  BlackGetRightCrossSpeScan
     404  BlackGetRightCrossSpeWin
     402  BlackGetRightJustWin
     268  BlackGetRightParaInit
    1662  BlackGetRightStep1Edge
     564  BlackGetRightStep1Scan
     428  BlackGetRightStep2Win
       1  BlackLeft3ResetCount
     240  BlackLeft5Slope
       1  BlackLeft5SlopeIndex
      60  BlackLeft5SlopeRow
     936  BlackLeftAgainForCross
     654  BlackLeftBigChangeCheck
       1  BlackLeftBigChangeCheckAllRow
      60  BlackLeftBigChangeCheckRow
       1  BlackLeftBigChangeFlag
       1  BlackLeftBigChangeJumpFlag
       8  BlackLeftBigChangeNumx
       8  BlackLeftBigChangeNumy
       4  BlackLeftBigChangeSlopeStore
     978  BlackLeftContinueAdd
       1  BlackLeftContinueFlag
     350  BlackLeftCrossConfirm
       1  BlackLeftCrossConfirmFlag
       1  BlackLeftCrossDone
     300  BlackLeftCrossStep3
       1  BlackLeftCrossTailEndLine
       1  BlackLeftCrossTailFlag
       1  BlackLeftCrossTooLowLine
       1  BlackLeftDone
       1  BlackLeftEdgeStartCol
      60  BlackLeftEdgeStartColOffset
       1  BlackLeftEndLine
     174  BlackLeftHeadEndSearch
       1  BlackLeftHeadLine
       1  BlackLeftLastEdgeStartCol
     180  BlackLeftLoc
      60  BlackLeftPredictL
      60  BlackLeftPredictR
       2  BlackLeftRealB
      50  BlackLeftRealClear
       2  BlackLeftRealW
       2  BlackLeftRealWB
     160  BlackLeftRollCheck
       1  BlackLeftRollCheckFlag
       1  BlackLeftRow1RealLastLine
       1  BlackLeftStep1ScanRow
     648  BlackLeftStep4BackLine
      62  BlackLeftStep4ErrorCheck
       1  BlackLeftStep4Flag
       1  BlackLeftStep4StartLine
       1  BlackLeftWinPredictStore0
       1  BlackLeftWinPredictStore1
       1  BlackLeftWinPredictStore2
       1  BlackRight3ResetCount
     240  BlackRight5Slope
       1  BlackRight5SlopeIndex
      60  BlackRight5SlopeRow
     946  BlackRightAgainForCross
     676  BlackRightBigChangeCheck
       1  BlackRightBigChangeCheckAllRow
      60  BlackRightBigChangeCheckRow
       1  BlackRightBigChangeFlag
       1  BlackRightBigChangeJumpFlag
       8  BlackRightBigChangeNumx
       8  BlackRightBigChangeNumy
       4  BlackRightBigChangeSlopeStore
    1030  BlackRightContinueAdd
       1  BlackRightContinueFlag
     374  BlackRightCrossConfirm
       1  BlackRightCrossConfirmFlag
       1  BlackRightCrossDone
     306  BlackRightCrossStep3
       1  BlackRightCrossTailEndLine
       1  BlackRightCrossTailFlag
       1  BlackRightCrossTooLowLine
       1  BlackRightDone
       1  BlackRightEdgeStartCol
      60  BlackRightEdgeStartColOffset
       1  BlackRightEndLine
     208  BlackRightHeadEndSearch
       1  BlackRightHeadLine
       1  BlackRightLastEdgeStartCol
     180  BlackRightLoc
      60  BlackRightPredictL
      60  BlackRightPredictR
       2  BlackRightRealB
      50  BlackRightRealClear
       2  BlackRightRealW
       2  BlackRightRealWB
     158  BlackRightRollCheck
       1  BlackRightRollCheckFlag
       1  BlackRightRow1RealLastLine
       1  BlackRightStep1ScanRow
     628  BlackRightStep4BackLine
      62  BlackRightStep4ErrorCheck
       1  BlackRightStep4Flag
       1  BlackRightStep4StartLine
       1  BlackRightWinPredictStore0
       1  BlackRightWinPredictStore1
       1  BlackRightWinPredictStore2
       1  BlackSingleDir
       1  BlackSingleFlag
    2994  BlackSingleSpeCheck
    1290  BlackUdis
     480  BlackUdisLeftLocation
      32  BlackUdisMatrixFar
      32  BlackUdisMatrixLow
      32  BlackUdisMatrixMiddle
     480  BlackUdisRightLocation
      18  BoundaryLimitRe
     422  BrickAvoid
       1  BrickBorderColL
       1  BrickBorderColR
       1  BrickConfirmCount
       2  BrickConfirmCountMax
       1  BrickConfirmFinalColCom
       1  BrickConfirmLockFlag
       8  BrickConfirmMat0
       8  BrickConfirmMat1
       1  BrickConfirmMatCollect0
       1  BrickConfirmMatCollect1
       1  BrickConfirmMatLimit
       1  BrickEndColL
       1  BrickEndColR
       1  BrickHeadColL
       1  BrickHeadColR
    1344  BrickJudge
       1  BrickLineCountNumRecord
       1  BrickSpeDealBackCount
      80  BrickSpeDealBias
     356  BrickSpeDealCen
       1  BrickSpeDealCenFlag
       1  BrickSpeDealDir
       4  BrickSpeDealExitJudge
       1  BrickSpeDealExitJudgeFlag
       1  BrickSpeDealFlag
      86  BrickSpeDealServor
       4  BrickSpeDealStartJudge
       1  BrickSpeDealStartJudgeCol
       2  CURVEC
       2  CURVEL
       2  CURVER
       1  CameraRealLeftCol
       1  CenterEndLine
       1  CenterHeadLine
       1  CenterKeyLine
    5120  CenterLineGet
    4946  CenterLineGetNormal
      36  CenterLineGetRaw
    1428  CenterLineGetSingleWrongAdd
      60  CenterLineHalfWidth
      36  CenterLineHalfWidthGet
     120  CenterLineLoc
       1  CenterLineResult
       1  CenterLocStore
       8  ControlRowDeviInit
       8  ControlRowDeviOld
       4  ControlRowWeight
     342  CurveGet
       1  CurveLineChosenC1
       1  CurveLineChosenC2
       1  CurveLineChosenC3
       1  CurveLineChosenL1
       1  CurveLineChosenL2
       1  CurveLineChosenL3
       1  CurveLineChosenR1
       1  CurveLineChosenR2
       1  CurveLineChosenR3
       1  CurveSlopeFlagC
       1  CurveSlopeFlagL
       1  CurveSlopeFlagR
      64  CurveSlopeGet
     508  CurveSlopeGetCenter
     570  CurveSlopeGetLeft
     562  CurveSlopeGetRight
       1  DeviFlag
       4  DeviFuse
      40  DeviFuseArray
       4  DeviFuse_old
       8  DeviNowArray
       4  DeviNowArrayWight
       1  DeviNowLevel
       4  DeviPre
       4  DeviPrePre
       4  DeviPrePrePre
       1  DeviRowChosen
       4  Devi_far
       4  Devi_near
       1  EmergencyStopCount
       1  EmergencyStopFlag
       2  ErrorCountNow5
     186  ErrorGet
       1  ErrorGetCen
       1  ErrorGetSelf
       1  FuzzyDegree
     178  GyroResultForbidSpeDeal
     200  ImagePro
     332  ImageProParaInit
      16  ImageSend
       1  ImgBlackSucceedFlag
       1  ImgCenterSucceedFlag
   15000  ImgNew
       1  ImgProFailCount
     546  ImgProFailDeal
     564  ImgProSucceedDeal
       1  ImgProSucceedFlag
     168  ImgPut
     184  ImgReversePut
      78  ImgSendPut
      64  LeastSquareInt16a0
     108  LeastSquareInt16a1
      62  LeastSquarea0
     108  LeastSquarea1
       1  LimitLeftB
       1  LimitLeftBMax
       1  LimitLeftBMin
       1  LimitLeftHeadB
       1  LimitLeftHeadW
       1  LimitLeftHeadWB
       1  LimitLeftW
       1  LimitLeftWB
      60  LimitLeftWBAdjust
       1  LimitLeftWBMax
       1  LimitLeftWBMin
       1  LimitLeftWMax
       1  LimitLeftWMin
       1  LimitRightB
       1  LimitRightBMax
       1  LimitRightBMin
       1  LimitRightHeadB
       1  LimitRightHeadW
       1  LimitRightHeadWB
       1  LimitRightW
       1  LimitRightWB
      60  LimitRightWBAdjust
       1  LimitRightWBMax
       1  LimitRightWBMin
       1  LimitRightWMax
       1  LimitRightWMin
      46  MathSqrt
       8  MaxRe
       8  MinRe
      28  PathJudge
       1  PathJudgeDone
     212  PathJudgeNew
     740  PathJudgeNewStraight
    1072  PathLCRAngle1Judge
       1  PathRealStraightCount
       1  PathRealStraightCountLimit
       1  PathRealStraightFlag
       1  PathSmallSDir
       1  PathSmallSDoneFlag
     868  PathSmallSJudgeStep1
     242  PathSmallSJudgeStep2
       1  PathType
       1  RoadHalfWidth
       4  RoadHalfWidthCompen
       1  RoadHalfWidthLast
      60  RoadHalfWidthRecord
       1  RoadHalfWidthSingle
       1  RoadHalfWidthSwitch
       1  RoadHalfWidthWrongDir
       1  RoadHalfWidthWrongFlag
       1  RunOutFlag
       2  SABCC
      46  SABCGet
       2  SABCL
       2  SABCR
      52  SendCenterLineLoc
      74  SendImage
       4  ServoPIDDGetVal
       4  ServoPIDDGetValOld
     580  ShiZhiCheck
       1  ShiZhiCount
       1  ShiZhiFlag
       1  SingleBlackAllFlag
      60  SingleBlackFlag
       1  SingleBlackLastAllFlag
      60  SingleBlackWidthMax
      60  SingleBlackWidthMin
       1  SingleDoneFlag
       1  SingleFloorConfirmCount
       1  SingleFloorConfirmCountMax
       1  SingleFloorFlag
       4  SlopeC
       4  SlopeL
       4  SlopeR
     770  StopLineCheck
       1  StopLineCheckBeginFlag
       1  StopLineCheckFlag
       1  StopLineCheckTimer
     272  VariablesInit
       2  Weight_sum
       2  buXianCount
       1  flag000
       4  flag111
       4  flag222
       1  limitStopLineBlackXiu
       1  xiaoZhiDaoFlag

 
 17 920 bytes in section .bss
     72 bytes in section .data
    700 bytes in section .rodata
 57 596 bytes in section .text
 
 57 596 bytes of CODE  memory
    700 bytes of CONST memory
 17 992 bytes of DATA  memory

Errors: none
Warnings: 14
