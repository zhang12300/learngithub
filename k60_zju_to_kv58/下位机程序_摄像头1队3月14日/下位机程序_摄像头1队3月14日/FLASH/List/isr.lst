###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.3.8024/W32 for ARM        14/Mar/2018  19:12:13
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\C\isr.c
#    Command line =  
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\C\isr.c -D IAR
#        -D TWR_K60N512 -lCN
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\FLASH\List\ -lB
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\FLASH\List\ -o
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\FLASH\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\H\ -I
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\H\Component_H\
#        -I E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\H\Frame_H\ -I
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\H\Function_H\ -I
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\H\SD_H\ -Ol
#        --use_c++_inline
#    List file    =  
#        E:\智能车\程序\下位机程序_摄像头1队3月9日\FLASH\List\isr.lst
#    Object file  =  E:\智能车\程序\下位机程序_摄像头1队3月9日\FLASH\Obj\isr.o
#
###############################################################################

E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\C\isr.c
      1          //-------------------------------------------------------------------------*
      2          // 文件名: isr.c                                                           *
      3          // 说  明: 中断处理例程                                                    *
      4          //---------------苏州大学飞思卡尔嵌入式系统实验室2011年--------------------*
      5          
      6          #include "includes.h"
      7          #include "common.h"
      8          #include "DMA.h"
      9          #include "ImageGet.h"
     10          #include "Pit.h"
     11          #include "RunControl.h"
     12          #include "Debug.h"
     13          

   \                                 In section .bss, align 4
     14          uint32 ErrorCountNow9 = 0;
   \                     ErrorCountNow9:
   \   00000000                      DS8 4
     15          

   \                                 In section .bss, align 1
     16          uint8 QuadChangeFlag = 0;       //左右编码器切换标志位 
   \                     QuadChangeFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     17          uint32 QuadLeftCount = 0;       //左编码器计数值，越大表示速度越快。
   \                     QuadLeftCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     18          uint32 QuadRightCount = 0;      //右编码器计数值，越大表示速度越快。
   \                     QuadRightCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     19          uint8 PIT0Count = 0;            //PIT0计数值
   \                     PIT0Count:
   \   00000000                      DS8 1
     20          

   \                                 In section .bss, align 2
     21          uint16 DiffCountL = 0;        //用于差速测量时，左轮脉冲数的总计数。
   \                     DiffCountL:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     22          uint16 DiffCountR = 0;        //用于差速测量时，右轮脉冲数的总计数。
   \                     DiffCountR:
   \   00000000                      DS8 2
     23          

   \                                 In section .bss, align 1
     24          uint8 PIT2_Isr_Change = 0;    //PIT2的功能复用选择。0表示用于发车时的5秒计数，1表示用于定时停车。
   \                     PIT2_Isr_Change:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     25          uint8 LightHouseWaitStartTooLongFlag = 0;   //灯塔等久标志位置位
   \                     LightHouseWaitStartTooLongFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     26          volatile uint8 QuadDoneFlag = 0;         //编码器速度值采集完成标志，0未完成，1完成。
   \                     QuadDoneFlag:
   \   00000000                      DS8 1
     27          
     28          //串口相关

   \                                 In section .bss, align 1
     29          uint8 ch0;
   \                     ch0:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     30          uint8 ch1;
   \                     ch1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     31          uint8 ch2;
   \                     ch2:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     32          uint8 ch3;
   \                     ch3:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     33          uint8 ch4;
   \                     ch4:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     34          uint8 ch5;
   \                     ch5:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     35          uint8 ch6;
   \                     ch6:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     36          uint8 cnt = 0;
   \                     cnt:
   \   00000000                      DS8 1
     37          
     38          //-------------------------------------------------------------------------*
     39          //函数名: uart3_isr                                                        *
     40          //功  能: 串口3数据接收中断例程                                            *
     41          //说  明: 无                                                               *
     42          //-------------------------------------------------------------------------*

   \                                 In section .text, align 4, keep-with-next
     43          void uart0_isr(void)
     44          {
   \                     uart0_isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     45              uint8 ch;
     46              DisableInterrupts;		//关总中断
   \   00000002   0xB672             CPSID i
     47              
     48              if(cnt == 0){uart_re1 (UART0,&ch0);cnt++;}
   \   00000004   0x....             LDR.N    R0,??DataTable9
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD108             BNE.N    ??uart0_isr_0
   \   0000000C   0x....             LDR.N    R1,??DataTable9_1
   \   0000000E   0x....             LDR.N    R0,??DataTable9_2  ;; 0x4006a000
   \   00000010   0x.... 0x....      BL       uart_re1
   \   00000014   0x....             LDR.N    R0,??DataTable9
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0x....             LDR.N    R1,??DataTable9
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
     49              if(cnt == 1){uart_re1 (UART0,&ch1);cnt++;}
   \                     ??uart0_isr_0: (+1)
   \   0000001E   0x....             LDR.N    R0,??DataTable9
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD108             BNE.N    ??uart0_isr_1
   \   00000026   0x....             LDR.N    R1,??DataTable9_3
   \   00000028   0x....             LDR.N    R0,??DataTable9_2  ;; 0x4006a000
   \   0000002A   0x.... 0x....      BL       uart_re1
   \   0000002E   0x....             LDR.N    R0,??DataTable9
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \   00000034   0x....             LDR.N    R1,??DataTable9
   \   00000036   0x7008             STRB     R0,[R1, #+0]
     50              if(cnt == 2){uart_re1 (UART0,&ch2);cnt++;}
   \                     ??uart0_isr_1: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable9
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2802             CMP      R0,#+2
   \   0000003E   0xD108             BNE.N    ??uart0_isr_2
   \   00000040   0x....             LDR.N    R1,??DataTable9_4
   \   00000042   0x....             LDR.N    R0,??DataTable9_2  ;; 0x4006a000
   \   00000044   0x.... 0x....      BL       uart_re1
   \   00000048   0x....             LDR.N    R0,??DataTable9
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x....             LDR.N    R1,??DataTable9
   \   00000050   0x7008             STRB     R0,[R1, #+0]
     51              if(cnt == 3){uart_re1 (UART0,&ch3);cnt++;}
   \                     ??uart0_isr_2: (+1)
   \   00000052   0x....             LDR.N    R0,??DataTable9
   \   00000054   0x7800             LDRB     R0,[R0, #+0]
   \   00000056   0x2803             CMP      R0,#+3
   \   00000058   0xD108             BNE.N    ??uart0_isr_3
   \   0000005A   0x....             LDR.N    R1,??DataTable9_5
   \   0000005C   0x....             LDR.N    R0,??DataTable9_2  ;; 0x4006a000
   \   0000005E   0x.... 0x....      BL       uart_re1
   \   00000062   0x....             LDR.N    R0,??DataTable9
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x1C40             ADDS     R0,R0,#+1
   \   00000068   0x....             LDR.N    R1,??DataTable9
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
     52              if(cnt == 4){uart_re1 (UART0,&ch4);cnt++;}
   \                     ??uart0_isr_3: (+1)
   \   0000006C   0x....             LDR.N    R0,??DataTable9
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0x2804             CMP      R0,#+4
   \   00000072   0xD108             BNE.N    ??uart0_isr_4
   \   00000074   0x....             LDR.N    R1,??DataTable9_6
   \   00000076   0x....             LDR.N    R0,??DataTable9_2  ;; 0x4006a000
   \   00000078   0x.... 0x....      BL       uart_re1
   \   0000007C   0x....             LDR.N    R0,??DataTable9
   \   0000007E   0x7800             LDRB     R0,[R0, #+0]
   \   00000080   0x1C40             ADDS     R0,R0,#+1
   \   00000082   0x....             LDR.N    R1,??DataTable9
   \   00000084   0x7008             STRB     R0,[R1, #+0]
     53              if(cnt == 5){uart_re1 (UART0,&ch5);cnt++;}
   \                     ??uart0_isr_4: (+1)
   \   00000086   0x....             LDR.N    R0,??DataTable9
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0x2805             CMP      R0,#+5
   \   0000008C   0xD108             BNE.N    ??uart0_isr_5
   \   0000008E   0x....             LDR.N    R1,??DataTable9_7
   \   00000090   0x....             LDR.N    R0,??DataTable9_2  ;; 0x4006a000
   \   00000092   0x.... 0x....      BL       uart_re1
   \   00000096   0x....             LDR.N    R0,??DataTable9
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0x1C40             ADDS     R0,R0,#+1
   \   0000009C   0x....             LDR.N    R1,??DataTable9
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
     54              if(cnt == 6)
   \                     ??uart0_isr_5: (+1)
   \   000000A0   0x....             LDR.N    R0,??DataTable9
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0x2806             CMP      R0,#+6
   \   000000A6   0xD158             BNE.N    ??uart0_isr_6
     55              {
     56                  uart_re1 (UART0,&ch6);cnt=0;
   \   000000A8   0x....             LDR.N    R1,??DataTable9_8
   \   000000AA   0x....             LDR.N    R0,??DataTable9_2  ;; 0x4006a000
   \   000000AC   0x.... 0x....      BL       uart_re1
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x....             LDR.N    R1,??DataTable9
   \   000000B4   0x7008             STRB     R0,[R1, #+0]
     57                  if(ch0==0xFF && ch1==0x55 && ch2==0xAA && ch3==0x77 && ch4==0x01 && ch5==0x06 && ch6==0x7C)
   \   000000B6   0x....             LDR.N    R0,??DataTable9_1
   \   000000B8   0x7800             LDRB     R0,[R0, #+0]
   \   000000BA   0x28FF             CMP      R0,#+255
   \   000000BC   0xD124             BNE.N    ??uart0_isr_7
   \   000000BE   0x....             LDR.N    R0,??DataTable9_3
   \   000000C0   0x7800             LDRB     R0,[R0, #+0]
   \   000000C2   0x2855             CMP      R0,#+85
   \   000000C4   0xD120             BNE.N    ??uart0_isr_7
   \   000000C6   0x....             LDR.N    R0,??DataTable9_4
   \   000000C8   0x7800             LDRB     R0,[R0, #+0]
   \   000000CA   0x28AA             CMP      R0,#+170
   \   000000CC   0xD11C             BNE.N    ??uart0_isr_7
   \   000000CE   0x....             LDR.N    R0,??DataTable9_5
   \   000000D0   0x7800             LDRB     R0,[R0, #+0]
   \   000000D2   0x2877             CMP      R0,#+119
   \   000000D4   0xD118             BNE.N    ??uart0_isr_7
   \   000000D6   0x....             LDR.N    R0,??DataTable9_6
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0x2801             CMP      R0,#+1
   \   000000DC   0xD114             BNE.N    ??uart0_isr_7
   \   000000DE   0x....             LDR.N    R0,??DataTable9_7
   \   000000E0   0x7800             LDRB     R0,[R0, #+0]
   \   000000E2   0x2806             CMP      R0,#+6
   \   000000E4   0xD110             BNE.N    ??uart0_isr_7
   \   000000E6   0x....             LDR.N    R0,??DataTable9_8
   \   000000E8   0x7800             LDRB     R0,[R0, #+0]
   \   000000EA   0x287C             CMP      R0,#+124
   \   000000EC   0xD10C             BNE.N    ??uart0_isr_7
     58                  {
     59                      uart_sendN(UART0, (uint8 *)"\nCar Start!", 11);
   \   000000EE   0x220B             MOVS     R2,#+11
   \   000000F0   0x....             LDR.N    R1,??DataTable9_9
   \   000000F2   0x....             LDR.N    R0,??DataTable9_2  ;; 0x4006a000
   \   000000F4   0x.... 0x....      BL       uart_sendN
     60                      StopRealFlag = 0;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x....             LDR.N    R1,??DataTable9_10
   \   000000FC   0x7008             STRB     R0,[R1, #+0]
     61                      light_control(PORTE, 26, Light_ON);
   \   000000FE   0x2200             MOVS     R2,#+0
   \   00000100   0x211A             MOVS     R1,#+26
   \   00000102   0x....             LDR.N    R0,??DataTable9_11  ;; 0x400ff100
   \   00000104   0x.... 0x....      BL       light_control
     62                  }
     63                  if(ch0==0xFF && ch1==0x55 && ch2==0xAA && ch3==0x77 && ch4==0x01 && ch5==0x07 && ch6==0x7D)
   \                     ??uart0_isr_7: (+1)
   \   00000108   0x....             LDR.N    R0,??DataTable9_1
   \   0000010A   0x7800             LDRB     R0,[R0, #+0]
   \   0000010C   0x28FF             CMP      R0,#+255
   \   0000010E   0xD124             BNE.N    ??uart0_isr_6
   \   00000110   0x....             LDR.N    R0,??DataTable9_3
   \   00000112   0x7800             LDRB     R0,[R0, #+0]
   \   00000114   0x2855             CMP      R0,#+85
   \   00000116   0xD120             BNE.N    ??uart0_isr_6
   \   00000118   0x....             LDR.N    R0,??DataTable9_4
   \   0000011A   0x7800             LDRB     R0,[R0, #+0]
   \   0000011C   0x28AA             CMP      R0,#+170
   \   0000011E   0xD11C             BNE.N    ??uart0_isr_6
   \   00000120   0x....             LDR.N    R0,??DataTable9_5
   \   00000122   0x7800             LDRB     R0,[R0, #+0]
   \   00000124   0x2877             CMP      R0,#+119
   \   00000126   0xD118             BNE.N    ??uart0_isr_6
   \   00000128   0x....             LDR.N    R0,??DataTable9_6
   \   0000012A   0x7800             LDRB     R0,[R0, #+0]
   \   0000012C   0x2801             CMP      R0,#+1
   \   0000012E   0xD114             BNE.N    ??uart0_isr_6
   \   00000130   0x....             LDR.N    R0,??DataTable9_7
   \   00000132   0x7800             LDRB     R0,[R0, #+0]
   \   00000134   0x2807             CMP      R0,#+7
   \   00000136   0xD110             BNE.N    ??uart0_isr_6
   \   00000138   0x....             LDR.N    R0,??DataTable9_8
   \   0000013A   0x7800             LDRB     R0,[R0, #+0]
   \   0000013C   0x287D             CMP      R0,#+125
   \   0000013E   0xD10C             BNE.N    ??uart0_isr_6
     64                  {
     65                      uart_sendN(UART0, (uint8 *)"\nCar Stop!", 10);
   \   00000140   0x220A             MOVS     R2,#+10
   \   00000142   0x....             LDR.N    R1,??DataTable9_12
   \   00000144   0x....             LDR.N    R0,??DataTable9_2  ;; 0x4006a000
   \   00000146   0x.... 0x....      BL       uart_sendN
     66                      StopRealFlag = 1;
   \   0000014A   0x2001             MOVS     R0,#+1
   \   0000014C   0x....             LDR.N    R1,??DataTable9_10
   \   0000014E   0x7008             STRB     R0,[R1, #+0]
     67                      light_control(PORTE, 26, Light_OFF);
   \   00000150   0x2201             MOVS     R2,#+1
   \   00000152   0x211A             MOVS     R1,#+26
   \   00000154   0x....             LDR.N    R0,??DataTable9_11  ;; 0x400ff100
   \   00000156   0x.... 0x....      BL       light_control
     68                  }
     69              }
     70              
     71          	EnableInterrupts;		//开总中断
   \                     ??uart0_isr_6: (+1)
   \   0000015A   0xB662             CPSIE i
     72          }
   \   0000015C   0xBD01             POP      {R0,PC}          ;; return
     73          
     74          //------------------------------------------------------------------------------
     75          //函数名：PIT0_Isr
     76          //功  能：周期中断定时器PIT0中断服务函数
     77          //参  数：无
     78          //返  回：无
     79          //说  明：
     80              //暂定5ms进一次中断，进两次采集完两个编码器的值。
     81              //图像采集完成后、图像处理前，开启这个中断，与图像处理并行。
     82              //第2次进来时关掉这个中断。
     83          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     84          void PIT0_Isr(void)
     85          {       
   \                     PIT0_Isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     86              if((PIT_TFLG(0)&PIT_TFLG_TIF_MASK)!=0)
   \   00000002   0x....             LDR.N    R0,??DataTable9_13  ;; 0x4003710c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD505             BPL.N    ??PIT0_Isr_0
     87              {
     88                PIT_TFLG(0) |= PIT_TFLG_TIF_MASK;  //清中断标志
   \   0000000A   0x....             LDR.N    R0,??DataTable9_13  ;; 0x4003710c
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000012   0x....             LDR.N    R1,??DataTable9_13  ;; 0x4003710c
   \   00000014   0x6008             STR      R0,[R1, #+0]
     89              }
     90              
     91              //gpio_reverse(PORTE, 26);
     92              
     93              //计数值加1。
     94              //PIT0Count++;
     95              //编码器速度值采集完成标志，0未完成，1完成。
     96              //QuadDoneFlag = 0;    
     97              QuadLeftCount = FTM2_CNT;    //记录记数器的值。
   \                     ??PIT0_Isr_0: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable9_14  ;; 0x400b8004
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x....             LDR.N    R1,??DataTable9_15
   \   0000001C   0x6008             STR      R0,[R1, #+0]
     98              FTM2_CNT = 0; 
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x....             LDR.N    R1,??DataTable9_14  ;; 0x400b8004
   \   00000022   0x6008             STR      R0,[R1, #+0]
     99              
    100              //禁止PIT。很关键的一步，使得下一次从头开始倒数。
    101              PIT_TCTRL(PIT0) &= ~(PIT_TCTRL_TEN_MASK);       //禁止pit模块运行
   \   00000024   0x....             LDR.N    R0,??DataTable9_16  ;; 0x40037108
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x0840             LSRS     R0,R0,#+1
   \   0000002A   0x0040             LSLS     R0,R0,#+1
   \   0000002C   0x....             LDR.N    R1,??DataTable9_16  ;; 0x40037108
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    102              //关掉中断。
    103              disable_pit_interrupt(PIT0);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      BL       disable_pit_interrupt
    104              //编码器速度值采集完成标志，0未完成，1完成。
    105              QuadDoneFlag = 1; 
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x....             LDR.N    R1,??DataTable9_17
   \   0000003A   0x7008             STRB     R0,[R1, #+0]
    106          }
   \   0000003C   0xBD01             POP      {R0,PC}          ;; return
    107          /*
    108          void PIT0_Isr(void)
    109          {       
    110              if((PIT_TFLG(0)&PIT_TFLG_TIF_MASK)!=0)
    111              {
    112                PIT_TFLG(0) |= PIT_TFLG_TIF_MASK;  //清中断标志
    113              }
    114              
    115              //gpio_reverse(PORTE, 26);
    116              
    117              //计数值加1。
    118              PIT0Count++;
    119              //编码器速度值采集完成标志，0未完成，1完成。
    120              QuadDoneFlag = 0;         
    121          
    122              if(QuadChangeFlag == 0)
    123              {
    124                QuadChangeFlag = 1;          //切换至右编码器的标志。
    125                QuadLeftCount = FTM2_CNT;    //记录记数器的值。
    126                
    127                DiffCountL += QuadLeftCount;
    128                
    129                FTM2_CNT = 0;                //计数器清零。
    130                //右路A相 A10, B相 A11。打开。
    131                PORTA_PCR10 = PORT_PCR_MUX(6); // 设置引脚A10为FTM2_PHA功能  
    132                PORTA_PCR11 = PORT_PCR_MUX(6); // 设置引脚A11为FTM2_PHB功能   
    133                //左路A相 B18, B相 B19。置为无效复用。
    134                PORTB_PCR18 = PORT_PCR_MUX(5); // 设置引脚B18为无效复用。
    135                PORTB_PCR19 = PORT_PCR_MUX(5); // 设置引脚B19为无效复用。   
    136              }
    137              else
    138              {
    139                QuadChangeFlag = 0;          //切换至左编码器的标志。
    140                QuadRightCount = FTM2_CNT;   //记录记数器的值。
    141                
    142                DiffCountR += QuadRightCount;
    143                
    144                FTM2_CNT = 0;                //计数器清零。
    145                //左路A相 B18, B相 B19。打开。
    146                PORTB_PCR18 = PORT_PCR_MUX(6); // 设置引脚B18为FTM2_PHA功能  
    147                PORTB_PCR19 = PORT_PCR_MUX(6); // 设置引脚B19为FTM2_PHB功能   
    148                //右路A相 A10, B相 A11。置为无效复用。
    149                PORTA_PCR10 = PORT_PCR_MUX(5); // 设置引脚A10为无效复用。
    150                PORTA_PCR11 = PORT_PCR_MUX(5); // 设置引脚A11为无效复用。 
    151                
    152                //禁止PIT。很关键的一步，使得下一次从头开始倒数。
    153                PIT_TCTRL(PIT0) &= ~(PIT_TCTRL_TEN_MASK);       //禁止pit模块运行
    154                //关掉中断。
    155                disable_pit_interrupt(PIT0);
    156                //编码器速度值采集完成标志，0未完成，1完成。
    157                QuadDoneFlag = 1; 
    158                
    159                
    160                
    161              }
    162              
    163               
    164          }
    165          */

   \                                 In section .text, align 2, keep-with-next
    166          void PIT1_Isr(void)
    167          {       
    168              if((PIT_TFLG(1)&PIT_TFLG_TIF_MASK)!=0)
   \                     PIT1_Isr: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable9_18  ;; 0x4003711c
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x07C0             LSLS     R0,R0,#+31
   \   00000006   0xD505             BPL.N    ??PIT1_Isr_0
    169              {
    170                PIT_TFLG(1) |= PIT_TFLG_TIF_MASK;  //清中断标志
   \   00000008   0x....             LDR.N    R0,??DataTable9_18  ;; 0x4003711c
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000010   0x....             LDR.N    R1,??DataTable9_18  ;; 0x4003711c
   \   00000012   0x6008             STR      R0,[R1, #+0]
    171              }
    172              //FTM0_C7V = 0;
    173              TimeOutFlag = 1;
   \                     ??PIT1_Isr_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable9_19
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    174          }
   \   0000001A   0x4770             BX       LR               ;; return
    175          //------------------------------------------------------------------------------
    176          //函数名：PIT2_Isr
    177          //功  能：周期中断定时器PIT2中断服务函数
    178          //参  数：无
    179          //返  回：无
    180          //说  明：1. 用来定时跑车计数
    181          //
    182          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    183          void PIT2_Isr(void)
    184          {
   \                     PIT2_Isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    185            if((PIT_TFLG(2)&PIT_TFLG_TIF_MASK)!=0)
   \   00000002   0x....             LDR.N    R0,??DataTable9_20  ;; 0x4003712c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD505             BPL.N    ??PIT2_Isr_0
    186            {
    187              PIT_TFLG(2) |= PIT_TFLG_TIF_MASK;  //清中断标志
   \   0000000A   0x....             LDR.N    R0,??DataTable9_20  ;; 0x4003712c
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000012   0x....             LDR.N    R1,??DataTable9_20  ;; 0x4003712c
   \   00000014   0x6008             STR      R0,[R1, #+0]
    188            }
    189            
    190            //第一种功能是灯塔发车的5秒计时。
    191            if(PIT2_Isr_Change == 0)
   \                     ??PIT2_Isr_0: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable9_21
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD109             BNE.N    ??PIT2_Isr_1
    192            {
    193              //改用第二种功能。
    194              PIT2_Isr_Change = 1;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x....             LDR.N    R1,??DataTable9_21
   \   00000022   0x7008             STRB     R0,[R1, #+0]
    195              
    196              //灯塔等久标志位置位
    197              LightHouseWaitStartTooLongFlag = 1;    
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x....             LDR.N    R1,??DataTable9_22
   \   00000028   0x7008             STRB     R0,[R1, #+0]
    198              //进来一次后就不用再进来了。如果需要定时停车，需要重新给计数值后，再enable一次。
    199              disable_pit_interrupt(PIT2);
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0x.... 0x....      BL       disable_pit_interrupt
   \   00000030   0xE005             B.N      ??PIT2_Isr_2
    200            }
    201            //第二种功能是定时停车计时。
    202            else
    203            {
    204              //定时跑标志置1。表示定时跑完成，应该马上停车。
    205              TimeRealRunFlag = 1;
   \                     ??PIT2_Isr_1: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x....             LDR.N    R1,??DataTable9_23
   \   00000036   0x7008             STRB     R0,[R1, #+0]
    206              //进来一次后就不用再进来了。一辈子只进来一次。
    207              disable_pit_interrupt(PIT2);
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0x.... 0x....      BL       disable_pit_interrupt
    208            }
    209            
    210          
    211            
    212          }
   \                     ??PIT2_Isr_2: (+1)
   \   0000003E   0xBD01             POP      {R0,PC}          ;; return
    213          
    214          //DMA0传输结束函数，由PCLK触发，B9
    215          //这些处理放在这里，而不是放在LineIsr的原因是LineIsr进入后要马上开始采数据，来不及

   \                                 In section .text, align 2, keep-with-next
    216          void DMA0_Isr(void)
    217          {
   \                     DMA0_Isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    218            
    219              uint8 DMACHno = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    220            
    221              ErrorCountNow9++;
   \   00000004   0x....             LDR.N    R1,??DataTable9_24
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x1C49             ADDS     R1,R1,#+1
   \   0000000A   0x....             LDR.N    R2,??DataTable9_24
   \   0000000C   0x6011             STR      R1,[R2, #+0]
    222              
    223              
    224              DMA_INT |= (1 << DMACHno);    //清DMA0通道传输完成中断标志位
   \   0000000E   0x....             LDR.N    R1,??DataTable9_25  ;; 0x40008024
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0xFA12 0xF000      LSLS     R0,R2,R0
   \   00000018   0x4308             ORRS     R0,R0,R1
   \   0000001A   0x....             LDR.N    R1,??DataTable9_25  ;; 0x40008024
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    225              LineCount++;              //采集行计数值加1
   \   0000001E   0x....             LDR.N    R0,??DataTable9_26
   \   00000020   0x8800             LDRH     R0,[R0, #+0]
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0x....             LDR.N    R1,??DataTable9_26
   \   00000026   0x8008             STRH     R0,[R1, #+0]
    226              
    227              if(LineCount >= CameraHight)   //如果采集完成
   \   00000028   0x....             LDR.N    R0,??DataTable9_26
   \   0000002A   0x8800             LDRH     R0,[R0, #+0]
   \   0000002C   0x283C             CMP      R0,#+60
   \   0000002E   0xDB17             BLT.N    ??DMA0_Isr_0
    228              {
    229                  ImgStatus = ImgGetFinish;    //图像采集结束标志位
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x....             LDR.N    R1,??DataTable9_27
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    230                     
    231                  if(ImgPresent == ImgNO1)  
   \   00000036   0x....             LDR.N    R0,??DataTable9_28
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD103             BNE.N    ??DMA0_Isr_1
    232                  //如果当前采集的是第1幅图像，那么第1幅图像就采集完了，准备采集第2幅图像
    233                  {
    234                      ImgPresent = ImgNO2;  
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0x....             LDR.N    R1,??DataTable9_28
   \   00000042   0x7008             STRB     R0,[R1, #+0]
   \   00000044   0xE006             B.N      ??DMA0_Isr_2
    235                  }
    236                  else if(ImgPresent == ImgNO2)
   \                     ??DMA0_Isr_1: (+1)
   \   00000046   0x....             LDR.N    R0,??DataTable9_28
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x2802             CMP      R0,#+2
   \   0000004C   0xD102             BNE.N    ??DMA0_Isr_2
    237                  //如果当前采集的是第2幅图像，那么第2幅图像就采集完了，准备采集第1幅图像
    238                  {
    239                      ImgPresent = ImgNO1;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x....             LDR.N    R1,??DataTable9_28
   \   00000052   0x7008             STRB     R0,[R1, #+0]
    240                  }
    241                  else
    242                  {
    243                      //uart_sendN(UART0, (uint8 *)"\nError In DMA0_Isr()!", 21);  //错误警告 
    244                  }
    245                          
    246                  //disable_irq(FIELD_IRQ);   //场中断IRQ禁用，等待下一次ImgGet()函数再开启
    247                  disable_irq(LINE_IRQ);    //行中断IRQ禁用
   \                     ??DMA0_Isr_2: (+1)
   \   00000054   0x2059             MOVS     R0,#+89
   \   00000056   0x.... 0x....      BL       disable_irq
    248                  enable_irq(DMA0_IRQ);    //DMA0的IRQ禁用   
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x.... 0x....      BL       enable_irq
    249                   
    250              }   
    251              
    252            /*
    253              uint8 DMACHno = 0;
    254              DMA_INT |= (1 << DMACHno);    //清DMA0通道传输完成中断标志位
    255              LineCount++;              //采集行计数值加1
    256              
    257              if(LineCount >= CameraHight)   //如果采集完成
    258              {
    259                  ImgStatus = ImgGetFinish;    //图像采集结束标志位
    260                  disable_irq(FIELD_IRQ);   //场中断IRQ禁用，等待下一次ImgGet()函数再开启
    261                  disable_irq(LINE_IRQ);    //行中断IRQ禁用
    262                  disable_irq(DMA0_IRQ);    //DMA0的IRQ禁用          
    263              }
    264              */
    265          }
   \                     ??DMA0_Isr_0: (+1)
   \   00000060   0xBD01             POP      {R0,PC}          ;; return
    266           
    267          
    268          //PORTA中断服务函数
    269          //这个的IRQ不会打开，正常情况不会进来。

   \                                 In section .text, align 2, keep-with-next
    270          void PORTA_Isr(void)  
    271          {
   \                     PORTA_Isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    272              PORTA_ISFR = ~0;
   \   00000002   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000006   0x....             LDR.N    R1,??DataTable9_29  ;; 0x400490a0
   \   00000008   0x6008             STR      R0,[R1, #+0]
    273              uart_sendN(UART0, (uint8 *)"\nError In PORTA_Isr()!", 22); //错误警告
   \   0000000A   0x2216             MOVS     R2,#+22
   \   0000000C   0x....             LDR.N    R1,??DataTable9_30
   \   0000000E   0x....             LDR.N    R0,??DataTable9_2  ;; 0x4006a000
   \   00000010   0x.... 0x....      BL       uart_sendN
    274          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    275          
    276          
    277          //PORTB中断服务函数，含PCLK引发的DMA，B9
    278          //这个的IRQ不会打开，正常情况不会进来。

   \                                 In section .text, align 2, keep-with-next
    279          void PORTB_Isr(void)  
    280          {
   \                     PORTB_Isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    281              PORTB_ISFR = ~0;
   \   00000002   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000006   0x....             LDR.N    R1,??DataTable9_31  ;; 0x4004a0a0
   \   00000008   0x6008             STR      R0,[R1, #+0]
    282              uart_sendN(UART0, (uint8 *)"\nError In PORTB_Isr()!", 22);  //错误警告
   \   0000000A   0x2216             MOVS     R2,#+22
   \   0000000C   0x....             LDR.N    R1,??DataTable9_32
   \   0000000E   0x....             LDR.N    R0,??DataTable9_2  ;; 0x4006a000
   \   00000010   0x.... 0x....      BL       uart_sendN
    283          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    284          
    285          
    286          //PORTC中断服务函数，含行中断，C8

   \                                 In section .text, align 2, keep-with-next
    287          void PORTC_Isr(void)  
    288          {
   \                     PORTC_Isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    289              uint32 FlagTmp = PORTC_ISFR;  
   \   00000002   0x....             LDR.N    R0,??DataTable9_33  ;; 0x4004b0a0
   \   00000004   0x6800             LDR      R0,[R0, #+0]
    290              PORTC_ISFR =  ~0;             //清除PORTC的所有中断标志位
   \   00000006   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000A   0x....             LDR.N    R2,??DataTable9_33  ;; 0x4004b0a0
   \   0000000C   0x6011             STR      R1,[R2, #+0]
    291              
    292              if(FlagTmp & (1 << PIN_LINE))   //如果确认是行中断的
   \   0000000E   0x05C0             LSLS     R0,R0,#+23
   \   00000010   0xD501             BPL.N    ??PORTC_Isr_0
    293              {
    294                  LineIsr();                    //进行中断处理函数
   \   00000012   0x.... 0x....      BL       LineIsr
    295              }
    296          }
   \                     ??PORTC_Isr_0: (+1)
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    297          
    298          
    299          
    300          //PORTD中断服务函数，含场中断，D1

   \                                 In section .text, align 2, keep-with-next
    301          void PORTD_Isr(void)  
    302          {
   \                     PORTD_Isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    303              uint32 FlagTmp = PORTD_ISFR;  
   \   00000002   0x....             LDR.N    R0,??DataTable9_34  ;; 0x4004c0a0
   \   00000004   0x6800             LDR      R0,[R0, #+0]
    304              PORTD_ISFR =  ~0;             //清除PORTD的所有中断标志位
   \   00000006   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000A   0x....             LDR.N    R2,??DataTable9_34  ;; 0x4004c0a0
   \   0000000C   0x6011             STR      R1,[R2, #+0]
    305              
    306              if(FlagTmp & (1 << PIN_FIELD))   //如果确认是场中断的
   \   0000000E   0x0780             LSLS     R0,R0,#+30
   \   00000010   0xD501             BPL.N    ??PORTD_Isr_0
    307              {
    308                  FieldIsr();                    //进场中断处理函数
   \   00000012   0x.... 0x....      BL       FieldIsr
    309              }
    310          
    311          }
   \                     ??PORTD_Isr_0: (+1)
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    312          
    313          
    314          
    315          //PORTE中断服务函数
    316          //这个的IRQ不会打开，正常情况不会进来。

   \                                 In section .text, align 2, keep-with-next
    317          void PORTE_Isr(void)  
    318          {
   \                     PORTE_Isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    319              PORTE_ISFR = ~0;
   \   00000002   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000006   0x....             LDR.N    R1,??DataTable9_35  ;; 0x4004d0a0
   \   00000008   0x6008             STR      R0,[R1, #+0]
    320              uart_sendN(UART0, (uint8 *)"\nError In PORTE_Isr()!", 22);   //错误警告
   \   0000000A   0x2216             MOVS     R2,#+22
   \   0000000C   0x....             LDR.N    R1,??DataTable9_36
   \   0000000E   0x....             LDR.N    R0,??DataTable9_2  ;; 0x4006a000
   \   00000010   0x.... 0x....      BL       uart_sendN
    321          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     ch0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     ch1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     ch2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     ch3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     ch4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     ch5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     ch6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     StopRealFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x400FF100         DC32     0x400ff100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x4003710C         DC32     0x4003710c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x400B8004         DC32     0x400b8004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x........         DC32     QuadLeftCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x40037108         DC32     0x40037108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x........         DC32     QuadDoneFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_18:
   \   00000000   0x4003711C         DC32     0x4003711c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_19:
   \   00000000   0x........         DC32     TimeOutFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_20:
   \   00000000   0x4003712C         DC32     0x4003712c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_21:
   \   00000000   0x........         DC32     PIT2_Isr_Change

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_22:
   \   00000000   0x........         DC32     LightHouseWaitStartTooLongFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_23:
   \   00000000   0x........         DC32     TimeRealRunFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_24:
   \   00000000   0x........         DC32     ErrorCountNow9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_25:
   \   00000000   0x40008024         DC32     0x40008024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_26:
   \   00000000   0x........         DC32     LineCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_27:
   \   00000000   0x........         DC32     ImgStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_28:
   \   00000000   0x........         DC32     ImgPresent

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_29:
   \   00000000   0x400490A0         DC32     0x400490a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_30:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_31:
   \   00000000   0x4004A0A0         DC32     0x4004a0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_32:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_33:
   \   00000000   0x4004B0A0         DC32     0x4004b0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_34:
   \   00000000   0x4004C0A0         DC32     0x4004c0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_35:
   \   00000000   0x4004D0A0         DC32     0x4004d0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_36:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x0A 0x43          DC8 "\012Car Start!"
   \              0x61 0x72    
   \              0x20 0x53    
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x21 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x0A 0x43          DC8 "\012Car Stop!"
   \              0x61 0x72    
   \              0x20 0x53    
   \              0x74 0x6F    
   \              0x70 0x21    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x0A 0x45          DC8 "\012Error In PORTA_Isr()!"
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x20 0x49    
   \              0x6E 0x20    
   \              0x50 0x4F    
   \              0x52 0x54    
   \              0x41 0x5F    
   \              0x49 0x73    
   \              0x72 0x28    
   \              0x29 0x21    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x0A 0x45          DC8 "\012Error In PORTB_Isr()!"
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x20 0x49    
   \              0x6E 0x20    
   \              0x50 0x4F    
   \              0x52 0x54    
   \              0x42 0x5F    
   \              0x49 0x73    
   \              0x72 0x28    
   \              0x29 0x21    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x0A 0x45          DC8 "\012Error In PORTE_Isr()!"
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x20 0x49    
   \              0x6E 0x20    
   \              0x50 0x4F    
   \              0x52 0x54    
   \              0x45 0x5F    
   \              0x49 0x73    
   \              0x72 0x28    
   \              0x29 0x21    
   \              0x00         
   \   00000017   0x00               DC8 0
    322          
    323          
    324          
    325            
    326          
    327          /*
    328          void porta_isr(void)//场中断，A24，下降沿中断
    329          {
    330            
    331          	PORTA_PCR24 |= PORT_PCR_ISF_MASK;//清除中断标志
    332          	DMA0_Init();
    333          	enable_irq(0);//使能DMA通道0完成中断
    334          	row=0;//初始化行
    335          	imagerow=0;//初始化采集行
    336          	enable_irq (88);//使能B口中断 ，B10行中断
    337          
    338          }
    339          */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DMA0_Isr
         8   -> disable_irq
         8   -> enable_irq
       8   PIT0_Isr
         8   -> disable_pit_interrupt
       0   PIT1_Isr
       8   PIT2_Isr
         8   -> disable_pit_interrupt
       8   PORTA_Isr
         8   -> uart_sendN
       8   PORTB_Isr
         8   -> uart_sendN
       8   PORTC_Isr
         8   -> LineIsr
       8   PORTD_Isr
         8   -> FieldIsr
       8   PORTE_Isr
         8   -> uart_sendN
       8   uart0_isr
         8   -> light_control
         8   -> uart_re1
         8   -> uart_sendN


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_18
       4  ??DataTable9_19
       4  ??DataTable9_2
       4  ??DataTable9_20
       4  ??DataTable9_21
       4  ??DataTable9_22
       4  ??DataTable9_23
       4  ??DataTable9_24
       4  ??DataTable9_25
       4  ??DataTable9_26
       4  ??DataTable9_27
       4  ??DataTable9_28
       4  ??DataTable9_29
       4  ??DataTable9_3
       4  ??DataTable9_30
       4  ??DataTable9_31
       4  ??DataTable9_32
       4  ??DataTable9_33
       4  ??DataTable9_34
       4  ??DataTable9_35
       4  ??DataTable9_36
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      12  ?_0
      12  ?_1
      24  ?_2
      24  ?_3
      24  ?_4
      98  DMA0_Isr
       2  DiffCountL
       2  DiffCountR
       4  ErrorCountNow9
       1  LightHouseWaitStartTooLongFlag
       1  PIT0Count
      62  PIT0_Isr
      28  PIT1_Isr
      64  PIT2_Isr
       1  PIT2_Isr_Change
      22  PORTA_Isr
      22  PORTB_Isr
      24  PORTC_Isr
      24  PORTD_Isr
      22  PORTE_Isr
       1  QuadChangeFlag
       1  QuadDoneFlag
       4  QuadLeftCount
       4  QuadRightCount
       1  ch0
       1  ch1
       1  ch2
       1  ch3
       1  ch4
       1  ch5
       1  ch6
       1  cnt
     350  uart0_isr

 
  29 bytes in section .bss
  96 bytes in section .rodata
 864 bytes in section .text
 
 864 bytes of CODE  memory
  96 bytes of CONST memory
  29 bytes of DATA  memory

Errors: none
Warnings: 1
