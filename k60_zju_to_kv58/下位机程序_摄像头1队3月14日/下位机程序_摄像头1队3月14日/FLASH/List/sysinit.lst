###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.5.7591/W32 for ARM        06/Feb/2018  21:44:25
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\智能车\程序\下位机程序_摄像头1队\src\Sources\C\Frame_C\sysinit.c
#    Command line =  
#        D:\智能车\程序\下位机程序_摄像头1队\src\Sources\C\Frame_C\sysinit.c -D
#        IAR -D TWR_K60N512 -lCN
#        D:\智能车\程序\下位机程序_摄像头1队\FLASH\List\ -lB
#        D:\智能车\程序\下位机程序_摄像头1队\FLASH\List\ -o
#        D:\智能车\程序\下位机程序_摄像头1队\FLASH\Obj\ --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\智能车\程序\下位机程序_摄像头1队\src\Sources\H\ -I
#        D:\智能车\程序\下位机程序_摄像头1队\src\Sources\H\Component_H\ -I
#        D:\智能车\程序\下位机程序_摄像头1队\src\Sources\H\Frame_H\ -I
#        D:\智能车\程序\下位机程序_摄像头1队\src\Sources\H\Function_H\ -I
#        D:\智能车\程序\下位机程序_摄像头1队\src\Sources\H\SD_H\ -Ol
#        --use_c++_inline
#    List file    =  D:\智能车\程序\下位机程序_摄像头1队\FLASH\List\sysinit.lst
#    Object file  =  D:\智能车\程序\下位机程序_摄像头1队\FLASH\Obj\sysinit.o
#
###############################################################################

D:\智能车\程序\下位机程序_摄像头1队\src\Sources\C\Frame_C\sysinit.c
      1          //-------------------------------------------------------------------------*
      2          // 文件名:sysinit.c                                                        *
      3          // 说  明: 系统配置文件                                                    *
      4          //-------------------------------------------------------------------------*
      5          
      6          #include "sysinit.h"	//头文件
      7          
      8          //关于时钟的全局变量声明

   \                                 In section .bss, align 4
      9          int32 core_clk_khz;       //内核频率 kHz
   \                     core_clk_khz:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     10          int32 core_clk_mhz;     
   \                     core_clk_mhz:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     11          int32 periph_clk_khz;     //外设频率 kHz
   \                     periph_clk_khz:
   \   00000000                      DS8 4
     12          
     13          //-------------------------------------------------------------------------*
     14          //函数名: sysinit                                                          *
     15          //功  能: 系统设置                                                         * 
     16          //参  数: 无						  	           *	
     17          //返  回: 无                                                               *
     18          //说  明: 无                                                               *
     19          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
     20          void sysinit (void)
     21          {
   \                     sysinit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     22              //使能IO端口时钟    
     23              SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK
     24                                        | SIM_SCGC5_PORTB_MASK
     25                                        | SIM_SCGC5_PORTC_MASK
     26                                        | SIM_SCGC5_PORTD_MASK
     27                                        | SIM_SCGC5_PORTE_MASK );
   \   00000002   0x....             LDR.N    R0,??DataTable4  ;; 0x40048038
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x5078      ORRS     R0,R0,#0x3E00
   \   0000000A   0x....             LDR.N    R1,??DataTable4  ;; 0x40048038
   \   0000000C   0x6008             STR      R0,[R1, #+0]
     28          
     29          #if(defined(OVERCLOCK))
     30              {
     31                PllInit150M();
   \   0000000E   0x.... 0x....      BL       PllInit150M
     32                core_clk_mhz = 150;
   \   00000012   0x2096             MOVS     R0,#+150
   \   00000014   0x....             LDR.N    R1,??DataTable4_1
   \   00000016   0x6008             STR      R0,[R1, #+0]
     33              }
     34          #else
     35              {
     36                //开启系统时钟
     37                core_clk_mhz = pll_init(CORE_CLK_MHZ, REF_CLK);
     38              }
     39          #endif
     40              //通过pll_init函数的返回值来计算内核时钟和外设时钟
     41              core_clk_khz = core_clk_mhz * 1000;
   \   00000018   0x....             LDR.N    R0,??DataTable4_1
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF44F 0x717A      MOV      R1,#+1000
   \   00000020   0x4348             MULS     R0,R1,R0
   \   00000022   0x....             LDR.N    R1,??DataTable4_2
   \   00000024   0x6008             STR      R0,[R1, #+0]
     42              periph_clk_khz = core_clk_khz / (((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> 24)+ 1);
   \   00000026   0x....             LDR.N    R0,??DataTable4_2
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40048044
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0xF3C1 0x6103      UBFX     R1,R1,#+24,#+4
   \   00000032   0x1C49             ADDS     R1,R1,#+1
   \   00000034   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000038   0x....             LDR.N    R1,??DataTable4_4
   \   0000003A   0x6008             STR      R0,[R1, #+0]
     43              //使能跟踪时钟，用于调试
     44              trace_clk_init();	
   \   0000003C   0x.... 0x....      BL       trace_clk_init
     45              //FlexBus时钟初始化
     46              fb_clk_init();
   \   00000040   0x.... 0x....      BL       fb_clk_init
     47          }
   \   00000044   0xBD01             POP      {R0,PC}          ;; return
     48          
     49          
     50          
     51          
     52          //-------------------------------------------------------------------------*
     53          //函数名: trace_clk_init                                                   *
     54          //功  能: 跟踪时钟初始化                                                   * 
     55          //参  数: 无							  	   *	
     56          //返  回: 无                                                               *
     57          //说  明: 用于调试                                                         *
     58          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
     59          void trace_clk_init(void)
     60          {
     61              //设置跟踪时钟为内核时钟
     62              SIM_SOPT2 |= SIM_SOPT2_TRACECLKSEL_MASK;	
   \                     trace_clk_init: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4_5  ;; 0x40048004
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   00000008   0x....             LDR.N    R1,??DataTable4_5  ;; 0x40048004
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     63              //在PTA6引脚上使能TRACE_CLKOU功能
     64              PORTA_PCR6 = ( PORT_PCR_MUX(0x7));
   \   0000000C   0xF44F 0x60E0      MOV      R0,#+1792
   \   00000010   0x....             LDR.N    R1,??DataTable4_6  ;; 0x40049018
   \   00000012   0x6008             STR      R0,[R1, #+0]
     65          }
   \   00000014   0x4770             BX       LR               ;; return
     66          
     67          //-------------------------------------------------------------------------*
     68          //函数名: fb_clk_init                                                      *
     69          //功  能: FlexBus时钟初始化                                                * 
     70          //参  数: 无								   *	
     71          //返  回: 无                                                               *
     72          //说  明:                                                                  *
     73          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
     74          void fb_clk_init(void)
     75          {
     76              //使能FlexBus模块时钟
     77              SIM_SCGC7 |= SIM_SCGC7_FLEXBUS_MASK;
   \                     fb_clk_init: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4_7  ;; 0x40048040
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000008   0x....             LDR.N    R1,??DataTable4_7  ;; 0x40048040
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     78              //在PTA6引脚上使能FB_CLKOUT功能
     79              PORTC_PCR3 = ( PORT_PCR_MUX(0x5));
   \   0000000C   0xF44F 0x60A0      MOV      R0,#+1280
   \   00000010   0x....             LDR.N    R1,??DataTable4_8  ;; 0x4004b00c
   \   00000012   0x6008             STR      R0,[R1, #+0]
     80          }
   \   00000014   0x4770             BX       LR               ;; return
     81          
     82          //-------------------------------------------------------------------------*
     83          //函数名: pll_init                                                         *
     84          //功  能: pll初始化                                                        * 
     85          //参  数: clk_option:时钟选项						   * 
     86          //		  crystal_val:时钟值                                       *	
     87          //返  回: 时钟频率值                                                       *
     88          //说  明:                                                                  *
     89          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
     90          unsigned char pll_init(unsigned char clk_option, unsigned char crystal_val)
     91          {
   \                     pll_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x000A             MOVS     R2,R1
     92              unsigned char pll_freq;
     93              
     94              if (clk_option > 3) {return 0;}   //如果没有选择可用的选项则返回0
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x2804             CMP      R0,#+4
   \   00000008   0xDB01             BLT.N    ??pll_init_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE072             B.N      ??pll_init_1
     95              if (crystal_val > 15) {return 1;} // 如果如果可用的晶体选项不可用则返回1
   \                     ??pll_init_0: (+1)
   \   0000000E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000010   0x2A10             CMP      R2,#+16
   \   00000012   0xDB01             BLT.N    ??pll_init_2
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE06D             B.N      ??pll_init_1
     96              
     97              //这里处在默认的FEI模式
     98              //首先移动到FBE模式
     99              #if (defined(K60_CLK) || defined(ASB817))
    100                       MCG_C2 = 0;
   \                     ??pll_init_2: (+1)
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x....             LDR.N    R3,??DataTable4_9  ;; 0x40064001
   \   0000001C   0x701A             STRB     R2,[R3, #+0]
    101              #else
    102                       //使能外部晶振
    103                       MCG_C2 = MCG_C2_RANGE(2) | MCG_C2_HGO_MASK | MCG_C2_EREFS_MASK;
    104              #endif
    105              
    106              //初始化晶振后释放锁定状态的振荡器和GPIO
    107              SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;
   \   0000001E   0x....             LDR.N    R2,??DataTable4_10  ;; 0x40048034
   \   00000020   0x6812             LDR      R2,[R2, #+0]
   \   00000022   0xF052 0x5280      ORRS     R2,R2,#0x10000000
   \   00000026   0x....             LDR.N    R3,??DataTable4_10  ;; 0x40048034
   \   00000028   0x601A             STR      R2,[R3, #+0]
    108              LLWU_CS |= LLWU_CS_ACKISO_MASK;
   \   0000002A   0x....             LDR.N    R2,??DataTable4_11  ;; 0x4007c008
   \   0000002C   0x7812             LDRB     R2,[R2, #+0]
   \   0000002E   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   00000032   0x....             LDR.N    R3,??DataTable4_11  ;; 0x4007c008
   \   00000034   0x701A             STRB     R2,[R3, #+0]
    109              
    110              //选择外部晶振，参考分频器，清IREFS来启动外部晶振
    111              MCG_C1 = MCG_C1_CLKS(2) | MCG_C1_FRDIV(3);
   \   00000036   0x2298             MOVS     R2,#+152
   \   00000038   0x....             LDR.N    R3,??DataTable4_12  ;; 0x40064000
   \   0000003A   0x701A             STRB     R2,[R3, #+0]
    112              
    113              //等待晶振稳定	
    114              #if (!defined(K60_CLK) && !defined(ASB817))
    115              while (!(MCG_S & MCG_S_OSCINIT_MASK)){};  
    116              #endif
    117              
    118              //等待参考时钟状态位清零
    119              while (MCG_S & MCG_S_IREFST_MASK){}; 
   \                     ??pll_init_3: (+1)
   \   0000003C   0x....             LDR.N    R2,??DataTable4_13  ;; 0x40064006
   \   0000003E   0x7812             LDRB     R2,[R2, #+0]
   \   00000040   0x06D2             LSLS     R2,R2,#+27
   \   00000042   0xD4FB             BMI.N    ??pll_init_3
    120              //等待时钟状态位显示时钟源来自外部参考时钟
    121              while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2){}; 
   \                     ??pll_init_4: (+1)
   \   00000044   0x....             LDR.N    R2,??DataTable4_13  ;; 0x40064006
   \   00000046   0x7812             LDRB     R2,[R2, #+0]
   \   00000048   0xF3C2 0x0281      UBFX     R2,R2,#+2,#+2
   \   0000004C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000004E   0x2A02             CMP      R2,#+2
   \   00000050   0xD1F8             BNE.N    ??pll_init_4
    122              
    123              //进入FBE模式
    124              #if (defined(K60_CLK))
    125              MCG_C5 = MCG_C5_PRDIV(0x18);
   \   00000052   0x2218             MOVS     R2,#+24
   \   00000054   0x....             LDR.N    R3,??DataTable4_14  ;; 0x40064004
   \   00000056   0x701A             STRB     R2,[R3, #+0]
    126              #else
    127              
    128              //配置PLL分频器来匹配所用的晶振
    129              MCG_C5 = MCG_C5_PRDIV(crystal_val); 
    130              #endif
    131              
    132              //确保MCG_C6处于复位状态，禁止LOLIE、PLL、和时钟控制器，清PLL VCO分频器
    133              MCG_C6 = 0x0;
   \   00000058   0x2200             MOVS     R2,#+0
   \   0000005A   0x....             LDR.N    R3,??DataTable4_15  ;; 0x40064005
   \   0000005C   0x701A             STRB     R2,[R3, #+0]
    134              //选择PLL VCO分频器，系统时钟分频器取决于时钟选项
    135              switch (clk_option) {
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD005             BEQ.N    ??pll_init_5
   \   00000064   0x2802             CMP      R0,#+2
   \   00000066   0xD019             BEQ.N    ??pll_init_6
   \   00000068   0xD30D             BCC.N    ??pll_init_7
   \   0000006A   0x2803             CMP      R0,#+3
   \   0000006C   0xD021             BEQ.N    ??pll_init_8
   \   0000006E   0xE02A             B.N      ??pll_init_9
    136              case 0:
    137                //设置系统分频器
    138                //MCG=PLL, core = MCG, bus = MCG, FlexBus = MCG, Flash clock= MCG/2
    139                set_sys_dividers(0,0,0,1);
   \                     ??pll_init_5: (+1)
   \   00000070   0x2301             MOVS     R3,#+1
   \   00000072   0x2200             MOVS     R2,#+0
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x.... 0x....      BL       set_sys_dividers
    140                //设置VCO分频器，使能PLL为50MHz, LOLIE=0, PLLS=1, CME=0, VDIV=1
    141                MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(1); //VDIV = 1 (x25)
   \   0000007C   0x2041             MOVS     R0,#+65
   \   0000007E   0x....             LDR.N    R1,??DataTable4_15  ;; 0x40064005
   \   00000080   0x7008             STRB     R0,[R1, #+0]
    142                pll_freq = 50;
   \   00000082   0x2132             MOVS     R1,#+50
    143                break;
   \   00000084   0xE01F             B.N      ??pll_init_9
    144              case 1:
    145                //设置系统分频器
    146                //MCG=PLL, core = MCG, bus = MCG/2, FlexBus = MCG/2, Flash clock= MCG/4
    147                set_sys_dividers(0,1,1,3);
   \                     ??pll_init_7: (+1)
   \   00000086   0x2303             MOVS     R3,#+3
   \   00000088   0x2201             MOVS     R2,#+1
   \   0000008A   0x2101             MOVS     R1,#+1
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x.... 0x....      BL       set_sys_dividers
    148                //设置VCO分频器，使能PLL为100MHz, LOLIE=0, PLLS=1, CME=0, VDIV=26
    149                MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(26); //VDIV = 26 (x50)
   \   00000092   0x205A             MOVS     R0,#+90
   \   00000094   0x....             LDR.N    R1,??DataTable4_15  ;; 0x40064005
   \   00000096   0x7008             STRB     R0,[R1, #+0]
    150                pll_freq = 100;
   \   00000098   0x2164             MOVS     R1,#+100
    151                break;
   \   0000009A   0xE014             B.N      ??pll_init_9
    152              case 2:
    153                //设置系统分频器
    154                //MCG=PLL, core = MCG, bus = MCG/2, FlexBus = MCG/2, Flash clock= MCG/4
    155                set_sys_dividers(0,1,1,3);
   \                     ??pll_init_6: (+1)
   \   0000009C   0x2303             MOVS     R3,#+3
   \   0000009E   0x2201             MOVS     R2,#+1
   \   000000A0   0x2101             MOVS     R1,#+1
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x.... 0x....      BL       set_sys_dividers
    156                //设置VCO分频器，使能PLL为96MHz, LOLIE=0, PLLS=1, CME=0, VDIV=24
    157                MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(24); //VDIV = 24 (x48)
   \   000000A8   0x2058             MOVS     R0,#+88
   \   000000AA   0x....             LDR.N    R1,??DataTable4_15  ;; 0x40064005
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
    158                pll_freq = 96;
   \   000000AE   0x2160             MOVS     R1,#+96
    159                break;
   \   000000B0   0xE009             B.N      ??pll_init_9
    160              case 3:
    161                //设置系统分频器
    162                //MCG=PLL, core = MCG, bus = MCG, FlexBus = MCG, Flash clock= MCG/2
    163                set_sys_dividers(0,0,0,1);
   \                     ??pll_init_8: (+1)
   \   000000B2   0x2301             MOVS     R3,#+1
   \   000000B4   0x2200             MOVS     R2,#+0
   \   000000B6   0x2100             MOVS     R1,#+0
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x.... 0x....      BL       set_sys_dividers
    164                //设置VCO分频器，使能PLL为48MHz, LOLIE=0, PLLS=1, CME=0, VDIV=0
    165                MCG_C6 = MCG_C6_PLLS_MASK; //VDIV = 0 (x24)
   \   000000BE   0x2040             MOVS     R0,#+64
   \   000000C0   0x....             LDR.N    R1,??DataTable4_15  ;; 0x40064005
   \   000000C2   0x7008             STRB     R0,[R1, #+0]
    166                pll_freq = 48;
   \   000000C4   0x2130             MOVS     R1,#+48
    167                break;
    168              }
    169              while (!(MCG_S & MCG_S_PLLST_MASK)){}; // wait for PLL status bit to set
   \                     ??pll_init_9: (+1)
   \   000000C6   0x....             LDR.N    R0,??DataTable4_13  ;; 0x40064006
   \   000000C8   0x7800             LDRB     R0,[R0, #+0]
   \   000000CA   0x0680             LSLS     R0,R0,#+26
   \   000000CC   0xD5FB             BPL.N    ??pll_init_9
    170              
    171              while (!(MCG_S & MCG_S_LOCK_MASK)){}; // Wait for LOCK bit to set
   \                     ??pll_init_10: (+1)
   \   000000CE   0x....             LDR.N    R0,??DataTable4_13  ;; 0x40064006
   \   000000D0   0x7800             LDRB     R0,[R0, #+0]
   \   000000D2   0x0640             LSLS     R0,R0,#+25
   \   000000D4   0xD5FB             BPL.N    ??pll_init_10
    172              
    173              //进入PBE模式
    174              
    175              //通过清零CLKS位来进入PEE模式
    176              // CLKS=0, FRDIV=3, IREFS=0, IRCLKEN=0, IREFSTEN=0
    177              MCG_C1 &= ~MCG_C1_CLKS_MASK;
   \   000000D6   0x....             LDR.N    R0,??DataTable4_12  ;; 0x40064000
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   000000DE   0x....             LDR.N    R2,??DataTable4_12  ;; 0x40064000
   \   000000E0   0x7010             STRB     R0,[R2, #+0]
    178              
    179              //等待时钟状态位更新
    180              while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3){};
   \                     ??pll_init_11: (+1)
   \   000000E2   0x....             LDR.N    R0,??DataTable4_13  ;; 0x40064006
   \   000000E4   0x7800             LDRB     R0,[R0, #+0]
   \   000000E6   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   000000EA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EC   0x2803             CMP      R0,#+3
   \   000000EE   0xD1F8             BNE.N    ??pll_init_11
    181              
    182              //开始进入PEE模式
    183              
    184              return pll_freq;
   \   000000F0   0x0008             MOVS     R0,R1
   \   000000F2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??pll_init_1: (+1)
   \   000000F4   0xBD02             POP      {R1,PC}          ;; return
    185          }
    186          
    187          //-------------------------------------------------------------------------*
    188          //函数名: set_sys_dividers                                                 *
    189          //功  能: 设置系系统分频器                                                 * 
    190          //参  数: 预分频值   							   *	
    191          //返  回: 无                                                               *
    192          //说  明: 此函数必须放在RAM里执行，否则会产生错误e2448。当FLASH时钟分频改变* 
    193          //        时，必须禁止FLASH的预取功能。在时钟分频改变之后，必须延时一小段时*
    194          //	 间才可以从新使能预取功能。                                        * 
    195          //-------------------------------------------------------------------------*

   \                                 In section .textrw, align 4, keep-with-next
    196          __ramfunc void set_sys_dividers(uint32 outdiv1, uint32 outdiv2, uint32 outdiv3, uint32 outdiv4)
    197          {
   \                     set_sys_dividers: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    198              uint32 temp_reg;
    199              uint8 i;
    200              //保存FMC_PFAPR当前的值
    201              temp_reg = FMC_PFAPR;
   \   00000002   0x4C10             LDR.N    R4,??set_sys_dividers_0  ;; 0x4001f000
   \   00000004   0x6824             LDR      R4,[R4, #+0]
    202              
    203              //通过M&PFD置位M0PFD来禁止预取功能
    204              FMC_PFAPR |= FMC_PFAPR_M7PFD_MASK | FMC_PFAPR_M6PFD_MASK | FMC_PFAPR_M5PFD_MASK
    205                               | FMC_PFAPR_M4PFD_MASK | FMC_PFAPR_M3PFD_MASK | FMC_PFAPR_M2PFD_MASK
    206                               | FMC_PFAPR_M1PFD_MASK | FMC_PFAPR_M0PFD_MASK;
   \   00000006   0x4D0F             LDR.N    R5,??set_sys_dividers_0  ;; 0x4001f000
   \   00000008   0x682D             LDR      R5,[R5, #+0]
   \   0000000A   0xF455 0x057F      ORRS     R5,R5,#0xFF0000
   \   0000000E   0x4E0D             LDR.N    R6,??set_sys_dividers_0  ;; 0x4001f000
   \   00000010   0x6035             STR      R5,[R6, #+0]
    207              
    208              //给时钟分频器设置期望值  
    209              SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(outdiv1) | SIM_CLKDIV1_OUTDIV2(outdiv2) 
    210                                | SIM_CLKDIV1_OUTDIV3(outdiv3) | SIM_CLKDIV1_OUTDIV4(outdiv4);
   \   00000012   0x0609             LSLS     R1,R1,#+24
   \   00000014   0xF011 0x6170      ANDS     R1,R1,#0xF000000
   \   00000018   0xEA51 0x7000      ORRS     R0,R1,R0, LSL #+28
   \   0000001C   0x0511             LSLS     R1,R2,#+20
   \   0000001E   0xF411 0x0170      ANDS     R1,R1,#0xF00000
   \   00000022   0x4308             ORRS     R0,R1,R0
   \   00000024   0x0419             LSLS     R1,R3,#+16
   \   00000026   0xF411 0x2170      ANDS     R1,R1,#0xF0000
   \   0000002A   0x4308             ORRS     R0,R1,R0
   \   0000002C   0x4906             LDR.N    R1,??set_sys_dividers_0+0x4  ;; 0x40048044
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    211              
    212              //等待分频器改变
    213              for (i = 0 ; i < outdiv4 ; i++)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE000             B.N      ??set_sys_dividers_1
   \                     ??set_sys_dividers_2: (+1)
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \                     ??set_sys_dividers_1: (+1)
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x4298             CMP      R0,R3
   \   0000003A   0xD3FB             BCC.N    ??set_sys_dividers_2
    214              {}
    215              
    216              //从新存FMC_PFAPR的原始值
    217              FMC_PFAPR = temp_reg; 
   \   0000003C   0x4801             LDR.N    R0,??set_sys_dividers_0  ;; 0x4001f000
   \   0000003E   0x6004             STR      R4,[R0, #+0]
    218              
    219              return;
   \   00000040   0xBC70             POP      {R4-R6}
   \   00000042   0x4770             BX       LR               ;; return
   \                     ??set_sys_dividers_0:
   \   00000044   0x4001F000         DC32     0x4001f000
   \   00000048   0x40048044         DC32     0x40048044
    220          }
    221          
    222          
    223          //-------------------------------------------------------------------------*
    224          //函数名: PllInit150M                                                      *
    225          //功  能: pll初始化到150M（已经超频）                                      * 
    226          //参  数: 无                    					                                 * 
    227          //返  回: 时钟频率值                                                       *
    228          //说  明:                                                                  *
    229          //-------------------------------------------------------------------------*

   \                                 In section .text, align 2, keep-with-next
    230          void PllInit150M(void)
    231          {
    232            uint32_t temp_reg;
    233            //使能IO端口时钟    
    234            SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK
    235                          | SIM_SCGC5_PORTB_MASK
    236                            | SIM_SCGC5_PORTC_MASK
    237                              | SIM_SCGC5_PORTD_MASK
    238                                | SIM_SCGC5_PORTE_MASK );
   \                     PllInit150M: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable4  ;; 0x40048038
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF450 0x5078      ORRS     R0,R0,#0x3E00
   \   00000008   0x....             LDR.N    R1,??DataTable4  ;; 0x40048038
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    239            //这里处在默认的FEI模式
    240            //首先移动到FBE模式
    241            MCG_C2 = 0;  
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x....             LDR.N    R1,??DataTable4_9  ;; 0x40064001
   \   00000010   0x7008             STRB     R0,[R1, #+0]
    242            //MCG_C2 = MCG_C2_RANGE(2) | MCG_C2_HGO_MASK | MCG_C2_EREFS_MASK;
    243            //初始化晶振后释放锁定状态的振荡器和GPIO
    244            SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;
   \   00000012   0x....             LDR.N    R0,??DataTable4_10  ;; 0x40048034
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000001A   0x....             LDR.N    R1,??DataTable4_10  ;; 0x40048034
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    245            LLWU_CS |= LLWU_CS_ACKISO_MASK;
   \   0000001E   0x....             LDR.N    R0,??DataTable4_11  ;; 0x4007c008
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000026   0x....             LDR.N    R1,??DataTable4_11  ;; 0x4007c008
   \   00000028   0x7008             STRB     R0,[R1, #+0]
    246              
    247            //选择外部晶振，参考分频器，清IREFS来启动外部晶振
    248            MCG_C1 = MCG_C1_CLKS(2) | MCG_C1_FRDIV(3);
   \   0000002A   0x2098             MOVS     R0,#+152
   \   0000002C   0x....             LDR.N    R1,??DataTable4_12  ;; 0x40064000
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
    249              
    250            //等待晶振稳定	    
    251            while (MCG_S & MCG_S_IREFST_MASK){}                  //等待时钟切换到外部参考时钟
   \                     ??PllInit150M_0: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable4_13  ;; 0x40064006
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x06C0             LSLS     R0,R0,#+27
   \   00000036   0xD4FB             BMI.N    ??PllInit150M_0
    252            while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2){}
   \                     ??PllInit150M_1: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable4_13  ;; 0x40064006
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x2802             CMP      R0,#+2
   \   00000044   0xD1F8             BNE.N    ??PllInit150M_1
    253              
    254            //进入FBE模式,
    255            //0x18==25分频=2M,
    256            //0x11==18分频=2.7778M 
    257            //0x12==19分频=2.63M,
    258            //0x13==20分频=2.5M    
    259            MCG_C5 = MCG_C5_PRDIV(0x11);                
   \   00000046   0x2011             MOVS     R0,#+17
   \   00000048   0x....             LDR.N    R1,??DataTable4_14  ;; 0x40064004
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    260              
    261            //确保MCG_C6处于复位状态，禁止LOLIE、PLL、和时钟控制器，清PLL VCO分频器
    262            MCG_C6 = 0x0;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x....             LDR.N    R1,??DataTable4_15  ;; 0x40064005
   \   00000050   0x7008             STRB     R0,[R1, #+0]
    263              
    264            //保存FMC_PFAPR当前的值
    265            temp_reg = FMC_PFAPR;
   \   00000052   0x....             LDR.N    R0,??DataTable4_16  ;; 0x4001f000
   \   00000054   0x6800             LDR      R0,[R0, #+0]
    266              
    267            //通过M&PFD置位M0PFD来禁止预取功能
    268            FMC_PFAPR |= FMC_PFAPR_M7PFD_MASK | FMC_PFAPR_M6PFD_MASK | FMC_PFAPR_M5PFD_MASK
    269              | FMC_PFAPR_M4PFD_MASK | FMC_PFAPR_M3PFD_MASK | FMC_PFAPR_M2PFD_MASK
    270                | FMC_PFAPR_M1PFD_MASK | FMC_PFAPR_M0PFD_MASK;    
   \   00000056   0x....             LDR.N    R1,??DataTable4_16  ;; 0x4001f000
   \   00000058   0x6809             LDR      R1,[R1, #+0]
   \   0000005A   0xF451 0x017F      ORRS     R1,R1,#0xFF0000
   \   0000005E   0x....             LDR.N    R2,??DataTable4_16  ;; 0x4001f000
   \   00000060   0x6011             STR      R1,[R2, #+0]
    271            //设置系统分频器
    272            //MCG=PLL, core = MCG, bus = MCG/2, FlexBus = MCG/2, Flash clock= MCG/8
    273            SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) 
    274              | SIM_CLKDIV1_OUTDIV3(1) | SIM_CLKDIV1_OUTDIV4(7);       
   \   00000062   0x....             LDR.N    R1,??DataTable4_17  ;; 0x1170000
   \   00000064   0x....             LDR.N    R2,??DataTable4_3  ;; 0x40048044
   \   00000066   0x6011             STR      R1,[R2, #+0]
    275              
    276            //从新存FMC_PFAPR的原始值
    277            FMC_PFAPR = temp_reg; 
   \   00000068   0x....             LDR.N    R1,??DataTable4_16  ;; 0x4001f000
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    278              
    279            //设置VCO分频器，使能PLL为150MHz, LOLIE=0, PLLS=1, CME=0, VDIV=30
    280            //经过计算，精确的频率为50/18*54=150
    281            MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(30);  //VDIV = 30 (x54)
   \   0000006C   0x205E             MOVS     R0,#+94
   \   0000006E   0x....             LDR.N    R1,??DataTable4_15  ;; 0x40064005
   \   00000070   0x7008             STRB     R0,[R1, #+0]
    282                                                            //VDIV = 26 (x50)
    283            while (!(MCG_S & MCG_S_PLLST_MASK)){}; // wait for PLL status bit to set    
   \                     ??PllInit150M_2: (+1)
   \   00000072   0x....             LDR.N    R0,??DataTable4_13  ;; 0x40064006
   \   00000074   0x7800             LDRB     R0,[R0, #+0]
   \   00000076   0x0680             LSLS     R0,R0,#+26
   \   00000078   0xD5FB             BPL.N    ??PllInit150M_2
    284            while (!(MCG_S & MCG_S_LOCK_MASK)){}; // Wait for LOCK bit to set    
   \                     ??PllInit150M_3: (+1)
   \   0000007A   0x....             LDR.N    R0,??DataTable4_13  ;; 0x40064006
   \   0000007C   0x7800             LDRB     R0,[R0, #+0]
   \   0000007E   0x0640             LSLS     R0,R0,#+25
   \   00000080   0xD5FB             BPL.N    ??PllInit150M_3
    285              
    286            //进入PBE模式    
    287            //通过清零CLKS位来进入PEE模式
    288            // CLKS=0, FRDIV=3, IREFS=0, IRCLKEN=0, IREFSTEN=0
    289            MCG_C1 &= ~MCG_C1_CLKS_MASK;
   \   00000082   0x....             LDR.N    R0,??DataTable4_12  ;; 0x40064000
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   0000008A   0x....             LDR.N    R1,??DataTable4_12  ;; 0x40064000
   \   0000008C   0x7008             STRB     R0,[R1, #+0]
    290              
    291            //等待时钟状态位更新
    292            while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3){};
   \                     ??PllInit150M_4: (+1)
   \   0000008E   0x....             LDR.N    R0,??DataTable4_13  ;; 0x40064006
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0x2803             CMP      R0,#+3
   \   0000009A   0xD1F8             BNE.N    ??PllInit150M_4
    293            //SIM_CLKDIV2 |= SIM_CLKDIV2_USBDIV(1);  
    294              
    295            //设置跟踪时钟为内核时钟
    296            SIM_SOPT2 |= SIM_SOPT2_TRACECLKSEL_MASK;	
   \   0000009C   0x....             LDR.N    R0,??DataTable4_5  ;; 0x40048004
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   000000A4   0x....             LDR.N    R1,??DataTable4_5  ;; 0x40048004
   \   000000A6   0x6008             STR      R0,[R1, #+0]
    297            //在PTA6引脚上使能TRACE_CLKOU功能
    298            PORTA_PCR6 = ( PORT_PCR_MUX(0x7));  
   \   000000A8   0xF44F 0x60E0      MOV      R0,#+1792
   \   000000AC   0x....             LDR.N    R1,??DataTable4_6  ;; 0x40049018
   \   000000AE   0x6008             STR      R0,[R1, #+0]
    299            //使能FlexBus模块时钟
    300            SIM_SCGC7 |= SIM_SCGC7_FLEXBUS_MASK;
   \   000000B0   0x....             LDR.N    R0,??DataTable4_7  ;; 0x40048040
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000B8   0x....             LDR.N    R1,??DataTable4_7  ;; 0x40048040
   \   000000BA   0x6008             STR      R0,[R1, #+0]
    301            //在PTA6引脚上使能FB_CLKOUT功能
    302            PORTC_PCR3 = ( PORT_PCR_MUX(0x5));
   \   000000BC   0xF44F 0x60A0      MOV      R0,#+1280
   \   000000C0   0x....             LDR.N    R1,??DataTable4_8  ;; 0x4004b00c
   \   000000C2   0x6008             STR      R0,[R1, #+0]
    303          }
   \   000000C4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     core_clk_mhz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     core_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x40048044         DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     periph_clk_khz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x40048004         DC32     0x40048004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x40049018         DC32     0x40049018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x40048040         DC32     0x40048040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x4004B00C         DC32     0x4004b00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   0x4007C008         DC32     0x4007c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_13:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_14:
   \   00000000   0x40064004         DC32     0x40064004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_15:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_16:
   \   00000000   0x4001F000         DC32     0x4001f000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_17:
   \   00000000   0x01170000         DC32     0x1170000
    304          
    305          
    306          
    307          
    308          
    309          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   PllInit150M
       0   fb_clk_init
       8   pll_init
         8   -> set_sys_dividers
      12   set_sys_dividers
       8   sysinit
         8   -> PllInit150M
         8   -> fb_clk_init
         8   -> trace_clk_init
       0   trace_clk_init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_14
       4  ??DataTable4_15
       4  ??DataTable4_16
       4  ??DataTable4_17
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
     198  PllInit150M
       4  core_clk_khz
       4  core_clk_mhz
      22  fb_clk_init
       4  periph_clk_khz
     246  pll_init
      76  set_sys_dividers
      70  sysinit
      22  trace_clk_init

 
  12 bytes in section .bss
 630 bytes in section .text
  76 bytes in section .textrw
 
 706 bytes of CODE memory
  12 bytes of DATA memory

Errors: none
Warnings: none
