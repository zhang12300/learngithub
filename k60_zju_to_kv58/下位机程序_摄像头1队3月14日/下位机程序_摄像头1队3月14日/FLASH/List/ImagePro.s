///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.30.3.8024/W32 for ARM       14/Mar/2018  19:37:51
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\C\Function_C\ImagePro.c
//    Command line =  
//        E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\C\Function_C\ImagePro.c
//        -D IAR -D TWR_K60N512 -lCN
//        E:\智能车\程序\下位机程序_摄像头1队3月9日\FLASH\List\ -lB
//        E:\智能车\程序\下位机程序_摄像头1队3月9日\FLASH\List\ -o
//        E:\智能车\程序\下位机程序_摄像头1队3月9日\FLASH\Obj\ --no_cse
//        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
//        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Normal.h" -I
//        E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\H\ -I
//        E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\H\Component_H\
//        -I E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\H\Frame_H\
//        -I
//        E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\H\Function_H\
//        -I E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\H\SD_H\ -Ol
//        --use_c++_inline
//    List file    =  
//        E:\智能车\程序\下位机程序_摄像头1队3月9日\FLASH\List\ImagePro.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1

        EXTERN DeviationFuse
        EXTERN GyroResultForbidBackCount
        EXTERN GyroResultForbidFlag
        EXTERN ImgPresent
        EXTERN ImgRaw
        EXTERN ImgStore1
        EXTERN ImgStore2
        EXTERN MtrGet
        EXTERN ServoPIDInputVal
        EXTERN __aeabi_d2f
        EXTERN __aeabi_d2iz
        EXTERN __aeabi_ddiv
        EXTERN __aeabi_dmul
        EXTERN __aeabi_f2d
        EXTERN __aeabi_f2iz
        EXTERN __aeabi_fadd
        EXTERN __aeabi_fdiv
        EXTERN __aeabi_fmul
        EXTERN __aeabi_i2d
        EXTERN __aeabi_i2f
        EXTERN __aeabi_ui2f
        EXTERN light_control
        EXTERN sqrt
        EXTERN uart_send1
        EXTERN uart_sendN

        PUBLIC AbsInt
        PUBLIC AbsRe
        PUBLIC AngleConfirmCount
        PUBLIC AngleConfirmCountMax
        PUBLIC AngleConfirmLockFlag
        PUBLIC AngleConfirmMat
        PUBLIC AngleConfirmMatCollect
        PUBLIC AngleConfirmMatLimit
        PUBLIC AngleHeadLineNum
        PUBLIC AngleLongHeadLineStrategy
        PUBLIC AngleSpeDealBackCount
        PUBLIC AngleSpeDealCen
        PUBLIC AngleSpeDealDeviNow
        PUBLIC AngleSpeDealDir
        PUBLIC AngleSpeDealExitJudge
        PUBLIC AngleSpeDealExitJudgeFlag
        PUBLIC AngleSpeDealFlag
        PUBLIC AngleSpeDealSlopeC
        PUBLIC AngleStep1Judge
        PUBLIC AngleStep1JudgeNotBrick
        PUBLIC AngleStep1NotBrickBorderColL
        PUBLIC AngleStep1NotBrickBorderColR
        PUBLIC AngleStep1NotBrickEndColL
        PUBLIC AngleStep1NotBrickEndColR
        PUBLIC AngleStep2Confirm
        PUBLIC AngleZoneConfirm
        PUBLIC AngleZoneConfirmCount
        PUBLIC AngleZoneConfirmLockFlag
        PUBLIC AngleZoneConfirmLockMeterCount
        PUBLIC AngleZoneConfirmMat
        PUBLIC AngleZoneConfirmMatCollect
        PUBLIC AngleZoneConfirmMatLimit
        PUBLIC AngleZoneJudge
        PUBLIC AngleZoneJudgeColL
        PUBLIC AngleZoneJudgeColLFlag
        PUBLIC AngleZoneJudgeColR
        PUBLIC AngleZoneJudgeColRFlag
        PUBLIC AngleZoneJudgeCountColL
        PUBLIC AngleZoneJudgeCountColR
        PUBLIC AngleZoneJudgeRowL
        PUBLIC AngleZoneJudgeRowR
        PUBLIC BaseRowControlNum
        PUBLIC BlackBigChangeFinalCheck
        PUBLIC BlackBigChangeFinalCheckFlag
        PUBLIC BlackCenEdgeStartCol
        PUBLIC BlackGet
        PUBLIC BlackGetLeft
        PUBLIC BlackGetLeftCrossSpeScan
        PUBLIC BlackGetLeftCrossSpeWin
        PUBLIC BlackGetLeftJustWin
        PUBLIC BlackGetLeftParaInit
        PUBLIC BlackGetLeftStep1Edge
        PUBLIC BlackGetLeftStep1Scan
        PUBLIC BlackGetLeftStep2Win
        PUBLIC BlackGetPre
        PUBLIC BlackGetPreDir
        PUBLIC BlackGetRight
        PUBLIC BlackGetRightCrossSpeScan
        PUBLIC BlackGetRightCrossSpeWin
        PUBLIC BlackGetRightJustWin
        PUBLIC BlackGetRightParaInit
        PUBLIC BlackGetRightStep1Edge
        PUBLIC BlackGetRightStep1Scan
        PUBLIC BlackGetRightStep2Win
        PUBLIC BlackLeft3ResetCount
        PUBLIC BlackLeft5Slope
        PUBLIC BlackLeft5SlopeIndex
        PUBLIC BlackLeft5SlopeRow
        PUBLIC BlackLeftAgainForCross
        PUBLIC BlackLeftBigChangeCheck
        PUBLIC BlackLeftBigChangeCheckAllRow
        PUBLIC BlackLeftBigChangeCheckRow
        PUBLIC BlackLeftBigChangeFlag
        PUBLIC BlackLeftBigChangeJumpFlag
        PUBLIC BlackLeftBigChangeNumx
        PUBLIC BlackLeftBigChangeNumy
        PUBLIC BlackLeftBigChangeSlopeStore
        PUBLIC BlackLeftContinueAdd
        PUBLIC BlackLeftContinueFlag
        PUBLIC BlackLeftCrossConfirm
        PUBLIC BlackLeftCrossConfirmFlag
        PUBLIC BlackLeftCrossDone
        PUBLIC BlackLeftCrossStep3
        PUBLIC BlackLeftCrossTailEndLine
        PUBLIC BlackLeftCrossTailFlag
        PUBLIC BlackLeftCrossTooLowLine
        PUBLIC BlackLeftDone
        PUBLIC BlackLeftEdgeStartCol
        PUBLIC BlackLeftEdgeStartColOffset
        PUBLIC BlackLeftEndLine
        PUBLIC BlackLeftHeadEndSearch
        PUBLIC BlackLeftHeadLine
        PUBLIC BlackLeftLastEdgeStartCol
        PUBLIC BlackLeftLoc
        PUBLIC BlackLeftPredictL
        PUBLIC BlackLeftPredictR
        PUBLIC BlackLeftRealB
        PUBLIC BlackLeftRealClear
        PUBLIC BlackLeftRealW
        PUBLIC BlackLeftRealWB
        PUBLIC BlackLeftRollCheck
        PUBLIC BlackLeftRollCheckFlag
        PUBLIC BlackLeftRow1RealLastLine
        PUBLIC BlackLeftStep1ScanRow
        PUBLIC BlackLeftStep4BackLine
        PUBLIC BlackLeftStep4ErrorCheck
        PUBLIC BlackLeftStep4Flag
        PUBLIC BlackLeftStep4StartLine
        PUBLIC BlackLeftWinPredictStore0
        PUBLIC BlackLeftWinPredictStore1
        PUBLIC BlackLeftWinPredictStore2
        PUBLIC BlackRight3ResetCount
        PUBLIC BlackRight5Slope
        PUBLIC BlackRight5SlopeIndex
        PUBLIC BlackRight5SlopeRow
        PUBLIC BlackRightAgainForCross
        PUBLIC BlackRightBigChangeCheck
        PUBLIC BlackRightBigChangeCheckAllRow
        PUBLIC BlackRightBigChangeCheckRow
        PUBLIC BlackRightBigChangeFlag
        PUBLIC BlackRightBigChangeJumpFlag
        PUBLIC BlackRightBigChangeNumx
        PUBLIC BlackRightBigChangeNumy
        PUBLIC BlackRightBigChangeSlopeStore
        PUBLIC BlackRightContinueAdd
        PUBLIC BlackRightContinueFlag
        PUBLIC BlackRightCrossConfirm
        PUBLIC BlackRightCrossConfirmFlag
        PUBLIC BlackRightCrossDone
        PUBLIC BlackRightCrossStep3
        PUBLIC BlackRightCrossTailEndLine
        PUBLIC BlackRightCrossTailFlag
        PUBLIC BlackRightCrossTooLowLine
        PUBLIC BlackRightDone
        PUBLIC BlackRightEdgeStartCol
        PUBLIC BlackRightEdgeStartColOffset
        PUBLIC BlackRightEndLine
        PUBLIC BlackRightHeadEndSearch
        PUBLIC BlackRightHeadLine
        PUBLIC BlackRightLastEdgeStartCol
        PUBLIC BlackRightLoc
        PUBLIC BlackRightPredictL
        PUBLIC BlackRightPredictR
        PUBLIC BlackRightRealB
        PUBLIC BlackRightRealClear
        PUBLIC BlackRightRealW
        PUBLIC BlackRightRealWB
        PUBLIC BlackRightRollCheck
        PUBLIC BlackRightRollCheckFlag
        PUBLIC BlackRightRow1RealLastLine
        PUBLIC BlackRightStep1ScanRow
        PUBLIC BlackRightStep4BackLine
        PUBLIC BlackRightStep4ErrorCheck
        PUBLIC BlackRightStep4Flag
        PUBLIC BlackRightStep4StartLine
        PUBLIC BlackRightWinPredictStore0
        PUBLIC BlackRightWinPredictStore1
        PUBLIC BlackRightWinPredictStore2
        PUBLIC BlackSingleDir
        PUBLIC BlackSingleFlag
        PUBLIC BlackSingleSpeCheck
        PUBLIC BlackUdis
        PUBLIC BlackUdisLeftLocation
        PUBLIC BlackUdisMatrixFar
        PUBLIC BlackUdisMatrixLow
        PUBLIC BlackUdisMatrixMiddle
        PUBLIC BlackUdisRightLocation
        PUBLIC BoundaryLimitRe
        PUBLIC BrickAvoid
        PUBLIC BrickBorderColL
        PUBLIC BrickBorderColR
        PUBLIC BrickConfirmCount
        PUBLIC BrickConfirmCountMax
        PUBLIC BrickConfirmFinalColCom
        PUBLIC BrickConfirmLockFlag
        PUBLIC BrickConfirmMat0
        PUBLIC BrickConfirmMat1
        PUBLIC BrickConfirmMatCollect0
        PUBLIC BrickConfirmMatCollect1
        PUBLIC BrickConfirmMatLimit
        PUBLIC BrickEndColL
        PUBLIC BrickEndColR
        PUBLIC BrickHeadColL
        PUBLIC BrickHeadColR
        PUBLIC BrickJudge
        PUBLIC BrickLineCountNumRecord
        PUBLIC BrickSpeDealBackCount
        PUBLIC BrickSpeDealBias
        PUBLIC BrickSpeDealCen
        PUBLIC BrickSpeDealCenFlag
        PUBLIC BrickSpeDealDir
        PUBLIC BrickSpeDealExitJudge
        PUBLIC BrickSpeDealExitJudgeFlag
        PUBLIC BrickSpeDealFlag
        PUBLIC BrickSpeDealServor
        PUBLIC BrickSpeDealStartJudge
        PUBLIC BrickSpeDealStartJudgeCol
        PUBLIC CURVEC
        PUBLIC CURVEL
        PUBLIC CURVER
        PUBLIC CameraRealLeftCol
        PUBLIC CenterEndLine
        PUBLIC CenterHeadLine
        PUBLIC CenterKeyLine
        PUBLIC CenterLineGet
        PUBLIC CenterLineGetNormal
        PUBLIC CenterLineGetRaw
        PUBLIC CenterLineGetSingleWrongAdd
        PUBLIC CenterLineHalfWidth
        PUBLIC CenterLineHalfWidthGet
        PUBLIC CenterLineLoc
        PUBLIC CenterLineResult
        PUBLIC CenterLocStore
        PUBLIC ControlRowDeviInit
        PUBLIC ControlRowDeviOld
        PUBLIC ControlRowWeight
        PUBLIC CurveGet
        PUBLIC CurveLineChosenC1
        PUBLIC CurveLineChosenC2
        PUBLIC CurveLineChosenC3
        PUBLIC CurveLineChosenL1
        PUBLIC CurveLineChosenL2
        PUBLIC CurveLineChosenL3
        PUBLIC CurveLineChosenR1
        PUBLIC CurveLineChosenR2
        PUBLIC CurveLineChosenR3
        PUBLIC CurveSlopeFlagC
        PUBLIC CurveSlopeFlagL
        PUBLIC CurveSlopeFlagR
        PUBLIC CurveSlopeGet
        PUBLIC CurveSlopeGetCenter
        PUBLIC CurveSlopeGetLeft
        PUBLIC CurveSlopeGetRight
        PUBLIC DeviFlag
        PUBLIC DeviFuse
        PUBLIC DeviFuseArray
        PUBLIC DeviFuse_old
        PUBLIC DeviNowArray
        PUBLIC DeviNowArrayWight
        PUBLIC DeviNowLevel
        PUBLIC DeviPre
        PUBLIC DeviPrePre
        PUBLIC DeviPrePrePre
        PUBLIC DeviRowChosen
        PUBLIC Devi_far
        PUBLIC Devi_near
        PUBLIC EmergencyStopCount
        PUBLIC EmergencyStopFlag
        PUBLIC ErrorCountNow5
        PUBLIC ErrorGet
        PUBLIC ErrorGetCen
        PUBLIC ErrorGetSelf
        PUBLIC FuzzyDegree
        PUBLIC GyroResultForbidSpeDeal
        PUBLIC ImagePro
        PUBLIC ImageProParaInit
        PUBLIC ImageSend
        PUBLIC ImgBlackSucceedFlag
        PUBLIC ImgCenterSucceedFlag
        PUBLIC ImgNew
        PUBLIC ImgProFailCount
        PUBLIC ImgProFailDeal
        PUBLIC ImgProSucceedDeal
        PUBLIC ImgProSucceedFlag
        PUBLIC ImgPut
        PUBLIC ImgReversePut
        PUBLIC ImgSendPut
        PUBLIC LeastSquareInt16a0
        PUBLIC LeastSquareInt16a1
        PUBLIC LeastSquarea0
        PUBLIC LeastSquarea1
        PUBLIC LimitLeftB
        PUBLIC LimitLeftBMax
        PUBLIC LimitLeftBMin
        PUBLIC LimitLeftHeadB
        PUBLIC LimitLeftHeadW
        PUBLIC LimitLeftHeadWB
        PUBLIC LimitLeftW
        PUBLIC LimitLeftWB
        PUBLIC LimitLeftWBAdjust
        PUBLIC LimitLeftWBMax
        PUBLIC LimitLeftWBMin
        PUBLIC LimitLeftWMax
        PUBLIC LimitLeftWMin
        PUBLIC LimitRightB
        PUBLIC LimitRightBMax
        PUBLIC LimitRightBMin
        PUBLIC LimitRightHeadB
        PUBLIC LimitRightHeadW
        PUBLIC LimitRightHeadWB
        PUBLIC LimitRightW
        PUBLIC LimitRightWB
        PUBLIC LimitRightWBAdjust
        PUBLIC LimitRightWBMax
        PUBLIC LimitRightWBMin
        PUBLIC LimitRightWMax
        PUBLIC LimitRightWMin
        PUBLIC MathSqrt
        PUBLIC MaxRe
        PUBLIC MinRe
        PUBLIC PathJudge
        PUBLIC PathJudgeDone
        PUBLIC PathJudgeNew
        PUBLIC PathJudgeNewStraight
        PUBLIC PathLCRAngle1Judge
        PUBLIC PathRealStraightCount
        PUBLIC PathRealStraightCountLimit
        PUBLIC PathRealStraightFlag
        PUBLIC PathSmallSDir
        PUBLIC PathSmallSDoneFlag
        PUBLIC PathSmallSJudgeStep1
        PUBLIC PathSmallSJudgeStep2
        PUBLIC PathType
        PUBLIC RoadHalfWidth
        PUBLIC RoadHalfWidthCompen
        PUBLIC RoadHalfWidthLast
        PUBLIC RoadHalfWidthRecord
        PUBLIC RoadHalfWidthSingle
        PUBLIC RoadHalfWidthSwitch
        PUBLIC RoadHalfWidthWrongDir
        PUBLIC RoadHalfWidthWrongFlag
        PUBLIC RunOutFlag
        PUBLIC SABCC
        PUBLIC SABCGet
        PUBLIC SABCL
        PUBLIC SABCR
        PUBLIC SendCenterLineLoc
        PUBLIC SendImage
        PUBLIC ServoPIDDGetVal
        PUBLIC ServoPIDDGetValOld
        PUBLIC ShiZhiCheck
        PUBLIC ShiZhiCount
        PUBLIC ShiZhiFlag
        PUBLIC SingleBlackAllFlag
        PUBLIC SingleBlackFlag
        PUBLIC SingleBlackLastAllFlag
        PUBLIC SingleBlackWidthMax
        PUBLIC SingleBlackWidthMin
        PUBLIC SingleDoneFlag
        PUBLIC SingleFloorConfirmCount
        PUBLIC SingleFloorConfirmCountMax
        PUBLIC SingleFloorFlag
        PUBLIC SlopeC
        PUBLIC SlopeL
        PUBLIC SlopeR
        PUBLIC StopLineCheck
        PUBLIC StopLineCheckBeginFlag
        PUBLIC StopLineCheckFlag
        PUBLIC StopLineCheckTimer
        PUBLIC VariablesInit
        PUBLIC Weight_sum
        PUBLIC buXianCount
        PUBLIC flag000
        PUBLIC flag111
        PUBLIC flag222
        PUBLIC limitStopLineBlackXiu
        PUBLIC xiaoZhiDaoFlag

// E:\智能车\程序\下位机程序_摄像头1队3月9日\src\Sources\C\Function_C\ImagePro.c
//    1 /******************************************************************************/
//    2 /*******************************************************************************
//    3   文件名：图像处理程序文件ImagePro.c
//    4   功  能：图像处理
//    5   日  期：2014.10.09
//    6   作  者：HJZ
//    7   备  注：
//    8 *******************************************************************************/
//    9 /******************************************************************************/
//   10 
//   11 #include "ImagePro.h"
//   12 
//   13 //uint16 SW0;
//   14 //uint16 SW1;
//   15 //uint16 SW2;
//   16 //uint16 SW3;
//   17 //uint16 SW4;
//   18 //uint16 SW5;
//   19 //uint16 SW6;
//   20 //uint16 SW7;
//   21 //uint16 SW8;
//   22 

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//   23 uint8 limitStopLineBlackXiu = 30;       //与停车线黑色阈值有关的参数
limitStopLineBlackXiu:
        DATA
        DC8 30

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   24 uint8 ShiZhiFlag = 0;               //十字标志
ShiZhiFlag:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   25 uint8 ShiZhiCount = 0;              //十字计数
ShiZhiCount:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//   26 uint16 buXianCount = 0;             //补线修正计数
buXianCount:
        DS8 2
//   27 
//   28 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   29 uint8 xiaoZhiDaoFlag = 0;                 //小直道
xiaoZhiDaoFlag:
        DS8 1
//   30 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   31 uint8 ImgProFailCount = 0;          //图像失败计数
ImgProFailCount:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   32 uint8 RunOutFlag = 0;               //跑出赛道标志
RunOutFlag:
        DS8 1
//   33 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   34 uint8 StopLineCheckBeginFlag = 0;       //开始判断停车线标志
StopLineCheckBeginFlag:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   35 uint8 StopLineCheckTimer = 0;           //停车线计时
StopLineCheckTimer:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   36 uint8 StopLineCheckFlag = 0;            //停车线标志
StopLineCheckFlag:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//   37 int16 ErrorCountNow5 = 0;
ErrorCountNow5:
        DS8 2

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//   38 uint8 flag000;
flag000:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   39 int32 flag111;
flag111:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   40 int flag222;
flag222:
        DS8 4
//   41 //uint8 countcount;
//   42 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   43 int ServoPIDDGetVal;
ServoPIDDGetVal:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//   44 int ServoPIDDGetValOld;
ServoPIDDGetValOld:
        DS8 4

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
?_0:
        DATA
        DC8 0, 255, 1, 255

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
?_1:
        DATA
        DC8 0, 255, 1, 0
//   45 
//   46 //中心线提取时，实际赛道宽度的一半对应的像素点数。是固定角度后测得的值。

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//   47 uint8 const CenterLineHalfWidth[CameraHight] =  
CenterLineHalfWidth:
        DATA
        DC8 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120
        DC8 124, 128, 132, 136, 140, 143, 147, 150, 153, 156, 159, 162, 165
        DC8 168, 172, 177, 179, 181, 183, 185, 187, 189, 191, 193, 195, 213
        DC8 216, 219, 222, 225, 228, 231, 234, 237, 240, 100, 100, 100, 100
        DC8 100, 100, 100, 100, 100, 100
//   48 {
//   49 64, 68, 72, 76, 80, 84, 88, 92, 96, 100,
//   50 104,108,112,116,120,124,128,132,136,140,
//   51 143,147,150,153,156,159,162,165,168,172,
//   52 177,179,181,183,185,187,189,191,193,195,
//   53 213,216,219,222,225,228,231,234,237,240,
//   54 100,100,100,100,100,100,100,100,100,100
//   55 };
//   56 
//   57 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//   58 uint8 const BlackLeftEdgeStartColOffset[CameraHight] = //向左检测跳变沿的时候，起始列相对CameraRealWidth/2的向右偏移的列数 
BlackLeftEdgeStartColOffset:
        DATA
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 40
        DC8 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40
        DC8 40, 43, 43, 45, 45, 48, 48, 50, 50, 53, 53, 55, 55, 58, 58, 60, 60
        DC8 63, 63, 65, 65
//   59 {
//   60 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,         //远处20行
//   61 40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,         //中间20行
//   62 43,43,45,45,48,48,50,50,53,53,55,55,58,58,60,60,63,63,65,65          //近处20行
//   63 };
//   64 
//   65 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//   66 uint8 const BlackRightEdgeStartColOffset[CameraHight] = //向右检测跳变沿的时候，起始列相对CameraRealWidth/2的向左偏移的列数 
BlackRightEdgeStartColOffset:
        DATA
        DC8 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 20, 20, 20, 20, 20, 20, 20
        DC8 20, 30, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40
        DC8 40, 40, 40, 40, 40, 40, 43, 43, 45, 45, 48, 48, 50, 50, 53, 53, 55
        DC8 55, 58, 58, 60, 60, 63, 63, 65, 65
//   67 {
//   68 10,10,10,10,10,10,10,10,10,10,20,20,20,20,20,20,20,20,30,40,         //远处20行
//   69 40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,         //中间20行
//   70 43,43,45,45,48,48,50,50,53,53,55,55,58,58,60,60,63,63,65,65          //近处20行
//   71 };
//   72 
//   73 //直角弯
//   74 //直角弯特殊处理时，对DeviNow的特殊赋值。影响舵机控制。
//   75 //应使之较大，使舵机打角较大。
//   76 //最多用AngleSpeDealBackCountNumMax次，越高速用的次数越少。

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//   77 int16 const AngleSpeDealDeviNow[AngleSpeDealBackCountNum] = 
AngleSpeDealDeviNow:
        DATA
        DC16 50, 100, 130, 130, 130, 130, 130, 130, 130, 130, 130, 130, 100
        DC16 100, 100
        DC8 0, 0
//   78 {
//   79   //100, 100, 100, 100, 100,
//   80   //100, 100, 100, 100, 100
//   81 50,100,130,130,130,
//   82 130,130,130,130,130,
//   83 130,130,100,100,100
//   84 };
//   85 
//   86 //直角弯特殊处理时，对DeviNowLevel的特殊赋值。0~6，0偏差最小，6偏差最大。影响舵机和电机控制。
//   87 //应使之较大，使速度较慢。
//   88 //最多用AngleSpeDealBackCountNumMax次，越高速用的次数越少。
//   89 /*
//   90 uint8 const AngleSpeDealDeviNowLevel[AngleSpeDealBackCountNum] = 
//   91 {
//   92   6, 6, 6, 6, 6,
//   93   6, 6, 6, 6, 6
//   94 };
//   95 */
//   96 
//   97 //直角弯特殊处理时，对SlopeC的特殊赋值。影响电机控制。
//   98 //影响SlopeCLevel.0~5，0最直，5最斜。
//   99 //应使之较斜，使速度较慢。
//  100 //最多用AngleSpeDealBackCountNumMax次，越高速用的次数越少。

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//  101 int32 const AngleSpeDealSlopeC[AngleSpeDealBackCountNum] = 
AngleSpeDealSlopeC:
        DATA
        DC32 1500, 2400, 3000, 3000, 3000, 3000, 3000, 3000, 2850, 2550, 2250
        DC32 2040, 1950, 1860, 1800
//  102 {
//  103   //3000, 3000, 3000, 3000, 3000,
//  104   //3000, 3000, 3000, 3000, 3000
//  105 1500,2400,3000,3000,3000,
//  106 3000,3000,3000,2850,2550,
//  107 2250,2040,1950,1860,1800
//  108 };
//  109 
//  110 //DeviNow低通滤波时的权重,相加之和为100.不可修改。

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//  111 uint8 const DeviNowArrayWight[DeviNowArrayNum] = 
DeviNowArrayWight:
        DATA
        DC8 0, 0, 100, 0
//  112 {
//  113   0, 0, 100
//  114 };
//  115 
//  116 //DeviNow低通滤波时的储存数组,初始化为0;可修改。

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  117 int16 DeviNowArray[DeviNowArrayNum] = 
DeviNowArray:
        DS8 8
//  118 {
//  119   0, 0, 0
//  120 };
//  121 
//  122 
//  123 //单线处理
//  124 //单线处理时，允许的黑线宽度的最小值。越远则越小。

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//  125 uint8 const SingleBlackWidthMin[CameraHight] = 
SingleBlackWidthMin:
        DATA
        DC8 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6
        DC8 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7
        DC8 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
//  126 {
//  127 5,5,5,5,5,5,5,5,5,5,
//  128 5,5,5,5,5,5,5,5,5,5,
//  129 6,6,6,6,6,6,6,6,6,6,
//  130 6,6,6,6,6,6,6,6,6,6,
//  131 7,7,7,7,7,7,7,7,7,7,
//  132 7,7,7,7,7,7,7,7,7,7
//  133 };
//  134 
//  135 //单线处理时，允许的黑线宽度的最大值。越远则越小。

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//  136 uint8 const SingleBlackWidthMax[CameraHight] = 
SingleBlackWidthMax:
        DATA
        DC8 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20
        DC8 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20
        DC8 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20
        DC8 20, 20, 20, 20, 15, 15, 15, 15, 15
//  137 {
//  138 20,20,20,20,20,20,20,20,20,20,
//  139 20,20,20,20,20,20,20,20,20,20,
//  140 20,20,20,20,20,20,20,20,20,20,
//  141 20,20,20,20,20,20,20,20,20,20,
//  142 20,20,20,20,20,20,20,20,20,20,
//  143 20,20,20,20,20,15,15,15,15,15    //最近的几行15列就够了，太多了会采到旁边的赛道。
//  144 };
//  145 
//  146 /*
//  147 uint8 const SingleBlackWidthMax[CameraHight] = 
//  148 {
//  149 1,1,1,1,1,1,1,1,1,1,
//  150 1,1,1,1,1,1,1,1,1,1,
//  151 1,1,1,1,1,1,1,1,1,1,
//  152 1,1,1,1,1,1,1,1,1,1,
//  153 1,1,1,1,1,1,1,1,1,1,
//  154 1,1,1,1,1,1,1,1,1,1,
//  155 };
//  156 */
//  157 
//  158 //畸变矫正
//  159  //远处的黑线畸变矫正数组

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//  160 int32 const BlackUdisMatrixFar[8] = 
BlackUdisMatrixFar:
        DATA
        DC32 2950, 4062, -243750, 0, 23420, -22387, 0, 32
//  161 {
//  162         2950,
//  163         4062,
//  164      -243750,
//  165            0,
//  166        23420,
//  167       -22387,
//  168            0,
//  169           32,
//  170 };
//  171         //中间处的黑线畸变矫正数组

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//  172 int32 const BlackUdisMatrixMiddle[8] = 
BlackUdisMatrixMiddle:
        DATA
        DC32 2950, 4062, -243750, 0, 23420, -22387, 0, 32
//  173 {
//  174         2950,
//  175         4062,
//  176      -243750,
//  177            0,
//  178        23420,
//  179       -22387,
//  180            0,
//  181           32,
//  182 };
//  183 
//  184         //近处的黑线畸变矫正数组

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//  185 int32 const BlackUdisMatrixLow[8] = 
BlackUdisMatrixLow:
        DATA
        DC32 2950, 4062, -243750, 0, 23420, -22387, 0, 32
//  186 {
//  187        2950,
//  188         4062,
//  189      -243750,
//  190            0,
//  191        23420,
//  192       -22387,
//  193            0,
//  194           32,
//  195 };
//  196 
//  197 //对左黑线差值阈值的微调，因为越远的地方差值会越小。

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//  198 uint8 const LimitLeftWBAdjust[CameraHight] = 
LimitLeftWBAdjust:
        DATA
        DC8 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 5, 5, 5, 5, 5, 5, 5, 5, 5
        DC8 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
//  199 {
//  200 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
//  201  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,
//  202 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
//  203 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
//  204 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
//  205 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
//  206 };
//  207 
//  208 //对右黑线差值阈值的微调，因为越远的地方差值会越小。

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//  209 uint8 const LimitRightWBAdjust[CameraHight] = 
LimitRightWBAdjust:
        DATA
        DC8 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 5, 5, 5, 5, 5, 5, 5, 5, 5
        DC8 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
//  210 {
//  211 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
//  212  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,
//  213 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
//  214 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
//  215 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
//  216 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
//  217 };
//  218 
//  219 
//  220 

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  221 uint8 CameraRealLeftCol = CameraWidth/2 - CameraRealWidth/2;    //ImgPut()函数中，320列图像取250列的真正起始列，用以修正机械偏差。
CameraRealLeftCol:
        DATA
        DC8 35
//  222 //只有图像处理成功了，才会进行赛道类型判断，才会进行偏差获取，舵机电机控制值才会更新。

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  223 uint8 ImgProSucceedFlag = 1;                 //图像处理成功标志位，默认为1，若黑线或中心线提取失败，则置0.
ImgProSucceedFlag:
        DATA
        DC8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  224 uint8 ImgBlackSucceedFlag = 1;                 //黑线提取成功标志位，默认为1，若黑线提取失败，则置0.
ImgBlackSucceedFlag:
        DATA
        DC8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  225 uint8 ImgCenterSucceedFlag = 1;                //中心线提取成功标志位，默认为1，若中心线提取失败，则置0.
ImgCenterSucceedFlag:
        DATA
        DC8 1
//  226 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  227 uint8 ImgNew[CameraHight][CameraRealWidth];       //处理后的图像数据储存数组
ImgNew:
        DS8 15000

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  228 uint8 BlackLeftLoc[CameraHight][3];       //左黑线位置存储数组,每行3个可疑点， 255为无效值
BlackLeftLoc:
        DS8 180

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  229 uint8 BlackRightLoc[CameraHight][3];      //右黑线位置存储数组,每行3个可疑点， 255为无效值
BlackRightLoc:
        DS8 180
//  230 //uint8 MaxValUint8 = 255;             //自定义的无效值

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  231 uint8 CenterLineResult = 1;             //中心线提取成功标志
CenterLineResult:
        DATA
        DC8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  232 uint8 CenterKeyLine = 25;                  //固定的要选取的行。
CenterKeyLine:
        DATA
        DC8 25

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  233 uint8 CenterLocStore = MaxValUint8;         //左右黑线都提取到的时候，保存的CenterLineLoc[CameraHight - 1]。
CenterLocStore:
        DATA
        DC8 255

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  234 uint8 CenterHeadLine = MaxValUint8;         //中心线的线头。
CenterHeadLine:
        DATA
        DC8 255

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  235 uint8 CenterEndLine = MaxValUint8;          //中心线的线尾。
CenterEndLine:
        DATA
        DC8 255

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  236 uint8 BlackCenEdgeStartCol = 0;             //扫描起点定位点
BlackCenEdgeStartCol:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  237 uint8 BlackGetPreDir;                       //黑线预扫描方向。0左线头成功，1右线头成功，2左右线头均失败。
BlackGetPreDir:
        DS8 1
//  238 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  239 uint8 CurveLineChosenC1 = 0;               //曲率求取时，中心线选取的第1行。
CurveLineChosenC1:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  240 uint8 CurveLineChosenC2 = 0;               //曲率求取时，中心线选取的第1行。
CurveLineChosenC2:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  241 uint8 CurveLineChosenC3 = 0;               //曲率求取时，中心线选取的第1行。
CurveLineChosenC3:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  242 uint8 CurveLineChosenL1 = 0;               //曲率求取时，左黑线选取的第1行。
CurveLineChosenL1:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  243 uint8 CurveLineChosenL2 = 0;               //曲率求取时，左黑线选取的第1行。
CurveLineChosenL2:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  244 uint8 CurveLineChosenL3 = 0;               //曲率求取时，左黑线选取的第1行。
CurveLineChosenL3:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  245 uint8 CurveLineChosenR1 = 0;               //曲率求取时，右黑线选取的第1行。
CurveLineChosenR1:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  246 uint8 CurveLineChosenR2 = 0;               //曲率求取时，右黑线选取的第1行。
CurveLineChosenR2:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  247 uint8 CurveLineChosenR3 = 0;               //曲率求取时，右黑线选取的第1行。
CurveLineChosenR3:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  248 int16 SABCL = 0;                          //曲率求取时，左黑线曲率三角形的面积，顺时针为负，逆时针为正。
SABCL:
        DS8 2

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  249 int16 SABCC = 0;                          //曲率求取时，中心线曲率三角形的面积，顺时针为负，逆时针为正。
SABCC:
        DS8 2

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  250 int16 SABCR = 0;                          //曲率求取时，右黑线曲率三角形的面积，顺时针为负，逆时针为正。
SABCR:
        DS8 2

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  251 int16 CURVEL = 0;                          //曲率求取时，左黑线的曲率，顺时钟为负，逆时针为正。
CURVEL:
        DS8 2

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  252 int16 CURVEC = 0;                          //曲率求取时，中心线的曲率，顺时钟为负，逆时针为正。
CURVEC:
        DS8 2

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  253 int16 CURVER = 0;                          //曲率求取时，右黑线的曲率，顺时钟为负，逆时针为正。
CURVER:
        DS8 2
//  254 //int16 CurveLeftLimitL = 8;               //赛道类型判断时，通过左黑线曲率判断赛道为左弯的阈值。很敏感，任何硬软件改变后需手动改动此值。
//  255 //int16 CurveLeftLimitC = 10;              //赛道类型判断时，通过中心线曲率判断赛道为左弯的阈值。很敏感，任何硬软件改变后需手动改动此值。
//  256 //int16 CurveLeftLimitR = 12;              //赛道类型判断时，通过右黑线曲率判断赛道为左弯的阈值。很敏感，任何硬软件改变后需手动改动此值。
//  257 //int16 CurveRightLimitL = 12;             //赛道类型判断时，通过左黑线曲率判断赛道为右弯的阈值。很敏感，任何硬软件改变后需手动改动此值。
//  258 //int16 CurveRightLimitC = 10;             //赛道类型判断时，通过中心线曲率判断赛道为右弯的阈值。很敏感，任何硬软件改变后需手动改动此值。
//  259 //int16 CurveRightLimitR = 8;              //赛道类型判断时，通过右黑线曲率判断赛道为右弯的阈值。很敏感，任何硬软件改变后需手动改动此值。

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//  260 int32 SlopeL = MaxValInt16;                           //斜率求取时，左黑线的斜率。
SlopeL:
        DATA
        DC32 32767

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//  261 int32 SlopeC = MaxValInt16;                           //斜率求取时，中心线的斜率。
SlopeC:
        DATA
        DC32 32767

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//  262 int32 SlopeR = MaxValInt16;                           //斜率求取时，右黑线的斜率。
SlopeR:
        DATA
        DC32 32767
//  263 

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  264 uint8 CurveSlopeFlagL = 1;                  //左黑线曲率、斜率求取的标志位，1成功，0失败(CURVE和Slope均置了无效值)
CurveSlopeFlagL:
        DATA
        DC8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  265 uint8 CurveSlopeFlagC = 1;                  //中心线曲率、斜率求取的标志位，1成功，0失败(CURVE和Slope均置了无效值)
CurveSlopeFlagC:
        DATA
        DC8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  266 uint8 CurveSlopeFlagR = 1;                  //右黑线曲率、斜率求取的标志位，1成功，0失败(CURVE和Slope均置了无效值)
CurveSlopeFlagR:
        DATA
        DC8 1
//  267 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  268 uint8 ErrorGetSelf;                 //平均值与自身的偏差，也就是curve
ErrorGetSelf:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  269 uint8 ErrorGetCen;                 //平均值与物理中心线的偏差。
ErrorGetCen:
        DS8 1
//  270 
//  271 //左

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  272 uint8 BlackLeftRealWB[2];                  //黑线的实际黑白差值的存储数组，用于计算实际黑白差值的阈值。替代LimitLeftWB
BlackLeftRealWB:
        DS8 2

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  273 uint8 BlackLeftRealB[2];                   //黑线的实际黑点值存储数组，用于计算实际黑点阈值。替代LimitLeftB
BlackLeftRealB:
        DS8 2

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  274 uint8 BlackLeftRealW[2];                   //黑线的实际白点值存储数组，用于计算实际白点阈值。替代LimitLeftW
BlackLeftRealW:
        DS8 2
//  275 //3个关键值的上下界

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  276 uint8 LimitLeftWBMin = 35;
LimitLeftWBMin:
        DATA
        DC8 35

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  277 uint8 LimitLeftWBMax = 90;
LimitLeftWBMax:
        DATA
        DC8 90

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  278 uint8 LimitLeftWMin = 90;
LimitLeftWMin:
        DATA
        DC8 90

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  279 uint8 LimitLeftWMax = 140;
LimitLeftWMax:
        DATA
        DC8 140

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  280 uint8 LimitLeftBMin = 80;
LimitLeftBMin:
        DATA
        DC8 80

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  281 uint8 LimitLeftBMax = 110;
LimitLeftBMax:
        DATA
        DC8 110
//  282 
//  283 
//  284 //右

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  285 uint8 BlackRightRealWB[2];                  //黑线的实际黑白差值的存储数组，用于计算实际黑白差值的阈值。替代LimitRightWB
BlackRightRealWB:
        DS8 2

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  286 uint8 BlackRightRealB[2];                   //黑线的实际黑点值存储数组，用于计算实际黑点阈值。替代LimitRightB
BlackRightRealB:
        DS8 2

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  287 uint8 BlackRightRealW[2];                   //黑线的实际白点值存储数组，用于计算实际白点阈值。替代LimitRightW
BlackRightRealW:
        DS8 2
//  288 //3个关键值的上下界

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  289 uint8 LimitRightWBMin = 35;
LimitRightWBMin:
        DATA
        DC8 35

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  290 uint8 LimitRightWBMax = 90;
LimitRightWBMax:
        DATA
        DC8 90

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  291 uint8 LimitRightWMin = 90;
LimitRightWMin:
        DATA
        DC8 90

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  292 uint8 LimitRightWMax = 140;
LimitRightWMax:
        DATA
        DC8 140

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  293 uint8 LimitRightBMin = 80;
LimitRightBMin:
        DATA
        DC8 80

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  294 uint8 LimitRightBMax = 110;
LimitRightBMax:
        DATA
        DC8 110
//  295 
//  296  
//  297 //左
//  298 //小5点斜率储存

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  299 uint8 BlackLeft5SlopeIndex = 0;          //左线的小5点斜率储存数组的下标。
BlackLeft5SlopeIndex:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  300 uint8 BlackLeft5SlopeRow[CameraHight];      //右线的小5点斜率储存，计算小5点斜率时的最远点所在行。
BlackLeft5SlopeRow:
        DS8 60

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  301 int32 BlackLeft5Slope[CameraHight];      //左线的小5点斜率储存，从近往远储存。大跳变点不会储存进来。
BlackLeft5Slope:
        DS8 240
//  302 //3个关键值的可改值，可由自适应性算法更改。

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  303 uint8 LimitLeftWB;    //黑白像素点的差值，两个点的差必须要大于这个值，才能认为有跳变。
LimitLeftWB:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  304 uint8 LimitLeftW;      //白点必须要大于此值
LimitLeftW:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  305 uint8 LimitLeftB;      //黑点必须要小于此值
LimitLeftB:
        DS8 1
//  306 
//  307 //每幅有效图像的左线线头对应的3个阈值，单独储存，每幅有效图像刷新一次。

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  308 uint8 LimitLeftHeadWB;    
LimitLeftHeadWB:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  309 uint8 LimitLeftHeadW;      
LimitLeftHeadW:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  310 uint8 LimitLeftHeadB;      
LimitLeftHeadB:
        DS8 1
//  311 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  312 uint8 BlackLeftCrossDone = 0;    //左黑线十字检测标志位 0未进入 1失败 2成功
BlackLeftCrossDone:
        DS8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  313 uint8 BlackLeftDone = 1;          //左黑线提取成功标示位 1成功 0失败
BlackLeftDone:
        DATA
        DC8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  314 uint8 BlackLeft3ResetCount = 0;       //由于光线变化太大引起的3个关键值重置的次数。
BlackLeft3ResetCount:
        DS8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  315 uint8 BlackLeftCrossTooLowLine = 3;    //十字再检测时，低于该行就没必要启动再检测程序了。
BlackLeftCrossTooLowLine:
        DATA
        DC8 3

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  316 uint8 BlackLeftStep4Flag = 0;          //左黑线需要执行第4阶段的标志位，0未进入，1失败，2成功，3出错。
BlackLeftStep4Flag:
        DS8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  317 uint8 BlackLeftStep4StartLine = MaxValUint8;     //左黑线第4阶段起始行
BlackLeftStep4StartLine:
        DATA
        DC8 255

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  318 uint8 BlackLeftHeadLine = MaxValUint8;   //左黑线的线头，从上往下。
BlackLeftHeadLine:
        DATA
        DC8 255

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  319 uint8 BlackLeftEndLine = MaxValUint8;    //左黑线的线尾，从上往下。
BlackLeftEndLine:
        DATA
        DC8 255

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  320 uint8 BlackLeftWinPredictStore0 = 0;         //左黑线窗口内检测黑点时，防止预测点更新失败而储存的预测点值0.
BlackLeftWinPredictStore0:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  321 uint8 BlackLeftWinPredictStore1 = 0;         //左黑线窗口内检测黑点时，防止预测点更新失败而储存的预测点值1.
BlackLeftWinPredictStore1:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  322 uint8 BlackLeftWinPredictStore2 = 0;         //左黑线窗口内检测黑点时，防止预测点更新失败而储存的预测点值2.
BlackLeftWinPredictStore2:
        DS8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  323 uint8 BlackLeftContinueFlag = 1;           //左黑线连续性标志，1连续或采线未成功，0不连续，2出错。
BlackLeftContinueFlag:
        DATA
        DC8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  324 uint8 BlackLeftCrossConfirmFlag = 0;  //左十字线头标志。0未进入，1超范围，2成功。默认为未进入。  
BlackLeftCrossConfirmFlag:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  325 uint8 BlackLeftEdgeStartCol;      //左黑线检测跳变沿时的下一幅图的起始列，每幅图根据上一幅有效图像来估计，需要考虑到单线的宽度。
BlackLeftEdgeStartCol:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  326 uint8 BlackLeftLastEdgeStartCol;  //左黑线检测跳变沿时的上一幅图的起始列（也就是这一幅图），每幅图根据上一幅有效图像来估计，需要考虑到单线的宽度。
BlackLeftLastEdgeStartCol:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  327 uint8 BlackLeftStep1ScanRow;      //左黑线第1阶段线头检测时的返回行。
BlackLeftStep1ScanRow:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  328 uint8 BlackLeftRow1RealLastLine;       //左黑线十字检测，第1段黑线的真实结束行，有可能因为大跳变被删掉，但差别不会超过3行。
BlackLeftRow1RealLastLine:
        DS8 1
//  329 
//  330 //右
//  331 //小5点斜率储存

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  332 uint8 BlackRight5SlopeIndex = 0;          //右线的小5点斜率储存数组的下标。
BlackRight5SlopeIndex:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  333 uint8 BlackRight5SlopeRow[CameraHight];      //右线的小5点斜率储存，计算小5点斜率时的最远点所在行。
BlackRight5SlopeRow:
        DS8 60

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  334 int32 BlackRight5Slope[CameraHight];      //右线的小5点斜率储存，从近往远储存。大跳变点不会储存进来。
BlackRight5Slope:
        DS8 240
//  335 //3个关键值的可改值，可由自适应性算法更改。

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  336 uint8 LimitRightWB;    //黑白像素点的差值，两个点的差必须要大于这个值，才能认为有跳变。
LimitRightWB:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  337 uint8 LimitRightW;      //白点必须要大于此值
LimitRightW:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  338 uint8 LimitRightB;      //黑点必须要小于此值
LimitRightB:
        DS8 1
//  339 
//  340 //每幅有效图像的右线线头对应的3个阈值，单独储存，每幅有效图像刷新一次。

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  341 uint8 LimitRightHeadWB;    
LimitRightHeadWB:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  342 uint8 LimitRightHeadW;      
LimitRightHeadW:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  343 uint8 LimitRightHeadB;      
LimitRightHeadB:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  344 uint8 BlackRightCrossDone = 0;   //右黑线十字检测标志位 0未进入 1失败 2成功
BlackRightCrossDone:
        DS8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  345 uint8 BlackRightDone = 1;          //右黑线提取成功标示位 1成功 0失败
BlackRightDone:
        DATA
        DC8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  346 uint8 BlackRight3ResetCount = 0;       //由于光线变化太大引起的3个关键值重置的次数。
BlackRight3ResetCount:
        DS8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  347 uint8 BlackRightCrossTooLowLine = 3;    //十字再检测时，低于该行就没必要启动再检测程序了。
BlackRightCrossTooLowLine:
        DATA
        DC8 3

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  348 uint8 BlackRightStep4Flag = 0;          //右黑线需要执行第4阶段的标志位，0未进入，1失败，2成功，3出错。
BlackRightStep4Flag:
        DS8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  349 uint8 BlackRightStep4StartLine = MaxValUint8;     //右黑线第4阶段起始行
BlackRightStep4StartLine:
        DATA
        DC8 255

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  350 uint8 BlackRightHeadLine = MaxValUint8;    //右黑线的线头，从上往下。
BlackRightHeadLine:
        DATA
        DC8 255

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  351 uint8 BlackRightEndLine = MaxValUint8;     //右黑线的线尾，从上往下。
BlackRightEndLine:
        DATA
        DC8 255

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  352 uint8 BlackRightWinPredictStore0 = 0;         //右黑线窗口内检测黑点时，防止预测点更新失败而储存的预测点值0.
BlackRightWinPredictStore0:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  353 uint8 BlackRightWinPredictStore1 = 0;         //右黑线窗口内检测黑点时，防止预测点更新失败而储存的预测点值1.
BlackRightWinPredictStore1:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  354 uint8 BlackRightWinPredictStore2 = 0;         //右黑线窗口内检测黑点时，防止预测点更新失败而储存的预测点值2.
BlackRightWinPredictStore2:
        DS8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  355 uint8 BlackRightContinueFlag = 1;           //右黑线连续性标志，1连续或采线未成功，0不连续，2出错。
BlackRightContinueFlag:
        DATA
        DC8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  356 uint8 BlackRightCrossConfirmFlag = 0;  //右十字线头标志。0未进入，1超范围，2成功。默认为未进入。
BlackRightCrossConfirmFlag:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  357 uint8 BlackRightEdgeStartCol;      //右黑线检测跳变沿时的下一幅图的起始列，每幅图根据上一幅有效图像来估计，需要考虑到单线的宽度。
BlackRightEdgeStartCol:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  358 uint8 BlackRightLastEdgeStartCol;  //右黑线检测跳变沿时的上一幅图的起始列（也就是这一幅图），每幅图根据上一幅有效图像来估计，需要考虑到单线的宽度。
BlackRightLastEdgeStartCol:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  359 uint8 BlackRightStep1ScanRow;      //右黑线第1阶段线头检测时的返回行。
BlackRightStep1ScanRow:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  360 uint8 BlackRightRow1RealLastLine;       //右黑线十字检测，第1段黑线的真实结束行，有可能因为大跳变被删掉，但差别不会超过3行。
BlackRightRow1RealLastLine:
        DS8 1
//  361 
//  362 //紧急停车

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  363 uint8 EmergencyStopCount = 0;     //紧急停车计数器。每当图像处理失败时加1，连续计EmergencyStopCountNum个则置标志位。
EmergencyStopCount:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  364 uint8 EmergencyStopFlag = 0;      //紧急停车标志。1表示紧急停车，会将电机输出置0，只有掉电重开才能置0.
EmergencyStopFlag:
        DS8 1
//  365 
//  366 
//  367 //偏差获取
//  368 //int16 DeviNow = 0;                  //当前偏差

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  369 uint8 DeviFlag = 0;                //偏差求取标志位，告诉程序这次应该写入第几个偏差。
DeviFlag:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  370 uint8 DeviRowChosen = 0;               //求取偏差时选取的行，若指定范围没选取到则置无效值，若偏差过小，则置为0。
DeviRowChosen:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  371 uint8 DeviNowLevel = 0;      //当前偏差的绝对值的等级，10个等级，0偏差最小，9偏差最大。
DeviNowLevel:
        DS8 1
//  372 
//  373 //直角黑色区域
//  374 //判断

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  375 uint8 AngleZoneJudgeRowL[AngleZoneJudgeRowNum];  //直角黑块，根据线头选中的要检测的左线行。
AngleZoneJudgeRowL:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  376 uint8 AngleZoneJudgeColL[AngleZoneJudgeRowNum];  //直角黑块，左线定位的所在列。
AngleZoneJudgeColL:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  377 uint8 AngleZoneJudgeColLFlag[AngleZoneJudgeRowNum]; //直角黑块，左线该行的有效黑点满足要求时置位。
AngleZoneJudgeColLFlag:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  378 uint8 AngleZoneJudgeCountColL[AngleZoneJudgeRowNum]; //直角黑块，左线，记录该行的有效黑点数，以供确定合适的阈值。
AngleZoneJudgeCountColL:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  379 uint8 AngleZoneJudgeRowR[AngleZoneJudgeRowNum];  //直角黑块，根据线头选中的要检测的右线行。
AngleZoneJudgeRowR:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  380 uint8 AngleZoneJudgeColR[AngleZoneJudgeRowNum];  //直角黑块，右线定位的所在列。
AngleZoneJudgeColR:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  381 uint8 AngleZoneJudgeColRFlag[AngleZoneJudgeRowNum]; //直角黑块，右线该行的有效黑点满足要求时置位。
AngleZoneJudgeColRFlag:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  382 uint8 AngleZoneJudgeCountColR[AngleZoneJudgeRowNum]; //直角黑块，右线，记录该行的有效黑点数，以供确定合适的阈值。
AngleZoneJudgeCountColR:
        DS8 8
//  383 //确认

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  384 uint8 AngleZoneConfirmLockMeterCount = 0; //直角黑块，锁存后进行的累加计数，用以直角黑块误判后的恢复正常。
AngleZoneConfirmLockMeterCount:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  385 uint8 AngleZoneConfirmCount = 0;   //对直角黑块确认次数的计数。
AngleZoneConfirmCount:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  386 uint8 AngleZoneConfirmLockFlag = 0;    //直角黑块判断成功锁存标志位,确认是直角黑块后置位。
AngleZoneConfirmLockFlag:
        DS8 1
//  387                                        //有两种情况清零，一是之后的线头差检测成功后，二是一定距离后仍没有检测到线头差。

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  388 uint8 AngleZoneConfirmMat[AngleZoneConfirmMatNum];  //直角黑块确认标志存储数组，1表示本次为直角黑块，0表示不是直角黑块。
AngleZoneConfirmMat:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  389 uint8 AngleZoneConfirmMatCollect = 0;      //直角黑块，AngleZoneConfirmMat数组中1的个数。
AngleZoneConfirmMatCollect:
        DS8 1
//  390 //可修改

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  391 uint8 AngleZoneConfirmMatLimit = 3;         //直角黑块，标志存储数组中直角黑块的个数大于该值时，则锁存为直角黑块。
AngleZoneConfirmMatLimit:
        DATA
        DC8 3
//  392 
//  393 //直角弯处理

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  394 uint8 AngleConfirmCount = 0;   //对直角弯确认次数的计数。
AngleConfirmCount:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  395 uint8 AngleSpeDealBackCount = 0;  //直角弯最终确认后，特殊情况次数的倒数计数。
AngleSpeDealBackCount:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  396 uint8 AngleSpeDealDir = 0;        //直角弯方向标志，0左直角弯，1右直角弯，2错误。
AngleSpeDealDir:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  397 uint8 AngleSpeDealFlag = 0;       //直角弯特殊处理标志，1表示该周期进行了直角弯特殊处理，0表示该周期没有进行直角弯特殊处理。
AngleSpeDealFlag:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  398 uint16 AngleConfirmCountMax = 0;   //记录实际直角弯确认次数的最大值，方便调节阈值。
AngleConfirmCountMax:
        DS8 2

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  399 uint8 AngleConfirmLockFlag = 0;    //直角弯判断成功锁存标志位,确认是直角弯后置位，用以确认直角弯特殊处理开始的位置。
AngleConfirmLockFlag:
        DS8 1
//  400                                    //直角弯锁存期间，不进行特殊赛道判断。

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  401 uint8 AngleSpeDealExitJudgeFlag = 0;  //出直角弯判断标志，1已出，0未出
AngleSpeDealExitJudgeFlag:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  402 uint8 AngleConfirmMat[AngleConfirmMatNum];  //直角弯确认标志存储数组，1表示本次为直角，0表示不是直角。
AngleConfirmMat:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  403 uint8 AngleConfirmMatCollect = 0;      //直角弯 ，AngleConfirmMat数组中1的个数。
AngleConfirmMatCollect:
        DS8 1
//  404 

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  405 uint8 AngleConfirmMatLimit = 3;         //直角弯标志存储数组中直角的个数大于该值时，则锁存为直角。
AngleConfirmMatLimit:
        DATA
        DC8 3

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  406 uint8 AngleLongHeadLineStrategy = 1;                //直角弯长线头策略，1表示去掉长线头，0表示不去长线头。
AngleLongHeadLineStrategy:
        DATA
        DC8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  407 uint8 AngleHeadLineNum = 5;              //左右线头之差大于该值，则有可能为直角弯。
AngleHeadLineNum:
        DATA
        DC8 5
//  408 
//  409 
//  410 //直角弯非障碍物确认。

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  411 uint8 AngleStep1NotBrickEndColL;    //直角弯非障碍物确认，左直角梯形，起始行（近行）黑点所在列。
AngleStep1NotBrickEndColL:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  412 uint8 AngleStep1NotBrickBorderColL; //直角弯非障碍物确认，左直角梯形，直角边所在列。
AngleStep1NotBrickBorderColL:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  413 uint8 AngleStep1NotBrickEndColR;    //直角弯非障碍物确认，右直角梯形，起始行（近行）黑点所在列。
AngleStep1NotBrickEndColR:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  414 uint8 AngleStep1NotBrickBorderColR; //直角弯非障碍物确认，右直角梯形，直角边所在列。
AngleStep1NotBrickBorderColR:
        DS8 1
//  415 
//  416 //障碍物

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  417 uint8 BrickConfirmCount = 0;   //对障碍物确认次数的计数。
BrickConfirmCount:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  418 uint8 BrickSpeDealBackCount = 0;  //障碍物最终确认后，特殊情况次数的倒数计数。
BrickSpeDealBackCount:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  419 uint8 BrickSpeDealDir = 0;        //障碍物位置，0左障碍物，1右障碍物，2错误。
BrickSpeDealDir:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  420 uint8 BrickSpeDealFlag = 0;       //障碍物特殊处理标志，1表示该周期进行了障碍物特殊处理，0表示该周期没有进行障碍物特殊处理。
BrickSpeDealFlag:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  421 uint16 BrickConfirmCountMax = 0;   //记录实际障碍物确认次数的最大值，方便调节阈值。
BrickConfirmCountMax:
        DS8 2

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  422 uint8 BrickConfirmLockFlag = 0;    //障碍物判断成功锁存标志位,确认是障碍物后置位，用以确认障碍物特殊处理开始的位置。
BrickConfirmLockFlag:
        DS8 1
//  423                                    //障碍物锁存期间，不进行特殊赛道判断。

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  424 uint8 BrickSpeDealExitJudgeFlag = 1;  //出障碍物判断标志，1表示初始态，2表示当前已经与障碍平行，0退出特殊控制，把控制权交还给普通控制。
BrickSpeDealExitJudgeFlag:
        DATA
        DC8 1
//  425                                       //不用每幅图更新，每次过完障碍，会手动写成1.

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  426 uint8 BrickConfirmMat0[BrickConfirmMatNum];  //左障碍物确认标志存储数组，1表示本次为障碍物，0表示不是障碍物。
BrickConfirmMat0:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  427 uint8 BrickConfirmMatCollect0 = 0;      //左障碍，BrickConfirmMat数组中1的个数。
BrickConfirmMatCollect0:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  428 uint8 BrickConfirmMat1[BrickConfirmMatNum];  //右障碍物确认标志存储数组，1表示本次为障碍物，0表示不是障碍物。
BrickConfirmMat1:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  429 uint8 BrickConfirmMatCollect1 = 0;      //右障碍，BrickConfirmMat数组中1的个数。
BrickConfirmMatCollect1:
        DS8 1
//  430 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  431 uint8 BrickSpeDealStartJudgeCol;     //障碍，判定是否开始特殊控制时，特定行对应的最小二乘法算出来的列。
BrickSpeDealStartJudgeCol:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  432 uint8 BrickEndColL;    //障碍物，左直角梯形，起始行（近行）黑点所在列。
BrickEndColL:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  433 uint8 BrickHeadColL;   //障碍物，左直角梯形，结束行（远行）黑点所在列。
BrickHeadColL:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  434 uint8 BrickBorderColL; //障碍物，左直角梯形，直角边所在列。
BrickBorderColL:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  435 uint8 BrickEndColR;    //障碍物，右直角梯形，起始行（近行）黑点所在列。
BrickEndColR:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  436 uint8 BrickHeadColR;   //障碍物，右直角梯形，结束行（远行）黑点所在列。
BrickHeadColR:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  437 uint8 BrickBorderColR; //障碍物，右直角梯形，直角边所在列。
BrickBorderColR:
        DS8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  438 uint8 BrickSpeDealCenFlag = 1; //障碍物，中心线特殊处理标志位，每幅图像会预置1。1表示无特殊处理或处理成功，0表示处理失败。
BrickSpeDealCenFlag:
        DATA
        DC8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  439 uint8 BrickLineCountNumRecord;
BrickLineCountNumRecord:
        DS8 1
//  440 //障碍，特殊控制时，偏移的列数。从数字大的开始执行，到数字小的。

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
//  441 const int BrickSpeDealBias[BrickSpeDealBackCountNum] = 
BrickSpeDealBias:
        DATA
        DC32 30, 30, 30, 25, 25, 25, 25, 25, 20, 20, 20, 15, 5, 0, -2, -5, -10
        DC32 -10, -19, -19
//  442 {
//  443   30,30,30,25,25,  
//  444   25,25,25,20, 20,
//  445    20, 15, 5, 0, -2,
//  446    -5, -10, -10, -19, -19
//  447 };
//  448 

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  449 uint8 BrickConfirmMatLimit = 3;         //障碍标志存储数组中障碍的个数大于该值时，则锁存为障碍。
BrickConfirmMatLimit:
        DATA
        DC8 3

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  450 uint8 BrickConfirmFinalColCom = 50;     //障碍躲避时的列修正量（以50为零，左减右加。）比50小表示往中心线靠，比50大表示往外走。
BrickConfirmFinalColCom:
        DATA
        DC8 50
//  451 
//  452 //单线处理

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  453 uint8 SingleBlackAllFlag = 0;   //总幅图像的单线标志，只要有一行检测单线成功，则置1.每幅图像处理前置0.
SingleBlackAllFlag:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  454 uint8 SingleBlackLastAllFlag = 0;      //上一幅图像的单线标志。
SingleBlackLastAllFlag:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  455 uint8 SingleDoneFlag = 0;              //单线处理时，单线成功标志位。
SingleDoneFlag:
        DS8 1
//  456                          //////////////////////目前还不完善，是每个有效行验证一次，一次成功则视为成功。

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  457 uint8 SingleFloorFlag = 0;             //单线处理时，地板判断成功标志位。1该幅图画左线是地板，0不是或没有判断。
SingleFloorFlag:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  458 uint8 SingleFloorConfirmCount = 0;       //单线处理时，地板判断确认计数值。每幅图归零一次。
SingleFloorConfirmCount:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  459 uint8 SingleFloorConfirmCountMax = 0;   //单线处理时，地板判断确认计数值的最大值，用于确认最佳确认阈值。每幅图归零一次。
SingleFloorConfirmCountMax:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  460 uint8 SingleBlackFlag[CameraHight];     //单线处理时，每行的单线判断成功标志。1该行为单线，0该行不是单线。每次图像处理前会置0.
SingleBlackFlag:
        DS8 60
//  461 
//  462 //赛道类型

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  463 uint8 PathJudgeDone = 1;                   //赛道类型判断成功标志位，1成功，0失败。
PathJudgeDone:
        DATA
        DC8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  464 uint8 PathType = PathTypeUnknown;          //未知 直道 左弯 右弯 左直 右直 小S
PathType:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  465 uint8 PathSmallSDoneFlag = 0;              //赛道类型判断时，小S弯判断成功标志位。1成功，0失败。每幅图赛道类型判断时初始化为0。
PathSmallSDoneFlag:
        DS8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  466 uint8 PathSmallSDir = 1;                   //赛道类型判断时，小S弯起始方向。
PathSmallSDir:
        DATA
        DC8 1
//  467 
//  468 //畸变矫正

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  469 int16 CenterLineLoc[CameraHight];      //中心线位置存储数组, 255为无效值
CenterLineLoc:
        DS8 120

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  470 LocationUdis BlackUdisLeftLocation[CameraHight];  //畸变矫正后，左黑线的位置储存数组。有正负，包括了行和列。
BlackUdisLeftLocation:
        DS8 480

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  471 LocationUdis BlackUdisRightLocation[CameraHight]; //畸变矫正后，左黑线的位置储存数组。有正负，包括了行和列。
BlackUdisRightLocation:
        DS8 480
//  472 //多行控制

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  473 int32 DeviFuse = 0;            //多行融合后的偏差。
DeviFuse:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  474 int32 DeviFuse_old = 0;
DeviFuse_old:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  475 uint32 DeviFuseArray[10];
DeviFuseArray:
        DS8 40

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  476 int32 Devi_near,Devi_far;      //近远行偏移量
Devi_near:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
Devi_far:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  477 int32 DeviPre = 0;                  //上一次偏差
DeviPre:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  478 int32 DeviPrePre=0;              //上上次偏差
DeviPrePre:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  479 int32 DeviPrePrePre=0;              //上上上次偏差
DeviPrePrePre:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  480 int16 ControlRowDeviInit[4];    //各控制行的初始偏差,归一的0~100,0~3分别是base，low，middle，high
ControlRowDeviInit:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  481 int16 ControlRowDeviOld[4]; 
ControlRowDeviOld:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  482 uint8 BaseRowControlNum;        //近行控制序号，对应于权重数组列下标
BaseRowControlNum:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  483 uint8 FuzzyDegree;              //隶属度计算辅助变量
FuzzyDegree:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  484 uint8 ControlRowWeight[4];      //控制行权重系数,模糊计算
ControlRowWeight:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
//  485 uint16 Weight_sum = 0;            //权重系数的和
Weight_sum:
        DS8 2
//  486 
//  487 
//  488 
//  489 //大斜率检测。

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  490 uint8 BlackLeftBigChangeNumx[5];                     //大斜率检测时，横坐标X的储存数组。储存行号。
BlackLeftBigChangeNumx:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  491 uint8 BlackLeftBigChangeNumy[5];                     //大斜率检测时，横坐标X的储存数组。储存有效行的黑点所在列。
BlackLeftBigChangeNumy:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  492 uint8 BlackLeftBigChangeFlag = 0;              //大斜率检测时，检测到大斜率的标志。每幅图像会清零，但只要有一次检测到则置位。1该幅图像检测到大斜率，0该幅图像没有检测到。
BlackLeftBigChangeFlag:
        DS8 1

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//  493 int32 BlackLeftBigChangeSlopeStore = MaxValInt16;    //大斜率检测时，储存的上一次的斜率值。
BlackLeftBigChangeSlopeStore:
        DATA
        DC32 32767

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  494 uint8 BlackLeftBigChangeJumpFlag = 0;                //大斜率检测时，用来跳过程序内的一个小循环。
BlackLeftBigChangeJumpFlag:
        DS8 1
//  495 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  496 uint8 BlackRightBigChangeNumx[5];                     //大斜率检测时，横坐标X的储存数组。储存行号。
BlackRightBigChangeNumx:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  497 uint8 BlackRightBigChangeNumy[5];                     //大斜率检测时，横坐标X的储存数组。储存有效行的黑点所在列。
BlackRightBigChangeNumy:
        DS8 8

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  498 uint8 BlackRightBigChangeFlag = 0;              //大斜率检测时，检测到大斜率的标志。每幅图像会清零，但只要有一次检测到则置位。
BlackRightBigChangeFlag:
        DS8 1

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//  499 int32 BlackRightBigChangeSlopeStore = MaxValInt16;    //大斜率检测时，储存的上一次的斜率值。
BlackRightBigChangeSlopeStore:
        DATA
        DC32 32767

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  500 uint8 BlackRightBigChangeJumpFlag = 0;                //大斜率检测时，用来跳过程序内的一个小循环。
BlackRightBigChangeJumpFlag:
        DS8 1
//  501 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  502 uint8 BlackLeftBigChangeCheckRow[CameraHight];   //大斜率检测时，每行的标志。1表示该行左黑线未通过大跳变检测，0表示通过。
BlackLeftBigChangeCheckRow:
        DS8 60

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  503 uint8 BlackLeftBigChangeCheckAllRow;             //大斜率检测时，1该幅图像的左黑线存在有某行未通过大跳变检测，0该幅图像每行左黑线均通过大跳变检测。
BlackLeftBigChangeCheckAllRow:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  504 uint8 BlackRightBigChangeCheckRow[CameraHight];  //大斜率检测时，每行的标志。1表示该行右黑线未通过大跳变检测，0表示通过。
BlackRightBigChangeCheckRow:
        DS8 60

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  505 uint8 BlackRightBigChangeCheckAllRow;            //大斜率检测时，1该幅图像的右黑线存在有某行未通过大跳变检测，0该幅图像每行右黑线均通过大跳变检测。
BlackRightBigChangeCheckAllRow:
        DS8 1
//  506 
//  507 //回弯检测

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  508 uint8 BlackLeftRollCheckFlag = 0;             //回弯检测标志位，0未检测到回弯，1检测到回弯。
BlackLeftRollCheckFlag:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  509 uint8 BlackRightRollCheckFlag = 0;             //回弯检测标志位，0未检测到回弯，1检测到回弯。
BlackRightRollCheckFlag:
        DS8 1
//  510 
//  511 
//  512 
//  513 //十字外尾

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  514 uint8 BlackLeftCrossTailFlag = 2;       //十字外尾标志，0失败，1确认，2未进入。
BlackLeftCrossTailFlag:
        DATA
        DC8 2

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  515 uint8 BlackLeftCrossTailEndLine;        //十字外尾，待删除的最远行。
BlackLeftCrossTailEndLine:
        DS8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  516 uint8 BlackRightCrossTailFlag = 2;       //十字外尾标志，0失败，1确认，2未进入。
BlackRightCrossTailFlag:
        DATA
        DC8 2

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  517 uint8 BlackRightCrossTailEndLine;        //十字外尾，待删除的最远行。
BlackRightCrossTailEndLine:
        DS8 1
//  518 
//  519 //窗口预测值管理

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  520 uint8 BlackLeftPredictL[CameraHight];          //窗口预测值，左线的左边界。
BlackLeftPredictL:
        DS8 60

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  521 uint8 BlackLeftPredictR[CameraHight];          //窗口预测值，左线的右边界。
BlackLeftPredictR:
        DS8 60

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  522 uint8 BlackRightPredictL[CameraHight];          //窗口预测值，右线的左边界。
BlackRightPredictL:
        DS8 60

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  523 uint8 BlackRightPredictR[CameraHight];          //窗口预测值，右线的右边界。
BlackRightPredictR:
        DS8 60
//  524 
//  525 //赛道半宽

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  526 uint8 RoadHalfWidth;                              //双线赛道半宽
RoadHalfWidth:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  527 uint8 RoadHalfWidthLast;                          //上一幅图最终的双线赛道半宽
RoadHalfWidthLast:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  528 uint8 RoadHalfWidthRecord[CameraHight];           //双线赛道半宽记录
RoadHalfWidthRecord:
        DS8 60

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  529 uint8 RoadHalfWidthSingle;                        //单线赛道半宽
RoadHalfWidthSingle:
        DS8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  530 uint8 RoadHalfWidthWrongFlag = 2;                 //通过赛道半宽判断出来的单线错误标志，2未进入，1错误，0正确。
RoadHalfWidthWrongFlag:
        DATA
        DC8 2

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  531 uint8 RoadHalfWidthWrongDir;                      //单线错误时，0左线悬空，1右线悬空。
RoadHalfWidthWrongDir:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  532 float RoadHalfWidthCompen;                        //单双线切换的修正系数
RoadHalfWidthCompen:
        DS8 4

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  533 uint8 RoadHalfWidthSwitch = 1;                        //路宽开关，1单线算斜率，取最大值，0单线直接用上次双线的
RoadHalfWidthSwitch:
        DATA
        DC8 1
//  534 
//  535 
//  536 //单线错误

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  537 uint8 BlackSingleFlag = 0;   //单线错误标志。0没错误，1有错误。每幅图初始化为0.
BlackSingleFlag:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  538 uint8 BlackSingleDir;        //单线错误的方向标志，0表示左线悬空，1表示右线悬空。
BlackSingleDir:
        DS8 1
//  539 
//  540 //最终大跳变检测

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  541 uint8 BlackBigChangeFinalCheckFlag = 0;  //最终大跳变检测标志位。0未检测到或没必要检测，1检测到左线最终大跳变，2检测到右线最终大跳变
BlackBigChangeFinalCheckFlag:
        DS8 1
//  542 
//  543 //长直道

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  544 uint8 PathRealStraightCount = 0;   //连续直道计数
PathRealStraightCount:
        DS8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
//  545 uint8 PathRealStraightCountLimit = 10;  //连续直道计数阈值，大于该值则确认为长直道。
PathRealStraightCountLimit:
        DATA
        DC8 10

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  546 uint8 PathRealStraightFlag = 0;        //长直道标志，1是长直道，0不是。
PathRealStraightFlag:
        DS8 1
//  547 
//  548 
//  549 
//  550 
//  551 //绝对值求取

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  552 int32 AbsInt(int32 val)
//  553 {
//  554   if(val >= 0)
AbsInt:
        CMP      R0,#+0
        BPL.N    ??AbsInt_0
//  555   {
//  556     return val;
//  557   }
//  558   else
//  559   {
//  560     return (0-val);
??AbsInt_1:
        RSBS     R0,R0,#+0
??AbsInt_0:
        BX       LR               ;; return
//  561   }
//  562 }
//  563 
//  564 //左右边界限制

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  565 int32 BoundaryLimitRe(int32 x, int32 left, int32 right)
//  566 {
//  567   if(x < left)
BoundaryLimitRe:
        CMP      R0,R1
        BGE.N    ??BoundaryLimitRe_0
//  568   {
//  569     return left;
        MOVS     R0,R1
        B.N      ??BoundaryLimitRe_1
//  570   }
//  571   else if(x > right)
??BoundaryLimitRe_0:
        CMP      R2,R0
        BGE.N    ??BoundaryLimitRe_2
//  572   {
//  573     return right;
        MOVS     R0,R2
        B.N      ??BoundaryLimitRe_1
//  574   }
//  575   else
//  576   {
//  577     return x;
??BoundaryLimitRe_2:
??BoundaryLimitRe_1:
        BX       LR               ;; return
//  578   }
//  579 }
//  580 
//  581 //======================================================================
//  582 //函数名：MaxRe
//  583 //功  能：求取两数最大值
//  584 //参  数：第1个数num1, 第2个数num2。
//  585 //返  回：2个数中的最大值
//  586 //影  响：无
//  587 //说  明：1. 两个输入参数无先后顺序。
//  588 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  589 int32 MaxRe(int32 a, int32 b)
//  590 {
//  591   return (a > b ? a : b);
MaxRe:
        CMP      R1,R0
        BLT.N    ??MaxRe_0
??MaxRe_1:
        MOVS     R0,R1
??MaxRe_0:
        BX       LR               ;; return
//  592 }
//  593 
//  594 //======================================================================
//  595 //函数名：MinRe
//  596 //功  能：求取两数最小值
//  597 //参  数：第1个数num1, 第2个数num2。
//  598 //返  回：2个数中的最小值
//  599 //影  响：无
//  600 //说  明：1. 两个输入参数无先后顺序。   
//  601 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  602 int32 MinRe(int32 a, int32 b)
//  603 {
//  604   return (a < b ? a : b);
MinRe:
        CMP      R0,R1
        BLT.N    ??MinRe_0
??MinRe_1:
        MOVS     R0,R1
??MinRe_0:
        BX       LR               ;; return
//  605 }
//  606 
//  607 //======================================================================
//  608 //函数名：AbsRe
//  609 //功  能：求取两数差值的绝对值
//  610 //参  数：第1个数num1, 第2个数num2。
//  611 //返  回：2个数的绝对值。
//  612 //影  响：无
//  613 //说  明：1. 两个输入参数无先后顺序。 
//  614 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  615 int32 AbsRe(int32 num1, int32 num2)
//  616 {
//  617   if(num1 >= num2)
AbsRe:
        CMP      R0,R1
        BLT.N    ??AbsRe_0
//  618   {
//  619     return (num1 - num2);  
        SUBS     R0,R0,R1
        B.N      ??AbsRe_1
//  620   }
//  621   else
//  622   {
//  623     return (num2 - num1);  
??AbsRe_0:
        SUBS     R0,R1,R0
??AbsRe_1:
        BX       LR               ;; return
//  624   }
//  625 }
//  626 
//  627 
//  628 
//  629 //十字检测

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  630 int ShiZhiCheck()
//  631 {
ShiZhiCheck:
        PUSH     {R4-R6,LR}
//  632     uint8 startRow = 59;
        MOVS     R4,#+59
//  633     uint8 row;
//  634     uint8 col;
//  635     uint32 limitL;
//  636     uint32 limitR;
//  637     uint32 limit;
//  638 
//  639     limitL = 0;
        MOVS     R4,#+0
//  640     limitR = 0;
        MOVS     R5,#+0
//  641     limit = 0;
        MOVS     R6,#+0
//  642     if(ShiZhiFlag==0)
        LDR.W    R0,??DataTable6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.W    ??ShiZhiCheck_0
//  643     {
//  644         //要保证黑线采集成功
//  645         if (BlackLeftDone != 1 || BlackRightDone != 1) { return 0; }
        LDR.W    R0,??DataTable6_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??ShiZhiCheck_1
        LDR.W    R0,??DataTable6_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??ShiZhiCheck_2
??ShiZhiCheck_1:
        MOVS     R0,#+0
        B.N      ??ShiZhiCheck_3
//  646         //要保证是在直道
//  647         if (AbsInt(SlopeL) < 1700 && AbsInt(SlopeR) < 1700
//  648             && BlackRightCrossDone != 2 && BlackLeftCrossDone != 2
//  649                 && BlackRightEndLine > 57 && BlackLeftEndLine > 57)
??ShiZhiCheck_2:
        LDR.W    R0,??DataTable6_3
        LDR      R0,[R0, #+0]
        BL       AbsInt
        MOVW     R1,#+1700
        CMP      R0,R1
        BGE.N    ??ShiZhiCheck_4
        LDR.W    R0,??DataTable6_4
        LDR      R0,[R0, #+0]
        BL       AbsInt
        MOVW     R1,#+1700
        CMP      R0,R1
        BGE.N    ??ShiZhiCheck_4
        LDR.W    R0,??DataTable6_5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BEQ.N    ??ShiZhiCheck_4
        LDR.W    R0,??DataTable6_6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BEQ.N    ??ShiZhiCheck_4
        LDR.W    R0,??DataTable6_7
        LDRB     R0,[R0, #+0]
        CMP      R0,#+58
        BLT.N    ??ShiZhiCheck_4
        LDR.W    R0,??DataTable6_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+58
        BLT.N    ??ShiZhiCheck_4
//  650         {
//  651             if (BlackRightHeadLine >= 15 && BlackLeftHeadLine >= 15 && BlackRightHeadLine <= 59 && BlackLeftHeadLine <= 59 && AbsInt(BlackLeftHeadLine - BlackRightHeadLine) <= 10) { }
        LDR.W    R0,??DataTable6_9
        LDRB     R0,[R0, #+0]
        CMP      R0,#+15
        BLT.N    ??ShiZhiCheck_5
        LDR.W    R0,??DataTable6_10
        LDRB     R0,[R0, #+0]
        CMP      R0,#+15
        BLT.N    ??ShiZhiCheck_5
        LDR.W    R0,??DataTable6_9
        LDRB     R0,[R0, #+0]
        CMP      R0,#+60
        BGE.N    ??ShiZhiCheck_5
        LDR.W    R0,??DataTable6_10
        LDRB     R0,[R0, #+0]
        CMP      R0,#+60
        BGE.N    ??ShiZhiCheck_5
        LDR.W    R0,??DataTable6_10
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable6_9
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        BL       AbsInt
        CMP      R0,#+11
        BLT.N    ??ShiZhiCheck_6
//  652             else { return 0; }
??ShiZhiCheck_5:
        MOVS     R0,#+0
        B.N      ??ShiZhiCheck_3
//  653         }
//  654         else { return 0; }
//  655 
//  656         if (BlackLeftHeadLine >= BlackLeftEndLine) { return 0; }
??ShiZhiCheck_6:
        LDR.W    R0,??DataTable6_10
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable6_8
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCC.N    ??ShiZhiCheck_7
        MOVS     R0,#+0
        B.N      ??ShiZhiCheck_3
??ShiZhiCheck_4:
        MOVS     R0,#+0
        B.N      ??ShiZhiCheck_3
//  657         //线所在的列必须在一定范围内
//  658         for (row = BlackLeftEndLine; row >= BlackLeftHeadLine; row--)
??ShiZhiCheck_7:
        LDR.W    R0,??DataTable6_8
        LDRB     R0,[R0, #+0]
        B.N      ??ShiZhiCheck_8
//  659         {
//  660             if (BlackLeftLoc[row][0] < 10 || BlackLeftLoc[row][0] > 240) { return 0; }
//  661             else
//  662             {
//  663                 limitL += ImgNew[row][BlackLeftLoc[row][0] - 9];
??ShiZhiCheck_9:
        LDR.W    R1,??DataTable6_11
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R0,R1
        LDR.W    R2,??DataTable6_12
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #-9]
        UXTAB    R4,R4,R1
//  664             }
        SUBS     R0,R0,#+1
??ShiZhiCheck_8:
        LDR.W    R1,??DataTable6_10
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCC.N    ??ShiZhiCheck_10
        LDR.W    R1,??DataTable6_12
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+10
        CMP      R1,#+231
        BCC.N    ??ShiZhiCheck_9
        MOVS     R0,#+0
        B.N      ??ShiZhiCheck_3
//  665         }
//  666         for (row = BlackRightEndLine ; row >= BlackRightHeadLine; row--)
??ShiZhiCheck_10:
        LDR.W    R0,??DataTable6_7
        LDRB     R0,[R0, #+0]
        B.N      ??ShiZhiCheck_11
//  667         {
//  668             if (BlackRightLoc[row][0] < 10 || BlackRightLoc[row][0] > 240) { return 0; }
//  669             else
//  670             {
//  671                 limitR += ImgNew[row][BlackRightLoc[row][0] + 9];
??ShiZhiCheck_12:
        LDR.W    R1,??DataTable6_11
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R0,R1
        LDR.W    R2,??DataTable7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #+9]
        UXTAB    R5,R5,R1
//  672             }
        SUBS     R0,R0,#+1
??ShiZhiCheck_11:
        LDR.W    R1,??DataTable6_9
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCC.N    ??ShiZhiCheck_13
        LDR.W    R1,??DataTable7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+10
        CMP      R1,#+231
        BCC.N    ??ShiZhiCheck_12
        MOVS     R0,#+0
        B.N      ??ShiZhiCheck_3
//  673         }
//  674 
//  675         limit = (limitL + limitR) / (BlackLeftEndLine - BlackLeftHeadLine + 1) / 2;
??ShiZhiCheck_13:
        ADDS     R0,R5,R4
        LDR.W    R1,??DataTable6_8
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable6_10
        LDRB     R2,[R2, #+0]
        SUBS     R1,R1,R2
        ADDS     R1,R1,#+1
        UDIV     R0,R0,R1
        LSRS     R6,R0,#+1
//  676         startRow = MinRe(BlackLeftHeadLine, BlackRightHeadLine) - 3;
        LDR.W    R0,??DataTable6_9
        LDRB     R1,[R0, #+0]
        LDR.W    R0,??DataTable6_10
        LDRB     R0,[R0, #+0]
        BL       MinRe
        SUBS     R4,R0,#+3
//  677         limit = MaxRe(limit, LimitLeftB) + 10;
        LDR.W    R0,??DataTable7_1
        LDRB     R1,[R0, #+0]
        MOVS     R0,R6
        BL       MaxRe
        ADDS     R6,R0,#+10
//  678 
//  679         for (row = startRow; row > startRow - 3; row--)
        MOVS     R0,R4
        B.N      ??ShiZhiCheck_14
??ShiZhiCheck_15:
        SUBS     R0,R0,#+1
??ShiZhiCheck_14:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        SUBS     R1,R4,#+3
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BGE.N    ??ShiZhiCheck_16
//  680         {
//  681             for (col = 30; col <= 220; col++)
        MOVS     R1,#+30
        B.N      ??ShiZhiCheck_17
??ShiZhiCheck_18:
        ADDS     R1,R1,#+1
??ShiZhiCheck_17:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+221
        BGE.N    ??ShiZhiCheck_15
//  682             {
//  683                 if (ImgNew[row][col] <= limit) { return 0; }
        LDR.W    R2,??DataTable6_11
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R0,R2
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R2,[R1, R2]
        CMP      R6,R2
        BCC.N    ??ShiZhiCheck_18
        MOVS     R0,#+0
        B.N      ??ShiZhiCheck_3
//  684             }
//  685         }
//  686         ShiZhiCount = 0;
??ShiZhiCheck_16:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable7_2
        STRB     R0,[R1, #+0]
//  687         return 1;
        MOVS     R0,#+1
        B.N      ??ShiZhiCheck_3
//  688     }
//  689     else
//  690     {
//  691         if(BlackLeftLoc[20][0]!=MaxValUint8 && BlackRightLoc[20][0]!=MaxValUint8){return 0;}
??ShiZhiCheck_0:
        LDR.W    R0,??DataTable6_12
        LDRB     R0,[R0, #+60]
        CMP      R0,#+255
        BEQ.N    ??ShiZhiCheck_19
        LDR.W    R0,??DataTable7
        LDRB     R0,[R0, #+60]
        CMP      R0,#+255
        BEQ.N    ??ShiZhiCheck_19
        MOVS     R0,#+0
        B.N      ??ShiZhiCheck_3
//  692         else if(BlackRightHeadLine<15 && BlackLeftHeadLine<15){return 0;}
??ShiZhiCheck_19:
        LDR.W    R0,??DataTable6_9
        LDRB     R0,[R0, #+0]
        CMP      R0,#+15
        BGE.N    ??ShiZhiCheck_20
        LDR.W    R0,??DataTable6_10
        LDRB     R0,[R0, #+0]
        CMP      R0,#+15
        BGE.N    ??ShiZhiCheck_20
        MOVS     R0,#+0
        B.N      ??ShiZhiCheck_3
//  693         else if(++ShiZhiCount>=6){return 0;}
??ShiZhiCheck_20:
        LDR.W    R0,??DataTable7_2
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.W    R1,??DataTable7_2
        STRB     R0,[R1, #+0]
        LDR.W    R0,??DataTable7_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+6
        BLT.N    ??ShiZhiCheck_21
        MOVS     R0,#+0
        B.N      ??ShiZhiCheck_3
//  694         else{return 1;}
??ShiZhiCheck_21:
        MOVS     R0,#+1
??ShiZhiCheck_3:
        POP      {R4-R6,PC}       ;; return
//  695     }
//  696 }
//  697 
//  698 
//  699 
//  700 
//  701 //新加入的停车线检测

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  702 uint8 StopLineCheck()
//  703 {
StopLineCheck:
        PUSH     {R3-R7,LR}
//  704     uint8 row;
//  705     uint8 col;
//  706     uint16 leftCount = 0;
        MOVS     R4,#+0
//  707     uint16 rightCount = 0;
        MOVS     R5,#+0
//  708     uint16 centerErrorCount = 0;
        MOVS     R0,#+0
//  709     uint32 limitStopLineBlack = 0;
        MOVS     R6,#+0
//  710     
//  711     
//  712     if(StopLineCheckBeginFlag == 0)
        LDR.W    R0,??DataTable7_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??StopLineCheck_0
//  713     {
//  714         if(++StopLineCheckTimer >= 50)
        LDR.W    R0,??DataTable7_4
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.W    R1,??DataTable7_4
        STRB     R0,[R1, #+0]
        LDR.W    R0,??DataTable7_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+50
        BLT.N    ??StopLineCheck_1
//  715         {
//  716             StopLineCheckBeginFlag = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable7_3
        STRB     R0,[R1, #+0]
//  717         }
//  718         else {return 0;}
//  719     }
//  720 
//  721     
//  722     limitStopLineBlack = 0;
??StopLineCheck_0:
        MOVS     R6,#+0
//  723     centerErrorCount = 0;
        MOVS     R0,#+0
//  724     //要保证黑线采集成功
//  725     if (BlackLeftDone != 1 || BlackRightDone != 1) { return 0; }
        LDR.W    R0,??DataTable6_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??StopLineCheck_2
        LDR.W    R0,??DataTable6_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??StopLineCheck_3
??StopLineCheck_2:
        MOVS     R0,#+0
        B.N      ??StopLineCheck_4
??StopLineCheck_1:
        MOVS     R0,#+0
        B.N      ??StopLineCheck_4
//  726     //要保证是在直道
//  727     if (AbsInt(SlopeL) < 1500 && AbsInt(SlopeR) < 1500 && AbsInt(CURVEL) < 15 && AbsInt(CURVER) < 15
//  728         && BlackRightCrossDone == 0 && BlackLeftCrossDone == 0
//  729             && BlackRightHeadLine < 3 && BlackLeftHeadLine < 3 && BlackRightEndLine > 57 && BlackLeftEndLine > 57
//  730                 && BlackLeftCrossDone == 0 && BlackRightCrossDone == 0
//  731                  && ShiZhiFlag == 0) { }
??StopLineCheck_3:
        LDR.W    R0,??DataTable6_3
        LDR      R0,[R0, #+0]
        BL       AbsInt
        MOVW     R1,#+1500
        CMP      R0,R1
        BGE.N    ??StopLineCheck_5
        LDR.W    R0,??DataTable6_4
        LDR      R0,[R0, #+0]
        BL       AbsInt
        MOVW     R1,#+1500
        CMP      R0,R1
        BGE.N    ??StopLineCheck_5
        LDR.W    R0,??DataTable7_5
        LDRSH    R0,[R0, #+0]
        BL       AbsInt
        CMP      R0,#+15
        BGE.N    ??StopLineCheck_5
        LDR.W    R0,??DataTable7_6
        LDRSH    R0,[R0, #+0]
        BL       AbsInt
        CMP      R0,#+15
        BGE.N    ??StopLineCheck_5
        LDR.W    R0,??DataTable6_5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??StopLineCheck_5
        LDR.W    R0,??DataTable6_6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??StopLineCheck_5
        LDR.W    R0,??DataTable6_9
        LDRB     R0,[R0, #+0]
        CMP      R0,#+3
        BGE.N    ??StopLineCheck_5
        LDR.W    R0,??DataTable6_10
        LDRB     R0,[R0, #+0]
        CMP      R0,#+3
        BGE.N    ??StopLineCheck_5
        LDR.W    R0,??DataTable6_7
        LDRB     R0,[R0, #+0]
        CMP      R0,#+58
        BLT.N    ??StopLineCheck_5
        LDR.W    R0,??DataTable6_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+58
        BLT.N    ??StopLineCheck_5
        LDR.W    R0,??DataTable6_6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??StopLineCheck_5
        LDR.W    R0,??DataTable6_5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??StopLineCheck_5
        LDR.W    R0,??DataTable6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??StopLineCheck_6
//  732     else { return 0; }
??StopLineCheck_5:
        MOVS     R0,#+0
        B.N      ??StopLineCheck_4
//  733 
//  734     centerErrorCount = 0;
??StopLineCheck_6:
        MOVS     R0,#+0
//  735     //检测20-35行之间有没有可疑的停车线
//  736     for (row = 59; row >= 20; row--)
        MOVS     R1,#+59
        B.N      ??StopLineCheck_7
//  737     {
//  738         //防止下面的判断溢出
//  739         if (BlackLeftLoc[row][0] == MaxValUint8 || BlackRightLoc[row][0] == MaxValUint8)
//  740         {
//  741             centerErrorCount++;
//  742             if (centerErrorCount > 5)
//  743             {
//  744                 return 0;
//  745             }
//  746             continue;
//  747         }
//  748         limitStopLineBlack += ImgNew[row][BlackLeftLoc[row][0]];
??StopLineCheck_8:
        LDR.W    R2,??DataTable6_11
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R1,R2
        LDR.W    R3,??DataTable6_12
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R7,#+3
        MLA      R3,R7,R1,R3
        LDRB     R3,[R3, #+0]
        LDRB     R2,[R3, R2]
        UXTAB    R6,R6,R2
//  749         limitStopLineBlack += ImgNew[row][BlackRightLoc[row][0]];
        LDR.W    R2,??DataTable6_11
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R1,R2
        LDR.W    R3,??DataTable7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R7,#+3
        MLA      R3,R7,R1,R3
        LDRB     R3,[R3, #+0]
        LDRB     R2,[R3, R2]
        UXTAB    R6,R6,R2
??StopLineCheck_9:
        SUBS     R1,R1,#+1
??StopLineCheck_7:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+20
        BLT.N    ??StopLineCheck_10
        LDR.W    R2,??DataTable6_12
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BEQ.N    ??StopLineCheck_11
        LDR.W    R2,??DataTable7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BNE.N    ??StopLineCheck_8
??StopLineCheck_11:
        ADDS     R0,R0,#+1
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        CMP      R0,#+6
        BLT.N    ??StopLineCheck_12
        MOVS     R0,#+0
        B.N      ??StopLineCheck_4
??StopLineCheck_12:
        B.N      ??StopLineCheck_9
//  750     }
//  751     limitStopLineBlack /= (59 - 20 + 1 - centerErrorCount)*2;
??StopLineCheck_10:
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        RSBS     R0,R0,#+40
        LSLS     R0,R0,#+1
        UDIV     R6,R6,R0
//  752 
//  753     centerErrorCount = 0;
        MOVS     R0,#+0
//  754     //检测20-35行之间有没有可疑的停车线
//  755     for (row = 55; row >= 40; row--)
        MOVS     R1,#+55
        B.N      ??StopLineCheck_13
//  756     {
//  757         //防止下面的判断溢出
//  758         if (ImgNew[row][BlackLeftLoc[row][0]] >= LimitLeftW || ImgNew[row][BlackRightLoc[row][0]] >= LimitRightW)
//  759         {
//  760             centerErrorCount++;
//  761             if (centerErrorCount > 2)
//  762             {
//  763                 return 0;
//  764             }
//  765             continue;
??StopLineCheck_14:
??StopLineCheck_15:
        SUBS     R1,R1,#+1
??StopLineCheck_13:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+40
        BLT.N    ??StopLineCheck_16
        LDR.W    R2,??DataTable6_11
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R1,R2
        LDR.W    R3,??DataTable6_12
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R7,#+3
        MLA      R3,R7,R1,R3
        LDRB     R3,[R3, #+0]
        LDRB     R2,[R3, R2]
        LDR.W    R3,??DataTable7_7
        LDRB     R3,[R3, #+0]
        CMP      R2,R3
        BCS.N    ??StopLineCheck_17
        LDR.W    R2,??DataTable6_11
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R1,R2
        LDR.W    R3,??DataTable7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R7,#+3
        MLA      R3,R7,R1,R3
        LDRB     R3,[R3, #+0]
        LDRB     R2,[R3, R2]
        LDR.W    R3,??DataTable7_8
        LDRB     R3,[R3, #+0]
        CMP      R2,R3
        BCC.N    ??StopLineCheck_15
??StopLineCheck_17:
        ADDS     R0,R0,#+1
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        CMP      R0,#+3
        BLT.N    ??StopLineCheck_14
        MOVS     R0,#+0
        B.N      ??StopLineCheck_4
//  766         }
//  767     }
//  768 
//  769     centerErrorCount = 0;
??StopLineCheck_16:
        MOVS     R0,#+0
//  770     //检测20-35行之间有没有可疑的停车线
//  771     for (row = 59; row >= 20; row--)
        MOVS     R1,#+59
        B.N      ??StopLineCheck_18
//  772     {
//  773         //防止下面的判断溢出
//  774         if (BlackLeftLoc[row][0] == MaxValUint8 || BlackRightLoc[row][0] == MaxValUint8)
//  775         {
//  776             centerErrorCount++;
//  777             if (centerErrorCount > 5)
//  778             {
//  779                 return 0;
//  780             }
//  781             continue;
//  782         }
//  783         //从中间线的位置开始找线，一直找到中间线-40
//  784         for (col = BlackLeftLoc[row][0] + 3; col <= (BlackLeftLoc[row][0] + BlackRightLoc[row][0]) / 2; col++)
//  785         {
//  786             if (ImgNew[row][col] < limitStopLineBlack+ limitStopLineBlackXiu)
//  787             {
//  788                 leftCount++;
//  789             }
//  790         }
//  791 
//  792         //从中间线的位置开始找线，一直找到中间线+40
//  793         for (col = BlackRightLoc[row][0] - 3; col >= (BlackLeftLoc[row][0] + BlackRightLoc[row][0]) / 2; col--)
//  794         {
//  795             if (ImgNew[row][col] < limitStopLineBlack + limitStopLineBlackXiu)
??StopLineCheck_19:
        LDR.W    R3,??DataTable6_11
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R7,#+250
        MLA      R3,R7,R1,R3
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        LDRB     R3,[R2, R3]
        LDR.W    R7,??DataTable7_9
        LDRB     R7,[R7, #+0]
        ADDS     R7,R6,R7
        CMP      R3,R7
        BCS.N    ??StopLineCheck_20
//  796             {
//  797                 rightCount++;
        ADDS     R5,R5,#+1
//  798             }
//  799         }
??StopLineCheck_20:
        SUBS     R2,R2,#+1
??StopLineCheck_21:
        LDR.W    R3,??DataTable6_12
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R7,#+3
        MLA      R3,R7,R1,R3
        LDRB     R3,[R3, #+0]
        LDR.W    R7,??DataTable7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R12,#+3
        MLA      R7,R12,R1,R7
        LDRB     R7,[R7, #+0]
        ADDS     R3,R7,R3
        MOVS     R7,#+2
        SDIV     R3,R3,R7
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,R3
        BGE.N    ??StopLineCheck_19
??StopLineCheck_22:
        SUBS     R1,R1,#+1
??StopLineCheck_18:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+20
        BLT.N    ??StopLineCheck_23
        LDR.W    R2,??DataTable6_12
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BEQ.N    ??StopLineCheck_24
        LDR.W    R2,??DataTable7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BNE.N    ??StopLineCheck_25
??StopLineCheck_24:
        ADDS     R0,R0,#+1
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        CMP      R0,#+6
        BLT.N    ??StopLineCheck_26
        MOVS     R0,#+0
        B.N      ??StopLineCheck_4
??StopLineCheck_26:
        B.N      ??StopLineCheck_22
??StopLineCheck_25:
        LDR.W    R2,??DataTable6_12
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        ADDS     R2,R2,#+3
        B.N      ??StopLineCheck_27
??StopLineCheck_28:
        LDR.W    R3,??DataTable6_11
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R7,#+250
        MLA      R3,R7,R1,R3
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        LDRB     R3,[R2, R3]
        LDR.W    R7,??DataTable7_9
        LDRB     R7,[R7, #+0]
        ADDS     R7,R6,R7
        CMP      R3,R7
        BCS.N    ??StopLineCheck_29
        ADDS     R4,R4,#+1
??StopLineCheck_29:
        ADDS     R2,R2,#+1
??StopLineCheck_27:
        LDR.W    R3,??DataTable6_12
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R7,#+3
        MLA      R3,R7,R1,R3
        LDRB     R3,[R3, #+0]
        LDR.W    R7,??DataTable7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R12,#+3
        MLA      R7,R12,R1,R7
        LDRB     R7,[R7, #+0]
        ADDS     R3,R7,R3
        MOVS     R7,#+2
        SDIV     R3,R3,R7
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R3,R2
        BGE.N    ??StopLineCheck_28
        LDR.W    R2,??DataTable7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        SUBS     R2,R2,#+3
        B.N      ??StopLineCheck_21
//  800     }
//  801 
//  802 
//  803     //最后看左右停止线的线头是不是满足水平距离要求
//  804     if (leftCount + rightCount > 10 && leftCount >= 5 && rightCount >= 5)//(stopLineLeft!=MaxValUint8)&&(stopLineRight!=MaxValUint8)&&(stopLineRight-stopLineLeft<=40)&&(stopLineRight-stopLineLeft>=20)
??StopLineCheck_23:
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        UXTAH    R0,R5,R4
        CMP      R0,#+11
        BLT.N    ??StopLineCheck_30
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        CMP      R4,#+5
        BLT.N    ??StopLineCheck_30
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        CMP      R5,#+5
        BLT.N    ??StopLineCheck_30
//  805     {
//  806         return 1;
        MOVS     R0,#+1
        B.N      ??StopLineCheck_4
//  807     }
//  808     else
//  809     {
//  810         return 0;
??StopLineCheck_30:
        MOVS     R0,#+0
??StopLineCheck_4:
        POP      {R1,R4-R7,PC}    ;; return
//  811     }
//  812 }
//  813 
//  814 
//  815 
//  816 
//  817 
//  818 
//  819 //======================================================================
//  820 //函数名：LeastSquareInt16a1
//  821 //功  能：针对y是int16型数据的最小二乘法的a1值的求取
//  822 //参  数：x数组，y数组，num基于的有效数据个数
//  823 //返  回：a1
//  824 //影  响：无
//  825 //说  明：1. y = a0 + a1 * x;
//  826 //        2. a1 = (N * Σxy - Σx * Σy) / (N * Σx^2 - Σx * Σx);
//  827 //        3. a1乘以了LeastSquareMulti倍。
//  828 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  829 int32 LeastSquareInt16a1(uint8 x[], int16 y[], uint8 num)
//  830 {
LeastSquareInt16a1:
        PUSH     {R4-R7,LR}
//  831   int32 andxy = 0, andx = 0, andy = 0, andx2 = 0;
        MOVS     R6,#+0
        MOVS     R3,#+0
        MOVS     R4,#+0
        MOVS     R5,#+0
//  832   int32 a1;
//  833   uint8 i;
//  834  
//  835   for(i = 0; i < num; i++)
        MOVS     R7,#+0
        B.N      ??LeastSquareInt16a1_0
//  836   {
//  837     andxy += x[i] * y[i];
??LeastSquareInt16a1_1:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R12,[R7, R0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRSH    LR,[R1, R7, LSL #+1]
        MLA      R6,LR,R12,R6
//  838     andx += x[i];
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R12,[R7, R0]
        ADDS     R3,R3,R12
//  839     andy += y[i];
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRSH    R12,[R1, R7, LSL #+1]
        ADDS     R4,R4,R12
//  840     andx2 += x[i] * x[i];
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R12,[R7, R0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     LR,[R7, R0]
        MLA      R5,LR,R12,R5
//  841   }
        ADDS     R7,R7,#+1
??LeastSquareInt16a1_0:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R7,R2
        BCC.N    ??LeastSquareInt16a1_1
//  842   
//  843   //运算时为整型，最后变为int32型，且放大了LeastSquareMulti倍。
//  844   a1 = (int32)(LeastSquareMulti * (num * andxy - andx * andy) / (num * andx2 - andx * andx));    
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MUL      R0,R6,R2
        MLS      R0,R4,R3,R0
        MOV      R1,#+1000
        MULS     R0,R1,R0
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MUL      R1,R5,R2
        MLS      R1,R3,R3,R1
        SDIV     R0,R0,R1
//  845   
//  846   return a1;  
        POP      {R4-R7,PC}       ;; return
//  847   
//  848 }
//  849 
//  850 //======================================================================
//  851 //函数名：LeastSquareInt16a0
//  852 //功  能：针对y是int16型数据的最小二乘法的a0值的求取
//  853 //参  数：x数组，y数组，a1参数，num基于的有效数据个数
//  854 //返  回：a0
//  855 //影  响：无
//  856 //说  明：1. y = a0 + a1 * x;
//  857 //        2. a0 = Σy / N - a1 * Σx / N;
//  858 //        3. a0乘以了LeastSquareMulti倍。      
//  859 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  860 int32 LeastSquareInt16a0(uint8 x[], int16 y[], int32 a1, uint8 num)
//  861 {
LeastSquareInt16a0:
        PUSH     {R4-R7}
//  862   int32 andx = 0, andy = 0;
        MOVS     R4,#+0
        MOVS     R5,#+0
//  863   int32 a0;
//  864   uint8 i;
//  865   for(i = 0; i < num; i++)
        MOVS     R6,#+0
        B.N      ??LeastSquareInt16a0_0
//  866   {
//  867     andx += x[i];
??LeastSquareInt16a0_1:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRB     R7,[R6, R0]
        ADDS     R4,R4,R7
//  868     andy += y[i];
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRSH    R7,[R1, R6, LSL #+1]
        ADDS     R5,R5,R7
//  869   }
        ADDS     R6,R6,#+1
??LeastSquareInt16a0_0:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R6,R3
        BCC.N    ??LeastSquareInt16a0_1
//  870   
//  871   //运算时为整型，最后变为int32型，且放大了LeastSquareMulti倍。
//  872   a0 = (int32)(LeastSquareMulti * andy / num - a1 * andx / num);
        MOV      R0,#+1000
        MUL      R0,R0,R5
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        SDIV     R0,R0,R3
        MUL      R1,R4,R2
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        SDIV     R1,R1,R3
        SUBS     R0,R0,R1
//  873   return a0;
        POP      {R4-R7}
        BX       LR               ;; return
//  874 }
//  875 
//  876 //======================================================================
//  877 //函数名：LeastSquarea1
//  878 //功  能：最小二乘法的a1值的求取
//  879 //参  数：x数组，y数组，num基于的有效数据个数
//  880 //返  回：a1
//  881 //影  响：无
//  882 //说  明：1. y = a0 + a1 * x;
//  883 //        2. a1 = (N * Σxy - Σx * Σy) / (N * Σx^2 - Σx * Σx);
//  884 //        3. a1乘以了LeastSquareMulti倍。
//  885 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  886 int32 LeastSquarea1(uint8 x[], uint8 y[], uint8 num)
//  887 {
LeastSquarea1:
        PUSH     {R4-R7,LR}
//  888   int32 andxy = 0, andx = 0, andy = 0, andx2 = 0;
        MOVS     R6,#+0
        MOVS     R3,#+0
        MOVS     R4,#+0
        MOVS     R5,#+0
//  889   int32 a1;
//  890   uint8 i;
//  891  
//  892   for(i = 0; i < num; i++)
        MOVS     R7,#+0
        B.N      ??LeastSquarea1_0
//  893   {
//  894     andxy += x[i] * y[i];
??LeastSquarea1_1:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R12,[R7, R0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     LR,[R7, R1]
        MLA      R6,LR,R12,R6
//  895     andx += x[i];
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R12,[R7, R0]
        ADDS     R3,R3,R12
//  896     andy += y[i];
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R12,[R7, R1]
        ADDS     R4,R4,R12
//  897     andx2 += x[i] * x[i];
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R12,[R7, R0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     LR,[R7, R0]
        MLA      R5,LR,R12,R5
//  898   }
        ADDS     R7,R7,#+1
??LeastSquarea1_0:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R7,R2
        BCC.N    ??LeastSquarea1_1
//  899   
//  900   //运算时为整型，最后变为int32型，且放大了LeastSquareMulti倍。
//  901   a1 = (int32)(LeastSquareMulti * (num * andxy - andx * andy) / (num * andx2 - andx * andx));    
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MUL      R0,R6,R2
        MLS      R0,R4,R3,R0
        MOV      R1,#+1000
        MULS     R0,R1,R0
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MUL      R1,R5,R2
        MLS      R1,R3,R3,R1
        SDIV     R0,R0,R1
//  902   return a1;  
        POP      {R4-R7,PC}       ;; return
//  903 }
//  904 
//  905 
//  906 //======================================================================
//  907 //函数名：LeastSquarea0
//  908 //功  能：最小二乘法的a0值的求取
//  909 //参  数：x数组，y数组，a1参数，num基于的有效数据个数
//  910 //返  回：a0
//  911 //影  响：无
//  912 //说  明：1. y = a0 + a1 * x;
//  913 //        2. a0 = Σy / N - a1 * Σx / N;
//  914 //        3. a0乘以了LeastSquareMulti倍。      
//  915 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  916 int32 LeastSquarea0(uint8 x[], uint8 y[], int32 a1, uint8 num)
//  917 {
LeastSquarea0:
        PUSH     {R4-R7}
//  918   int32 andx = 0, andy = 0;
        MOVS     R4,#+0
        MOVS     R5,#+0
//  919   int32 a0;
//  920   uint8 i;
//  921   for(i = 0; i < num; i++)
        MOVS     R6,#+0
        B.N      ??LeastSquarea0_0
//  922   {
//  923     andx += x[i];
??LeastSquarea0_1:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRB     R7,[R6, R0]
        ADDS     R4,R4,R7
//  924     andy += y[i];
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRB     R7,[R6, R1]
        ADDS     R5,R5,R7
//  925   }
        ADDS     R6,R6,#+1
??LeastSquarea0_0:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R6,R3
        BCC.N    ??LeastSquarea0_1
//  926   
//  927   //运算时为整型，最后变为int32型，且放大了LeastSquareMulti倍。
//  928   a0 = (int32)(LeastSquareMulti * andy / num - a1 * andx / num);
        MOV      R0,#+1000
        MUL      R0,R0,R5
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        SDIV     R0,R0,R3
        MUL      R1,R4,R2
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        SDIV     R1,R1,R3
        SUBS     R0,R0,R1
//  929   return a0;
        POP      {R4-R7}
        BX       LR               ;; return
//  930 }
//  931 
//  932 
//  933 
//  934 
//  935 /*
//  936 //二值化图像解压函数
//  937 //dst             图像解压目的地址
//  938 //src             图像解压源地址
//  939 //srclen          二值化图像的占用空间大小
//  940 void ImageExtract(uint8 *dst, uint8 *src, uint32 srclen)
//  941 {
//  942     uint8 colour[2] = {255, 0}; //0 和 1 分别对应的颜色
//  943     //注：山外的摄像头 0 表示 白色，1表示 黑色
//  944     uint8 tmpsrc;
//  945     while(srclen --)
//  946     {
//  947         tmpsrc = *src++;
//  948         *dst++ = colour[ (tmpsrc >> 7 ) & 0x01 ];
//  949         *dst++ = colour[ (tmpsrc >> 6 ) & 0x01 ];
//  950         *dst++ = colour[ (tmpsrc >> 5 ) & 0x01 ];
//  951         *dst++ = colour[ (tmpsrc >> 4 ) & 0x01 ];
//  952         *dst++ = colour[ (tmpsrc >> 3 ) & 0x01 ];
//  953         *dst++ = colour[ (tmpsrc >> 2 ) & 0x01 ];
//  954         *dst++ = colour[ (tmpsrc >> 1 ) & 0x01 ];
//  955         *dst++ = colour[ (tmpsrc >> 0 ) & 0x01 ];
//  956     }
//  957 }
//  958 
//  959 
//  960 */
//  961 
//  962 /*          //OV7725的图像发送函数
//  963 //图像发送到上位机
//  964 void SendImage(uint8 *imgaddr, uint32 imgsize)
//  965 {                                                                                   
//  966     uint8 cmd[4] = {0, 255, 1, 0 };    //yy_摄像头串口调试 使用的命令
//  967 
//  968     //uint8 cmd[1] = {255};       //DEMOK上位机使用的命令   
//  969   
//  970     uart_sendN(UART0, cmd, sizeof(cmd));    //先发送命令
//  971 
//  972     uart_sendN(UART0, imgaddr, imgsize); //再发送图像
//  973 }
//  974 
//  975 */
//  976 
//  977 //======================================================================
//  978 //函数名：SendCenterLineLoc
//  979 //功  能：中心线数组发送函数
//  980 //参  数：img待发送的一维图像数组
//  981 //返  回：无
//  982 //影  响：无
//  983 //说  明：1. 这里的命令头和图像数组发送函数的命令头不一样。
//  984 //      
//  985 //          
//  986 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  987 void SendCenterLineLoc(uint8 img[CameraHight])
//  988 {
SendCenterLineLoc:
        PUSH     {R3-R5,LR}
        MOVS     R4,R0
//  989     uint8 i;
//  990     uint8 cmd[4] = {0, 255, 1, 255 };   //中心线数组的数据头
        ADD      R0,SP,#+0
        LDR.W    R1,??DataTable7_10
        LDR      R2,[R1, #0]
        STR      R2,[R0, #+0]
//  991     uart_sendN(UART0, cmd, sizeof(cmd));    //先发送命令
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        LDR.W    R0,??DataTable7_11  ;; 0x4006a000
        BL       uart_sendN
//  992     for(i = 0; i < CameraHight; i++)
        MOVS     R5,#+0
        B.N      ??SendCenterLineLoc_0
//  993     {
//  994       uart_send1(UART0, img[i]); //发送中心线数组
??SendCenterLineLoc_1:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LDRB     R1,[R5, R4]
        LDR.W    R0,??DataTable7_11  ;; 0x4006a000
        BL       uart_send1
//  995     }
        ADDS     R5,R5,#+1
??SendCenterLineLoc_0:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+60
        BLT.N    ??SendCenterLineLoc_1
//  996     
//  997 }
        POP      {R0,R4,R5,PC}    ;; return
//  998 
//  999 
// 1000 
// 1001 
// 1002 //======================================================================
// 1003 //函数名：SendImage
// 1004 //功  能：OV7620的图像发送函数
// 1005 //参  数：待发送的二维图像数组imgaddr
// 1006 //返  回：无
// 1007 //影  响：无
// 1008 //说  明：1. 修改图像数组大小时需要把内部两个for的内容也改掉
// 1009 //        2. 这里的命令头与中心线数组发送函数的命令头不一样。
// 1010 //          
// 1011 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1012 void SendImage(uint8 imgaddr[CameraHight][CameraRealWidth])
// 1013 {                            
SendImage:
        PUSH     {R4-R6,LR}
        SUB      SP,SP,#+8
        MOVS     R4,R0
// 1014     uint16 i, j;
// 1015     uint8 cmd[4] = {0, 255, 1, 0 };    //图像数组的数据头
        ADD      R0,SP,#+0
        LDR.W    R1,??DataTable7_12
        LDR      R2,[R1, #0]
        STR      R2,[R0, #+0]
// 1016 
// 1017     //uint8 cmd[1] = {255};       //DEMOK上位机使用的命令   
// 1018   
// 1019     uart_sendN(UART0, cmd, sizeof(cmd));    //先发送命令
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        LDR.W    R0,??DataTable7_11  ;; 0x4006a000
        BL       uart_sendN
// 1020     
// 1021     //这里不能用uart_sendN(UART0, imgaddr, CameraSize)来代替，因为uart_sendN函数里的buff[i].
// 1022     for(i = 0; i < CameraHight; i++)
        MOVS     R5,#+0
        B.N      ??SendImage_0
// 1023         for(j = 0; j < CameraRealWidth; j++)
// 1024             uart_send1(UART0, imgaddr[i][j]); //发送图像
??SendImage_1:
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        MOVS     R0,#+250
        MLA      R0,R0,R5,R4
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        LDRB     R1,[R6, R0]
        LDR.W    R0,??DataTable7_11  ;; 0x4006a000
        BL       uart_send1
        ADDS     R6,R6,#+1
??SendImage_2:
        UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
        CMP      R6,#+250
        BLT.N    ??SendImage_1
        ADDS     R5,R5,#+1
??SendImage_0:
        UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
        CMP      R5,#+60
        BGE.N    ??SendImage_3
        MOVS     R6,#+0
        B.N      ??SendImage_2
// 1025 }
??SendImage_3:
        POP      {R0,R1,R4-R6,PC}  ;; return
// 1026 
// 1027 
// 1028 
// 1029 //====================================左左左左左左左左左左左左左左左左左============================
// 1030 
// 1031 
// 1032 
// 1033 
// 1034 //======================================================================
// 1035 //函数名：BlackLeftRealClear
// 1036 //功  能：左黑线提取中，对3个关键值的实际值清零
// 1037 //参  数：无
// 1038 //返  回：无
// 1039 //影  响：BlackLeftRealWB[], BlackLeftRealW[], BlackLeftRealB[]
// 1040 //说  明：
// 1041 //      
// 1042 //             
// 1043 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1044 void BlackLeftRealClear(void)
// 1045 {
// 1046     BlackLeftRealWB[0] = 0;
BlackLeftRealClear:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable7_13
        STRB     R0,[R1, #+0]
// 1047     BlackLeftRealWB[1] = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable7_13
        STRB     R0,[R1, #+1]
// 1048     BlackLeftRealW[0] = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable7_14
        STRB     R0,[R1, #+0]
// 1049     BlackLeftRealW[1] = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable7_14
        STRB     R0,[R1, #+1]
// 1050     BlackLeftRealB[0] = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable7_15
        STRB     R0,[R1, #+0]
// 1051     BlackLeftRealB[1] = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable7_15
        STRB     R0,[R1, #+1]
// 1052 }
        BX       LR               ;; return
// 1053 
// 1054 
// 1055 //黑线提取成功，找左黑线的线头线尾。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1056 uint8 BlackLeftHeadEndSearch(void)
// 1057 {
// 1058   uint8 i;
// 1059   //左线线头和线尾的查找
// 1060   if(BlackLeftDone == 1)
BlackLeftHeadEndSearch:
        LDR.N    R0,??DataTable6_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackLeftHeadEndSearch_0
// 1061   { //左线线头的查找。
// 1062     for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??BlackLeftHeadEndSearch_1
??BlackLeftHeadEndSearch_2:
        ADDS     R0,R0,#+1
// 1063     {
// 1064       if(BlackLeftLoc[i][0] != MaxValUint8)
??BlackLeftHeadEndSearch_1:
        LDR.N    R1,??DataTable6_12
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BEQ.N    ??BlackLeftHeadEndSearch_3
// 1065       { //找到了线头
// 1066         BlackLeftHeadLine = i;
        LDR.N    R1,??DataTable6_10
        STRB     R0,[R1, #+0]
// 1067         break;
        B.N      ??BlackLeftHeadEndSearch_4
// 1068       }
// 1069       if(i == CameraHight - 1) 
??BlackLeftHeadEndSearch_3:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??BlackLeftHeadEndSearch_2
// 1070       { //直到最近一行还没有找到线头
// 1071         BlackLeftHeadLine = MaxValUint8;
        MOVS     R0,#+255
        LDR.N    R1,??DataTable6_10
        STRB     R0,[R1, #+0]
// 1072         break;
// 1073       }
// 1074     }
// 1075     
// 1076     //若线头已经查找失败，就不用查找线尾了。
// 1077     if(BlackLeftHeadLine == MaxValUint8)
??BlackLeftHeadEndSearch_4:
        LDR.N    R0,??DataTable6_10
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??BlackLeftHeadEndSearch_5
// 1078     {
// 1079       BlackLeftEndLine = MaxValUint8;
        MOVS     R0,#+255
        LDR.N    R1,??DataTable6_8
        STRB     R0,[R1, #+0]
// 1080       BlackLeftDone = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable6_1
        STRB     R0,[R1, #+0]
        B.N      ??BlackLeftHeadEndSearch_6
// 1081     }
// 1082     //若线头查找成功，就开始找线尾。
// 1083     else
// 1084     {
// 1085       //左线线尾的查找。
// 1086       for(i = CameraHight - 1; ; i--)
??BlackLeftHeadEndSearch_5:
        MOVS     R0,#+59
        B.N      ??BlackLeftHeadEndSearch_7
??BlackLeftHeadEndSearch_8:
        SUBS     R0,R0,#+1
// 1087       { //左线线尾查找成功。
// 1088         if(BlackLeftLoc[i][0] != MaxValUint8)
??BlackLeftHeadEndSearch_7:
        LDR.N    R1,??DataTable6_12
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BEQ.N    ??BlackLeftHeadEndSearch_9
// 1089         {
// 1090           BlackLeftEndLine = i;
        LDR.N    R1,??DataTable6_8
        STRB     R0,[R1, #+0]
// 1091           break;
        B.N      ??BlackLeftHeadEndSearch_6
// 1092         }
// 1093         //左线线尾查找失败。左线不可能有头无尾，所以均置无效值。
// 1094         if(i == BlackLeftHeadLine)
??BlackLeftHeadEndSearch_9:
        LDR.N    R1,??DataTable6_10
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BNE.N    ??BlackLeftHeadEndSearch_8
// 1095         {
// 1096           BlackLeftHeadLine = MaxValUint8;
        MOVS     R0,#+255
        LDR.N    R1,??DataTable6_10
        STRB     R0,[R1, #+0]
// 1097           BlackLeftEndLine = MaxValUint8;
        MOVS     R0,#+255
        LDR.N    R1,??DataTable6_8
        STRB     R0,[R1, #+0]
// 1098           break;
        B.N      ??BlackLeftHeadEndSearch_6
// 1099         }
// 1100       }
// 1101     }
// 1102   }
// 1103   //如果左黑线提取失败，就不用找线头和线尾了。
// 1104   else
// 1105   {
// 1106     BlackLeftHeadLine = MaxValUint8;
??BlackLeftHeadEndSearch_0:
        MOVS     R0,#+255
        LDR.N    R1,??DataTable6_10
        STRB     R0,[R1, #+0]
// 1107     BlackLeftEndLine = MaxValUint8;
        MOVS     R0,#+255
        LDR.N    R1,??DataTable6_8
        STRB     R0,[R1, #+0]
// 1108   }
// 1109   
// 1110   //本幅图像有单线时，删掉最远一个点。
// 1111   if(SingleBlackAllFlag == 1)
??BlackLeftHeadEndSearch_6:
        LDR.W    R0,??DataTable7_16
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackLeftHeadEndSearch_10
// 1112   {
// 1113     BlackLeftLoc[BlackLeftHeadLine][0] = MaxValUint8; //Udis数组不用改，因为线头线尾查找之后才轮到矫正函数。
        MOVS     R0,#+255
        LDR.N    R1,??DataTable6_12
        LDR.N    R2,??DataTable6_10
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+3
        MLA      R1,R3,R2,R1
        STRB     R0,[R1, #+0]
// 1114     BlackLeftHeadLine += 1;
        LDR.N    R0,??DataTable6_10
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.N    R1,??DataTable6_10
        STRB     R0,[R1, #+0]
// 1115   }
// 1116   else
// 1117   {
// 1118   }
// 1119   
// 1120   return 1;
??BlackLeftHeadEndSearch_10:
        MOVS     R0,#+1
        BX       LR               ;; return
// 1121 }
// 1122 
// 1123 
// 1124 
// 1125 
// 1126 
// 1127 
// 1128 
// 1129 
// 1130 //======================================================================
// 1131 //函数名：BlackLeftBigChangeCheck
// 1132 //功  能：左黑线提取时，大斜率检测。
// 1133 //参  数：newrow新加进来的需要判定是否有效的行,use调用时是连续2行的第几行。
// 1134 //返  回：1该行黑线成功，0该行黑线失败。
// 1135 //影  响：
// 1136 //说  明：1. 用来防止大斜率突变的坏点。
// 1137 //        2. 共5个行，取1，3，5行进行斜率计算，每进一个新行，移出一个旧行。
// 1138 //             
// 1139 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1140 uint8 BlackLeftBigChangeCheck(uint8 newrow, uint8 use)
// 1141 {
BlackLeftBigChangeCheck:
        PUSH     {R4-R7}
// 1142   uint8 tempstorex, tempstorey;
// 1143   uint8 i;
// 1144   int32 tempslope1, tempslope2;
// 1145   
// 1146   //tempstorex用来储存将要移出的一行，用来检测失败时复原5行数组。
// 1147   tempstorex = BlackLeftBigChangeNumx[0];
        LDR.W    R1,??DataTable8
        LDRB     R1,[R1, #+0]
// 1148   BlackLeftBigChangeNumx[0] = BlackLeftBigChangeNumx[1];
        LDR.W    R2,??DataTable8
        LDRB     R2,[R2, #+1]
        LDR.W    R3,??DataTable8
        STRB     R2,[R3, #+0]
// 1149   BlackLeftBigChangeNumx[1] = BlackLeftBigChangeNumx[2];
        LDR.W    R2,??DataTable8
        LDRB     R2,[R2, #+2]
        LDR.W    R3,??DataTable8
        STRB     R2,[R3, #+1]
// 1150   BlackLeftBigChangeNumx[2] = BlackLeftBigChangeNumx[3];
        LDR.W    R2,??DataTable8
        LDRB     R2,[R2, #+3]
        LDR.W    R3,??DataTable8
        STRB     R2,[R3, #+2]
// 1151   BlackLeftBigChangeNumx[3] = BlackLeftBigChangeNumx[4];
        LDR.W    R2,??DataTable8
        LDRB     R2,[R2, #+4]
        LDR.W    R3,??DataTable8
        STRB     R2,[R3, #+3]
// 1152   BlackLeftBigChangeNumx[4] = newrow;
        LDR.W    R2,??DataTable8
        STRB     R0,[R2, #+4]
// 1153 
// 1154   tempstorey = BlackLeftBigChangeNumy[0];
        LDR.W    R2,??DataTable7_17
        LDRB     R2,[R2, #+0]
// 1155   BlackLeftBigChangeNumy[0] = BlackLeftBigChangeNumy[1];
        LDR.W    R3,??DataTable7_17
        LDRB     R3,[R3, #+1]
        LDR.W    R4,??DataTable7_17
        STRB     R3,[R4, #+0]
// 1156   BlackLeftBigChangeNumy[1] = BlackLeftBigChangeNumy[2];
        LDR.W    R3,??DataTable7_17
        LDRB     R3,[R3, #+2]
        LDR.W    R4,??DataTable7_17
        STRB     R3,[R4, #+1]
// 1157   BlackLeftBigChangeNumy[2] = BlackLeftBigChangeNumy[3];
        LDR.W    R3,??DataTable7_17
        LDRB     R3,[R3, #+3]
        LDR.W    R4,??DataTable7_17
        STRB     R3,[R4, #+2]
// 1158   BlackLeftBigChangeNumy[3] = BlackLeftBigChangeNumy[4];
        LDR.W    R3,??DataTable7_17
        LDRB     R3,[R3, #+4]
        LDR.W    R4,??DataTable7_17
        STRB     R3,[R4, #+3]
// 1159   BlackLeftBigChangeNumy[4] = BlackLeftLoc[newrow][0];
        LDR.N    R3,??DataTable6_12
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R0,R3
        LDRB     R3,[R3, #+0]
        LDR.W    R4,??DataTable7_17
        STRB     R3,[R4, #+4]
// 1160   
// 1161   //每幅图最多只进一次这个for循环，可以省时间。
// 1162   if(BlackLeftBigChangeJumpFlag == 0)
        LDR.W    R3,??DataTable7_18
        LDRB     R3,[R3, #+0]
        CMP      R3,#+0
        BNE.N    ??BlackLeftBigChangeCheck_0
// 1163   {
// 1164     //储存数组的有效性判断，若不足5个数，则无法进行大斜率检测，直接返回成功。
// 1165     for(i = 0; i <= 4; i++)
        MOVS     R3,#+0
        B.N      ??BlackLeftBigChangeCheck_1
??BlackLeftBigChangeCheck_2:
        ADDS     R3,R3,#+1
??BlackLeftBigChangeCheck_1:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+5
        BGE.N    ??BlackLeftBigChangeCheck_3
// 1166     {
// 1167       if(BlackLeftBigChangeNumx[i] == MaxValUint8)
        LDR.W    R4,??DataTable8
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R4,[R3, R4]
        CMP      R4,#+255
        BNE.N    ??BlackLeftBigChangeCheck_2
// 1168       {
// 1169         return 1;
        MOVS     R0,#+1
        B.N      ??BlackLeftBigChangeCheck_4
// 1170       }
// 1171     }
// 1172     //改变标志位，下次就不进来了。
// 1173     BlackLeftBigChangeJumpFlag = 1;
??BlackLeftBigChangeCheck_3:
        MOVS     R3,#+1
        LDR.W    R4,??DataTable7_18
        STRB     R3,[R4, #+0]
// 1174   }
// 1175   //走到这里说明通过了数组有效性判断。
// 1176   
// 1177   
// 1178   //取1，3点进行斜率计算。
// 1179   //因为只有两个点，所以斜率的计算采取斜率的初始定义的方式，不采取最小二乘法，可以省很多时间。
// 1180   tempslope1 = (BlackLeftBigChangeNumy[2] - BlackLeftBigChangeNumy[0]) 
// 1181              * LeastSquareMulti   //乘以了这么多倍。跟最小二乘法一样。
// 1182              / (BlackLeftBigChangeNumx[2] - BlackLeftBigChangeNumx[0]);
??BlackLeftBigChangeCheck_0:
        LDR.W    R3,??DataTable7_17
        LDRB     R3,[R3, #+2]
        LDR.W    R4,??DataTable7_17
        LDRB     R4,[R4, #+0]
        SUBS     R3,R3,R4
        MOV      R4,#+1000
        MULS     R3,R4,R3
        LDR.W    R4,??DataTable8
        LDRB     R4,[R4, #+2]
        LDR.W    R5,??DataTable8
        LDRB     R5,[R5, #+0]
        SUBS     R4,R4,R5
        SDIV     R3,R3,R4
// 1183   tempslope2 = (BlackLeftBigChangeNumy[4] - BlackLeftBigChangeNumy[2]) 
// 1184              * LeastSquareMulti   //乘以了这么多倍。跟最小二乘法一样。
// 1185              / (BlackLeftBigChangeNumx[4] - BlackLeftBigChangeNumx[2]);
        LDR.W    R4,??DataTable7_17
        LDRB     R4,[R4, #+4]
        LDR.W    R5,??DataTable7_17
        LDRB     R5,[R5, #+2]
        SUBS     R4,R4,R5
        MOV      R5,#+1000
        MULS     R4,R5,R4
        LDR.W    R5,??DataTable8
        LDRB     R5,[R5, #+4]
        LDR.W    R6,??DataTable8
        LDRB     R6,[R6, #+2]
        SUBS     R5,R5,R6
        SDIV     R4,R4,R5
// 1186   BlackLeftBigChangeSlopeStore = tempslope1;
        LDR.W    R5,??DataTable8_1
        STR      R3,[R5, #+0]
// 1187   //小5点斜率储存在数组中，由于储存的是tempslope1，所以大跳变点不会记录，会出现多行相同值。
// 1188   BlackLeft5Slope[BlackLeft5SlopeIndex] = BlackLeftBigChangeSlopeStore;
        LDR.W    R5,??DataTable8_1
        LDR      R5,[R5, #+0]
        LDR.W    R6,??DataTable8_2
        LDR.W    R7,??DataTable8_3
        LDRB     R7,[R7, #+0]
        STR      R5,[R6, R7, LSL #+2]
// 1189   BlackLeft5SlopeRow[BlackLeft5SlopeIndex] = newrow;  //记录计算5点斜率的最远点所在行
        LDR.W    R5,??DataTable8_4
        LDR.W    R6,??DataTable8_3
        LDRB     R6,[R6, #+0]
        STRB     R0,[R6, R5]
// 1190   BlackLeft5SlopeIndex++;
        LDR.W    R0,??DataTable8_3
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.W    R5,??DataTable8_3
        STRB     R0,[R5, #+0]
// 1191   
// 1192   //1. 前后两次的斜率是相反的。
// 1193   if(tempslope1 >= 0 && tempslope2 < 0)
        CMP      R3,#+0
        BMI.N    ??BlackLeftBigChangeCheck_5
        CMP      R4,#+0
        BPL.N    ??BlackLeftBigChangeCheck_5
// 1194   {
// 1195     //2. 两者差值很大很大。
// 1196     if(tempslope1 >= tempslope2 + BlackLeftBigChangeSlopeLimit)
        ADDS     R0,R4,#+4000
        CMP      R3,R0
        BLT.N    ??BlackLeftBigChangeCheck_6
// 1197     {
// 1198       //两者差值的确很大。不会刷新储存值。
// 1199       //if(use == 2)                    //另一种方案是在连续2行的第2行调用时才置成功标志位。
// 1200       //{
// 1201         //置成功标志位。
// 1202         BlackLeftBigChangeFlag = 1;
        MOVS     R0,#+1
        LDR.W    R3,??DataTable8_5
        STRB     R0,[R3, #+0]
// 1203       //}
// 1204       //else
// 1205       //{
// 1206       //}
// 1207       //此次行不进入队列。
// 1208       BlackLeftBigChangeNumx[4] = BlackLeftBigChangeNumx[3];
        LDR.W    R0,??DataTable8
        LDRB     R0,[R0, #+3]
        LDR.W    R3,??DataTable8
        STRB     R0,[R3, #+4]
// 1209       BlackLeftBigChangeNumx[3] = BlackLeftBigChangeNumx[2];
        LDR.W    R0,??DataTable8
        LDRB     R0,[R0, #+2]
        LDR.W    R3,??DataTable8
        STRB     R0,[R3, #+3]
// 1210       BlackLeftBigChangeNumx[2] = BlackLeftBigChangeNumx[1];
        LDR.W    R0,??DataTable8
        LDRB     R0,[R0, #+1]
        LDR.W    R3,??DataTable8
        STRB     R0,[R3, #+2]
// 1211       BlackLeftBigChangeNumx[1] = BlackLeftBigChangeNumx[0];
        LDR.W    R0,??DataTable8
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable8
        STRB     R0,[R3, #+1]
// 1212       BlackLeftBigChangeNumx[0] = tempstorex;
        LDR.W    R0,??DataTable8
        STRB     R1,[R0, #+0]
// 1213       BlackLeftBigChangeNumy[4] = BlackLeftBigChangeNumy[3];
        LDR.W    R0,??DataTable7_17
        LDRB     R0,[R0, #+3]
        LDR.W    R1,??DataTable7_17
        STRB     R0,[R1, #+4]
// 1214       BlackLeftBigChangeNumy[3] = BlackLeftBigChangeNumy[2];
        LDR.W    R0,??DataTable7_17
        LDRB     R0,[R0, #+2]
        LDR.W    R1,??DataTable7_17
        STRB     R0,[R1, #+3]
// 1215       BlackLeftBigChangeNumy[2] = BlackLeftBigChangeNumy[1];
        LDR.W    R0,??DataTable7_17
        LDRB     R0,[R0, #+1]
        LDR.W    R1,??DataTable7_17
        STRB     R0,[R1, #+2]
// 1216       BlackLeftBigChangeNumy[1] = BlackLeftBigChangeNumy[0];
        LDR.W    R0,??DataTable7_17
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable7_17
        STRB     R0,[R1, #+1]
// 1217       BlackLeftBigChangeNumy[0] = tempstorey;
        LDR.W    R0,??DataTable7_17
        STRB     R2,[R0, #+0]
// 1218       
// 1219       //将前面3个左黑线(共4个)的值置无效值。图像上更连续。
// 1220       BlackLeftLoc[BlackLeftBigChangeNumx[4]][0] = MaxValUint8;
        MOVS     R0,#+255
        LDR.N    R1,??DataTable6_12
        LDR.W    R2,??DataTable8
        LDRB     R2,[R2, #+4]
        MOVS     R3,#+3
        MLA      R1,R3,R2,R1
        STRB     R0,[R1, #+0]
// 1221       BlackLeftLoc[BlackLeftBigChangeNumx[3]][0] = MaxValUint8;
        MOVS     R0,#+255
        LDR.N    R1,??DataTable6_12
        LDR.W    R2,??DataTable8
        LDRB     R2,[R2, #+3]
        MOVS     R3,#+3
        MLA      R1,R3,R2,R1
        STRB     R0,[R1, #+0]
// 1222       //BlackLeftLoc[BlackLeftBigChangeNumx[2]][0] = MaxValUint8;    
// 1223       
// 1224       return 0;
        MOVS     R0,#+0
        B.N      ??BlackLeftBigChangeCheck_4
// 1225     }
// 1226     else
// 1227     {
// 1228       //刷新斜率储存值。
// 1229       //BlackLeftBigChangeSlopeStore = tempslope;
// 1230       return 1;
??BlackLeftBigChangeCheck_6:
        MOVS     R0,#+1
        B.N      ??BlackLeftBigChangeCheck_4
// 1231     }
// 1232   }
// 1233   //1. 前后两次的斜率是相反的。
// 1234   else if(tempslope1 < 0 && tempslope2 >= 0)
??BlackLeftBigChangeCheck_5:
        CMP      R3,#+0
        BPL.N    ??BlackLeftBigChangeCheck_7
        CMP      R4,#+0
        BMI.N    ??BlackLeftBigChangeCheck_7
// 1235   {
// 1236     //2. 两者差值很大很大。
// 1237     if(tempslope2 >= tempslope1 + BlackLeftBigChangeSlopeLimit)
        ADDS     R0,R3,#+4000
        CMP      R4,R0
        BLT.N    ??BlackLeftBigChangeCheck_8
// 1238     {
// 1239       //两者差值的确很大。不会刷新储存值。
// 1240       //if(use == 2)                    //另一种方案是在连续2行的第2行调用时才置成功标志位。
// 1241       //{
// 1242         //置成功标志位。
// 1243         BlackLeftBigChangeFlag = 1;
        MOVS     R0,#+1
        LDR.W    R3,??DataTable8_5
        STRB     R0,[R3, #+0]
// 1244       //}
// 1245       //else
// 1246       //{
// 1247       //}
// 1248       //此次行不进入队列。
// 1249       BlackLeftBigChangeNumx[4] = BlackLeftBigChangeNumx[3];
        LDR.W    R0,??DataTable8
        LDRB     R0,[R0, #+3]
        LDR.W    R3,??DataTable8
        STRB     R0,[R3, #+4]
// 1250       BlackLeftBigChangeNumx[3] = BlackLeftBigChangeNumx[2];
        LDR.W    R0,??DataTable8
        LDRB     R0,[R0, #+2]
        LDR.W    R3,??DataTable8
        STRB     R0,[R3, #+3]
// 1251       BlackLeftBigChangeNumx[2] = BlackLeftBigChangeNumx[1];
        LDR.W    R0,??DataTable8
        LDRB     R0,[R0, #+1]
        LDR.W    R3,??DataTable8
        STRB     R0,[R3, #+2]
// 1252       BlackLeftBigChangeNumx[1] = BlackLeftBigChangeNumx[0];
        LDR.W    R0,??DataTable8
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable8
        STRB     R0,[R3, #+1]
// 1253       BlackLeftBigChangeNumx[0] = tempstorex;
        LDR.W    R0,??DataTable8
        STRB     R1,[R0, #+0]
// 1254       BlackLeftBigChangeNumy[4] = BlackLeftBigChangeNumy[3];
        LDR.W    R0,??DataTable7_17
        LDRB     R0,[R0, #+3]
        LDR.W    R1,??DataTable7_17
        STRB     R0,[R1, #+4]
// 1255       BlackLeftBigChangeNumy[3] = BlackLeftBigChangeNumy[2];
        LDR.W    R0,??DataTable7_17
        LDRB     R0,[R0, #+2]
        LDR.N    R1,??DataTable7_17
        STRB     R0,[R1, #+3]
// 1256       BlackLeftBigChangeNumy[2] = BlackLeftBigChangeNumy[1];
        LDR.N    R0,??DataTable7_17
        LDRB     R0,[R0, #+1]
        LDR.N    R1,??DataTable7_17
        STRB     R0,[R1, #+2]
// 1257       BlackLeftBigChangeNumy[1] = BlackLeftBigChangeNumy[0];
        LDR.N    R0,??DataTable7_17
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable7_17
        STRB     R0,[R1, #+1]
// 1258       BlackLeftBigChangeNumy[0] = tempstorey;
        LDR.N    R0,??DataTable7_17
        STRB     R2,[R0, #+0]
// 1259       
// 1260       //将前面3个左黑线(共4个)的值置无效值。图像上更连续。
// 1261       BlackLeftLoc[BlackLeftBigChangeNumx[4]][0] = MaxValUint8;
        MOVS     R0,#+255
        LDR.N    R1,??DataTable6_12
        LDR.W    R2,??DataTable8
        LDRB     R2,[R2, #+4]
        MOVS     R3,#+3
        MLA      R1,R3,R2,R1
        STRB     R0,[R1, #+0]
// 1262       BlackLeftLoc[BlackLeftBigChangeNumx[3]][0] = MaxValUint8;
        MOVS     R0,#+255
        LDR.N    R1,??DataTable6_12
        LDR.W    R2,??DataTable8
        LDRB     R2,[R2, #+3]
        MOVS     R3,#+3
        MLA      R1,R3,R2,R1
        STRB     R0,[R1, #+0]
// 1263       //BlackLeftLoc[BlackLeftBigChangeNumx[2]][0] = MaxValUint8; 
// 1264       
// 1265       return 0;
        MOVS     R0,#+0
        B.N      ??BlackLeftBigChangeCheck_4
// 1266     }
// 1267     else
// 1268     {
// 1269       //刷新斜率储存值。
// 1270       //BlackLeftBigChangeSlopeStore = tempslope;
// 1271       return 1;
??BlackLeftBigChangeCheck_8:
        MOVS     R0,#+1
        B.N      ??BlackLeftBigChangeCheck_4
// 1272     }
// 1273   }
// 1274   //若不相反，则判定无大斜率的跳变。返回成功。
// 1275   else
// 1276   {
// 1277     //刷新斜率储存值。
// 1278     //BlackLeftBigChangeSlopeStore = tempslope;
// 1279     return 1;
??BlackLeftBigChangeCheck_7:
        MOVS     R0,#+1
??BlackLeftBigChangeCheck_4:
        POP      {R4-R7}
        BX       LR               ;; return
// 1280   }
// 1281   
// 1282 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6:
        DC32     ShiZhiFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_1:
        DC32     BlackLeftDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_2:
        DC32     BlackRightDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_3:
        DC32     SlopeL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_4:
        DC32     SlopeR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_5:
        DC32     BlackRightCrossDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_6:
        DC32     BlackLeftCrossDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_7:
        DC32     BlackRightEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_8:
        DC32     BlackLeftEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_9:
        DC32     BlackRightHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_10:
        DC32     BlackLeftHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_11:
        DC32     ImgNew

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6_12:
        DC32     BlackLeftLoc
// 1283 
// 1284 
// 1285 //单纯的、从右往左的、一定窗口内的、扫描跳变沿的函数.可以精简Step2Win, CrossSpeWin等诸多内容。
// 1286 //返回的是跳变沿的白点所在位置。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1287 uint8 BlackGetLeftJustWin(uint8 row, int32 colleft, int32 colright)
// 1288 {
BlackGetLeftJustWin:
        PUSH     {R3-R7,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
// 1289   uint8 temp1, abs1;
// 1290   uint8 tempadd1, tempadd2, tempadd3, tempadd4;
// 1291   
// 1292   //左右边界限幅
// 1293   colleft = BoundaryLimitRe(colleft, 0, CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        MOVS     R0,R5
        BL       BoundaryLimitRe
        MOVS     R5,R0
// 1294   colright = BoundaryLimitRe(colright, 0, CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        MOVS     R0,R6
        BL       BoundaryLimitRe
        MOVS     R6,R0
        B.N      ??BlackGetLeftJustWin_0
// 1295   
// 1296   //判断条件里的">"很关键，没有写">="是考虑temp = 0的情况，这样可以防止产生负数（uint8中为正数），即无限循环。
// 1297   for( ; colright > colleft; colright--) 
??BlackGetLeftJustWin_1:
        SUBS     R6,R6,#+1
??BlackGetLeftJustWin_0:
        CMP      R5,R6
        BGE.W    ??BlackGetLeftJustWin_2
// 1298   {
// 1299     //右白点与左黑线的差。
// 1300     if(ImgNew[row][colright] > ImgNew[row][colright-1-BlackLeftEdgeNum])
        LDR.W    R0,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        ADDS     R0,R6,R0
        LDRB     R0,[R0, #-4]
        LDR.W    R1,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        LDRB     R1,[R6, R1]
        CMP      R0,R1
        BCS.N    ??BlackGetLeftJustWin_3
// 1301     {
// 1302       abs1 = ImgNew[row][colright] - ImgNew[row][colright-1-BlackLeftEdgeNum];
        LDR.W    R0,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        LDRB     R0,[R6, R0]
        LDR.W    R1,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #-4]
        SUBS     R0,R0,R1
        B.N      ??BlackGetLeftJustWin_4
// 1303     }
// 1304     else
// 1305     {
// 1306       abs1 = 0;
??BlackGetLeftJustWin_3:
        MOVS     R0,#+0
// 1307     }
// 1308    
// 1309     if( //跳变沿的第一批条件：
// 1310         //黑够黑，白够白，差够大。
// 1311         //这里的3个阈值是自适应之后调整的值
// 1312           (abs1 > LimitLeftWB - LimitLeftWBAdjust[row]) //两者的差够大
// 1313         &&(ImgNew[row][colright] > LimitLeftW)                     //白点够白
// 1314         &&(ImgNew[row][colright-1-BlackLeftEdgeNum] < LimitLeftB)                   //黑点够黑
// 1315        )
??BlackGetLeftJustWin_4:
        LDR.W    R1,??DataTable9_1
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable9_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R2,[R4, R2]
        SUBS     R1,R1,R2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BGE.N    ??BlackGetLeftJustWin_1
        LDR.N    R0,??DataTable7_7
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        LDRB     R1,[R6, R1]
        CMP      R0,R1
        BCS.N    ??BlackGetLeftJustWin_1
        LDR.W    R0,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        ADDS     R0,R6,R0
        LDRB     R0,[R0, #-4]
        LDR.N    R1,??DataTable7_1
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCS.N    ??BlackGetLeftJustWin_1
// 1316     {
// 1317             //多几个白点的确认。用来防止右黑线右边的白边。
// 1318             if(colright < CameraRealWidth - 1 - 6)
        CMP      R6,#+243
        BGE.N    ??BlackGetLeftJustWin_5
// 1319             {
// 1320               tempadd1 = (ImgNew[row][colright+3] > LimitLeftW);
        LDR.N    R0,??DataTable7_7
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #+3]
        CMP      R0,R1
        BCS.N    ??BlackGetLeftJustWin_6
        MOVS     R0,#+1
        B.N      ??BlackGetLeftJustWin_7
??BlackGetLeftJustWin_6:
        MOVS     R0,#+0
// 1321               tempadd2 = (ImgNew[row][colright+4] > LimitLeftW);
??BlackGetLeftJustWin_7:
        LDR.N    R1,??DataTable7_7
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R4,R2
        ADDS     R2,R6,R2
        LDRB     R2,[R2, #+4]
        CMP      R1,R2
        BCS.N    ??BlackGetLeftJustWin_8
        MOVS     R1,#+1
        B.N      ??BlackGetLeftJustWin_9
??BlackGetLeftJustWin_8:
        MOVS     R1,#+0
// 1322               tempadd3 = (ImgNew[row][colright+5] > LimitLeftW);
??BlackGetLeftJustWin_9:
        LDR.N    R2,??DataTable7_7
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R7,#+250
        MLA      R3,R7,R4,R3
        ADDS     R3,R6,R3
        LDRB     R3,[R3, #+5]
        CMP      R2,R3
        BCS.N    ??BlackGetLeftJustWin_10
        MOVS     R2,#+1
        B.N      ??BlackGetLeftJustWin_11
??BlackGetLeftJustWin_10:
        MOVS     R2,#+0
// 1323               tempadd4 = (ImgNew[row][colright+6] > LimitLeftW);
??BlackGetLeftJustWin_11:
        LDR.N    R3,??DataTable7_7
        LDRB     R3,[R3, #+0]
        LDR.W    R7,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R12,#+250
        MLA      R7,R12,R4,R7
        ADDS     R7,R6,R7
        LDRB     R7,[R7, #+6]
        CMP      R3,R7
        BCS.N    ??BlackGetLeftJustWin_12
        MOVS     R3,#+1
        B.N      ??BlackGetLeftJustWin_13
??BlackGetLeftJustWin_12:
        MOVS     R3,#+0
        B.N      ??BlackGetLeftJustWin_13
// 1324             }
// 1325             else
// 1326             {
// 1327               tempadd1 = 1;
??BlackGetLeftJustWin_5:
        MOVS     R0,#+1
// 1328               tempadd2 = 1;
        MOVS     R1,#+1
// 1329               tempadd3 = 1;
        MOVS     R2,#+1
// 1330               tempadd4 = 1;
        MOVS     R3,#+1
// 1331             }       
// 1332       
// 1333           //近处的行，向左3个点仍为黑点，向右4个点仍为白点。
// 1334           if(row > BlackMiddleLine)
??BlackGetLeftJustWin_13:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+51
        BLT.N    ??BlackGetLeftJustWin_14
// 1335           {                        
// 1336             temp1 = (
// 1337                       (ImgNew[row][colright-2-BlackLeftEdgeNum] < LimitLeftB)
// 1338                     &&(ImgNew[row][colright-3-BlackLeftEdgeNum] < LimitLeftB)
// 1339                     //&&(ImgNew[row][colright-4-BlackLeftEdgeNum] < LimitLeftB)
// 1340                     &&(ImgNew[row][colright+1] > LimitLeftW)
// 1341                     &&(ImgNew[row][colright+2] > LimitLeftW)
// 1342                     &&(tempadd1 == 1)
// 1343                     &&(tempadd2 == 1)
// 1344                     &&(tempadd3 == 1)
// 1345                     &&(tempadd4 == 1)
// 1346                     );
        LDR.W    R7,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R12,#+250
        MLA      R7,R12,R4,R7
        ADDS     R7,R6,R7
        LDRB     R7,[R7, #-5]
        LDR.W    R12,??DataTable7_1
        LDRB     R12,[R12, #+0]
        CMP      R7,R12
        BCS.N    ??BlackGetLeftJustWin_15
        LDR.W    R7,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R12,#+250
        MLA      R7,R12,R4,R7
        ADDS     R7,R6,R7
        LDRB     R7,[R7, #-6]
        LDR.W    R12,??DataTable7_1
        LDRB     R12,[R12, #+0]
        CMP      R7,R12
        BCS.N    ??BlackGetLeftJustWin_15
        LDR.N    R7,??DataTable7_7
        LDRB     R7,[R7, #+0]
        LDR.W    R12,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     LR,#+250
        MLA      R12,LR,R4,R12
        ADDS     R12,R6,R12
        LDRB     R12,[R12, #+1]
        CMP      R7,R12
        BCS.N    ??BlackGetLeftJustWin_15
        LDR.N    R7,??DataTable7_7
        LDRB     R7,[R7, #+0]
        LDR.W    R12,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     LR,#+250
        MLA      R12,LR,R4,R12
        ADDS     R12,R6,R12
        LDRB     R12,[R12, #+2]
        CMP      R7,R12
        BCS.N    ??BlackGetLeftJustWin_15
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??BlackGetLeftJustWin_15
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??BlackGetLeftJustWin_15
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.N    ??BlackGetLeftJustWin_15
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+1
        BNE.N    ??BlackGetLeftJustWin_15
        MOVS     R0,#+1
        B.N      ??BlackGetLeftJustWin_16
??BlackGetLeftJustWin_15:
        MOVS     R0,#+0
        B.N      ??BlackGetLeftJustWin_16
// 1347           }
// 1348           else
// 1349           {
// 1350             //中间的行 ，向左2个点为仍为黑点，向右4个点仍为白点。
// 1351             if(row > BlackFarLine)
??BlackGetLeftJustWin_14:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+41
        BLT.N    ??BlackGetLeftJustWin_17
// 1352             {
// 1353               temp1 = (
// 1354                         (ImgNew[row][colright-2-BlackLeftEdgeNum] < LimitLeftB)
// 1355                       //&&(ImgNew[row][colright-3-BlackLeftEdgeNum] < LimitLeftB)
// 1356                       &&(ImgNew[row][colright+1] > LimitLeftW)
// 1357                       &&(tempadd1 == 1)
// 1358                       &&(tempadd2 == 1)
// 1359                       &&(tempadd3 == 1)
// 1360                       &&(tempadd4 == 1)                        
// 1361                       );
        LDR.W    R7,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R12,#+250
        MLA      R7,R12,R4,R7
        ADDS     R7,R6,R7
        LDRB     R7,[R7, #-5]
        LDR.W    R12,??DataTable7_1
        LDRB     R12,[R12, #+0]
        CMP      R7,R12
        BCS.N    ??BlackGetLeftJustWin_18
        LDR.N    R7,??DataTable7_7
        LDRB     R7,[R7, #+0]
        LDR.W    R12,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     LR,#+250
        MLA      R12,LR,R4,R12
        ADDS     R12,R6,R12
        LDRB     R12,[R12, #+1]
        CMP      R7,R12
        BCS.N    ??BlackGetLeftJustWin_18
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??BlackGetLeftJustWin_18
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??BlackGetLeftJustWin_18
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.N    ??BlackGetLeftJustWin_18
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+1
        BNE.N    ??BlackGetLeftJustWin_18
        MOVS     R0,#+1
        B.N      ??BlackGetLeftJustWin_16
??BlackGetLeftJustWin_18:
        MOVS     R0,#+0
        B.N      ??BlackGetLeftJustWin_16
// 1362             }
// 1363             else
// 1364             {
// 1365               if(row > BlackFarfarLine)
??BlackGetLeftJustWin_17:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+21
        BLT.N    ??BlackGetLeftJustWin_19
// 1366               {
// 1367                 //远处的行 ，向左1个点为仍为黑点，向右4个点仍为白点。
// 1368                 temp1 = (
// 1369                         //(ImgNew[row][colright-2-BlackLeftEdgeNum] < LimitLeftB)
// 1370                         (tempadd1 == 1)
// 1371                       &&(tempadd2 == 1)
// 1372                       &&(tempadd3 == 1)
// 1373                       &&(tempadd4 == 1)
// 1374                         );                   
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??BlackGetLeftJustWin_20
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??BlackGetLeftJustWin_20
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.N    ??BlackGetLeftJustWin_20
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+1
        BNE.N    ??BlackGetLeftJustWin_20
        MOVS     R0,#+1
        B.N      ??BlackGetLeftJustWin_16
??BlackGetLeftJustWin_20:
        MOVS     R0,#+0
        B.N      ??BlackGetLeftJustWin_16
// 1375               }
// 1376               else
// 1377               {
// 1378                 //很远处的行，只对跳变和周围白点有要求，对周围黑点没有要求。
// 1379                 temp1 = (
// 1380                         (tempadd1 == 1)
// 1381                       &&(tempadd2 == 1)
// 1382                       &&(tempadd3 == 1)
// 1383                       &&(tempadd4 == 1)
// 1384                         );    
??BlackGetLeftJustWin_19:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??BlackGetLeftJustWin_21
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??BlackGetLeftJustWin_21
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.N    ??BlackGetLeftJustWin_21
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+1
        BNE.N    ??BlackGetLeftJustWin_21
        MOVS     R0,#+1
        B.N      ??BlackGetLeftJustWin_16
??BlackGetLeftJustWin_21:
        MOVS     R0,#+0
// 1385               }
// 1386                     
// 1387             }
// 1388           }
// 1389           
// 1390           //跳变沿的第二批条件：
// 1391           if(temp1 == 1)
??BlackGetLeftJustWin_16:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.W    ??BlackGetLeftJustWin_1
// 1392           {
// 1393             //两批条件均满足，返回白点位置，不是黑点位置！           
// 1394             return colright;              
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??BlackGetLeftJustWin_22
// 1395             
// 1396             //break;          
// 1397           }// end of 跳变沿检测的第2批条件
// 1398     }// end of 跳变沿检测的第1批条件
// 1399   }// end of for循环  
// 1400   
// 1401   
// 1402   
// 1403   //如果一直到窗口最左边还没有找到跳变沿，返回无效值。
// 1404   return MaxValUint8;  
??BlackGetLeftJustWin_2:
        MOVS     R0,#+255
??BlackGetLeftJustWin_22:
        POP      {R1,R4-R7,PC}    ;; return
// 1405   
// 1406 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7:
        DC32     BlackRightLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_1:
        DC32     LimitLeftB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_2:
        DC32     ShiZhiCount

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_3:
        DC32     StopLineCheckBeginFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_4:
        DC32     StopLineCheckTimer

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_5:
        DC32     CURVEL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_6:
        DC32     CURVER

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_7:
        DC32     LimitLeftW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_8:
        DC32     LimitRightW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_9:
        DC32     limitStopLineBlackXiu

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_10:
        DC32     ?_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_11:
        DC32     0x4006a000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_12:
        DC32     ?_1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_13:
        DC32     BlackLeftRealWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_14:
        DC32     BlackLeftRealW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_15:
        DC32     BlackLeftRealB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_16:
        DC32     SingleBlackAllFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_17:
        DC32     BlackLeftBigChangeNumy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_18:
        DC32     BlackLeftBigChangeJumpFlag
// 1407 
// 1408 
// 1409 
// 1410 
// 1411 //======================================================================
// 1412 //函数名：BlackGetLeftStep1Edge
// 1413 //功  能：左黑线提取中，第1阶段跳变检测函数,处理该行左线的可疑黑点
// 1414 //参  数：待检测的行号row, 第几次使用use, 黑线预处理标志preflag(1是预处理)
// 1415 //返  回：1成功 0失败
// 1416 //影  响：BlackLeftRealWB[], BlackLeftRealW[], BlackLeftRealB[]
// 1417 //        BlackLeftLoc[][]
// 1418 //说  明：1. 对第row行的跳变向左进行白到黑检测，成功就赋相应的值（有3个备用值），失败则赋255
// 1419 //        2. 两批条件均满足时。则检测成功。会有最多3个值进行记录，现阶段只用到了第1个值
// 1420 //        3. 里面有涉及3个关键值的实际值的记录，CrossFlag的情况就不用记录（也就不用更改）
// 1421 //        4. 若1个黑点也没有，或者超过3个黑点，则检测失败。
// 1422 //        5. 若要改成黑到白的检测，或者任意检测，只需更改第一批条件即可，很方便。
// 1423 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1424 uint8 BlackGetLeftStep1Edge(uint8 row, uint8 use, uint8 preflag)
// 1425 {
BlackGetLeftStep1Edge:
        PUSH     {R3-R9,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
// 1426   uint8 index, col, temp1;
// 1427   uint8 abs1;
// 1428   uint8 tempadd1, tempadd2, tempadd3, tempadd4;
// 1429   uint8 avgr1, avgl1;
// 1430   uint8 i;
// 1431   
// 1432   //根据上一幅有效图像的中线来预估这一幅图像的左右黑线扫描起点，左线起点需要在中线往右一个黑线宽度。 
// 1433   col = (uint8)MinRe((int32)BlackLeftEdgeStartCol+10, CameraRealWidth - 1);
        MOVS     R1,#+249
        LDR.W    R0,??DataTable10
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+10
        BL       MinRe
        MOVS     R7,R0
// 1434 
// 1435   //右线开始扫描。
// 1436   //如果是预处理，也不用考虑这个情况。直接往下走就好。
// 1437   if((BlackGetPreDir == 1)
// 1438   &&(BlackRightLoc[row][0] != MaxValUint8)
// 1439   &&(preflag == 0)
// 1440     )
        LDR.W    R0,??DataTable10_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackGetLeftStep1Edge_0
        LDR.W    R0,??DataTable10_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??BlackGetLeftStep1Edge_0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BNE.N    ??BlackGetLeftStep1Edge_0
// 1441   {
// 1442     //如果上一幅图是单线，则左线扫描起点必须在右线的右边一个单线宽度。
// 1443     if(
// 1444       (row > CameraHight - 5)
// 1445     &&(SingleBlackLastAllFlag == 1)
// 1446        )
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+56
        BLT.N    ??BlackGetLeftStep1Edge_1
        LDR.W    R0,??DataTable10_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackGetLeftStep1Edge_1
// 1447     {
// 1448       col = MaxRe(col, MinRe(CameraRealWidth - 1, BlackRightLoc[row][0] + SingleBlackWidthMax[row]));
        LDR.W    R0,??DataTable10_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable10_4
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R1,[R4, R1]
        ADDS     R1,R1,R0
        MOVS     R0,#+249
        BL       MinRe
        MOVS     R1,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R0,R7
        BL       MaxRe
        MOVS     R7,R0
        B.N      ??BlackGetLeftStep1Edge_0
// 1449     }
// 1450     //如果上一幅图不是单线，且最近四行没有采集到单线，那就视为不可能出现单线。所以左线扫描起点必须在右线的左边
// 1451     else if(
// 1452            (row <= CameraHight - 5)
// 1453          //&&(SingleBlackLastAllFlag == 0)
// 1454             )
??BlackGetLeftStep1Edge_1:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+56
        BGE.N    ??BlackGetLeftStep1Edge_2
// 1455     {
// 1456       col = MinRe(col, BlackRightLoc[row][0]);
        LDR.W    R0,??DataTable10_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R1,[R0, #+0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R0,R7
        BL       MinRe
        MOVS     R7,R0
        B.N      ??BlackGetLeftStep1Edge_0
// 1457     }
// 1458     else
// 1459     {
// 1460       col = MinRe(col, BlackRightLoc[row][0]);
??BlackGetLeftStep1Edge_2:
        LDR.W    R0,??DataTable10_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R1,[R0, #+0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R0,R7
        BL       MinRe
        MOVS     R7,R0
// 1461     }
// 1462   }
// 1463   else
// 1464   {    
// 1465   }
// 1466   
// 1467   //窗口预测值记录
// 1468   BlackLeftPredictL[row] = 4 + BlackLeftEdgeNum;
??BlackGetLeftStep1Edge_0:
        MOVS     R0,#+7
        LDR.W    R1,??DataTable11
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R0,[R4, R1]
// 1469   BlackLeftPredictR[row] = col;
        LDR.W    R0,??DataTable11_1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R7,[R4, R0]
// 1470   
// 1471   index = 0;         //可疑点的序号
        MOVS     R0,#+0
        B.N      ??BlackGetLeftStep1Edge_3
// 1472   //从中间到最左边扫描，隔1个点求差
// 1473   for(; col >= 4+BlackLeftEdgeNum; col--) 
??BlackGetLeftStep1Edge_4:
        SUBS     R7,R7,#+1
??BlackGetLeftStep1Edge_3:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+7
        BLT.W    ??BlackGetLeftStep1Edge_5
// 1474   {
// 1475       //右白点与左黑点的差。
// 1476       if(ImgNew[row][col] > ImgNew[row][col-1-BlackLeftEdgeNum])
        LDR.W    R1,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R1,R7,R1
        LDRB     R1,[R1, #-4]
        LDR.W    R2,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R4,R2
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R2,[R7, R2]
        CMP      R1,R2
        BCS.N    ??BlackGetLeftStep1Edge_6
// 1477       {
// 1478         abs1 = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum];
        LDR.W    R1,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R1,[R7, R1]
        LDR.W    R2,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R4,R2
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R2,R7,R2
        LDRB     R2,[R2, #-4]
        SUBS     R1,R1,R2
        B.N      ??BlackGetLeftStep1Edge_7
// 1479       }
// 1480       else
// 1481       {
// 1482         abs1 = 0;
??BlackGetLeftStep1Edge_6:
        MOVS     R1,#+0
// 1483       }
// 1484       
// 1485       if( //跳变沿的第一批条件：
// 1486           //黑够黑，白够白，差够大。
// 1487           //这里的3个阈值为初始值，不是自适应之后调整的值。
// 1488           (abs1 > LimitLeftWB - LimitLeftWBAdjust[row]) //两者的差够大
// 1489         //后面两个条件改一下，就可以实现黑到白的跳变检测，或者任意检测。
// 1490         &&(ImgNew[row][col] > LimitLeftW)                     //白点够白
// 1491         &&(ImgNew[row][col-1-BlackLeftEdgeNum] < LimitLeftB)                   //黑点够黑
// 1492          )
??BlackGetLeftStep1Edge_7:
        LDR.W    R2,??DataTable9_1
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable9_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R3,[R4, R3]
        SUBS     R2,R2,R3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R2,R1
        BGE.N    ??BlackGetLeftStep1Edge_4
        LDR.W    R1,??DataTable11_2
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R4,R2
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R2,[R7, R2]
        CMP      R1,R2
        BCS.N    ??BlackGetLeftStep1Edge_4
        LDR.W    R1,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R1,R7,R1
        LDRB     R1,[R1, #-4]
        LDR.W    R2,??DataTable11_3
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BCS.N    ??BlackGetLeftStep1Edge_4
// 1493       {
// 1494             //多几个白点的确认。用来防止右黑线右边的白边。
// 1495             if(col < CameraRealWidth - 1 - 6)
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+243
        BGE.N    ??BlackGetLeftStep1Edge_8
// 1496             {
// 1497               tempadd1 = (ImgNew[row][col+3] > LimitLeftW);
        LDR.W    R1,??DataTable11_2
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R4,R2
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R2,R7,R2
        LDRB     R2,[R2, #+3]
        CMP      R1,R2
        BCS.N    ??BlackGetLeftStep1Edge_9
        MOVS     R1,#+1
        B.N      ??BlackGetLeftStep1Edge_10
??BlackGetLeftStep1Edge_9:
        MOVS     R1,#+0
// 1498               tempadd2 = (ImgNew[row][col+4] > LimitLeftW);
??BlackGetLeftStep1Edge_10:
        LDR.W    R2,??DataTable11_2
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R12,#+250
        MLA      R3,R12,R4,R3
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R3,R7,R3
        LDRB     R3,[R3, #+4]
        CMP      R2,R3
        BCS.N    ??BlackGetLeftStep1Edge_11
        MOVS     R2,#+1
        B.N      ??BlackGetLeftStep1Edge_12
??BlackGetLeftStep1Edge_11:
        MOVS     R2,#+0
// 1499               tempadd3 = (ImgNew[row][col+5] > LimitLeftW);
??BlackGetLeftStep1Edge_12:
        LDR.W    R3,??DataTable11_2
        LDRB     R3,[R3, #+0]
        LDR.W    R12,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     LR,#+250
        MLA      R12,LR,R4,R12
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R12,R7,R12
        LDRB     R12,[R12, #+5]
        CMP      R3,R12
        BCS.N    ??BlackGetLeftStep1Edge_13
        MOVS     R3,#+1
        B.N      ??BlackGetLeftStep1Edge_14
??BlackGetLeftStep1Edge_13:
        MOVS     R3,#+0
// 1500               tempadd4 = (ImgNew[row][col+6] > LimitLeftW);
??BlackGetLeftStep1Edge_14:
        LDR.W    R12,??DataTable11_2
        LDRB     R12,[R12, #+0]
        LDR.W    LR,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R8,#+250
        MLA      LR,R8,R4,LR
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     LR,R7,LR
        LDRB     LR,[LR, #+6]
        CMP      R12,LR
        BCS.N    ??BlackGetLeftStep1Edge_15
        MOVS     R12,#+1
        B.N      ??BlackGetLeftStep1Edge_16
??BlackGetLeftStep1Edge_15:
        MOVS     R12,#+0
        B.N      ??BlackGetLeftStep1Edge_16
// 1501             }
// 1502             else
// 1503             {
// 1504               tempadd1 = 1;
??BlackGetLeftStep1Edge_8:
        MOVS     R1,#+1
// 1505               tempadd2 = 1;
        MOVS     R2,#+1
// 1506               tempadd3 = 1;
        MOVS     R3,#+1
// 1507               tempadd4 = 1;
        MOVS     R12,#+1
// 1508             }       
// 1509           //跳变沿的第二批条件：
// 1510           //近处的行，向左3个点仍为黑点，向右4个点仍为白点。
// 1511           if(row > BlackMiddleLine)
??BlackGetLeftStep1Edge_16:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+51
        BLT.N    ??BlackGetLeftStep1Edge_17
// 1512           {                                
// 1513             temp1 = (
// 1514                       (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB)
// 1515                     &&(ImgNew[row][col-3-BlackLeftEdgeNum] < LimitLeftB)
// 1516                     &&(ImgNew[row][col-4-BlackLeftEdgeNum] < LimitLeftB)
// 1517                     &&(ImgNew[row][col+1] > LimitLeftW)
// 1518                     &&(ImgNew[row][col+2] > LimitLeftW)
// 1519                     &&(tempadd1 == 1)
// 1520                     &&(tempadd2 == 1)
// 1521                     &&(tempadd3 == 1)
// 1522                     &&(tempadd4 == 1)
// 1523                     );
        LDR.W    LR,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R8,#+250
        MLA      LR,R8,R4,LR
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     LR,R7,LR
        LDRB     LR,[LR, #-5]
        LDR.W    R8,??DataTable11_3
        LDRB     R8,[R8, #+0]
        CMP      LR,R8
        BCS.N    ??BlackGetLeftStep1Edge_18
        LDR.W    LR,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R8,#+250
        MLA      LR,R8,R4,LR
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     LR,R7,LR
        LDRB     LR,[LR, #-6]
        LDR.W    R8,??DataTable11_3
        LDRB     R8,[R8, #+0]
        CMP      LR,R8
        BCS.N    ??BlackGetLeftStep1Edge_18
        LDR.W    LR,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R8,#+250
        MLA      LR,R8,R4,LR
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     LR,R7,LR
        LDRB     LR,[LR, #-7]
        LDR.W    R8,??DataTable11_3
        LDRB     R8,[R8, #+0]
        CMP      LR,R8
        BCS.N    ??BlackGetLeftStep1Edge_18
        LDR.W    LR,??DataTable11_2
        LDRB     LR,[LR, #+0]
        LDR.W    R8,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R9,#+250
        MLA      R8,R9,R4,R8
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R8,R7,R8
        LDRB     R8,[R8, #+1]
        CMP      LR,R8
        BCS.N    ??BlackGetLeftStep1Edge_18
        LDR.W    LR,??DataTable11_2
        LDRB     LR,[LR, #+0]
        LDR.W    R8,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R9,#+250
        MLA      R8,R9,R4,R8
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R8,R7,R8
        LDRB     R8,[R8, #+2]
        CMP      LR,R8
        BCS.N    ??BlackGetLeftStep1Edge_18
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??BlackGetLeftStep1Edge_18
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.N    ??BlackGetLeftStep1Edge_18
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+1
        BNE.N    ??BlackGetLeftStep1Edge_18
        UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
        CMP      R12,#+1
        BNE.N    ??BlackGetLeftStep1Edge_18
        MOVS     R1,#+1
        B.N      ??BlackGetLeftStep1Edge_19
??BlackGetLeftStep1Edge_18:
        MOVS     R1,#+0
        B.N      ??BlackGetLeftStep1Edge_19
// 1524           }          
// 1525           else
// 1526           {
// 1527             //远处的行 ，向左2个点为仍为黑点，向右4个点仍为白点。
// 1528             if(row > BlackFarLine)
??BlackGetLeftStep1Edge_17:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+41
        BLT.N    ??BlackGetLeftStep1Edge_20
// 1529             {
// 1530               temp1 = (
// 1531                         (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB)
// 1532                       &&(ImgNew[row][col-3-BlackLeftEdgeNum] < LimitLeftB)
// 1533                       &&(ImgNew[row][col+1] > LimitLeftW)
// 1534                       &&(tempadd1 == 1)
// 1535                       &&(tempadd2 == 1)
// 1536                       &&(tempadd3 == 1)
// 1537                       &&(tempadd4 == 1)
// 1538                       );
        LDR.W    LR,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R8,#+250
        MLA      LR,R8,R4,LR
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     LR,R7,LR
        LDRB     LR,[LR, #-5]
        LDR.W    R8,??DataTable11_3
        LDRB     R8,[R8, #+0]
        CMP      LR,R8
        BCS.N    ??BlackGetLeftStep1Edge_21
        LDR.W    LR,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R8,#+250
        MLA      LR,R8,R4,LR
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     LR,R7,LR
        LDRB     LR,[LR, #-6]
        LDR.W    R8,??DataTable11_3
        LDRB     R8,[R8, #+0]
        CMP      LR,R8
        BCS.N    ??BlackGetLeftStep1Edge_21
        LDR.W    LR,??DataTable11_2
        LDRB     LR,[LR, #+0]
        LDR.W    R8,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R9,#+250
        MLA      R8,R9,R4,R8
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R8,R7,R8
        LDRB     R8,[R8, #+1]
        CMP      LR,R8
        BCS.N    ??BlackGetLeftStep1Edge_21
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??BlackGetLeftStep1Edge_21
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.N    ??BlackGetLeftStep1Edge_21
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+1
        BNE.N    ??BlackGetLeftStep1Edge_21
        UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
        CMP      R12,#+1
        BNE.N    ??BlackGetLeftStep1Edge_21
        MOVS     R1,#+1
        B.N      ??BlackGetLeftStep1Edge_19
??BlackGetLeftStep1Edge_21:
        MOVS     R1,#+0
        B.N      ??BlackGetLeftStep1Edge_19
// 1539             }            
// 1540             else
// 1541             {
// 1542               if(row > BlackFarfarLine)
??BlackGetLeftStep1Edge_20:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+21
        BLT.N    ??BlackGetLeftStep1Edge_22
// 1543               {
// 1544                 //远处的行 ，向左1个点为仍为黑点，向右4个点仍为白点。
// 1545                 temp1 = (
// 1546                         (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB)
// 1547                       &&(tempadd1 == 1)
// 1548                       &&(tempadd2 == 1)
// 1549                       &&(tempadd3 == 1)
// 1550                       &&(tempadd4 == 1)
// 1551                         );
        LDR.W    LR,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R8,#+250
        MLA      LR,R8,R4,LR
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     LR,R7,LR
        LDRB     LR,[LR, #-5]
        LDR.W    R8,??DataTable11_3
        LDRB     R8,[R8, #+0]
        CMP      LR,R8
        BCS.N    ??BlackGetLeftStep1Edge_23
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??BlackGetLeftStep1Edge_23
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.N    ??BlackGetLeftStep1Edge_23
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+1
        BNE.N    ??BlackGetLeftStep1Edge_23
        UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
        CMP      R12,#+1
        BNE.N    ??BlackGetLeftStep1Edge_23
        MOVS     R1,#+1
        B.N      ??BlackGetLeftStep1Edge_19
??BlackGetLeftStep1Edge_23:
        MOVS     R1,#+0
        B.N      ??BlackGetLeftStep1Edge_19
// 1552               }
// 1553               else
// 1554               {
// 1555                 //很远的行，有跳变，有周围白点确认就行，对周围黑点没有要求。
// 1556                 temp1 = (
// 1557                         (tempadd1 == 1)
// 1558                       &&(tempadd2 == 1)
// 1559                       &&(tempadd3 == 1)
// 1560                       &&(tempadd4 == 1)
// 1561                         );
??BlackGetLeftStep1Edge_22:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??BlackGetLeftStep1Edge_24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.N    ??BlackGetLeftStep1Edge_24
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+1
        BNE.N    ??BlackGetLeftStep1Edge_24
        UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
        CMP      R12,#+1
        BNE.N    ??BlackGetLeftStep1Edge_24
        MOVS     R1,#+1
        B.N      ??BlackGetLeftStep1Edge_19
??BlackGetLeftStep1Edge_24:
        MOVS     R1,#+0
// 1562               }
// 1563             }
// 1564           }
// 1565 
// 1566           if(temp1)
??BlackGetLeftStep1Edge_19:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BEQ.W    ??BlackGetLeftStep1Edge_4
// 1567           {            
// 1568               //跳变检测成功，取黑点
// 1569               BlackLeftLoc[row][index] = col - 1 - BlackLeftEdgeNum;          
        LDR.W    R1,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        SUBS     R2,R7,#+4
        STRB     R2,[R0, R1]
// 1570               index++;
        ADDS     R0,R0,#+1
// 1571               break;
// 1572             
// 1573           }    //end of 跳变沿的第二批条件
// 1574       }   //end of 跳变沿的第一批条件
// 1575   }// end of 从中间到最左边扫描，隔1个点求差
// 1576   
// 1577   //1个可疑黑点也没有，则报错。
// 1578   if(index == 0)
??BlackGetLeftStep1Edge_5:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackGetLeftStep1Edge_25
// 1579   {
// 1580     //如果是黑线预处理的调用，也不用更新这几个值。
// 1581     if(preflag == 0)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BNE.N    ??BlackGetLeftStep1Edge_26
// 1582     {
// 1583       //对3个关键值的实际值清零
// 1584       BlackLeftRealClear();
        BL       BlackLeftRealClear
// 1585     }
// 1586     //该行定位黑线失败，赋无效值
// 1587     BlackLeftLoc[row][0] = MaxValUint8;
??BlackGetLeftStep1Edge_26:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 1588     return 0;
        MOVS     R0,#+0
        B.N      ??BlackGetLeftStep1Edge_27
// 1589   }
// 1590   
// 1591   //不是黑线预处理的调用，则进行大斜率检测。
// 1592   if(preflag == 0)
??BlackGetLeftStep1Edge_25:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BNE.W    ??BlackGetLeftStep1Edge_28
// 1593   {
// 1594     //最后确认前，需要进行大斜率的检测。若不成功，则说明检测到坏点。
// 1595     if(BlackLeftBigChangeCheck(row, use) == 1)
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackLeftBigChangeCheck
        CMP      R0,#+1
        BNE.W    ??BlackGetLeftStep1Edge_29
// 1596     {
// 1597       //从右线开始的扫描
// 1598       //若已经确认为单线了，就不用再次确认了。
// 1599       if(
// 1600         (SingleBlackAllFlag == 0) 
// 1601       &&(BlackGetPreDir == 1)   
// 1602         )
        LDR.W    R0,??DataTable13_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.W    ??BlackGetLeftStep1Edge_28
        LDR.W    R0,??DataTable10_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??BlackGetLeftStep1Edge_28
// 1603       {
// 1604         //若该行左右黑线均检测成功，且右线在左线的左边一定范围内，则该行判定为单线。
// 1605         if((BlackLeftLoc[row][0] != MaxValUint8)
// 1606          &&(BlackRightLoc[row][0] != MaxValUint8)
// 1607          &&(BlackRightLoc[row][0] < BlackLeftLoc[row][0])
// 1608          &&(BlackRightLoc[row][0] - BlackLeftLoc[row][0] < SingleBlackWidthMax[row]) //结果是负数也会满足，所以必须小于。
// 1609         )
        LDR.W    R0,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.W    ??BlackGetLeftStep1Edge_30
        LDR.W    R0,??DataTable10_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.W    ??BlackGetLeftStep1Edge_30
        LDR.W    R0,??DataTable10_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCS.W    ??BlackGetLeftStep1Edge_30
        LDR.W    R0,??DataTable10_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable10_4
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R1,[R4, R1]
        CMP      R0,R1
        BGE.W    ??BlackGetLeftStep1Edge_30
// 1610         {
// 1611           //检查5个白点的平均值是否相近，若相近，则是单线，若不相近，则置无效值。
// 1612           if(
// 1613             (BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 5 < 0)
// 1614           ||(BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 5 > CameraRealWidth - 1)
// 1615             )
        LDR.W    R0,??DataTable10_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+9
        CMP      R0,#+0
        BMI.N    ??BlackGetLeftStep1Edge_31
        LDR.W    R0,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+9
        CMP      R0,#+250
        BLT.N    ??BlackGetLeftStep1Edge_32
// 1616           {
// 1617             //不哆5个点。
// 1618             //因为进行过大跳变，所以要清除。只针对最近几行。
// 1619             if(row > CameraHight - 5)
??BlackGetLeftStep1Edge_31:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+56
        BLT.N    ??BlackGetLeftStep1Edge_33
// 1620             {
// 1621                 for(i = 0; i <= 4; i++)
        MOVS     R0,#+0
        B.N      ??BlackGetLeftStep1Edge_34
// 1622                 {
// 1623                     BlackLeftBigChangeNumx[i] = MaxValUint8;
??BlackGetLeftStep1Edge_35:
        MOVS     R1,#+255
        LDR.N    R2,??DataTable8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 1624                     BlackLeftBigChangeNumy[i] = MaxValUint8;
        MOVS     R1,#+255
        LDR.W    R2,??DataTable13_2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 1625                 }
        ADDS     R0,R0,#+1
??BlackGetLeftStep1Edge_34:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+5
        BLT.N    ??BlackGetLeftStep1Edge_35
// 1626                 BlackLeftBigChangeJumpFlag = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable13_3
        STRB     R0,[R1, #+0]
// 1627             }
// 1628             else
// 1629             {
// 1630             }
// 1631             
// 1632             //该行定位黑线失败，赋无效值
// 1633             BlackLeftLoc[row][0] = MaxValUint8;
??BlackGetLeftStep1Edge_33:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 1634             return 0;
        MOVS     R0,#+0
        B.N      ??BlackGetLeftStep1Edge_27
// 1635           }
// 1636           else
// 1637           {
// 1638             //该行右线的白点平均值
// 1639             avgr1 = (ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 1]
// 1640                    + ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 2]
// 1641                    + ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 3]
// 1642                    + ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 4]
// 1643                    + ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 5])
// 1644                    / 5;
??BlackGetLeftStep1Edge_32:
        LDR.W    R0,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        LDR.W    R1,??DataTable10_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        ADDS     R0,R1,R0
        LDRB     R0,[R0, #-5]
        LDR.W    R1,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        LDR.W    R2,??DataTable10_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R4,R2
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #-6]
        UXTAB    R0,R1,R0
        LDR.W    R1,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        LDR.W    R2,??DataTable10_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R4,R2
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #-7]
        UXTAB    R0,R0,R1
        LDR.W    R1,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        LDR.W    R2,??DataTable10_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R4,R2
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #-8]
        UXTAB    R0,R0,R1
        LDR.W    R1,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        LDR.W    R2,??DataTable10_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R4,R2
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #-9]
        UXTAB    R0,R0,R1
        MOVS     R1,#+5
        SDIV     R0,R0,R1
// 1645             //该行左线的白点平均值
// 1646             avgl1 = (ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 1]
// 1647                    + ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 2]
// 1648                    + ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 3]
// 1649                    + ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 4]
// 1650                    + ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 5])
// 1651                    / 5;    
        LDR.W    R1,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        LDR.W    R2,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R4,R2
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #+5]
        LDR.W    R2,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R4,R2
        LDR.W    R3,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R12,#+3
        MLA      R3,R12,R4,R3
        LDRB     R3,[R3, #+0]
        ADDS     R2,R3,R2
        LDRB     R2,[R2, #+6]
        UXTAB    R1,R2,R1
        LDR.N    R2,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R4,R2
        LDR.W    R3,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R12,#+3
        MLA      R3,R12,R4,R3
        LDRB     R3,[R3, #+0]
        ADDS     R2,R3,R2
        LDRB     R2,[R2, #+7]
        UXTAB    R1,R1,R2
        LDR.N    R2,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R4,R2
        LDR.W    R3,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R12,#+3
        MLA      R3,R12,R4,R3
        LDRB     R3,[R3, #+0]
        ADDS     R2,R3,R2
        LDRB     R2,[R2, #+8]
        UXTAB    R1,R1,R2
        LDR.N    R2,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R4,R2
        LDR.W    R3,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R12,#+3
        MLA      R3,R12,R4,R3
        LDRB     R3,[R3, #+0]
        ADDS     R2,R3,R2
        LDRB     R2,[R2, #+9]
        UXTAB    R1,R1,R2
        MOVS     R2,#+5
        SDIV     R1,R1,R2
// 1652             if(AbsInt(avgr1 - avgl1) < 20)
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        SUBS     R0,R0,R1
        BL       AbsInt
        CMP      R0,#+20
        BGE.N    ??BlackGetLeftStep1Edge_36
// 1653             {
// 1654               //5个白点之间的差别够小，单线判断成功。
// 1655               SingleBlackFlag[row] = 1;      
        MOVS     R0,#+1
        LDR.W    R1,??DataTable14
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R0,[R4, R1]
// 1656               //SingleBlackAllFlag = 1;   //总幅图像的单线标志，只要有一行检测单线成功，则置1.
// 1657             }
// 1658             else
// 1659             {
// 1660               //5个白点之间的差别太大，单线判断失败。
// 1661               //因为进行过大跳变，所以要清除。只针对最近几行。
// 1662               if(row > CameraHight - 5)
// 1663               {
// 1664                   for(i = 0; i <= 4; i++)
// 1665                   {
// 1666                       BlackLeftBigChangeNumx[i] = MaxValUint8;
// 1667                       BlackLeftBigChangeNumy[i] = MaxValUint8;
// 1668                   }
// 1669                   BlackLeftBigChangeJumpFlag = 0;
// 1670               }
// 1671               else
// 1672               {
// 1673               }             
// 1674               
// 1675               //该行定位黑线失败，赋无效值
// 1676               BlackLeftLoc[row][0] = MaxValUint8;
// 1677               return 0;              
// 1678             }
// 1679           }          
// 1680         }
// 1681         else
// 1682         {
// 1683           //否则该行单线标志为0.
// 1684           SingleBlackFlag[row] = 0;
// 1685         }
// 1686       }
// 1687       //从右线开始的扫描，右线不用检测是否有单线，左线去检测即可。
// 1688       else
// 1689       {
// 1690       }
// 1691       
// 1692       //没有报错，就会走到这里，黑点查找成功，会有1，2，3个黑点
// 1693       //return 1;
// 1694     }
// 1695     else
// 1696     {
// 1697       //没通过大斜率检测。
// 1698       BlackLeftBigChangeCheckRow[row] = 1;
// 1699       BlackLeftBigChangeCheckAllRow = 1;
// 1700       
// 1701       //return 1;    
// 1702       
// 1703       
// 1704       //该行定位黑线失败，赋无效值
// 1705       BlackLeftLoc[row][0] = MaxValUint8;
// 1706       return 0;    
// 1707     }
// 1708   }
// 1709   //不是黑线预处理的调用，不需进行大斜率检测，直接返回成功。
// 1710   else
// 1711   {
// 1712     //return 1;    
// 1713   }
// 1714   
// 1715   //如果是黑线预处理，也不用更新这几个值
// 1716   if(preflag == 0)
??BlackGetLeftStep1Edge_28:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BNE.W    ??BlackGetLeftStep1Edge_37
// 1717   {
// 1718     //进入这里说明跳变沿的二批条件均满足，进入黑点记录阶段
// 1719     //记录3个关键值的实际信息，作为后面的参考。
// 1720     if(use == 1)
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+1
        BNE.N    ??BlackGetLeftStep1Edge_38
// 1721     {
// 1722       BlackLeftRealWB[0] = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum]; 
        LDR.N    R0,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R0,[R7, R0]
        LDR.N    R1,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R1,R7,R1
        LDRB     R1,[R1, #-4]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable14_1
        STRB     R0,[R1, #+0]
// 1723       BlackLeftRealW[0] = ImgNew[row][col];
        LDR.N    R0,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R0,[R7, R0]
        LDR.W    R1,??DataTable14_2
        STRB     R0,[R1, #+0]
// 1724       BlackLeftRealB[0] = ImgNew[row][col-1-BlackLeftEdgeNum];
        LDR.N    R0,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R0,R7,R0
        LDRB     R0,[R0, #-4]
        LDR.W    R1,??DataTable14_3
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetLeftStep1Edge_37
// 1725     }
??BlackGetLeftStep1Edge_36:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+56
        BLT.N    ??BlackGetLeftStep1Edge_39
        MOVS     R0,#+0
        B.N      ??BlackGetLeftStep1Edge_40
??BlackGetLeftStep1Edge_41:
        MOVS     R1,#+255
        LDR.N    R2,??DataTable8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
        MOVS     R1,#+255
        LDR.W    R2,??DataTable13_2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
        ADDS     R0,R0,#+1
??BlackGetLeftStep1Edge_40:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+5
        BLT.N    ??BlackGetLeftStep1Edge_41
        MOVS     R0,#+0
        LDR.W    R1,??DataTable13_3
        STRB     R0,[R1, #+0]
??BlackGetLeftStep1Edge_39:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
        MOVS     R0,#+0
        B.N      ??BlackGetLeftStep1Edge_27
??BlackGetLeftStep1Edge_30:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable14
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R0,[R4, R1]
        B.N      ??BlackGetLeftStep1Edge_28
??BlackGetLeftStep1Edge_29:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable14_4
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R0,[R4, R1]
        MOVS     R0,#+1
        LDR.W    R1,??DataTable14_5
        STRB     R0,[R1, #+0]
        MOVS     R0,#+255
        LDR.W    R1,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
        MOVS     R0,#+0
        B.N      ??BlackGetLeftStep1Edge_27
// 1726     else if(use == 2)
??BlackGetLeftStep1Edge_38:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+2
        BNE.N    ??BlackGetLeftStep1Edge_37
// 1727     {
// 1728       BlackLeftRealWB[1] = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum]; 
        LDR.N    R0,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R0,[R7, R0]
        LDR.N    R1,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R1,R7,R1
        LDRB     R1,[R1, #-4]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable14_1
        STRB     R0,[R1, #+1]
// 1729       BlackLeftRealW[1] = ImgNew[row][col];
        LDR.N    R0,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R0,[R7, R0]
        LDR.W    R1,??DataTable14_2
        STRB     R0,[R1, #+1]
// 1730       BlackLeftRealB[1] = ImgNew[row][col-1-BlackLeftEdgeNum];
        LDR.N    R0,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R0,R7,R0
        LDRB     R0,[R0, #-4]
        LDR.W    R1,??DataTable14_3
        STRB     R0,[R1, #+1]
// 1731     }
// 1732     else
// 1733     {
// 1734     }
// 1735   }
// 1736   else
// 1737   {
// 1738   }
// 1739   
// 1740   return 1;
??BlackGetLeftStep1Edge_37:
        MOVS     R0,#+1
??BlackGetLeftStep1Edge_27:
        POP      {R1,R4-R9,PC}    ;; return
// 1741   
// 1742 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable8:
        DC32     BlackLeftBigChangeNumx

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable8_1:
        DC32     BlackLeftBigChangeSlopeStore

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable8_2:
        DC32     BlackLeft5Slope

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable8_3:
        DC32     BlackLeft5SlopeIndex

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable8_4:
        DC32     BlackLeft5SlopeRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable8_5:
        DC32     BlackLeftBigChangeFlag
// 1743 
// 1744 
// 1745 
// 1746 //======================================================================
// 1747 //函数名：BlackGetLeftStep2Win
// 1748 //功  能：左黑线提取中，第2阶段窗口内跳变检测函数
// 1749 //参  数：待处理行号row, 窗口大小win, 预测的跳变点的位置predict, 第几次使用use
// 1750 //返  回：1成功  0失败
// 1751 //影  响：BlackLeftLoc[][0]
// 1752 //说  明：1. 满足两批条件，才能检测成功。只有一个点的记录。
// 1753 //        2. 窗口内没有检测到，则检测失败。
// 1754 //        3. 窗缩小可以减少一定的时间，但如果遇到斜率过大的情况，就有可能检测不到。     
// 1755 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1756 uint8 BlackGetLeftStep2Win(uint8 row, uint8 win, uint8 predict, uint8 use)
// 1757 {
BlackGetLeftStep2Win:
        PUSH     {R3-R7,LR}
        MOVS     R4,R0
        MOVS     R5,R3
// 1758   uint8 col, temp;
// 1759   
// 1760   //在规划好的窗口内，从右往左查找跳变沿
// 1761   //防止溢出
// 1762   
// 1763   //对左边界的限制
// 1764   if(predict <= win)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R1,R2
        BCC.N    ??BlackGetLeftStep2Win_0
// 1765   {
// 1766     temp = 4 + BlackLeftEdgeNum;
        MOVS     R6,#+7
        B.N      ??BlackGetLeftStep2Win_1
// 1767   }  
// 1768   else
// 1769   {
// 1770     temp = predict - win;
??BlackGetLeftStep2Win_0:
        SUBS     R6,R2,R1
// 1771     if(temp < 4 + BlackLeftEdgeNum)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+7
        BGE.N    ??BlackGetLeftStep2Win_1
// 1772     {
// 1773       temp = 4 + BlackLeftEdgeNum;
        MOVS     R6,#+7
// 1774     }
// 1775     else 
// 1776     {
// 1777     } 
// 1778   }
// 1779   
// 1780   //对右边界的限制
// 1781   if(predict + win > CameraRealWidth - 1)
??BlackGetLeftStep2Win_1:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTAB    R0,R1,R2
        CMP      R0,#+250
        BLT.N    ??BlackGetLeftStep2Win_2
// 1782   {
// 1783     col = CameraRealWidth - 1;  
        MOVS     R7,#+249
        B.N      ??BlackGetLeftStep2Win_3
// 1784   }
// 1785   else
// 1786   {
// 1787     col = predict + win;  
??BlackGetLeftStep2Win_2:
        ADDS     R7,R1,R2
// 1788   }
// 1789   
// 1790   //右线开始扫描时，左线的扫描右边界必须在该行有效右黑线的左边。
// 1791   if((BlackGetPreDir == 1)
// 1792   &&(SingleBlackAllFlag == 0)   
// 1793   &&(BlackRightLoc[row][0] != MaxValUint8)
// 1794     )
??BlackGetLeftStep2Win_3:
        LDR.W    R0,??DataTable10_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackGetLeftStep2Win_4
        LDR.W    R0,??DataTable13_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??BlackGetLeftStep2Win_4
        LDR.W    R0,??DataTable10_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??BlackGetLeftStep2Win_4
// 1795   {
// 1796     col = MinRe(col, BlackRightLoc[row][0]);
        LDR.W    R0,??DataTable10_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R1,[R0, #+0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R0,R7
        BL       MinRe
        MOVS     R7,R0
// 1797   }
// 1798   else
// 1799   {
// 1800   }
// 1801   
// 1802   //窗口预测值记录
// 1803   BlackLeftPredictL[row] = temp;
??BlackGetLeftStep2Win_4:
        LDR.W    R0,??DataTable11
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R6,[R4, R0]
// 1804   BlackLeftPredictR[row] = col;
        LDR.W    R0,??DataTable11_1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R7,[R4, R0]
// 1805   
// 1806   //右边界小于左边界，返回失败
// 1807   if(col <= temp) return 0;
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R6,R7
        BCC.N    ??BlackGetLeftStep2Win_5
        MOVS     R0,#+0
        B.N      ??BlackGetLeftStep2Win_6
// 1808   
// 1809   //开窗扫描跳变沿
// 1810   col = BlackGetLeftJustWin(row, temp, col);
??BlackGetLeftStep2Win_5:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R2,R7
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MOVS     R1,R6
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetLeftJustWin
        MOVS     R7,R0
// 1811   if(col != MaxValUint8)
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+255
        BEQ.W    ??BlackGetLeftStep2Win_7
// 1812   {
// 1813     //两批条件均满足，直接记录该点为黑线，返回即可
// 1814     BlackLeftLoc[row][0] = col - 1 - BlackLeftEdgeNum;
        SUBS     R0,R7,#+4
        LDR.W    R1,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 1815 
// 1816     //最后确认前，需要进行大斜率的检测。若不成功，则说明检测到坏点。
// 1817     if(BlackLeftBigChangeCheck(row, use) == 0)
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackLeftBigChangeCheck
        CMP      R0,#+0
        BNE.N    ??BlackGetLeftStep2Win_8
// 1818     {              
// 1819       //没通过大斜率检测。
// 1820       BlackLeftBigChangeCheckRow[row] = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable14_4
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R0,[R4, R1]
// 1821       BlackLeftBigChangeCheckAllRow = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable14_5
        STRB     R0,[R1, #+0]
// 1822    
// 1823       
// 1824       //该行定位黑线失败，赋无效值
// 1825       BlackLeftLoc[row][0] = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 1826       return 0;
        MOVS     R0,#+0
        B.N      ??BlackGetLeftStep2Win_6
// 1827     }
// 1828     else
// 1829     {
// 1830     }
// 1831     
// 1832     //通过了大斜率检测。
// 1833     //记录3个关键值的实际信息，作为后面的参考。
// 1834     if(use == 1)
??BlackGetLeftStep2Win_8:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+1
        BNE.N    ??BlackGetLeftStep2Win_9
// 1835     {
// 1836       BlackLeftRealWB[0] = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum]; 
        LDR.N    R0,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R0,[R7, R0]
        LDR.N    R1,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R1,R7,R1
        LDRB     R1,[R1, #-4]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable14_1
        STRB     R0,[R1, #+0]
// 1837       BlackLeftRealW[0] = ImgNew[row][col];
        LDR.N    R0,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R0,[R7, R0]
        LDR.W    R1,??DataTable14_2
        STRB     R0,[R1, #+0]
// 1838       BlackLeftRealB[0] = ImgNew[row][col-1-BlackLeftEdgeNum];
        LDR.N    R0,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R0,R7,R0
        LDRB     R0,[R0, #-4]
        LDR.W    R1,??DataTable14_3
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetLeftStep2Win_10
// 1839     }
// 1840     else if(use == 2)
??BlackGetLeftStep2Win_9:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+2
        BNE.N    ??BlackGetLeftStep2Win_10
// 1841     {
// 1842       BlackLeftRealWB[1] = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum]; 
        LDR.N    R0,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R0,[R7, R0]
        LDR.N    R1,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R1,R7,R1
        LDRB     R1,[R1, #-4]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable14_1
        STRB     R0,[R1, #+1]
// 1843       BlackLeftRealW[1] = ImgNew[row][col];
        LDR.N    R0,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R0,[R7, R0]
        LDR.W    R1,??DataTable14_2
        STRB     R0,[R1, #+1]
// 1844       BlackLeftRealB[1] = ImgNew[row][col-1-BlackLeftEdgeNum];
        LDR.N    R0,??DataTable9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R0,R7,R0
        LDRB     R0,[R0, #-4]
        LDR.W    R1,??DataTable14_3
        STRB     R0,[R1, #+1]
// 1845     }
// 1846     else
// 1847     {
// 1848     }     
// 1849     
// 1850     return 1;                  
??BlackGetLeftStep2Win_10:
        MOVS     R0,#+1
        B.N      ??BlackGetLeftStep2Win_6
// 1851   }
// 1852   else
// 1853   {
// 1854     //窗口内没有扫描到跳变沿，该行的黑线位置记为无效值，返回0失败.
// 1855     BlackLeftLoc[row][0] = MaxValUint8;
??BlackGetLeftStep2Win_7:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 1856     return 0;   
        MOVS     R0,#+0
??BlackGetLeftStep2Win_6:
        POP      {R1,R4-R7,PC}    ;; return
// 1857   }
// 1858   
// 1859 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable9:
        DC32     ImgNew

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable9_1:
        DC32     LimitLeftWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable9_2:
        DC32     LimitLeftWBAdjust
// 1860 
// 1861 
// 1862 //======================================================================
// 1863 //函数名：BlackGetLeftStep1Scan
// 1864 //功  能：左黑线提取中，第1阶段的行扫描函数
// 1865 //参  数：扫描起始行FirstLine, 扫描结束行LastLine
// 1866 //返  回：0~CameraHight-1行数 255采集失败
// 1867 //影  响：BlackLeftRealWB[], BlackLeftRealW[], BlackLeftRealB[], BlackLeftLoc[][],
// 1868 //        LimitLeftWB, LimitLeftW, LimitLeftB
// 1869 //说  明：1. 可用于正常地第1阶段行扫描，也可用于十字再检测时的行扫描
// 1870 //        2. 正常第1阶段扫描时，会更改3个关键阈值的值。
// 1871 //             
// 1872 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1873 uint8 BlackGetLeftStep1Scan(uint8 FirstLine, uint8 LastLine, uint8 CrossFlag)
// 1874 {
BlackGetLeftStep1Scan:
        PUSH     {R3-R9,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
// 1875     uint8 row, temp1, temp2;
// 1876     uint8 abs1;
// 1877     uint8 tempWB, tempW, tempB;
// 1878     uint8 flag, i;
// 1879     
// 1880     flag = 0;
        MOVS     R7,#+0
// 1881     //最近的BlackStep1Size行用差值法找黑线
// 1882     for(row = FirstLine; row > LastLine; row -= 2)
        MOV      R8,R4
        B.N      ??BlackGetLeftStep1Scan_0
// 1883     {
// 1884       //判断是否连续两行检测到跳变，可疑黑点有3个点，暂取其中一个。非黑线预处理。
// 1885       temp1 = BlackGetLeftStep1Edge(row, 1, 0);
// 1886       temp2 = BlackGetLeftStep1Edge(row-1, 2, 0);
// 1887       if(temp1 == 1 && temp2 == 1)//这里可以这么写，不用嵌套if，因为&&的特点
// 1888       {
// 1889         abs1 = AbsRe(BlackLeftLoc[row-1][0], BlackLeftLoc[row][0]);
// 1890         //进一步判断连续两行的黑点的间隔是否够小，且暂取第1个可疑黑点。
// 1891         if(abs1 < BlackLeftStep1ScanMinus)
// 1892         {
// 1893           //检测到了连续的黑线，停止差值法找跳变沿，节省时间，下面进入第2阶段
// 1894           //如果不是十字再检测的情况，就更新一下实际的3个关键值，否则不更新。
// 1895           if(CrossFlag == 1)
// 1896             {
// 1897               //差值的处理，留有裕度，且有上下界。
// 1898               tempWB = (BlackLeftRealWB[0] + BlackLeftRealWB[1]) / 2 - LimitLeftWBMargin; 
// 1899               if(tempWB < LimitLeftWBMin) tempWB = LimitLeftWBMin;
// 1900               else if(tempWB > LimitLeftWBMax) tempWB = LimitLeftWBMax;
// 1901               else ;
// 1902               LimitLeftWB = tempWB;
// 1903               
// 1904               //白点的处理，留有裕度，且有上下界。
// 1905               tempW = (BlackLeftRealW[0] + BlackLeftRealW[1]) / 2 - LimitLeftWMargin;
// 1906               if(tempW < LimitLeftWMin) tempW = LimitLeftWMin;
// 1907               else if(tempW > LimitLeftWMax) tempW = LimitLeftWMax;
// 1908               else ;
// 1909               LimitLeftW = tempW;
// 1910               
// 1911               //黑点的处理，留有裕度，且有上下界。
// 1912               tempB = (BlackLeftRealB[0] + BlackLeftRealB[1]) / 2 + LimitLeftBMargin;
// 1913               if(tempB < LimitLeftBMin) tempB = LimitLeftBMin;
// 1914               else if(tempB > LimitLeftBMax) tempB = LimitLeftBMax;
// 1915               else ;
// 1916               //黑色阈值不能超过白色
// 1917               if(tempB >= LimitLeftW)
// 1918               {
// 1919                 tempB = LimitLeftW - 1;
// 1920               }
// 1921               else
// 1922               {
// 1923               }
// 1924               
// 1925               LimitLeftB = tempB;
// 1926             }
// 1927           break;
// 1928         }
// 1929         else
// 1930         {
// 1931           //连续两行黑点差别太大，视为错误的点。
// 1932           BlackLeftLoc[row][0] = MaxValUint8;
// 1933           BlackLeftLoc[row-1][0] = MaxValUint8;
// 1934           //大跳变检测数组的复位。
// 1935           BlackLeftBigChangeNumx[3] = MaxValUint8;
// 1936           BlackLeftBigChangeNumx[4] = MaxValUint8;
// 1937           BlackLeftBigChangeNumy[3] = MaxValUint8;
// 1938           BlackLeftBigChangeNumy[4] = MaxValUint8;
// 1939           BlackLeftBigChangeJumpFlag = 0;
// 1940         }
// 1941       }
// 1942       else if(temp1 == 0 && temp2 == 1)
// 1943       {
// 1944         //走到这里，说明双黑线检测成功之前有双线之一采集成功。
// 1945         flag = 1;
// 1946       }
// 1947       else if(temp1 == 1 && temp2 == 0)
??BlackGetLeftStep1Scan_1:
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+1
        BNE.N    ??BlackGetLeftStep1Scan_2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackGetLeftStep1Scan_2
// 1948       {
// 1949         //走到这里，说明双黑线检测成功之前有双线之一采集成功。
// 1950         flag = 1;
        MOVS     R7,#+1
// 1951       }
??BlackGetLeftStep1Scan_2:
        SUBS     R8,R8,#+2
??BlackGetLeftStep1Scan_0:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R5,R8
        BCS.W    ??BlackGetLeftStep1Scan_3
        MOVS     R2,#+0
        MOVS     R1,#+1
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetLeftStep1Edge
        MOV      R9,R0
        MOVS     R2,#+0
        MOVS     R1,#+2
        SUBS     R0,R8,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetLeftStep1Edge
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+1
        BNE.W    ??BlackGetLeftStep1Scan_4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.W    ??BlackGetLeftStep1Scan_4
        LDR.W    R0,??DataTable13
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R1,[R0, #+0]
        LDR.W    R0,??DataTable13
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R2,#+3
        MLA      R0,R2,R8,R0
        LDRB     R0,[R0, #-3]
        BL       AbsRe
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+8
        BGE.N    ??BlackGetLeftStep1Scan_5
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+1
        BNE.N    ??BlackGetLeftStep1Scan_6
        LDR.W    R0,??DataTable14_1
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable14_1
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+20
        LDR.W    R1,??DataTable15
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackGetLeftStep1Scan_7
        LDR.W    R0,??DataTable15
        LDRB     R0,[R0, #+0]
        B.N      ??BlackGetLeftStep1Scan_8
??BlackGetLeftStep1Scan_7:
        LDR.W    R1,??DataTable15_1
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackGetLeftStep1Scan_8
        LDR.W    R0,??DataTable15_1
        LDRB     R0,[R0, #+0]
??BlackGetLeftStep1Scan_8:
        LDR.W    R1,??DataTable15_2
        STRB     R0,[R1, #+0]
        LDR.W    R0,??DataTable14_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable14_2
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+40
        LDR.W    R1,??DataTable15_3
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackGetLeftStep1Scan_9
        LDR.W    R0,??DataTable15_3
        LDRB     R0,[R0, #+0]
        B.N      ??BlackGetLeftStep1Scan_10
??BlackGetLeftStep1Scan_9:
        LDR.W    R1,??DataTable15_4
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackGetLeftStep1Scan_10
        LDR.W    R0,??DataTable15_4
        LDRB     R0,[R0, #+0]
??BlackGetLeftStep1Scan_10:
        LDR.N    R1,??DataTable11_2
        STRB     R0,[R1, #+0]
        LDR.W    R0,??DataTable14_3
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable14_3
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        ADDS     R0,R0,#+35
        LDR.W    R1,??DataTable15_5
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackGetLeftStep1Scan_11
        LDR.W    R0,??DataTable15_5
        LDRB     R0,[R0, #+0]
        B.N      ??BlackGetLeftStep1Scan_12
??BlackGetLeftStep1Scan_11:
        LDR.W    R1,??DataTable15_6
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackGetLeftStep1Scan_12
        LDR.W    R0,??DataTable15_6
        LDRB     R0,[R0, #+0]
??BlackGetLeftStep1Scan_12:
        LDR.N    R1,??DataTable11_2
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCC.N    ??BlackGetLeftStep1Scan_13
        LDR.N    R0,??DataTable11_2
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
??BlackGetLeftStep1Scan_13:
        LDR.N    R1,??DataTable11_3
        STRB     R0,[R1, #+0]
// 1952       else
// 1953       {
// 1954       }
// 1955     }   
// 1956     
// 1957     //检测了BlackStep1Size行也没有检测到连续的黑线，说明黑线检测失败
// 1958     if(row <= LastLine)
??BlackGetLeftStep1Scan_6:
??BlackGetLeftStep1Scan_3:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R5,R8
        BCC.N    ??BlackGetLeftStep1Scan_14
// 1959     {
// 1960       return MaxValUint8;
        MOVS     R0,#+255
        B.N      ??BlackGetLeftStep1Scan_15
// 1961     }               
??BlackGetLeftStep1Scan_5:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable13
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R8,R1
        STRB     R0,[R1, #+0]
        MOVS     R0,#+255
        LDR.W    R1,??DataTable13
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R8,R1
        STRB     R0,[R1, #-3]
        MOVS     R0,#+255
        LDR.W    R1,??DataTable13_4
        STRB     R0,[R1, #+3]
        MOVS     R0,#+255
        LDR.W    R1,??DataTable13_4
        STRB     R0,[R1, #+4]
        MOVS     R0,#+255
        LDR.W    R1,??DataTable13_2
        STRB     R0,[R1, #+3]
        MOVS     R0,#+255
        LDR.W    R1,??DataTable13_2
        STRB     R0,[R1, #+4]
        MOVS     R0,#+0
        LDR.W    R1,??DataTable13_3
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetLeftStep1Scan_2
??BlackGetLeftStep1Scan_4:
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+0
        BNE.W    ??BlackGetLeftStep1Scan_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.W    ??BlackGetLeftStep1Scan_1
        MOVS     R7,#+1
        B.N      ??BlackGetLeftStep1Scan_2
// 1962     else
// 1963     {
// 1964         //双黑线检测成功 且 双黑线检测成功之前有双线之一采集成功。
// 1965         if(flag == 1)
??BlackGetLeftStep1Scan_14:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+1
        BNE.N    ??BlackGetLeftStep1Scan_16
// 1966         {
// 1967             //把前面的双线之一都去掉。
// 1968             for(i = FirstLine; ; i--)
        B.N      ??BlackGetLeftStep1Scan_17
// 1969             {
// 1970                 if(i == row) break;
// 1971                 BlackLeftLoc[i][0] = MaxValUint8;                
??BlackGetLeftStep1Scan_18:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
        SUBS     R4,R4,#+1
??BlackGetLeftStep1Scan_17:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R4,R8
        BNE.N    ??BlackGetLeftStep1Scan_18
// 1972             }
// 1973             
// 1974             //第一次scan
// 1975             if(CrossFlag == 1)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+1
        BNE.N    ??BlackGetLeftStep1Scan_16
// 1976             {
// 1977               //把前3个大斜率检测储存值都去掉，后面2个不用，因为是对的。
// 1978               for(i = 0; i <= 2; i++)
        MOVS     R4,#+0
        B.N      ??BlackGetLeftStep1Scan_19
// 1979               {
// 1980                   BlackLeftBigChangeNumx[i] = MaxValUint8;
??BlackGetLeftStep1Scan_20:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable13_4
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R0,[R4, R1]
// 1981                   BlackLeftBigChangeNumy[i] = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable13_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R0,[R4, R1]
// 1982                   BlackLeftBigChangeJumpFlag = 0;   //小细节
        MOVS     R0,#+0
        LDR.W    R1,??DataTable13_3
        STRB     R0,[R1, #+0]
// 1983               }
        ADDS     R4,R4,#+1
??BlackGetLeftStep1Scan_19:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+3
        BLT.N    ??BlackGetLeftStep1Scan_20
// 1984             }
// 1985             else
// 1986             {
// 1987             }
// 1988         }
// 1989         else
// 1990         {
// 1991 
// 1992         }
// 1993         
// 1994         return row;
??BlackGetLeftStep1Scan_16:
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??BlackGetLeftStep1Scan_15:
        POP      {R1,R4-R9,PC}    ;; return
// 1995     }
// 1996   
// 1997 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10:
        DC32     BlackLeftEdgeStartCol

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10_1:
        DC32     BlackGetPreDir

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10_2:
        DC32     BlackRightLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10_3:
        DC32     SingleBlackLastAllFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable10_4:
        DC32     SingleBlackWidthMax
// 1998 
// 1999 //======================================================================
// 2000 //函数名：BlackLeftCrossStep3
// 2001 //功  能：左线提取中，十字检测第3阶段，脑补线函数
// 2002 //参  数：第1段有效黑线的最后一行FirstLine， 第2段有效黑线的第一行LastLine
// 2003 //返  回：1成功 0失败
// 2004 //影  响：BlackLeftLoc[][0]
// 2005 //说  明：1. 这里有一些浮点运算，会占时间，在调用本函数时要慎重，尽量不要用。
// 2006 //        2. 这里的两点间连线的思路很不错，float强转和uint8强转用得很好。
// 2007 //             
// 2008 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2009 uint8 BlackLeftCrossStep3(uint8 FirstLine, uint8 LastLine)
// 2010 {
BlackLeftCrossStep3:
        PUSH     {R4-R7}
// 2011   int32 delta_x, delta_y, delta, index;
// 2012   uint8 row, temp1, temp2;
// 2013   uint8 i;
// 2014   //uint8 temp3, temp4, flag1, flag2;
// 2015   
// 2016   //超始行比结束行还高，报错！
// 2017   if(LastLine >= FirstLine)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCC.N    ??BlackLeftCrossStep3_0
// 2018   {
// 2019     //uart_sendN(UART0, (uint8 *)"\nError In BlackLeftCrossStep3!", 30);
// 2020     return 0;  
        MOVS     R0,#+0
        B.N      ??BlackLeftCrossStep3_1
// 2021   }
// 2022   
// 2023   //有可能出现被大斜率检测删掉的情况，这种情况下该行黑线判断为错误，就不进行十字补线了。
// 2024   if(BlackLeftLoc[LastLine][0] == MaxValUint8)
??BlackLeftCrossStep3_0:
        LDR.W    R2,??DataTable13
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BNE.N    ??BlackLeftCrossStep3_2
// 2025   {
// 2026     //返回失败前扫屁股
// 2027     for(i = FirstLine - 1; ; i--)
        SUBS     R0,R0,#+1
        B.N      ??BlackLeftCrossStep3_3
??BlackLeftCrossStep3_4:
        SUBS     R0,R0,#+1
// 2028     {
// 2029       BlackLeftLoc[i][0] = MaxValUint8;
??BlackLeftCrossStep3_3:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable13
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 2030       if(i == 0) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackLeftCrossStep3_4
// 2031     }
// 2032     
// 2033     return 0;
        MOVS     R0,#+0
        B.N      ??BlackLeftCrossStep3_1
// 2034   }
// 2035   else
// 2036   {
// 2037   }
// 2038   
// 2039   temp1 = BlackLeftLoc[FirstLine][0];
??BlackLeftCrossStep3_2:
        LDR.W    R2,??DataTable13
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R4,[R2, #+0]
// 2040   temp2 = BlackLeftLoc[LastLine][0];
        LDR.W    R2,??DataTable13
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
// 2041   
// 2042   /*
// 2043   flag = 1;
// 2044   flag = 2;
// 2045   //确认这两个点是直角处的点，也就是往左6个点仍为黑点
// 2046   if(temp1 <= (CameraRealWidth - 9))
// 2047   {
// 2048     temp3 = (
// 2049             (ImgNew[FirstLine+1][temp1+6] < LimitLeftB)
// 2050           &&(ImgNew[FirstLine+1][temp1+7] < LimitLeftB)
// 2051           &&(ImgNew[FirstLine+1][temp1+8] < LimitLeftB)
// 2052           );
// 2053     if(temp3)
// 2054     {
// 2055       flag1 = 0;  
// 2056     }
// 2057   }
// 2058   
// 2059   if(temp2 <= (CameraRealWidth - 9))
// 2060   {
// 2061     temp4 = (
// 2062             (ImgNew[LastLine-1][temp2+6] < LimitLeftB)
// 2063           &&(ImgNew[LastLine-1][temp2+7] < LimitLeftB)
// 2064           &&(ImgNew[LastLine-1][temp2+8] < LimitLeftB)
// 2065           );
// 2066     if(temp4)
// 2067     {
// 2068       flag2 = 0;  
// 2069     }
// 2070   }
// 2071   
// 2072   if((flag1 == 0) || (flag2 == 0))
// 2073   {
// 2074     return 0;  
// 2075   }
// 2076   
// 2077   */
// 2078   
// 2079   delta_y = FirstLine - LastLine;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        SUBS     R3,R0,R1
// 2080   
// 2081   
// 2082   //斜率向右
// 2083   if(temp1 < temp2)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R4,R2
        BCS.N    ??BlackLeftCrossStep3_5
// 2084   {
// 2085     //放大BlackLeftCrossStep3Multi倍。
// 2086     delta_x = temp2 - temp1;  
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        SUBS     R2,R2,R4
// 2087     delta = delta_x * BlackLeftCrossStep3Multi / delta_y; 
        MOV      R4,#+1000
        MULS     R2,R4,R2
        SDIV     R3,R2,R3
// 2088     
// 2089     index = 1;
        MOVS     R4,#+1
// 2090     for(row = FirstLine - 1; row >= LastLine + 1; row-- )
        SUBS     R2,R0,#+1
??BlackLeftCrossStep3_6:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADDS     R5,R1,#+1
        CMP      R2,R5
        BLT.N    ??BlackLeftCrossStep3_7
// 2091     {
// 2092       //每次右移一点点
// 2093       BlackLeftLoc[row][0] = (uint8)(BlackLeftLoc[FirstLine][0] + delta * index / BlackLeftCrossStep3Multi);
        LDR.W    R5,??DataTable13
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R0,R5
        LDRB     R5,[R5, #+0]
        MUL      R6,R4,R3
        MOV      R7,#+1000
        SDIV     R6,R6,R7
        ADDS     R5,R6,R5
        LDR.W    R6,??DataTable13
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R7,#+3
        MLA      R6,R7,R2,R6
        STRB     R5,[R6, #+0]
// 2094       index += 1;
        ADDS     R4,R4,#+1
// 2095     }
        SUBS     R2,R2,#+1
        B.N      ??BlackLeftCrossStep3_6
// 2096   }
// 2097   //斜率向左
// 2098   else if(temp1 > temp2)
??BlackLeftCrossStep3_5:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R2,R4
        BCS.N    ??BlackLeftCrossStep3_8
// 2099   {
// 2100     //放大BlackLeftCrossStep3Multi倍。
// 2101     delta_x = temp1 - temp2;
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        SUBS     R2,R4,R2
// 2102     delta = delta_x * BlackLeftCrossStep3Multi / delta_y;
        MOV      R4,#+1000
        MULS     R2,R4,R2
        SDIV     R3,R2,R3
// 2103     
// 2104     index = 1;
        MOVS     R4,#+1
// 2105     for(row = FirstLine - 1; row >= LastLine + 1; row-- )
        SUBS     R2,R0,#+1
??BlackLeftCrossStep3_9:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADDS     R5,R1,#+1
        CMP      R2,R5
        BLT.N    ??BlackLeftCrossStep3_7
// 2106     {
// 2107       //每次右移一点点
// 2108       BlackLeftLoc[row][0] = (uint8)(BlackLeftLoc[FirstLine][0] - delta * index / BlackLeftCrossStep3Multi);
        LDR.N    R5,??DataTable13
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R0,R5
        LDRB     R5,[R5, #+0]
        MUL      R6,R4,R3
        MOV      R7,#+1000
        SDIV     R6,R6,R7
        SUBS     R5,R5,R6
        LDR.N    R6,??DataTable13
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R7,#+3
        MLA      R6,R7,R2,R6
        STRB     R5,[R6, #+0]
// 2109       index += 1;
        ADDS     R4,R4,#+1
// 2110     }
        SUBS     R2,R2,#+1
        B.N      ??BlackLeftCrossStep3_9
// 2111   }
// 2112   //斜率直走，这个不太可能出现
// 2113   else
// 2114   {
// 2115     for(row = FirstLine - 1; row >= LastLine + 1; row-- )
??BlackLeftCrossStep3_8:
        SUBS     R2,R0,#+1
        B.N      ??BlackLeftCrossStep3_10
// 2116     {
// 2117       //赋相同的值
// 2118       BlackLeftLoc[row][0] = temp1;
??BlackLeftCrossStep3_11:
        LDR.N    R0,??DataTable13
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R3,#+3
        MLA      R0,R3,R2,R0
        STRB     R4,[R0, #+0]
// 2119     }
        SUBS     R2,R2,#+1
??BlackLeftCrossStep3_10:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADDS     R0,R1,#+1
        CMP      R2,R0
        BGE.N    ??BlackLeftCrossStep3_11
// 2120   }
// 2121   
// 2122   return 1;
??BlackLeftCrossStep3_7:
        MOVS     R0,#+1
??BlackLeftCrossStep3_1:
        POP      {R4-R7}
        BX       LR               ;; return
// 2123     
// 2124 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable11:
        DC32     BlackLeftPredictL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable11_1:
        DC32     BlackLeftPredictR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable11_2:
        DC32     LimitLeftW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable11_3:
        DC32     LimitLeftB
// 2125 
// 2126 //======================================================================
// 2127 //函数名：BlackLeftCrossConfirm
// 2128 //功  能：十字再检测时 ，线头有效性的确认。
// 2129 //参  数：第1段黑线的真实结束行Row1RealLastLine，第2段黑线的真实起始行Row2RealFirstLine
// 2130 //返  回：1成功 0失败
// 2131 //影  响：无
// 2132 //说  明：1. 为了应对270度弯道十字误检测而诞生，编写过程中没有过多考虑其它情况。
// 2133 //      
// 2134 //             
// 2135 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2136 uint8 BlackLeftCrossConfirm(uint8 Row1RealLastLine, uint8 Row2RealFirstLine)
// 2137 {
BlackLeftCrossConfirm:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+12
        MOVS     R4,R1
// 2138   uint8 row, index;
// 2139   uint8 x[BlackCrossConfirmNum];
// 2140   uint8 y[BlackCrossConfirmNum];
// 2141   
// 2142   int32 a0, a1, temp;
// 2143 
// 2144   //1. 先进行第二段黑线起始点方向判定，若不满足左十字该有方向，则判定为错误点。直接返回0.
// 2145   if(BlackLeftLoc[Row2RealFirstLine][0] > BlackLeftLoc[Row2RealFirstLine-1][0]) 
        LDR.N    R1,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #-3]
        LDR.N    R2,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R4,R2
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BCS.N    ??BlackLeftCrossConfirm_0
// 2146   {
// 2147     return 0;
        MOVS     R0,#+0
        B.N      ??BlackLeftCrossConfirm_1
// 2148   }
// 2149   //2. 再进行第二段黑线起始两点的斜率判定，也就是对两点的列差作限定，太大则有可能是大弯回弯。针对回弯十字误补。
// 2150   else if((BlackLeftLoc[Row2RealFirstLine][0] < BlackLeftLoc[Row2RealFirstLine-1][0])
// 2151    &&(BlackLeftLoc[Row2RealFirstLine-1][0] - BlackLeftLoc[Row2RealFirstLine][0] >= 3)
// 2152      )
??BlackLeftCrossConfirm_0:
        LDR.N    R1,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        LDR.N    R2,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R4,R2
        LDRB     R2,[R2, #-3]
        CMP      R1,R2
        BCS.N    ??BlackLeftCrossConfirm_2
        LDR.N    R1,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #-3]
        LDR.N    R2,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R4,R2
        LDRB     R2,[R2, #+0]
        SUBS     R1,R1,R2
        CMP      R1,#+3
        BLT.N    ??BlackLeftCrossConfirm_2
// 2153   {
// 2154     return 0;
        MOVS     R0,#+0
        B.N      ??BlackLeftCrossConfirm_1
// 2155   }
// 2156   //3. 再对上一幅图的右线斜率和右线头进行检查。这里的右线斜率与右线头因为还没更新，所以是上一幅图的。针对回弯十字误补。
// 2157   else if((SlopeR > BlackCrossConfirmSlopeLimit) //上一幅图的右线斜率很大。
// 2158    &&(BlackRightHeadLine < BlackCrossConfirmHeadLineLimit) //上一幅图的右线线头比较高。（防止因为线特别短而造成的斜率不准确）
// 2159      )
??BlackLeftCrossConfirm_2:
        LDR.W    R1,??DataTable16
        LDR      R1,[R1, #+0]
        MOVW     R2,#+3001
        CMP      R1,R2
        BLT.N    ??BlackLeftCrossConfirm_3
        LDR.W    R1,??DataTable16_1
        LDRB     R1,[R1, #+0]
        CMP      R1,#+40
        BGE.N    ??BlackLeftCrossConfirm_3
// 2160   {
// 2161     return 0;
        MOVS     R0,#+0
        B.N      ??BlackLeftCrossConfirm_1
// 2162   }
// 2163   else
// 2164   {
// 2165   }
// 2166   
// 2167   //第一段黑线太短，无法检测正确性时，检查要补的行是不是够长，如果够长，就视为正确。
// 2168   //if(Row1RealLastLine >= CameraHight - 5 && Row2RealFirstLine > Row1RealLastLine + BlackLeftCrossConfirmGapLine) return 1;
// 2169   //if(Row1RealLastLine >= CameraHight - 5) return 0;
// 2170   
// 2171   //以左上角为原点，向下为x轴正方向（0~49），向右为y轴正方向(0~249)
// 2172   index = 0;
??BlackLeftCrossConfirm_3:
        MOVS     R1,#+0
// 2173   for(row = Row1RealLastLine; ; row++)
        B.N      ??BlackLeftCrossConfirm_4
??BlackLeftCrossConfirm_5:
        ADDS     R0,R0,#+1
// 2174   {
// 2175     //有效行的记录
// 2176     if(BlackLeftLoc[row][0] != MaxValUint8)
??BlackLeftCrossConfirm_4:
        LDR.N    R2,??DataTable13
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BEQ.N    ??BlackLeftCrossConfirm_6
// 2177     {
// 2178       y[index] = BlackLeftLoc[row][0];
        LDR.N    R2,??DataTable13
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        ADD      R3,SP,#+0
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R2,[R1, R3]
// 2179       x[index] = row;
        ADD      R2,SP,#+4
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R0,[R1, R2]
// 2180       index++;
        ADDS     R1,R1,#+1
// 2181     }
// 2182     //点数够多，则跳出。
// 2183     if(index == BlackCrossConfirmNum) break;
??BlackLeftCrossConfirm_6:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??BlackLeftCrossConfirm_7
// 2184     //直到最低行仍没有凑够足够的点数，说明第一段有效黑线太短，无法检测正确性，直接返回1.
// 2185     if(row == CameraHight - 1) 
// 2186     {
// 2187       if(index == 0) return 0;
// 2188       //判断第二段黑点起点是不是在第一段黑点末尾的右边一定范围内
// 2189       if(BlackLeftLoc[Row2RealFirstLine][0] > y[0] && BlackLeftLoc[Row2RealFirstLine][0] - y[0] < 50)
// 2190       {
// 2191         return 1;
// 2192       }
// 2193       else
// 2194       {
// 2195         return 0;
// 2196       }      
// 2197     }
// 2198     else
// 2199     {
// 2200     }
// 2201   }
// 2202   
// 2203   //最小二乘法
// 2204   //y = a0 + a1 * x
// 2205   a1 = LeastSquarea1(x, y, BlackCrossConfirmNum);
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
        BL       LeastSquarea1
        MOVS     R5,R0
// 2206   
// 2207   //判断斜率是不是从右下到左上，如果是，则返回失败。
// 2208   if(a1 > BlackLeftCrossConfirmSlopeLimit) return 0;
        MOVW     R0,#+1101
        CMP      R5,R0
        BLT.N    ??BlackLeftCrossConfirm_8
        MOVS     R0,#+0
        B.N      ??BlackLeftCrossConfirm_1
??BlackLeftCrossConfirm_7:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??BlackLeftCrossConfirm_5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??BlackLeftCrossConfirm_9
        MOVS     R0,#+0
        B.N      ??BlackLeftCrossConfirm_1
??BlackLeftCrossConfirm_9:
        LDRB     R0,[SP, #+0]
        LDR.N    R1,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCS.N    ??BlackLeftCrossConfirm_10
        LDR.N    R0,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        LDRB     R1,[SP, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+50
        BGE.N    ??BlackLeftCrossConfirm_10
        MOVS     R0,#+1
        B.N      ??BlackLeftCrossConfirm_1
??BlackLeftCrossConfirm_10:
        MOVS     R0,#+0
        B.N      ??BlackLeftCrossConfirm_1
// 2209   
// 2210   a0 = LeastSquarea0(x, y, a1, BlackCrossConfirmNum);
??BlackLeftCrossConfirm_8:
        MOVS     R3,#+4
        MOVS     R2,R5
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
        BL       LeastSquarea0
// 2211   
// 2212   //temp为第2段黑线起始行本应该在的位置。
// 2213   temp = (a0 + a1 * Row2RealFirstLine) / LeastSquareMulti;
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MLA      R0,R4,R5,R0
        MOV      R1,#+1000
        SDIV     R0,R0,R1
// 2214 
// 2215   //把这个点限定在窗内
// 2216   if(
// 2217     (BlackLeftLoc[Row2RealFirstLine][0] > temp - BlackCrossConfirmWin) 
// 2218   &&(BlackLeftLoc[Row2RealFirstLine][0] < temp + BlackCrossConfirmWin)  //向右的值太大的话，会在“下双上单”的时候出现十字误补线。
// 2219     )
        SUBS     R1,R0,#+40
        LDR.N    R2,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R4,R2
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BGE.N    ??BlackLeftCrossConfirm_11
        LDR.N    R1,??DataTable13
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,#+40
        CMP      R1,R0
        BGE.N    ??BlackLeftCrossConfirm_11
// 2220   {
// 2221     return 1;
        MOVS     R0,#+1
        B.N      ??BlackLeftCrossConfirm_1
// 2222   }
// 2223   else
// 2224   {
// 2225     return 0;
??BlackLeftCrossConfirm_11:
        MOVS     R0,#+0
??BlackLeftCrossConfirm_1:
        POP      {R1-R5,PC}       ;; return
// 2226   }
// 2227     
// 2228    
// 2229 }
// 2230 
// 2231 
// 2232 
// 2233 
// 2234 //======================================================================
// 2235 //函数名：BlackGetLeftCrossSpeWin
// 2236 //功  能：左黑线十字再检测时，窗口的特殊扫描
// 2237 //参  数：待处理行号row, 窗口左边界colleft, 窗口右边界colright, 第几次使用use.
// 2238 //返  回：1成功  0失败
// 2239 //影  响：BlackLeftLoc[][0]
// 2240 //说  明：1. 满足两批条件，才能检测成功。只有一个点的记录。
// 2241 //        2. 窗口内没有检测到，则检测失败。  
// 2242 //        3. 跟普通窗口扫描不一样，前者输入变量是预测值和窗口大小，后者是左右边界。
// 2243 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2244 uint8 BlackGetLeftCrossSpeWin(uint8 row, uint8 colleft, uint8 colright, uint8 use)
// 2245 {
BlackGetLeftCrossSpeWin:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
        MOVS     R6,R1
        MOVS     R0,R2
        MOVS     R5,R3
// 2246   uint8 col;
// 2247   
// 2248   //在规划好的窗口内，从右往左查找跳变沿
// 2249   //防止溢出
// 2250   
// 2251   //对左边界的限制
// 2252   if(colleft < 4 + BlackLeftEdgeNum)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+7
        BGE.N    ??BlackGetLeftCrossSpeWin_0
// 2253   {
// 2254     colleft = 4 + BlackLeftEdgeNum;
        MOVS     R6,#+7
// 2255   }
// 2256   else 
// 2257   {
// 2258   } 
// 2259 
// 2260   //对右边界的限制
// 2261   if(colright > CameraRealWidth - 1)
??BlackGetLeftCrossSpeWin_0:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+250
        BLT.N    ??BlackGetLeftCrossSpeWin_1
// 2262   {
// 2263     colright = CameraRealWidth - 1;  
        MOVS     R0,#+249
// 2264   }
// 2265   else
// 2266   {
// 2267   }
// 2268   
// 2269   //右线开始扫描时，左线扫描的右边界必须在该行有效右黑线的左边。
// 2270   if((BlackGetPreDir == 1)
// 2271    &&(BlackRightLoc[row][0] != MaxValUint8)
// 2272      )
??BlackGetLeftCrossSpeWin_1:
        LDR.W    R1,??DataTable16_2
        LDRB     R1,[R1, #+0]
        CMP      R1,#+1
        BNE.N    ??BlackGetLeftCrossSpeWin_2
        LDR.W    R1,??DataTable16_3
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BEQ.N    ??BlackGetLeftCrossSpeWin_2
// 2273   {
// 2274     colright = MinRe(colright, BlackRightLoc[row][0]);
        LDR.W    R1,??DataTable16_3
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       MinRe
// 2275   }
// 2276   else
// 2277   {
// 2278   }
// 2279   
// 2280   //窗口预测值记录
// 2281   BlackLeftPredictL[row] = colleft;
??BlackGetLeftCrossSpeWin_2:
        LDR.W    R1,??DataTable16_4
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R6,[R4, R1]
// 2282   BlackLeftPredictR[row] = colright;
        LDR.W    R1,??DataTable16_5
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R0,[R4, R1]
// 2283   
// 2284   //左边界在右边界右边，直接返回失败。
// 2285   if(colleft >= colright) return 0;
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R6,R0
        BCC.N    ??BlackGetLeftCrossSpeWin_3
        MOVS     R0,#+0
        B.N      ??BlackGetLeftCrossSpeWin_4
// 2286   
// 2287   //开窗扫描跳变沿
// 2288   col = BlackGetLeftJustWin(row, colleft, colright);
??BlackGetLeftCrossSpeWin_3:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,R0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MOVS     R1,R6
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetLeftJustWin
        MOVS     R6,R0
// 2289   if(col != MaxValUint8)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+255
        BEQ.W    ??BlackGetLeftCrossSpeWin_5
// 2290   {
// 2291     //两批条件均满足，直接记录该点为黑线，返回即可
// 2292     BlackLeftLoc[row][0] = col - 1 - BlackLeftEdgeNum;
        SUBS     R0,R6,#+4
        LDR.W    R1,??DataTable17
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 2293 
// 2294     //最后确认前，需要进行大斜率的检测。若不成功，则说明检测到坏点。
// 2295     if(BlackLeftBigChangeCheck(row, use) == 0)
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackLeftBigChangeCheck
        CMP      R0,#+0
        BNE.N    ??BlackGetLeftCrossSpeWin_6
// 2296     {              
// 2297       //没通过大斜率检测。
// 2298       BlackLeftBigChangeCheckRow[row] = 1;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable14_4
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R0,[R4, R1]
// 2299       BlackLeftBigChangeCheckAllRow = 1;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable14_5
        STRB     R0,[R1, #+0]
// 2300    
// 2301       
// 2302       //该行定位黑线失败，赋无效值
// 2303       BlackLeftLoc[row][0] = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable17
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 2304       return 0;
        MOVS     R0,#+0
        B.N      ??BlackGetLeftCrossSpeWin_4
// 2305     }
// 2306     else
// 2307     {
// 2308     }
// 2309     
// 2310     //通过了大斜率检测。
// 2311     //记录3个关键值的实际信息，作为后面的参考。
// 2312     if(use == 1)
??BlackGetLeftCrossSpeWin_6:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+1
        BNE.N    ??BlackGetLeftCrossSpeWin_7
// 2313     {
// 2314       BlackLeftRealWB[0] = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum]; 
        LDR.W    R0,??DataTable16_6
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRB     R0,[R6, R0]
        LDR.W    R1,??DataTable16_6
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #-4]
        SUBS     R0,R0,R1
        LDR.N    R1,??DataTable14_1
        STRB     R0,[R1, #+0]
// 2315       BlackLeftRealW[0] = ImgNew[row][col];
        LDR.W    R0,??DataTable16_6
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRB     R0,[R6, R0]
        LDR.N    R1,??DataTable14_2
        STRB     R0,[R1, #+0]
// 2316       BlackLeftRealB[0] = ImgNew[row][col-1-BlackLeftEdgeNum];
        LDR.W    R0,??DataTable16_6
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R0,R6,R0
        LDRB     R0,[R0, #-4]
        LDR.N    R1,??DataTable14_3
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetLeftCrossSpeWin_8
// 2317     }
// 2318     else if(use == 2)
??BlackGetLeftCrossSpeWin_7:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+2
        BNE.N    ??BlackGetLeftCrossSpeWin_8
// 2319     {
// 2320       BlackLeftRealWB[1] = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum]; 
        LDR.W    R0,??DataTable16_6
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRB     R0,[R6, R0]
        LDR.W    R1,??DataTable16_6
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #-4]
        SUBS     R0,R0,R1
        LDR.N    R1,??DataTable14_1
        STRB     R0,[R1, #+1]
// 2321       BlackLeftRealW[1] = ImgNew[row][col];
        LDR.W    R0,??DataTable16_6
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRB     R0,[R6, R0]
        LDR.N    R1,??DataTable14_2
        STRB     R0,[R1, #+1]
// 2322       BlackLeftRealB[1] = ImgNew[row][col-1-BlackLeftEdgeNum];
        LDR.W    R0,??DataTable16_6
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R0,R6,R0
        LDRB     R0,[R0, #-4]
        LDR.N    R1,??DataTable14_3
        STRB     R0,[R1, #+1]
// 2323     }
// 2324     else
// 2325     {
// 2326     }     
// 2327     
// 2328     return 1;   
??BlackGetLeftCrossSpeWin_8:
        MOVS     R0,#+1
        B.N      ??BlackGetLeftCrossSpeWin_4
// 2329   }
// 2330   else
// 2331   {
// 2332     //窗口内没有扫描到跳变沿，该行的黑线位置记为无效值，返回0失败.
// 2333     BlackLeftLoc[row][0] = MaxValUint8;
??BlackGetLeftCrossSpeWin_5:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable17
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 2334     return 0; 
        MOVS     R0,#+0
??BlackGetLeftCrossSpeWin_4:
        POP      {R4-R6,PC}       ;; return
// 2335   }
// 2336 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13:
        DC32     BlackLeftLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_1:
        DC32     SingleBlackAllFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_2:
        DC32     BlackLeftBigChangeNumy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_3:
        DC32     BlackLeftBigChangeJumpFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13_4:
        DC32     BlackLeftBigChangeNumx
// 2337 
// 2338 
// 2339 
// 2340 //======================================================================
// 2341 //函数名：BlackGetLeftCrossSpeScan
// 2342 //功  能：十字再检测时，线头的特殊扫描
// 2343 //参  数：第2段黑线的预测起始行Row2FirstLine， 第2段黑线的预测结束行Row2LastLine，
// 2344 //        最近一次的窗口预测值LastWinPredict
// 2345 //返  回：MaxValUint8失败，否则成功。
// 2346 //影  响：
// 2347 //说  明：
// 2348 //      
// 2349 //             
// 2350 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2351 uint8 BlackGetLeftCrossSpeScan(uint8 Row2FirstLine, uint8 Row2LastLine, uint8 LastWinPredict)
// 2352 {
BlackGetLeftCrossSpeScan:
        PUSH     {R4-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R0,R2
// 2353   uint8 row;
// 2354   uint8 temp1, temp2, temppredict, tempminus;
// 2355   uint8 colleft, colright;
// 2356   uint8 i;
// 2357   
// 2358   //最近一次的窗口预测值。
// 2359   temppredict = LastWinPredict;
// 2360   
// 2361   //colleft的确定
// 2362   //对于左黑线扫描，colleft表示之前所有有效黑线的最左点。
// 2363   //找第1个有效左黑线。
// 2364   for(i = Row2FirstLine+1; ; i++)
        ADDS     R1,R4,#+1
        B.N      ??BlackGetLeftCrossSpeScan_0
??BlackGetLeftCrossSpeScan_1:
        ADDS     R1,R1,#+1
// 2365   {
// 2366     if(BlackLeftLoc[i][0] != MaxValUint8)
??BlackGetLeftCrossSpeScan_0:
        LDR.W    R2,??DataTable17
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BEQ.N    ??BlackGetLeftCrossSpeScan_2
// 2367     {
// 2368       colleft = BlackLeftLoc[i][0];
        LDR.W    R2,??DataTable17
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R1,R3,R1,R2
        LDRB     R6,[R1, #+0]
// 2369       break;
// 2370     }
// 2371     else
// 2372     {
// 2373     }
// 2374     //若一直到最近一行仍没有有效左黑线，则返回失败。理论上不可能走到这里。
// 2375     if(i == CameraHight - 1) return MaxValUint8;
// 2376   }
// 2377   //暂时不用最左边的左黑线，也就相当于用最右边的左黑线。
// 2378 //  //找最左的有效左黑线。
// 2379 //  for( ; ; i++)
// 2380 //  {
// 2381 //    if(BlackLeftLoc[i][0] != MaxValUint8)
// 2382 //    {
// 2383 //      if(BlackLeftLoc[i][0] < colleft)
// 2384 //      {
// 2385 //        colleft = BlackLeftLoc[i][0];
// 2386 //      }
// 2387 //      else
// 2388 //      {
// 2389 //      }
// 2390 //    }
// 2391 //    else
// 2392 //    { 
// 2393 //    }
// 2394 //    
// 2395 //    if(i == CameraHight - 1) break;
// 2396 //  }
// 2397 
// 2398   //逐行开窗扫描左黑线。
// 2399   for(row = Row2FirstLine; ; row -= 2)
        B.N      ??BlackGetLeftCrossSpeScan_3
??BlackGetLeftCrossSpeScan_2:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+59
        BNE.N    ??BlackGetLeftCrossSpeScan_1
        MOVS     R0,#+255
        B.N      ??BlackGetLeftCrossSpeScan_4
??BlackGetLeftCrossSpeScan_5:
        SUBS     R4,R4,#+2
// 2400   {
// 2401     //colright的确定
// 2402     colright = BoundaryLimitRe(temppredict + BlackLeftWinVal * 2,
// 2403                                0,
// 2404                                CameraRealWidth - 1);        
??BlackGetLeftCrossSpeScan_3:
        MOVS     R2,#+249
        MOVS     R1,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R0,R0,#+30
        BL       BoundaryLimitRe
        MOV      R8,R0
// 2405     
// 2406     //为了防止窗口有错，所以最左边不得小于BlackLeftEdgeStartColOffset。
// 2407     colright = MaxRe(colright, CameraRealWidth / 2 - 1 + BlackLeftEdgeStartColOffset[row]);
        LDR.W    R0,??DataTable18
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R0,[R4, R0]
        ADDS     R1,R0,#+124
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOV      R0,R8
        BL       MaxRe
        MOV      R8,R0
// 2408     
// 2409     //连续2行检测黑点,特殊开窗扫描。
// 2410     temp1 = BlackGetLeftCrossSpeWin(row, colleft, colright, 1);
        MOVS     R3,#+1
        MOV      R2,R8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetLeftCrossSpeWin
        MOVS     R7,R0
// 2411     temp2 = BlackGetLeftCrossSpeWin(row-1, colleft, colright, 2);
        MOVS     R3,#+2
        MOV      R2,R8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        SUBS     R0,R4,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetLeftCrossSpeWin
// 2412     //连续2行开窗检测黑点成功，则线头检测成功。跳出。
// 2413     if(temp1 == 1 && temp2 == 1)
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+1
        BNE.N    ??BlackGetLeftCrossSpeScan_6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??BlackGetLeftCrossSpeScan_6
// 2414     {
// 2415       return row;
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??BlackGetLeftCrossSpeScan_4
// 2416     }
// 2417     //连续2行开窗检测黑线失败，则窗口预测点继续变化，继续开窗检测。
// 2418     else if(temp1 == 0 && temp2 == 0)
??BlackGetLeftCrossSpeScan_6:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BNE.N    ??BlackGetLeftCrossSpeScan_7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackGetLeftCrossSpeScan_7
// 2419     {
// 2420       //预测点按趋势走也要限幅。
// 2421       tempminus = BoundaryLimitRe(BlackLeftWinPredictStore2 + BlackLeftWinPredictStore2 - BlackLeftWinPredictStore1,
// 2422                                   0,
// 2423                                   CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable20
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable20
        LDRB     R3,[R3, #+0]
        ADDS     R0,R3,R0
        LDR.W    R3,??DataTable19
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
// 2424       //temp在这里表示窗口预测点位置。
// 2425       temppredict = tempminus;
// 2426       BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
        LDR.W    R1,??DataTable19
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable19_1
        STRB     R1,[R2, #+0]
// 2427       BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
        LDR.W    R1,??DataTable20
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable19
        STRB     R1,[R2, #+0]
// 2428       BlackLeftWinPredictStore2 = temppredict;      
        LDR.W    R1,??DataTable20
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetLeftCrossSpeScan_8
// 2429     }
// 2430     //其中一行开窗检测成功，则当作干扰点，窗口预测点继续变化，继续开窗检测。
// 2431     else
// 2432     {
// 2433       //当作干扰点滤掉。
// 2434       BlackLeftLoc[row][0] = MaxValUint8;
??BlackGetLeftCrossSpeScan_7:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable17
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 2435       BlackLeftLoc[row-1][0] = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable17
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #-3]
// 2436       
// 2437       //预测点按趋势走也要限幅。
// 2438       tempminus = BoundaryLimitRe(BlackLeftWinPredictStore2 + BlackLeftWinPredictStore2 - BlackLeftWinPredictStore1,
// 2439                                   0,
// 2440                                   CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable20
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable20
        LDRB     R3,[R3, #+0]
        ADDS     R0,R3,R0
        LDR.W    R3,??DataTable19
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
// 2441       //temp在这里表示窗口预测点位置。
// 2442       temppredict = tempminus;
// 2443       BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
        LDR.W    R1,??DataTable19
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable19_1
        STRB     R1,[R2, #+0]
// 2444       BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
        LDR.W    R1,??DataTable20
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable19
        STRB     R1,[R2, #+0]
// 2445       BlackLeftWinPredictStore2 = temppredict;        
        LDR.W    R1,??DataTable20
        STRB     R0,[R1, #+0]
// 2446     }
// 2447       
// 2448       
// 2449       
// 2450     //一直到第Row2LastLine行也没有连续2行检测成功，则返回失败。
// 2451     if(row == Row2LastLine) 
??BlackGetLeftCrossSpeScan_8:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R4,R5
        BNE.W    ??BlackGetLeftCrossSpeScan_5
// 2452     {
// 2453       return MaxValUint8;
        MOVS     R0,#+255
??BlackGetLeftCrossSpeScan_4:
        POP      {R4-R8,PC}       ;; return
// 2454     }
// 2455     else
// 2456     {
// 2457     }
// 2458   }
// 2459  
// 2460 
// 2461 
// 2462 
// 2463 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14:
        DC32     SingleBlackFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_1:
        DC32     BlackLeftRealWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_2:
        DC32     BlackLeftRealW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_3:
        DC32     BlackLeftRealB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_4:
        DC32     BlackLeftBigChangeCheckRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14_5:
        DC32     BlackLeftBigChangeCheckAllRow
// 2464 
// 2465 //======================================================================
// 2466 //函数名：BlackLeftAgainForCross
// 2467 //功  能：左黑线提取中，针对十字的再检测程序
// 2468 //参  数：第2段黑线的预测起始行Row2FirstLine， 第2段黑线的预测结束行Row2LastLine，
// 2469 //        第1段黑线的实际结束行Row1RealLastLine， 最近一次的窗口预测值LastWinPredict
// 2470 //返  回：1成功 0失败
// 2471 //影  响：BlackLeftLoc[][]。 （不会影响那几个阈值。）
// 2472 //说  明：1. 本函数会调用浮点运算的函数，预计花费较多时间，调用入口需谨慎。
// 2473 //        2. 本函数仅影响了BlackLeftLoc[][]，以后也应该保持。
// 2474 //             
// 2475 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2476 uint8 BlackLeftAgainForCross(uint8 Row2FirstLine, uint8 Row2LastLine, uint8 Row1RealLastLine, uint8 LastWinPredict)
// 2477 {
BlackLeftAgainForCross:
        PUSH     {R3-R9,LR}
        MOVS     R6,R0
        MOVS     R4,R1
        MOVS     R5,R2
// 2478     uint8 row, temp, temp1, temp2;
// 2479     uint8 Row2RealFirstLine; //第2段黑线的真实起始行
// 2480     uint8 i;
// 2481     
// 2482     uint8 tempWB, tempW, tempB;
// 2483     uint8 tempminus;
// 2484     
// 2485     //第1段黑线的真实结束行有可能因为大跳变被删掉，所以需要重新查找并更新。
// 2486     for(i = Row1RealLastLine; i <= CameraHight - 1; i++)
        MOVS     R0,R5
        B.N      ??BlackLeftAgainForCross_0
??BlackLeftAgainForCross_1:
        ADDS     R0,R0,#+1
??BlackLeftAgainForCross_0:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+60
        BGE.N    ??BlackLeftAgainForCross_2
// 2487     {
// 2488       if(BlackLeftLoc[i][0] != MaxValUint8)
        LDR.W    R1,??DataTable17
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BEQ.N    ??BlackLeftAgainForCross_1
// 2489       {
// 2490         Row1RealLastLine = i;
        MOVS     R5,R0
// 2491         break;
// 2492       }
// 2493       else
// 2494       {
// 2495       }
// 2496     }
// 2497     //由于直角黑块不允许检测十字再补线，所以当第1段黑线真实结束行的斜上方有黑块时，不允许补线。
// 2498     //取5列。
// 2499     for(i = 0; i <= 5; i++)
??BlackLeftAgainForCross_2:
        MOVS     R0,#+0
        B.N      ??BlackLeftAgainForCross_3
??BlackLeftAgainForCross_4:
        ADDS     R0,R0,#+1
??BlackLeftAgainForCross_3:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+6
        BGE.N    ??BlackLeftAgainForCross_5
// 2500     {
// 2501       if(ImgNew[Row1RealLastLine - 4][BlackLeftLoc[Row1RealLastLine][0] + 5 + i] < LimitLeftB) //往远4行。斜右上方。
        LDR.W    R1,??DataTable16_6
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R5,R1
        LDR.W    R2,??DataTable17
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R7,#+3
        MLA      R2,R7,R5,R2
        LDRB     R2,[R2, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R2,R0,R2
        ADDS     R1,R2,R1
        SUBW     R1,R1,#+995
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable19_2
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BCS.N    ??BlackLeftAgainForCross_6
// 2502       {
// 2503         return 0;
        MOVS     R0,#+0
        B.N      ??BlackLeftAgainForCross_7
// 2504       }
// 2505       else if(ImgNew[Row1RealLastLine - 5][BlackLeftLoc[Row1RealLastLine][0] + 5 + i] < LimitLeftB) //往远5行。斜右上方。
??BlackLeftAgainForCross_6:
        LDR.W    R1,??DataTable16_6
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R5,R1
        LDR.W    R2,??DataTable17
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R7,#+3
        MLA      R2,R7,R5,R2
        LDRB     R2,[R2, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R2,R0,R2
        ADDS     R1,R2,R1
        SUBW     R1,R1,#+1245
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable19_2
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BCS.N    ??BlackLeftAgainForCross_4
// 2506       {
// 2507         return 0;
        MOVS     R0,#+0
        B.N      ??BlackLeftAgainForCross_7
// 2508       }
// 2509       else
// 2510       {
// 2511       }      
// 2512     }
// 2513     
// 2514     //十字再检测第1阶段，找线头。
// 2515     //temp = BlackGetLeftStep1Scan(Row2FirstLine, Row2LastLine, 0); //第3个参数0表示是十字再检测，不用更新3个关键值
// 2516     
// 2517     //十字再检测第1阶段，找线头，不采用Scan的方式，采用Win的方式。
// 2518     temp = BlackGetLeftCrossSpeScan(Row2FirstLine, Row2LastLine, LastWinPredict);
??BlackLeftAgainForCross_5:
        MOVS     R2,R3
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,R4
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetLeftCrossSpeScan
        MOV      R8,R0
// 2519     
// 2520     //线头查找失败，或找到最远两行（继续执行后面会数组超出界限），就直接判定为失败。
// 2521     if(
// 2522       (temp == MaxValUint8)
// 2523     ||(temp <= 1)
// 2524     ||(BlackAgainForCrossFar10CutSwitch == 1 && temp <= 9)  //当远10行删除开关开启时，且十字再检测时的第2段黑线线头在最远的10行，则十字再检测失败。
// 2525       )
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+255
        BEQ.N    ??BlackLeftAgainForCross_8
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+2
        BLT.N    ??BlackLeftAgainForCross_8
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+10
        BGE.N    ??BlackLeftAgainForCross_9
// 2526     {
// 2527       //扫屁股工作。       //i >= Row2LastLine
// 2528       for(i = Row2FirstLine; ; i--)
??BlackLeftAgainForCross_8:
        MOVS     R0,R6
        B.N      ??BlackLeftAgainForCross_10
??BlackLeftAgainForCross_11:
        SUBS     R0,R0,#+1
// 2529       {
// 2530         BlackLeftLoc[i][0] = MaxValUint8;
??BlackLeftAgainForCross_10:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable17
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 2531         if(i == 0) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackLeftAgainForCross_11
// 2532       }
// 2533       return 0;  
        MOVS     R0,#+0
        B.N      ??BlackLeftAgainForCross_7
// 2534     }
// 2535     else 
// 2536     {
// 2537       ////////////////如果要注释，就从这里开始注释
// 2538       
// 2539       //十字再检测的线头不在限定的范围内，认为是干扰点，不用顺着线头找线了，直接退出。
// 2540       if(BlackLeftCrossConfirm(Row1RealLastLine+1, temp) == 0)
??BlackLeftAgainForCross_9:
        MOV      R1,R8
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADDS     R0,R5,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackLeftCrossConfirm
        CMP      R0,#+0
        BNE.N    ??BlackLeftAgainForCross_12
// 2541       { //扫屁股工作。       //i >= (temp-1)
// 2542         BlackLeftCrossConfirmFlag = 1;  //左十字线头标志确认失败，超出预想范围。
        MOVS     R0,#+1
        LDR.W    R1,??DataTable20_1
        STRB     R0,[R1, #+0]
// 2543         for(i = Row2FirstLine; ; i--)
        MOVS     R0,R6
        B.N      ??BlackLeftAgainForCross_13
??BlackLeftAgainForCross_14:
        SUBS     R0,R0,#+1
// 2544         {
// 2545           BlackLeftLoc[i][0] = MaxValUint8;
??BlackLeftAgainForCross_13:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable17
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 2546           if(i == 0) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackLeftAgainForCross_14
// 2547         }
// 2548         return 0;
        MOVS     R0,#+0
        B.N      ??BlackLeftAgainForCross_7
// 2549       }
// 2550       //十字再检测的线头的确在限定的范围内，可以继续。
// 2551       else
// 2552       {
// 2553         BlackLeftCrossConfirmFlag = 2;  //左十字线头标志确认成功。
??BlackLeftAgainForCross_12:
        MOVS     R0,#+2
        LDR.W    R1,??DataTable20_1
        STRB     R0,[R1, #+0]
// 2554         row = temp;
        MOV      R7,R8
// 2555       }
// 2556       
// 2557       ////////////////如果要注释，就从这里结束注释
// 2558       
// 2559       //暂时不用confirm函数，如果要用的话 ，就把后面这句话去掉，前面注释去掉。
// 2560       //row = temp;
// 2561     }
// 2562     
// 2563     Row2RealFirstLine = row; //记录第2段黑线的真实起始行
        MOVS     R6,R7
// 2564     
// 2565     //十字再检测第2阶段，顺着线头找线。
// 2566     //temp为预测的黑点位置
// 2567     temp = BoundaryLimitRe(BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0],
// 2568                            0,
// 2569                            CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable17
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R3,#+3
        MLA      R0,R3,R7,R0
        LDRB     R0,[R0, #-3]
        LDR.W    R3,??DataTable17
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R12,#+3
        MLA      R3,R12,R7,R3
        LDRB     R3,[R3, #-3]
        UXTAB    R0,R3,R0
        LDR.W    R3,??DataTable17
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R12,#+3
        MLA      R3,R12,R7,R3
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
        MOV      R8,R0
// 2570     //预测值更新后就刷新一次堆栈，堆栈顶部丢失。
// 2571     BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
        LDR.W    R0,??DataTable19
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable19_1
        STRB     R0,[R1, #+0]
// 2572     BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
        LDR.W    R0,??DataTable20
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable19
        STRB     R0,[R1, #+0]
// 2573     BlackLeftWinPredictStore2 = temp;    
        LDR.W    R0,??DataTable20
        STRB     R8,[R0, #+0]
// 2574     
// 2575     //从最近的认证行到取最远的行
// 2576     for(row -= 2; ; row -= 2)
        SUBS     R7,R7,#+2
        B.N      ??BlackLeftAgainForCross_15
??BlackLeftAgainForCross_16:
        SUBS     R7,R7,#+2
// 2577     {
// 2578       //连续2行检测黑点。
// 2579       temp1 = BlackGetLeftStep2Win(row, BlackLeftWinVal, temp, 1);
??BlackLeftAgainForCross_15:
        MOVS     R3,#+1
        MOV      R2,R8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,#+15
        MOVS     R0,R7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetLeftStep2Win
        MOV      R9,R0
// 2580       temp2 = BlackGetLeftStep2Win(row-1, BlackLeftWinVal, temp, 2);
        MOVS     R3,#+2
        MOV      R2,R8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,#+15
        SUBS     R0,R7,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetLeftStep2Win
// 2581       
// 2582       //若连续2行黑点检测成功，则对3个阈值进行更新，且更新预测点位置。
// 2583       if(temp1 && temp2) 
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+0
        BEQ.W    ??BlackLeftAgainForCross_17
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BEQ.W    ??BlackLeftAgainForCross_17
// 2584       {
// 2585         //差值的处理，留有裕度，且有上下界。
// 2586         tempWB = (BlackLeftRealWB[0] + BlackLeftRealWB[1]) / 2 - LimitLeftWBMargin; 
        LDR.W    R0,??DataTable20_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable20_2
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+20
// 2587         if(tempWB < LimitLeftWBMin) tempWB = LimitLeftWBMin;
        LDR.N    R1,??DataTable15
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackLeftAgainForCross_18
        LDR.N    R0,??DataTable15
        LDRB     R0,[R0, #+0]
        B.N      ??BlackLeftAgainForCross_19
// 2588         else if(tempWB > LimitLeftWBMax) tempWB = LimitLeftWBMax;
??BlackLeftAgainForCross_18:
        LDR.N    R1,??DataTable15_1
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackLeftAgainForCross_19
        LDR.N    R0,??DataTable15_1
        LDRB     R0,[R0, #+0]
// 2589         else ;
// 2590         LimitLeftWB = tempWB;
??BlackLeftAgainForCross_19:
        LDR.N    R1,??DataTable15_2
        STRB     R0,[R1, #+0]
// 2591         
// 2592         //白点的处理，留有裕度，且有上下界。
// 2593         tempW = (BlackLeftRealW[0] + BlackLeftRealW[1]) / 2 - LimitLeftWMargin;
        LDR.W    R0,??DataTable20_3
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable20_3
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+40
// 2594         if(tempW < LimitLeftWMin) tempW = LimitLeftWMin;
        LDR.N    R1,??DataTable15_3
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackLeftAgainForCross_20
        LDR.N    R0,??DataTable15_3
        LDRB     R0,[R0, #+0]
        B.N      ??BlackLeftAgainForCross_21
// 2595         else if(tempW > LimitLeftWMax) tempW = LimitLeftWMax;
??BlackLeftAgainForCross_20:
        LDR.N    R1,??DataTable15_4
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackLeftAgainForCross_21
        LDR.N    R0,??DataTable15_4
        LDRB     R0,[R0, #+0]
// 2596         else ;
// 2597         LimitLeftW = tempW;
??BlackLeftAgainForCross_21:
        LDR.W    R1,??DataTable20_4
        STRB     R0,[R1, #+0]
// 2598         
// 2599         //黑点的处理，留有裕度，且有上下界。
// 2600         tempB = (BlackLeftRealB[0] + BlackLeftRealB[1]) / 2 + LimitLeftBMargin;
        LDR.N    R0,??DataTable15_7
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable15_7
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        ADDS     R0,R0,#+35
// 2601         if(tempB < LimitLeftBMin) tempB = LimitLeftBMin;
        LDR.N    R1,??DataTable15_5
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackLeftAgainForCross_22
        LDR.N    R0,??DataTable15_5
        LDRB     R0,[R0, #+0]
        B.N      ??BlackLeftAgainForCross_23
// 2602         else if(tempB > LimitLeftBMax) tempB = LimitLeftBMax;
??BlackLeftAgainForCross_22:
        LDR.N    R1,??DataTable15_6
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackLeftAgainForCross_23
        LDR.N    R0,??DataTable15_6
        LDRB     R0,[R0, #+0]
// 2603         else ;
// 2604         //黑色阈值不能超过白色
// 2605         if(tempB >= LimitLeftW)
??BlackLeftAgainForCross_23:
        LDR.W    R1,??DataTable20_4
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCC.N    ??BlackLeftAgainForCross_24
// 2606         {
// 2607           tempB = LimitLeftW - 1;
        LDR.W    R0,??DataTable20_4
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
// 2608         }
// 2609         else
// 2610         {
// 2611         }
// 2612         LimitLeftB = tempB;
??BlackLeftAgainForCross_24:
        LDR.W    R1,??DataTable19_2
        STRB     R0,[R1, #+0]
// 2613         
// 2614         //预测点更新，并限幅
// 2615         temp = BoundaryLimitRe(BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0],
// 2616                                0,
// 2617                                CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable17
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R3,#+3
        MLA      R0,R3,R7,R0
        LDRB     R0,[R0, #-3]
        LDR.W    R3,??DataTable17
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R12,#+3
        MLA      R3,R12,R7,R3
        LDRB     R3,[R3, #-3]
        UXTAB    R0,R3,R0
        LDR.W    R3,??DataTable17
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R12,#+3
        MLA      R3,R12,R7,R3
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
        MOV      R8,R0
// 2618         //预测值更新后就刷新一次堆栈，堆栈顶部丢失。
// 2619         BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
        LDR.W    R0,??DataTable19
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable19_1
        STRB     R0,[R1, #+0]
// 2620         BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
        LDR.W    R0,??DataTable20
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable19
        STRB     R0,[R1, #+0]
// 2621         BlackLeftWinPredictStore2 = temp;
        LDR.W    R0,??DataTable20
        STRB     R8,[R0, #+0]
        B.N      ??BlackLeftAgainForCross_25
// 2622       }
// 2623       //如果没能连续两行检测黑点成功，原本打算用原位置的预测点，后来发现效果不好，所以决定按预测点的趋势走。
// 2624       else
// 2625       {
// 2626         //预测点按趋势走也要限幅。
// 2627         tempminus = BoundaryLimitRe(BlackLeftWinPredictStore2 + BlackLeftWinPredictStore2 - BlackLeftWinPredictStore1,
// 2628                                     0,
// 2629                                     CameraRealWidth - 1);
??BlackLeftAgainForCross_17:
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable20
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable20
        LDRB     R3,[R3, #+0]
        ADDS     R0,R3,R0
        LDR.W    R3,??DataTable19
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
        MOV      R8,R0
// 2630         //temp在这里表示窗口预测点位置。
// 2631         temp = tempminus;
// 2632         BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
        LDR.W    R0,??DataTable19
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable19_1
        STRB     R0,[R1, #+0]
// 2633         BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
        LDR.W    R0,??DataTable20
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable19
        STRB     R0,[R1, #+0]
// 2634         BlackLeftWinPredictStore2 = temp;
        LDR.W    R0,??DataTable20
        STRB     R8,[R0, #+0]
// 2635       }       
// 2636       
// 2637       if((row == Row2LastLine) || (row == Row2LastLine+1)) break;      
??BlackLeftAgainForCross_25:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R7,R4
        BEQ.N    ??BlackLeftAgainForCross_26
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R0,R4,#+1
        CMP      R7,R0
        BNE.W    ??BlackLeftAgainForCross_16
// 2638     }
// 2639     
// 2640     //检查是否因大斜率而被削头。如果有，则更新头的位置，如果没有，则正常补线。
// 2641     if (BlackLeftLoc[Row1RealLastLine][0] == MaxValUint8)
??BlackLeftAgainForCross_26:
        LDR.W    R0,??DataTable17
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??BlackLeftAgainForCross_27
// 2642     {
// 2643 
// 2644         //头足够高，找回头。
// 2645         for (i = Row1RealLastLine; ; i++)
        MOVS     R0,R5
        B.N      ??BlackLeftAgainForCross_28
??BlackLeftAgainForCross_29:
        ADDS     R0,R0,#+1
// 2646         {
// 2647             if (BlackLeftLoc[i][0] != MaxValUint8)
??BlackLeftAgainForCross_28:
        LDR.W    R1,??DataTable17
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BEQ.N    ??BlackLeftAgainForCross_30
// 2648             {
// 2649                 Row1RealLastLine = i;
        MOVS     R5,R0
// 2650                 break;
// 2651             }
// 2652             else
// 2653             {
// 2654             }
// 2655             //直到最后一行也没有找到有效行，不用补线，直接返回1.
// 2656             if (i == CameraHight - 1) return 1;
// 2657         }
// 2658 
// 2659         //十字再检测第3阶段，脑补两段线的接线。
// 2660         if (BlackLeftCrossStep3(Row1RealLastLine, Row2RealFirstLine) == 0)
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackLeftCrossStep3
        CMP      R0,#+0
        BNE.N    ??BlackLeftAgainForCross_31
// 2661         {
// 2662             return 0;
        MOVS     R0,#+0
        B.N      ??BlackLeftAgainForCross_7
// 2663         }
??BlackLeftAgainForCross_30:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??BlackLeftAgainForCross_29
        MOVS     R0,#+1
        B.N      ??BlackLeftAgainForCross_7
// 2664 
// 2665     }
// 2666     else
// 2667     {
// 2668         //没有被大斜率削头。
// 2669         //十字再检测第3阶段，脑补两段线的接线。
// 2670         if (BlackLeftCrossStep3(Row1RealLastLine, Row2RealFirstLine) == 0)
??BlackLeftAgainForCross_27:
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackLeftCrossStep3
        CMP      R0,#+0
        BNE.N    ??BlackLeftAgainForCross_31
// 2671         {
// 2672             return 0;
        MOVS     R0,#+0
        B.N      ??BlackLeftAgainForCross_7
// 2673         }
// 2674     }
// 2675 
// 2676     
// 2677     return 1;
??BlackLeftAgainForCross_31:
        MOVS     R0,#+1
??BlackLeftAgainForCross_7:
        POP      {R1,R4-R9,PC}    ;; return
// 2678         
// 2679 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15:
        DC32     LimitLeftWBMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_1:
        DC32     LimitLeftWBMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_2:
        DC32     LimitLeftWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_3:
        DC32     LimitLeftWMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_4:
        DC32     LimitLeftWMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_5:
        DC32     LimitLeftBMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_6:
        DC32     LimitLeftBMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15_7:
        DC32     BlackLeftRealB
// 2680 
// 2681 //======================================================================
// 2682 //函数名：BlackLeftStep4BackLine
// 2683 //功  能：左黑线提取中，第4阶段十字向后补线函数。
// 2684 //参  数：Step4StartLine开始行，flag标志0表示正常调用，1表示单线错误的调用
// 2685 //返  回：1成功 0失败
// 2686 //影  响：BlackLeftLoc[][0]
// 2687 //说  明：1. 这里引用了float型的函数，有可能占用较长的时间。
// 2688 //        2. 想要减少时间，可以把宏定义BlackBackLineNum减至3或者2.
// 2689 //        3. 单线错误的调用时，不用检测十字外尾     
// 2690 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2691 uint8 BlackLeftStep4BackLine(uint8 Step4StartLine, uint8 flag)
// 2692 {
BlackLeftStep4BackLine:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+12
        MOVS     R4,R0
// 2693   uint8 row;
// 2694   uint8 i, index;
// 2695   uint8 x[BlackBackLineNum];   //取多少个点在一开始有定义。
// 2696   uint8 y[BlackBackLineNum];
// 2697   uint8 j;
// 2698   uint8 temp1;
// 2699   uint8 tempend;
// 2700   
// 2701   int32 temp;
// 2702   int32 a0;
// 2703   int32 a1;
// 2704   
// 2705   //正常调用时，需要检测十字外尾
// 2706   if(flag == 0)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.W    ??BlackLeftStep4BackLine_0
// 2707   {
// 2708     //十字外尾处理
// 2709     //第1阶段的线头比较高的话，就开始十字外尾检测。否则不用管。
// 2710     if(BlackLeftStep1ScanRow < BlackLeftCrossTailRowLimit)
        LDR.W    R0,??DataTable20_5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+50
        BGE.W    ??BlackLeftStep4BackLine_1
// 2711     {
// 2712       //检查线头处的斜率是不是很大，若很大，则怀疑有十字外尾。否则不用管。
// 2713       //这里用的斜率是十字外尾专用斜率。
// 2714       if(BlackLeft5Slope[0] + BlackLeftCrossTailSlopeLimit < 0 || AbsInt(BlackLeft5Slope[0])>BlackLeftCrossTailSlopeLimit)
        LDR.W    R0,??DataTable20_6
        LDR      R0,[R0, #+0]
        ADDW     R0,R0,#+3400
        CMP      R0,#+0
        BMI.N    ??BlackLeftStep4BackLine_2
        LDR.W    R0,??DataTable20_6
        LDR      R0,[R0, #+0]
        BL       AbsInt
        MOVW     R1,#+3401
        CMP      R0,R1
        BLT.W    ??BlackLeftStep4BackLine_3
// 2715       {
// 2716         //十字外尾标志置位。
// 2717         BlackLeftCrossTailFlag = 1;
??BlackLeftStep4BackLine_2:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable20_7
        STRB     R0,[R1, #+0]
// 2718         BlackLeftHeadEndSearch();
        BL       BlackLeftHeadEndSearch
// 2719         if (BlackLeftEndLine - BlackLeftHeadLine<=8 && BlackLeftHeadLine!=MaxValUint8 && BlackLeftEndLine!=MaxValUint8)
        LDR.W    R0,??DataTable20_8
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable20_9
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+9
        BGE.N    ??BlackLeftStep4BackLine_4
        LDR.W    R0,??DataTable20_9
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??BlackLeftStep4BackLine_4
        LDR.W    R0,??DataTable20_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??BlackLeftStep4BackLine_4
// 2720         {
// 2721             //这种情况有可能是回弯导致的，过滤掉
// 2722             for (i = BlackLeftHeadLine; i <= BlackLeftEndLine; i++)
        LDR.W    R0,??DataTable20_9
        LDRB     R0,[R0, #+0]
        B.N      ??BlackLeftStep4BackLine_5
// 2723             {
// 2724                 BlackLeftLoc[i][0] = MaxValUint8;
??BlackLeftStep4BackLine_6:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable17
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 2725             }
        ADDS     R0,R0,#+1
??BlackLeftStep4BackLine_5:
        LDR.W    R1,??DataTable20_8
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackLeftStep4BackLine_6
// 2726             return 0;
        MOVS     R0,#+0
        B.N      ??BlackLeftStep4BackLine_7
// 2727         }
// 2728         else if (BlackLeft5Slope[0] == MaxValInt16)
??BlackLeftStep4BackLine_4:
        LDR.W    R0,??DataTable20_6
        LDR      R0,[R0, #+0]
        MOVW     R1,#+32767
        CMP      R0,R1
        BNE.N    ??BlackLeftStep4BackLine_8
// 2729         {
// 2730             //这种情况有可能是回弯导致的，过滤掉
// 2731             for (i = 0; i <= 59; i++)
        MOVS     R0,#+0
        B.N      ??BlackLeftStep4BackLine_9
// 2732             {
// 2733                 BlackLeftLoc[i][0] = MaxValUint8;
??BlackLeftStep4BackLine_10:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable17
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 2734             }
        ADDS     R0,R0,#+1
??BlackLeftStep4BackLine_9:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+60
        BLT.N    ??BlackLeftStep4BackLine_10
// 2735             return 0;
        MOVS     R0,#+0
        B.N      ??BlackLeftStep4BackLine_7
// 2736         }
// 2737         //5Slope数组有可能已经删掉了一些黑点，所以也要参考实际的有效黑点数。
// 2738         if(BlackLeftEndLine - BlackLeftHeadLine - 4 < 0 || BlackLeft5SlopeIndex - 1 < 0)
??BlackLeftStep4BackLine_8:
        LDR.W    R0,??DataTable20_8
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable20_9
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+4
        CMP      R0,#+0
        BMI.N    ??BlackLeftStep4BackLine_11
        LDR.W    R0,??DataTable20_10
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        CMP      R0,#+0
        BPL.N    ??BlackLeftStep4BackLine_12
// 2739         {
// 2740           return 0;
??BlackLeftStep4BackLine_11:
        MOVS     R0,#+0
        B.N      ??BlackLeftStep4BackLine_7
// 2741         }
// 2742         else
// 2743         {
// 2744         }        
// 2745         tempend = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 4, BlackLeft5SlopeIndex - 1);
??BlackLeftStep4BackLine_12:
        LDR.W    R0,??DataTable20_10
        LDRB     R0,[R0, #+0]
        SUBS     R1,R0,#+1
        LDR.W    R0,??DataTable20_8
        LDRB     R0,[R0, #+0]
        LDR.W    R2,??DataTable20_9
        LDRB     R2,[R2, #+0]
        SUBS     R0,R0,R2
        SUBS     R0,R0,#+4
        BL       MinRe
        MOVS     R1,R0
// 2746         //开始消除十字外尾，找十字外尾的处理最远行。              
// 2747         for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??BlackLeftStep4BackLine_13
??BlackLeftStep4BackLine_14:
        ADDS     R0,R0,#+1
// 2748         {
// 2749           //找斜率在直道范围内的。这里用的斜率是判断为直道的斜率。
// 2750           if(BlackLeft5Slope[i] + PathJudgeStraightSlopeLimit > 0)
??BlackLeftStep4BackLine_13:
        LDR.W    R2,??DataTable20_6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDR      R2,[R2, R0, LSL #+2]
        ADDW     R2,R2,#+2100
        CMP      R2,#+1
        BLT.N    ??BlackLeftStep4BackLine_15
// 2751           {
// 2752             BlackLeftCrossTailEndLine = BlackLeft5SlopeRow[i];
        LDR.W    R1,??DataTable20_11
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDRB     R0,[R0, R1]
        LDR.W    R1,??DataTable20_12
        STRB     R0,[R1, #+0]
// 2753             break;
// 2754           }
// 2755           
// 2756           if(i == tempend) return 0;  //一直都很斜，则有可能是回弯，直接返回失败。
// 2757           //按理说不会走到这里，因为回弯会导致向后补线出错，向后补线出错后进来本函数时会先检查出错的原因BlackLeftStep4ErrorCheck()，会检测斜率是不是都是直线，若不是则不会进来。
// 2758         }
// 2759         //向近处4个点，也就是“5”点斜率的计算末尾。
// 2760         BlackLeftCrossTailEndLine += 4;
        LDR.W    R0,??DataTable20_12
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+4
        LDR.W    R1,??DataTable20_12
        STRB     R0,[R1, #+0]
// 2761         //取最先采集到的行。
// 2762         i = MinRe(BlackLeft5SlopeRow[0] + 4, CameraHight - 1);
        MOVS     R1,#+59
        LDR.W    R0,??DataTable20_11
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+4
        BL       MinRe
// 2763         i = MaxRe(BlackLeftStep1ScanRow, i);
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R1,R0
        LDR.W    R0,??DataTable20_5
        LDRB     R0,[R0, #+0]
        BL       MaxRe
// 2764         if(i >= BlackLeftCrossTailEndLine)
        LDR.W    R1,??DataTable20_12
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCC.N    ??BlackLeftStep4BackLine_0
        B.N      ??BlackLeftStep4BackLine_16
??BlackLeftStep4BackLine_15:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R0,R1
        BNE.N    ??BlackLeftStep4BackLine_14
        MOVS     R0,#+0
        B.N      ??BlackLeftStep4BackLine_7
// 2765         {
// 2766           //开始删除十字外尾。
// 2767           for(; ; i--)
??BlackLeftStep4BackLine_17:
        SUBS     R0,R0,#+1
// 2768           {
// 2769             BlackLeftLoc[i][0] = MaxValUint8;
??BlackLeftStep4BackLine_16:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable17
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 2770             if(i == BlackLeftCrossTailEndLine) break;
        LDR.W    R1,??DataTable20_12
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BNE.N    ??BlackLeftStep4BackLine_17
// 2771           }
// 2772           //修改向后补线的起点。
// 2773           Step4StartLine = BlackLeftCrossTailEndLine - 1;
        LDR.W    R0,??DataTable20_12
        LDRB     R0,[R0, #+0]
        SUBS     R4,R0,#+1
        B.N      ??BlackLeftStep4BackLine_0
// 2774         }
// 2775         else
// 2776         {
// 2777         }
// 2778       }
// 2779       else
// 2780       {
// 2781         //没有十字外尾。
// 2782         BlackLeftCrossTailFlag = 0;      
??BlackLeftStep4BackLine_3:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable20_7
        STRB     R0,[R1, #+0]
        B.N      ??BlackLeftStep4BackLine_0
// 2783       }
// 2784     }
// 2785     else
// 2786     {    
// 2787       //没有十字外尾。
// 2788       BlackLeftCrossTailFlag = 0;
??BlackLeftStep4BackLine_1:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable20_7
        STRB     R0,[R1, #+0]
// 2789     }
// 2790   }
// 2791   //单线错误调用时，就不用检测十字外尾了。
// 2792   else
// 2793   {
// 2794   }
// 2795  
// 2796   //正常的十字向后补线。
// 2797   if(Step4StartLine - BlackBackLineNum - BlackBackLineNum < 0)
??BlackLeftStep4BackLine_0:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        SUBS     R0,R4,#+8
        CMP      R0,#+0
        BPL.N    ??BlackLeftStep4BackLine_18
// 2798   {
// 2799     temp1 = 0;    
        MOVS     R2,#+0
        B.N      ??BlackLeftStep4BackLine_19
// 2800   }
// 2801   else
// 2802   {
// 2803     temp1 = Step4StartLine - BlackBackLineNum - BlackBackLineNum;
??BlackLeftStep4BackLine_18:
        SUBS     R2,R4,#+8
// 2804   }
// 2805   
// 2806   //取BlackBackLineNum个点作为最小二乘法的基准点。
// 2807   //以左上角为原点，向下为x轴正方向，向右为y轴正方向
// 2808   index = 0;
??BlackLeftStep4BackLine_19:
        MOVS     R1,#+0
// 2809   for(i = Step4StartLine; ; i--)
        MOVS     R0,R4
        B.N      ??BlackLeftStep4BackLine_20
??BlackLeftStep4BackLine_21:
        SUBS     R0,R0,#+1
// 2810   {
// 2811     if(BlackLeftLoc[i][0] != MaxValUint8)
??BlackLeftStep4BackLine_20:
        LDR.W    R3,??DataTable17
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R5,#+3
        MLA      R3,R5,R0,R3
        LDRB     R3,[R3, #+0]
        CMP      R3,#+255
        BEQ.N    ??BlackLeftStep4BackLine_22
// 2812     {
// 2813       y[index] = BlackLeftLoc[i][0];
        LDR.W    R3,??DataTable17
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R5,#+3
        MLA      R3,R5,R0,R3
        LDRB     R3,[R3, #+0]
        ADD      R5,SP,#+0
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R3,[R1, R5]
// 2814       x[index] = i;
        ADD      R3,SP,#+4
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R0,[R1, R3]
// 2815       index++;
        ADDS     R1,R1,#+1
// 2816     }
// 2817     if(index == BlackBackLineNum)
??BlackLeftStep4BackLine_22:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??BlackLeftStep4BackLine_23
// 2818     {
// 2819       break;  
// 2820     }
// 2821     if(i == temp1)
// 2822     {
// 2823       return 0;
// 2824     }
// 2825   }
// 2826   
// 2827   //最小二乘法
// 2828   //y = a0 + a1 * x
// 2829   a1 = LeastSquarea1(x, y, BlackBackLineNum);
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
        BL       LeastSquarea1
        MOVS     R5,R0
// 2830   /*
// 2831   //如果直线是从左上到右下，则说明是取到了错误的线，不必再补线，全数组清零。
// 2832   if(a1 > BlackLeftBackLineSlope)
// 2833   {
// 2834     for(row = Step4StartLine; ; row--)
// 2835     {
// 2836       BlackLeftLoc[row][0] = MaxValUint8;
// 2837       if(row == 0) break;
// 2838     }
// 2839     return 0;
// 2840   }
// 2841   //否则继续。
// 2842   else
// 2843   {
// 2844   }
// 2845   */
// 2846   
// 2847   
// 2848   //直着补，不是顺着补。
// 2849   /*
// 2850   for (row = Step4StartLine + 1; row <= CameraHight - 1; row++)
// 2851   {
// 2852     BlackLeftLoc[row][0] = BlackLeftLoc[Step4StartLine][0];
// 2853   }
// 2854   */
// 2855   
// 2856   //顺着补，不是直着补。
// 2857   a0 = LeastSquarea0(x, y, a1, BlackBackLineNum);
        MOVS     R3,#+4
        MOVS     R2,R5
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
        BL       LeastSquarea0
// 2858   
// 2859   for(row = Step4StartLine + 1; row <= CameraHight - 1; row++)
        ADDS     R1,R4,#+1
        B.N      ??BlackLeftStep4BackLine_24
??BlackLeftStep4BackLine_23:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R0,R2
        BNE.N    ??BlackLeftStep4BackLine_21
        MOVS     R0,#+0
        B.N      ??BlackLeftStep4BackLine_7
// 2860   {
// 2861     //补线也有个度，向左向右都不能补出范围。
// 2862     temp = (a0 + a1 * row) / LeastSquareMulti;
// 2863     if(temp >= CameraRealWidth-1)
// 2864     {
// 2865       //BlackLeftLoc[row][0] = CameraRealWidth - 1;
// 2866       //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。
// 2867       for(j = row; ; j++)
// 2868       {
// 2869         BlackLeftLoc[j][0] = CameraRealWidth-1;
// 2870         if(j == CameraHight - 1) break;
// 2871       }
// 2872       break;
// 2873     }
// 2874     else if(temp <= 0)
// 2875     {
// 2876       //BlackLeftLoc[row][0] = 0;
// 2877       //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。
// 2878       for(j = row; ; j++)
// 2879       {
// 2880         BlackLeftLoc[j][0] = 0;
// 2881         if(j == CameraHight - 1) break;
// 2882       }
// 2883       break;
// 2884     }
// 2885     else
// 2886     {
// 2887       BlackLeftLoc[row][0] = (uint8)(temp); 
??BlackLeftStep4BackLine_25:
        LDR.W    R3,??DataTable17
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R1,R3
        STRB     R2,[R3, #+0]
// 2888     }
        ADDS     R1,R1,#+1
??BlackLeftStep4BackLine_24:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+60
        BGE.N    ??BlackLeftStep4BackLine_26
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MLA      R2,R1,R5,R0
        MOV      R3,#+1000
        SDIV     R2,R2,R3
        CMP      R2,#+249
        BLT.N    ??BlackLeftStep4BackLine_27
        B.N      ??BlackLeftStep4BackLine_28
??BlackLeftStep4BackLine_29:
        ADDS     R1,R1,#+1
??BlackLeftStep4BackLine_28:
        MOVS     R0,#+249
        LDR.W    R2,??DataTable17
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        STRB     R0,[R2, #+0]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+59
        BNE.N    ??BlackLeftStep4BackLine_29
        B.N      ??BlackLeftStep4BackLine_26
??BlackLeftStep4BackLine_27:
        CMP      R2,#+1
        BGE.N    ??BlackLeftStep4BackLine_25
        B.N      ??BlackLeftStep4BackLine_30
??BlackLeftStep4BackLine_31:
        ADDS     R1,R1,#+1
??BlackLeftStep4BackLine_30:
        MOVS     R0,#+0
        LDR.W    R2,??DataTable17
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        STRB     R0,[R2, #+0]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+59
        BNE.N    ??BlackLeftStep4BackLine_31
// 2889   }
// 2890   
// 2891   
// 2892   
// 2893   return 1;
??BlackLeftStep4BackLine_26:
        MOVS     R0,#+1
??BlackLeftStep4BackLine_7:
        POP      {R1-R5,PC}       ;; return
// 2894   
// 2895 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16:
        DC32     SlopeR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_1:
        DC32     BlackRightHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_2:
        DC32     BlackGetPreDir

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_3:
        DC32     BlackRightLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_4:
        DC32     BlackLeftPredictL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_5:
        DC32     BlackLeftPredictR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16_6:
        DC32     ImgNew
// 2896 
// 2897 
// 2898 
// 2899 
// 2900 //左黑线连续性补线

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 2901 uint8 BlackLeftContinueAdd(void)
// 2902 {
BlackLeftContinueAdd:
        PUSH     {R4-R6}
// 2903     uint8 row, i, j;
// 2904     uint8 tempfirst, templast;
// 2905     uint8 fangHuiWanFlag =0;
        MOVS     R4,#+0
// 2906     uint8 fangDuanLieFlag = 0;
        MOVS     R3,#+0
// 2907     
// 2908     //左黑线连续性补线
// 2909     //只有左黑线采集成功才补线
// 2910     if(BlackLeftDone == 1)
        LDR.W    R0,??DataTable20_13
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??BlackLeftContinueAdd_0
// 2911     {        
// 2912         //找线尾
// 2913         for(row = CameraHight - 1; ; row--)
        MOVS     R0,#+59
        B.N      ??BlackLeftContinueAdd_1
??BlackLeftContinueAdd_2:
        SUBS     R0,R0,#+1
// 2914         {
// 2915           if(BlackLeftLoc[row][0] != MaxValUint8)
??BlackLeftContinueAdd_1:
        LDR.W    R1,??DataTable17
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BEQ.N    ??BlackLeftContinueAdd_3
// 2916           {
// 2917             break;
// 2918           }
// 2919           else
// 2920           {
// 2921           }
// 2922           
// 2923           if(row == 0)
// 2924           {
// 2925             BlackLeftDone = 0;
// 2926             return 0;
// 2927           }
// 2928         }
// 2929         
// 2930         //给线头线尾初始化为无效值。
// 2931         tempfirst = MaxValUint8;
        MOVS     R1,#+255
// 2932         templast = MaxValUint8;
        MOVS     R2,#+255
        B.N      ??BlackLeftContinueAdd_4
??BlackLeftContinueAdd_3:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackLeftContinueAdd_2
        MOVS     R0,#+0
        LDR.W    R1,??DataTable20_13
        STRB     R0,[R1, #+0]
        MOVS     R0,#+0
        B.N      ??BlackLeftContinueAdd_5
// 2933                 
// 2934         //开始补线
// 2935         for (; ; row--)
??BlackLeftContinueAdd_6:
        SUBS     R0,R0,#+1
// 2936         {
// 2937             if (BlackLeftLoc[row][0] == MaxValUint8)
??BlackLeftContinueAdd_4:
        LDR.W    R2,??DataTable17
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BNE.N    ??BlackLeftContinueAdd_7
// 2938             {
// 2939                 if (tempfirst == MaxValUint8)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+255
        BNE.W    ??BlackLeftContinueAdd_8
// 2940                 {
// 2941                     //若线头为无效值，就记录为线头。
// 2942                     tempfirst = row + 1;
        ADDS     R1,R0,#+1
        B.N      ??BlackLeftContinueAdd_8
// 2943                 }
// 2944                 else
// 2945                 {
// 2946                 }
// 2947             }
// 2948             else
// 2949             {
// 2950                 if (tempfirst != MaxValUint8)
??BlackLeftContinueAdd_7:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+255
        BEQ.W    ??BlackLeftContinueAdd_8
// 2951                 {
// 2952                     //若线头已经有赋值，则开始记录线尾。
// 2953                     templast = row;
        MOVS     R2,R0
// 2954                     if(templast > 5)
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+6
        BLT.N    ??BlackLeftContinueAdd_9
// 2955                     {
// 2956                         if (BlackLeftLoc[templast - 1][0] != MaxValUint8 && BlackLeftLoc[templast - 2][0] != MaxValUint8 && BlackLeftLoc[templast - 3][0] != MaxValUint8
// 2957                             && BlackLeftLoc[templast - 4][0] != MaxValUint8)
        LDR.W    R3,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R2,R3
        LDRB     R3,[R3, #-3]
        CMP      R3,#+255
        BEQ.N    ??BlackLeftContinueAdd_10
        LDR.W    R3,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R2,R3
        LDRB     R3,[R3, #-6]
        CMP      R3,#+255
        BEQ.N    ??BlackLeftContinueAdd_10
        LDR.W    R3,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R2,R3
        LDRB     R3,[R3, #-9]
        CMP      R3,#+255
        BEQ.N    ??BlackLeftContinueAdd_10
        LDR.N    R3,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R2,R3
        LDRB     R3,[R3, #-12]
        CMP      R3,#+255
        BEQ.N    ??BlackLeftContinueAdd_10
// 2958                         {
// 2959                             fangDuanLieFlag = 0;
        MOVS     R3,#+0
        B.N      ??BlackLeftContinueAdd_11
// 2960                         }
// 2961                         else
// 2962                         {
// 2963                             fangDuanLieFlag = 1;
??BlackLeftContinueAdd_10:
        MOVS     R3,#+1
        B.N      ??BlackLeftContinueAdd_11
// 2964                         }
// 2965                     }
// 2966                     else
// 2967                     {
// 2968                         fangDuanLieFlag = 1;
??BlackLeftContinueAdd_9:
        MOVS     R3,#+1
// 2969                     }
// 2970                     
// 2971                     if (templast >= 8)
??BlackLeftContinueAdd_11:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+8
        BLT.N    ??BlackLeftContinueAdd_12
// 2972                     {
// 2973                         if (BlackLeftLoc[templast - 1][0] != MaxValUint8 && BlackLeftLoc[templast - 2][0] != MaxValUint8 && BlackLeftLoc[templast - 3][0] != MaxValUint8
// 2974                             && BlackLeftLoc[templast - 4][0] != MaxValUint8 && BlackLeftLoc[templast - 5][0] != MaxValUint8
// 2975                                 && BlackLeftLoc[templast - 6][0] != MaxValUint8 && BlackLeftLoc[templast - 7][0] != MaxValUint8 && BlackLeftLoc[templast - 8][0] != MaxValUint8)
        LDR.N    R4,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R2,R4
        LDRB     R4,[R4, #-3]
        CMP      R4,#+255
        BEQ.N    ??BlackLeftContinueAdd_13
        LDR.N    R4,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R2,R4
        LDRB     R4,[R4, #-6]
        CMP      R4,#+255
        BEQ.N    ??BlackLeftContinueAdd_13
        LDR.N    R4,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R2,R4
        LDRB     R4,[R4, #-9]
        CMP      R4,#+255
        BEQ.N    ??BlackLeftContinueAdd_13
        LDR.N    R4,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R2,R4
        LDRB     R4,[R4, #-12]
        CMP      R4,#+255
        BEQ.N    ??BlackLeftContinueAdd_13
        LDR.N    R4,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R2,R4
        LDRB     R4,[R4, #-15]
        CMP      R4,#+255
        BEQ.N    ??BlackLeftContinueAdd_13
        LDR.N    R4,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R2,R4
        LDRB     R4,[R4, #-18]
        CMP      R4,#+255
        BEQ.N    ??BlackLeftContinueAdd_13
        LDR.N    R4,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R2,R4
        LDRB     R4,[R4, #-21]
        CMP      R4,#+255
        BEQ.N    ??BlackLeftContinueAdd_13
        LDR.N    R4,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R2,R4
        LDRB     R4,[R4, #-24]
        CMP      R4,#+255
        BEQ.N    ??BlackLeftContinueAdd_13
// 2976                         {
// 2977                             fangHuiWanFlag = 0;
        MOVS     R4,#+0
        B.N      ??BlackLeftContinueAdd_14
// 2978                         }
// 2979                         else
// 2980                         {
// 2981                             fangHuiWanFlag = 1;
??BlackLeftContinueAdd_13:
        MOVS     R4,#+1
        B.N      ??BlackLeftContinueAdd_14
// 2982                         }
// 2983                     }
// 2984                     else
// 2985                     {
// 2986                         fangHuiWanFlag = 1;
??BlackLeftContinueAdd_12:
        MOVS     R4,#+1
// 2987                     }
// 2988                     
// 2989                     if ((BlackLeftLoc[tempfirst][0]<=15 && BlackLeftLoc[templast][0]<=15) && (tempfirst - templast) <= 12)
??BlackLeftContinueAdd_14:
        LDR.N    R5,??DataTable17
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R1,R5
        LDRB     R5,[R5, #+0]
        CMP      R5,#+16
        BGE.N    ??BlackLeftContinueAdd_15
        LDR.N    R5,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R2,R5
        LDRB     R5,[R5, #+0]
        CMP      R5,#+16
        BGE.N    ??BlackLeftContinueAdd_15
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        SUBS     R5,R1,R2
        CMP      R5,#+13
        BGE.N    ??BlackLeftContinueAdd_15
// 2990                     {
// 2991                         //这种情况是防止黑线太靠镜头边界导致黑线不成功的
// 2992                         for (j = tempfirst - 1; ; j--)
        SUBS     R3,R1,#+1
        B.N      ??BlackLeftContinueAdd_16
??BlackLeftContinueAdd_17:
        SUBS     R3,R3,#+1
// 2993                         {
// 2994                             BlackLeftLoc[j][0] = (BlackLeftLoc[tempfirst][0] + BlackLeftLoc[templast][0]) / 2;
??BlackLeftContinueAdd_16:
        LDR.N    R4,??DataTable17
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R1,R4
        LDRB     R4,[R4, #+0]
        LDR.N    R5,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R2,R5
        LDRB     R5,[R5, #+0]
        ADDS     R4,R5,R4
        MOVS     R5,#+2
        SDIV     R4,R4,R5
        LDR.N    R5,??DataTable17
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R3,R5
        STRB     R4,[R5, #+0]
// 2995                             if (j == templast + 1) break;
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        ADDS     R4,R2,#+1
        CMP      R3,R4
        BNE.N    ??BlackLeftContinueAdd_17
        B.N      ??BlackLeftContinueAdd_18
// 2996                         }
// 2997                     }
// 2998                     else if ((BlackLeftLoc[tempfirst][0] <= 15 && BlackLeftLoc[templast][0] <= 15) && (tempfirst - templast) <20
// 2999                                 && (BlackLeftLoc[10][0] != MaxValUint8 || BlackLeftLoc[9][0] != MaxValUint8 || BlackLeftLoc[8][0] != MaxValUint8 || BlackLeftLoc[7][0] != MaxValUint8 || BlackLeftLoc[6][0] != MaxValUint8)
// 3000                                 && fangHuiWanFlag == 0)
??BlackLeftContinueAdd_15:
        LDR.N    R5,??DataTable17
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R1,R5
        LDRB     R5,[R5, #+0]
        CMP      R5,#+16
        BGE.N    ??BlackLeftContinueAdd_19
        LDR.N    R5,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R2,R5
        LDRB     R5,[R5, #+0]
        CMP      R5,#+16
        BGE.N    ??BlackLeftContinueAdd_19
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        SUBS     R5,R1,R2
        CMP      R5,#+20
        BGE.N    ??BlackLeftContinueAdd_19
        LDR.N    R5,??DataTable17
        LDRB     R5,[R5, #+30]
        CMP      R5,#+255
        BNE.N    ??BlackLeftContinueAdd_20
        LDR.N    R5,??DataTable17
        LDRB     R5,[R5, #+27]
        CMP      R5,#+255
        BNE.N    ??BlackLeftContinueAdd_20
        LDR.N    R5,??DataTable17
        LDRB     R5,[R5, #+24]
        CMP      R5,#+255
        BNE.N    ??BlackLeftContinueAdd_20
        LDR.N    R5,??DataTable17
        LDRB     R5,[R5, #+21]
        CMP      R5,#+255
        BNE.N    ??BlackLeftContinueAdd_20
        LDR.N    R5,??DataTable17
        LDRB     R5,[R5, #+18]
        CMP      R5,#+255
        BEQ.N    ??BlackLeftContinueAdd_19
??BlackLeftContinueAdd_20:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BNE.N    ??BlackLeftContinueAdd_19
// 3001                     {
// 3002                         //这种情况是防止黑线太靠镜头边界导致黑线不成功的
// 3003                         for (j = tempfirst - 1; ; j--)
        SUBS     R3,R1,#+1
        B.N      ??BlackLeftContinueAdd_21
??BlackLeftContinueAdd_22:
        SUBS     R3,R3,#+1
// 3004                         {
// 3005                             BlackLeftLoc[j][0] = (BlackLeftLoc[tempfirst][0] + BlackLeftLoc[templast][0]) / 2;
??BlackLeftContinueAdd_21:
        LDR.N    R4,??DataTable17
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R1,R4
        LDRB     R4,[R4, #+0]
        LDR.N    R5,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R2,R5
        LDRB     R5,[R5, #+0]
        ADDS     R4,R5,R4
        MOVS     R5,#+2
        SDIV     R4,R4,R5
        LDR.N    R5,??DataTable17
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R3,R5
        STRB     R4,[R5, #+0]
// 3006                             if (j == templast + 1) break;
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        ADDS     R4,R2,#+1
        CMP      R3,R4
        BNE.N    ??BlackLeftContinueAdd_22
        B.N      ??BlackLeftContinueAdd_18
// 3007                         }
// 3008                     }
// 3009                     else if ((BlackLeftLoc[tempfirst][0] <= 15 && BlackLeftLoc[templast][0] <= 15) && (tempfirst - templast) <= 35
// 3010                                 && (BlackLeftLoc[6][0] != MaxValUint8 || BlackLeftLoc[7][0] != MaxValUint8 || BlackLeftLoc[8][0] != MaxValUint8 || BlackLeftLoc[10][0] != MaxValUint8 || BlackLeftLoc[9][0] != MaxValUint8)
// 3011                                 && fangHuiWanFlag == 0)
??BlackLeftContinueAdd_19:
        LDR.N    R5,??DataTable17
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R1,R5
        LDRB     R5,[R5, #+0]
        CMP      R5,#+16
        BGE.N    ??BlackLeftContinueAdd_23
        LDR.N    R5,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R2,R5
        LDRB     R5,[R5, #+0]
        CMP      R5,#+16
        BGE.N    ??BlackLeftContinueAdd_23
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        SUBS     R5,R1,R2
        CMP      R5,#+36
        BGE.N    ??BlackLeftContinueAdd_23
        LDR.N    R5,??DataTable17
        LDRB     R5,[R5, #+18]
        CMP      R5,#+255
        BNE.N    ??BlackLeftContinueAdd_24
        LDR.N    R5,??DataTable17
        LDRB     R5,[R5, #+21]
        CMP      R5,#+255
        BNE.N    ??BlackLeftContinueAdd_24
        LDR.N    R5,??DataTable17
        LDRB     R5,[R5, #+24]
        CMP      R5,#+255
        BNE.N    ??BlackLeftContinueAdd_24
        LDR.N    R5,??DataTable17
        LDRB     R5,[R5, #+30]
        CMP      R5,#+255
        BNE.N    ??BlackLeftContinueAdd_24
        LDR.N    R5,??DataTable17
        LDRB     R5,[R5, #+27]
        CMP      R5,#+255
        BEQ.N    ??BlackLeftContinueAdd_23
??BlackLeftContinueAdd_24:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BNE.N    ??BlackLeftContinueAdd_23
// 3012                     {
// 3013                         //这种情况是防止黑线太靠镜头边界导致黑线不成功的
// 3014                         for (j = tempfirst - 1; ; j--)
        SUBS     R3,R1,#+1
        B.N      ??BlackLeftContinueAdd_25
??BlackLeftContinueAdd_26:
        SUBS     R3,R3,#+1
// 3015                         {
// 3016                             BlackLeftLoc[j][0] = (BlackLeftLoc[tempfirst][0] + BlackLeftLoc[templast][0]) / 2;
??BlackLeftContinueAdd_25:
        LDR.N    R4,??DataTable17
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R1,R4
        LDRB     R4,[R4, #+0]
        LDR.N    R5,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R2,R5
        LDRB     R5,[R5, #+0]
        ADDS     R4,R5,R4
        MOVS     R5,#+2
        SDIV     R4,R4,R5
        LDR.N    R5,??DataTable17
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R3,R5
        STRB     R4,[R5, #+0]
// 3017                             if (j == templast + 1) break;
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        ADDS     R4,R2,#+1
        CMP      R3,R4
        BNE.N    ??BlackLeftContinueAdd_26
        B.N      ??BlackLeftContinueAdd_18
// 3018                         }
// 3019                     }
// 3020                     //防边线断裂的
// 3021                     else if (tempfirst - templast <= 5 && fangDuanLieFlag == 0)
??BlackLeftContinueAdd_23:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        SUBS     R4,R1,R2
        CMP      R4,#+6
        BGE.N    ??BlackLeftContinueAdd_27
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BNE.N    ??BlackLeftContinueAdd_27
// 3022                     {
// 3023                         for (j = tempfirst - 1; ; j--)
        SUBS     R3,R1,#+1
        B.N      ??BlackLeftContinueAdd_28
??BlackLeftContinueAdd_29:
        SUBS     R3,R3,#+1
// 3024                         {
// 3025                             BlackLeftLoc[j][0] = (BlackLeftLoc[tempfirst][0] + BlackLeftLoc[templast][0]) / 2;
??BlackLeftContinueAdd_28:
        LDR.N    R4,??DataTable17
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R1,R4
        LDRB     R4,[R4, #+0]
        LDR.N    R5,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R2,R5
        LDRB     R5,[R5, #+0]
        ADDS     R4,R5,R4
        MOVS     R5,#+2
        SDIV     R4,R4,R5
        LDR.N    R5,??DataTable17
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R3,R5
        STRB     R4,[R5, #+0]
// 3026                             if (j == templast + 1) break;
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        ADDS     R4,R2,#+1
        CMP      R3,R4
        BNE.N    ??BlackLeftContinueAdd_29
        B.N      ??BlackLeftContinueAdd_18
// 3027                         }
// 3028                     }
// 3029                     else if(tempfirst - templast >= 3) 
??BlackLeftContinueAdd_27:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        SUBS     R3,R1,R2
        CMP      R3,#+3
        BLT.N    ??BlackLeftContinueAdd_30
// 3030                     {
// 3031                       //两者相差太多，则后面的行全部视为错误。
// 3032                       for(i = tempfirst - 1; ; i--)
        SUBS     R0,R1,#+1
        B.N      ??BlackLeftContinueAdd_31
??BlackLeftContinueAdd_32:
        SUBS     R0,R0,#+1
// 3033                       {
// 3034                         BlackLeftLoc[i][0] = MaxValUint8;
??BlackLeftContinueAdd_31:
        MOVS     R1,#+255
        LDR.N    R2,??DataTable17
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 3035                         if(i == 0) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackLeftContinueAdd_32
// 3036                       }
// 3037                       //左黑线连续性标志出错。
// 3038                       BlackLeftContinueFlag = 2;
        MOVS     R0,#+2
        LDR.W    R1,??DataTable24
        STRB     R0,[R1, #+0]
// 3039                       return 0;
        MOVS     R0,#+0
        B.N      ??BlackLeftContinueAdd_5
// 3040                     }
// 3041                     else
// 3042                     {
// 3043                       //一共才1或2个点，直接插值就行。
// 3044                       for(j = tempfirst - 1; ; j--)
??BlackLeftContinueAdd_30:
        SUBS     R3,R1,#+1
        B.N      ??BlackLeftContinueAdd_33
??BlackLeftContinueAdd_34:
        SUBS     R3,R3,#+1
// 3045                       {
// 3046                         BlackLeftLoc[j][0] = (BlackLeftLoc[tempfirst][0] + BlackLeftLoc[templast][0]) / 2;
??BlackLeftContinueAdd_33:
        LDR.N    R4,??DataTable17
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R1,R4
        LDRB     R4,[R4, #+0]
        LDR.N    R5,??DataTable17
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R2,R5
        LDRB     R5,[R5, #+0]
        ADDS     R4,R5,R4
        MOVS     R5,#+2
        SDIV     R4,R4,R5
        LDR.N    R5,??DataTable17
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R3,R5
        STRB     R4,[R5, #+0]
// 3047                         if(j == templast + 1) break;
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        ADDS     R4,R2,#+1
        CMP      R3,R4
        BNE.N    ??BlackLeftContinueAdd_34
// 3048                       }
// 3049                     }
// 3050                     tempfirst = MaxValUint8;
??BlackLeftContinueAdd_18:
        MOVS     R1,#+255
// 3051                     templast = MaxValUint8;
        MOVS     R2,#+255
// 3052                     //左黑线连续性标志置0，不连续。
// 3053                     BlackLeftContinueFlag = 0;
        MOVS     R2,#+0
        LDR.W    R3,??DataTable24
        STRB     R2,[R3, #+0]
// 3054                 }
// 3055                 else
// 3056                 {
// 3057                 }
// 3058             }
// 3059 
// 3060             if (row == 0) break;
??BlackLeftContinueAdd_8:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.W    ??BlackLeftContinueAdd_6
// 3061         }
// 3062     }
// 3063     else
// 3064     {
// 3065     }    
// 3066     
// 3067     return 1;
??BlackLeftContinueAdd_0:
        MOVS     R0,#+1
??BlackLeftContinueAdd_5:
        POP      {R4-R6}
        BX       LR               ;; return
// 3068 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17:
        DC32     BlackLeftLoc
// 3069 
// 3070 
// 3071 
// 3072 
// 3073 
// 3074 
// 3075 //左黑线的回弯特殊检测。进来前BlackLeftDone已经置为1了。
// 3076 //进来前已经进行左、右黑线的斜曲率检测。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 3077 uint8 BlackLeftRollCheck(void)
// 3078 {
// 3079   uint8 temp1, temp2, temp3;
// 3080   
// 3081   //当前为单线，不进行回弯特殊检测。
// 3082   if(SingleBlackAllFlag == 1) return 1;
BlackLeftRollCheck:
        LDR.W    R0,??DataTable23
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackLeftRollCheck_0
        MOVS     R0,#+1
        B.N      ??BlackLeftRollCheck_1
// 3083   
// 3084   //斜率确认。
// 3085   //若无效，直接确认。
// 3086   if(SlopeL == MaxValInt16)
??BlackLeftRollCheck_0:
        LDR.W    R0,??DataTable23_1
        LDR      R0,[R0, #+0]
        MOVW     R1,#+32767
        CMP      R0,R1
        BNE.N    ??BlackLeftRollCheck_2
// 3087   {
// 3088     temp1 = 1;
        MOVS     R0,#+1
        B.N      ??BlackLeftRollCheck_3
// 3089   }
// 3090   else
// 3091   {
// 3092     //斜率的确太大。
// 3093     if(SlopeL + BlackLeftRollSlopeLimit < 0)
??BlackLeftRollCheck_2:
        LDR.W    R0,??DataTable23_1
        LDR      R0,[R0, #+0]
        ADDS     R0,R0,#+2000
        CMP      R0,#+0
        BPL.N    ??BlackLeftRollCheck_4
// 3094     {
// 3095       temp1 = 1;
        MOVS     R0,#+1
        B.N      ??BlackLeftRollCheck_3
// 3096     }
// 3097     //斜率不大。
// 3098     else
// 3099     {
// 3100       temp1 = 0;
??BlackLeftRollCheck_4:
        MOVS     R0,#+0
// 3101     }
// 3102   }
// 3103   
// 3104   //线长度确认。
// 3105   //若无效，直接确认。
// 3106   if(BlackLeftHeadLine == MaxValUint8 || BlackLeftEndLine == MaxValUint8)
??BlackLeftRollCheck_3:
        LDR.N    R1,??DataTable20_9
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BEQ.N    ??BlackLeftRollCheck_5
        LDR.N    R1,??DataTable20_8
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BNE.N    ??BlackLeftRollCheck_6
// 3107   {
// 3108     temp2 = 1;
??BlackLeftRollCheck_5:
        MOVS     R1,#+1
        B.N      ??BlackLeftRollCheck_7
// 3109   }
// 3110   else
// 3111   {
// 3112     //线确实很短。
// 3113     if(BlackLeftEndLine - BlackLeftHeadLine < BlackLeftRollLengthLimit)
??BlackLeftRollCheck_6:
        LDR.N    R1,??DataTable20_8
        LDRB     R1,[R1, #+0]
        LDR.N    R2,??DataTable20_9
        LDRB     R2,[R2, #+0]
        SUBS     R1,R1,R2
        CMP      R1,#+12
        BGE.N    ??BlackLeftRollCheck_8
// 3114     {
// 3115       temp2 = 1;
        MOVS     R1,#+1
        B.N      ??BlackLeftRollCheck_7
// 3116     }
// 3117     //线很长。
// 3118     else
// 3119     {
// 3120       temp2 = 0;
??BlackLeftRollCheck_8:
        MOVS     R1,#+0
// 3121     }
// 3122   }
// 3123   
// 3124   /*
// 3125   //右线斜率确认。
// 3126   //右线必须是左上到右下的，也就是正的斜率。而且斜率要求比较大。才能说明是270等大弯。
// 3127   if(SlopeR == MaxValInt16)
// 3128   {
// 3129     temp3 = 1;    
// 3130   }
// 3131   else
// 3132   {
// 3133     if(SlopeR > BlackLeftRollSlopeRLimit)
// 3134     {
// 3135       temp3 = 1;
// 3136     }
// 3137     else
// 3138     {
// 3139       temp3 = 0;
// 3140     }
// 3141   }
// 3142   */
// 3143   temp3 = 1;
??BlackLeftRollCheck_7:
        MOVS     R2,#+1
// 3144 
// 3145   if(
// 3146     (BlackLeftStep4Flag == 3 || SingleBlackLastAllFlag == 1)   //左向后补线标志，出错。或者因为上幅图像是单线，无法开启十字，无法置向后补线出错。
// 3147   &&(BlackLeftCrossDone == 1 || BlackLeftCrossDone == 0)   //左十字标志，失败。或者未进入（线尾过高不会进行十字再检测）。
// 3148   &&(temp1 == 1)                //斜率很大。
// 3149   &&(temp2 == 1)                //线很短。
// 3150   &&(temp3 == 1)                //右线斜率很大。
// 3151     )
        LDR.W    R3,??DataTable23_2
        LDRB     R3,[R3, #+0]
        CMP      R3,#+3
        BEQ.N    ??BlackLeftRollCheck_9
        LDR.W    R3,??DataTable23_3
        LDRB     R3,[R3, #+0]
        CMP      R3,#+1
        BNE.N    ??BlackLeftRollCheck_10
??BlackLeftRollCheck_9:
        LDR.W    R3,??DataTable24_1
        LDRB     R3,[R3, #+0]
        CMP      R3,#+1
        BEQ.N    ??BlackLeftRollCheck_11
        LDR.W    R3,??DataTable24_1
        LDRB     R3,[R3, #+0]
        CMP      R3,#+0
        BNE.N    ??BlackLeftRollCheck_10
??BlackLeftRollCheck_11:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??BlackLeftRollCheck_10
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??BlackLeftRollCheck_10
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.N    ??BlackLeftRollCheck_10
// 3152   {
// 3153     //检测到回弯，返回0.
// 3154     return 0;   
        MOVS     R0,#+0
        B.N      ??BlackLeftRollCheck_1
// 3155   }
// 3156   else
// 3157   {
// 3158     //没检测到回弯，返回1.
// 3159     return 1;
??BlackLeftRollCheck_10:
        MOVS     R0,#+1
??BlackLeftRollCheck_1:
        BX       LR               ;; return
// 3160   }
// 3161 
// 3162 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable18:
        DC32     BlackLeftEdgeStartColOffset
// 3163 
// 3164 //向后补线标志出错时的检查，这个函数是防止回弯的很重要的函数。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 3165 uint8 BlackLeftStep4ErrorCheck(void)
// 3166 {
BlackLeftStep4ErrorCheck:
        PUSH     {R4,LR}
// 3167   uint8 i;
// 3168   
// 3169   //检查斜率是不是都满足直线
// 3170   for(i = 0; ; i++)
        MOVS     R4,#+0
        B.N      ??BlackLeftStep4ErrorCheck_0
??BlackLeftStep4ErrorCheck_1:
        ADDS     R4,R4,#+1
// 3171   {
// 3172     if(BlackLeft5Slope[i] == MaxValInt16) return 0;
??BlackLeftStep4ErrorCheck_0:
        LDR.N    R0,??DataTable20_6
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R0,[R0, R4, LSL #+2]
        MOVW     R1,#+32767
        CMP      R0,R1
        BNE.N    ??BlackLeftStep4ErrorCheck_2
        MOVS     R0,#+0
        B.N      ??BlackLeftStep4ErrorCheck_3
// 3173     
// 3174     if(AbsInt(BlackLeft5Slope[i]) > PathJudgeStraightSlopeLimit)
??BlackLeftStep4ErrorCheck_2:
        LDR.N    R0,??DataTable20_6
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R0,[R0, R4, LSL #+2]
        BL       AbsInt
        MOVW     R1,#+2101
        CMP      R0,R1
        BLT.N    ??BlackLeftStep4ErrorCheck_4
// 3175     {
// 3176       return 0;
        MOVS     R0,#+0
        B.N      ??BlackLeftStep4ErrorCheck_3
// 3177     }
// 3178     else
// 3179     {      
// 3180     }
// 3181     
// 3182     if(i == 5) break;
??BlackLeftStep4ErrorCheck_4:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+5
        BNE.N    ??BlackLeftStep4ErrorCheck_1
// 3183   }
// 3184   
// 3185   return 1;
        MOVS     R0,#+1
??BlackLeftStep4ErrorCheck_3:
        POP      {R4,PC}          ;; return
// 3186   
// 3187 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable19:
        DC32     BlackLeftWinPredictStore1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable19_1:
        DC32     BlackLeftWinPredictStore0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable19_2:
        DC32     LimitLeftB
// 3188 
// 3189 
// 3190 //左黑线提取前的参数初始化赋值

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 3191 uint8 BlackGetLeftParaInit(void)
// 3192 {
// 3193   uint8 i;
// 3194   
// 3195   //左线连续性标志。默认为1连续。
// 3196   BlackLeftContinueFlag = 1;  
BlackGetLeftParaInit:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable24
        STRB     R0,[R1, #+0]
// 3197   
// 3198   //采集成功标志位
// 3199   BlackLeftDone = 1;  
        MOVS     R0,#+1
        LDR.N    R1,??DataTable20_13
        STRB     R0,[R1, #+0]
// 3200  
// 3201   //左十字线头标志。0未进入，1超范围，2成功。
// 3202   BlackLeftCrossConfirmFlag = 0;  //默认为未进入。  
        MOVS     R0,#+0
        LDR.N    R1,??DataTable20_1
        STRB     R0,[R1, #+0]
// 3203   
// 3204   //小5点斜率储存数组置初始值。
// 3205   BlackLeft5SlopeIndex = 0;  
        MOVS     R0,#+0
        LDR.N    R1,??DataTable20_10
        STRB     R0,[R1, #+0]
// 3206   for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??BlackGetLeftParaInit_0
??BlackGetLeftParaInit_1:
        ADDS     R0,R0,#+1
// 3207   {
// 3208       BlackLeft5Slope[i] = MaxValInt16;
??BlackGetLeftParaInit_0:
        MOVW     R1,#+32767
        LDR.N    R2,??DataTable20_6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STR      R1,[R2, R0, LSL #+2]
// 3209       BlackLeft5SlopeRow[i] = MaxValUint8;
        MOVS     R1,#+255
        LDR.N    R2,??DataTable20_11
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 3210       if(i == CameraHight - 1) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??BlackGetLeftParaInit_1
// 3211   }  
// 3212   
// 3213   //回弯检测
// 3214   BlackLeftRollCheckFlag = 0;        //检测到回弯。
        MOVS     R0,#+0
        LDR.W    R1,??DataTable24_2
        STRB     R0,[R1, #+0]
// 3215   BlackLeftBigChangeJumpFlag = 0;    //回弯跳过标志。
        MOVS     R0,#+0
        LDR.W    R1,??DataTable24_3
        STRB     R0,[R1, #+0]
// 3216 
// 3217   //大斜率检测时，每幅图像的初始值初始化为无效值。
// 3218   for(i = 0; i <= 4; i++)
        MOVS     R0,#+0
        B.N      ??BlackGetLeftParaInit_2
// 3219   {
// 3220     BlackLeftBigChangeNumx[i] = MaxValUint8;
??BlackGetLeftParaInit_3:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable24_4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 3221     BlackLeftBigChangeNumy[i] = MaxValUint8; 
        MOVS     R1,#+255
        LDR.W    R2,??DataTable24_5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 3222   }
        ADDS     R0,R0,#+1
??BlackGetLeftParaInit_2:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+5
        BLT.N    ??BlackGetLeftParaInit_3
// 3223   BlackLeftBigChangeFlag = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable24_6
        STRB     R0,[R1, #+0]
// 3224   BlackLeftBigChangeSlopeStore = MaxValInt16;
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable24_7
        STR      R0,[R1, #+0]
// 3225 
// 3226   //大斜率检测时，每行的大跳变标志置0.
// 3227   for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??BlackGetLeftParaInit_4
??BlackGetLeftParaInit_5:
        ADDS     R0,R0,#+1
// 3228   {
// 3229     BlackLeftBigChangeCheckRow[i] = 0;
??BlackGetLeftParaInit_4:
        MOVS     R1,#+0
        LDR.W    R2,??DataTable24_8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 3230     if(i == CameraHight - 1) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??BlackGetLeftParaInit_5
// 3231   }
// 3232   BlackLeftBigChangeCheckAllRow = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable24_9
        STRB     R0,[R1, #+0]
// 3233 
// 3234   //左黑线储存数组初始化为无效值。
// 3235   for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??BlackGetLeftParaInit_6
??BlackGetLeftParaInit_7:
        ADDS     R0,R0,#+1
// 3236   {
// 3237     BlackLeftLoc[i][0] = MaxValUint8;
??BlackGetLeftParaInit_6:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable24_10
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 3238     if(i == CameraHight - 1) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??BlackGetLeftParaInit_7
// 3239   }
// 3240 
// 3241   //十字外尾
// 3242   BlackLeftCrossTailFlag = 2;       //十字外尾标志，0失败，1确认，2未进入。
        MOVS     R0,#+2
        LDR.N    R1,??DataTable20_7
        STRB     R0,[R1, #+0]
// 3243 
// 3244   //窗口预测值管理
// 3245   for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??BlackGetLeftParaInit_8
??BlackGetLeftParaInit_9:
        ADDS     R0,R0,#+1
// 3246   {
// 3247     BlackLeftPredictL[i] = MaxValUint8;
??BlackGetLeftParaInit_8:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable24_11
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 3248     BlackLeftPredictR[i] = MaxValUint8; 
        MOVS     R1,#+255
        LDR.W    R2,??DataTable24_12
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 3249     if(i == CameraHight - 1) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??BlackGetLeftParaInit_9
// 3250   }
// 3251   
// 3252   //窗口预测储存值
// 3253   BlackLeftWinPredictStore0 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable24_13
        STRB     R0,[R1, #+0]
// 3254   BlackLeftWinPredictStore1 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable24_14
        STRB     R0,[R1, #+0]
// 3255   BlackLeftWinPredictStore2 = MaxValUint8;
        MOVS     R0,#+255
        LDR.N    R1,??DataTable20
        STRB     R0,[R1, #+0]
// 3256 
// 3257   //第4阶段进入标志置为未进入
// 3258   BlackLeftStep4Flag = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable23_2
        STRB     R0,[R1, #+0]
// 3259   BlackLeftStep4StartLine = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable25
        STRB     R0,[R1, #+0]
// 3260   //默认十字检测标志置为未进入。
// 3261   BlackLeftCrossDone = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable25_1
        STRB     R0,[R1, #+0]
// 3262   
// 3263   return 1;
        MOVS     R0,#+1
        BX       LR               ;; return
// 3264 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable20:
        DC32     BlackLeftWinPredictStore2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable20_1:
        DC32     BlackLeftCrossConfirmFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable20_2:
        DC32     BlackLeftRealWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable20_3:
        DC32     BlackLeftRealW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable20_4:
        DC32     LimitLeftW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable20_5:
        DC32     BlackLeftStep1ScanRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable20_6:
        DC32     BlackLeft5Slope

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable20_7:
        DC32     BlackLeftCrossTailFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable20_8:
        DC32     BlackLeftEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable20_9:
        DC32     BlackLeftHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable20_10:
        DC32     BlackLeft5SlopeIndex

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable20_11:
        DC32     BlackLeft5SlopeRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable20_12:
        DC32     BlackLeftCrossTailEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable20_13:
        DC32     BlackLeftDone
// 3265 
// 3266 
// 3267 
// 3268 
// 3269 
// 3270 
// 3271 //======================================================================
// 3272 //函数名：BlackGetLeft
// 3273 //功  能：左黑线提取算法
// 3274 //参  数：无
// 3275 //返  回：1成功 0失败
// 3276 //影  响：BlackLeftCrossDone，BlackLeftLoc[][],
// 3277 //        BlackLeftRealWB[], BlackLeftRealW[], BlackLeftRealB[],
// 3278 //        LimitLeftWB, LimitLeftW, LimitLeftB
// 3279 //说  明：1. 暂时可以处理直道，弯道，十字路口3种情况。2014.11.10
// 3280 //      
// 3281 //             
// 3282 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 3283 uint8 BlackGetLeft(void)
// 3284 {
BlackGetLeft:
        PUSH     {R3-R11,LR}
// 3285     uint8 row, temp, temp1, temp2, temp3, i;
// 3286     uint8 GapCount, Row1RealLastLine, index, index1;
// 3287     uint8 tempWB, tempW, tempB;
// 3288     uint8 tempminus;
// 3289     uint8 successRow = MaxValUint8;
        MOV      R10,#+255
// 3290     
// 3291     int temp001;
// 3292     
// 3293     //左黑线提取前的参数初始化赋值
// 3294     BlackGetLeftParaInit();
        BL       BlackGetLeftParaInit
// 3295     
// 3296     //第1阶段。这1阶段有可能会返回黑线提取失败
// 3297     
// 3298     //每幅有效图像的线头的3个阈值单独储存。Step1Scan前调用前一幅有效图像保存的3个阈值。
// 3299     LimitLeftWB = LimitLeftHeadWB;
        LDR.W    R0,??DataTable25_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable25_3
        STRB     R0,[R1, #+0]
// 3300     LimitLeftW = LimitLeftHeadW;
        LDR.W    R0,??DataTable25_4
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable25_5
        STRB     R0,[R1, #+0]
// 3301     LimitLeftB = LimitLeftHeadB;
        LDR.W    R0,??DataTable25_6
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable25_7
        STRB     R0,[R1, #+0]
// 3302     
// 3303     temp = BlackGetLeftStep1Scan(CameraHight - 1, CameraHight - BlackStep1Size - 1, 1);
        MOVS     R2,#+1
        MOVS     R1,#+11
        MOVS     R0,#+59
        BL       BlackGetLeftStep1Scan
        MOVS     R4,R0
// 3304     BlackLeftStep1ScanRow = temp;
        LDR.W    R0,??DataTable25_8
        STRB     R4,[R0, #+0]
// 3305     
// 3306     //右线开始扫描的情况下，左线尾比右线头高，直接返回失败。增加后面这个条件是为了防止十字误判。
// 3307     if(
// 3308        (BlackGetPreDir == 1)
// 3309      &&(temp <= BlackRightHeadLine)
// 3310      &&(BlackRightHeadLine < CameraHight - 7)
// 3311       )
        LDR.W    R0,??DataTable25_9
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackGetLeft_0
        LDR.W    R0,??DataTable25_10
        LDRB     R0,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R0,R4
        BCC.N    ??BlackGetLeft_0
        LDR.W    R0,??DataTable25_10
        LDRB     R0,[R0, #+0]
        CMP      R0,#+53
        BGE.N    ??BlackGetLeft_0
// 3312     {
// 3313         BlackLeftLoc[temp][0] = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable24_10
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 3314         BlackLeftLoc[temp - 1][0] = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable24_10
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #-3]
// 3315         return 0;
        MOVS     R0,#+0
        B.N      ??BlackGetLeft_1
// 3316     }
// 3317     else
// 3318     {
// 3319     }
// 3320     
// 3321     if(temp == MaxValUint8)
??BlackGetLeft_0:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+255
        BNE.N    ??BlackGetLeft_2
// 3322     {
// 3323       return 0;
        MOVS     R0,#+0
        B.N      ??BlackGetLeft_1
// 3324     }    
// 3325     else 
// 3326     {     
// 3327               
// 3328       //每幅有效图像的线头的3个阈值单独储存。若线头提取成功，则该幅图像有效，线头3个阈值更新。
// 3329       LimitLeftHeadWB = LimitLeftWB;
??BlackGetLeft_2:
        LDR.W    R0,??DataTable25_3
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable25_2
        STRB     R0,[R1, #+0]
// 3330       LimitLeftHeadW = LimitLeftW;
        LDR.W    R0,??DataTable25_5
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable25_4
        STRB     R0,[R1, #+0]
// 3331       LimitLeftHeadB = LimitLeftB;
        LDR.W    R0,??DataTable25_7
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable25_6
        STRB     R0,[R1, #+0]
// 3332       
// 3333       row = temp;
        MOVS     R5,R4
// 3334       //如果起始线头的位置非常高，就认为是十字的前两个角，需要进入第4阶段向后补线。    
// 3335       if(row < CameraHight - BlackLeftBackLineStart)
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+12
        BGE.N    ??BlackGetLeft_3
// 3336       {
// 3337         BlackLeftStep4Flag = 1;               //默认为失败
        MOVS     R0,#+1
        LDR.W    R1,??DataTable23_2
        STRB     R0,[R1, #+0]
// 3338         BlackLeftStep4StartLine = row;
        LDR.W    R0,??DataTable25
        STRB     R5,[R0, #+0]
// 3339       }
// 3340     }
// 3341     
// 3342     //第2阶段。到了这一阶段，已经不会返回黑线提取失败 
// 3343     //temp为预测的黑点位置   
// 3344 
// 3345     //对预测值的大小限定
// 3346     temp = BoundaryLimitRe(BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0], 
// 3347                            0, 
// 3348                            CameraRealWidth - 1);
??BlackGetLeft_3:
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable24_10
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+3
        MLA      R0,R3,R5,R0
        LDRB     R0,[R0, #-3]
        LDR.W    R3,??DataTable24_10
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R5,R3
        LDRB     R3,[R3, #-3]
        UXTAB    R0,R3,R0
        LDR.W    R3,??DataTable24_10
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R5,R3
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
        MOVS     R4,R0
// 3349     //预测值更新后就刷新一次堆栈，堆栈顶部丢失。
// 3350     BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
        LDR.W    R0,??DataTable24_14
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable24_13
        STRB     R0,[R1, #+0]
// 3351     BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
        LDR.W    R0,??DataTable25_11
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable24_14
        STRB     R0,[R1, #+0]
// 3352     BlackLeftWinPredictStore2 = temp;
        LDR.W    R0,??DataTable25_11
        STRB     R4,[R0, #+0]
// 3353 
// 3354     index = 0;
        MOVS     R8,#+0
// 3355     index1 = 0;
        MOVS     R9,#+0
// 3356     
// 3357     GapCount = 0;  //连续多少行没有采集到黑线
        MOVS     R6,#+0
// 3358     successRow = MaxValUint8; //记录最后一次成功的行
        MOV      R10,#+255
// 3359     //从最近的认证行到取最远的行
// 3360     for(row -= 2; ; row -= 2)
        SUBS     R5,R5,#+2
        B.N      ??BlackGetLeft_4
??BlackGetLeft_5:
        SUBS     R5,R5,#+2
// 3361     {      
// 3362       //连续2行检测黑点。
// 3363       temp1 = BlackGetLeftStep2Win(row, BlackLeftWinVal, temp, 1);
??BlackGetLeft_4:
        MOVS     R3,#+1
        MOVS     R2,R4
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,#+15
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetLeftStep2Win
        MOV      R11,R0
// 3364       temp2 = BlackGetLeftStep2Win(row-1, BlackLeftWinVal, temp, 2);
        MOVS     R3,#+2
        MOVS     R2,R4
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,#+15
        SUBS     R0,R5,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetLeftStep2Win
// 3365       
// 3366       temp3 = (
// 3367               (temp1 == 0)
// 3368             &&(temp2 == 0)
// 3369             //&&(BlackLeftStep4Flag == 0)
// 3370               );
        UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
        CMP      R11,#+0
        BNE.N    ??BlackGetLeft_6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackGetLeft_6
        MOVS     R1,#+1
        B.N      ??BlackGetLeft_7
??BlackGetLeft_6:
        MOVS     R1,#+0
// 3371       
// 3372       //若连续2行黑点检测成功，则对3个阈值进行更新，且更新预测点位置。
// 3373       if(temp1 == 1 && temp2 == 1) 
??BlackGetLeft_7:
        UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
        CMP      R11,#+1
        BNE.W    ??BlackGetLeft_8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.W    ??BlackGetLeft_8
// 3374       {
// 3375         //只要连续采集到双黑线，则两个标志位重置为0.
// 3376         index = 0;
        MOVS     R8,#+0
// 3377         index1 = 0;
        MOVS     R9,#+0
// 3378         successRow = row;
        MOV      R10,R5
// 3379         
// 3380         //差值的处理，留有裕度，且有上下界。
// 3381         tempWB = (BlackLeftRealWB[0] + BlackLeftRealWB[1]) / 2 - LimitLeftWBMargin; 
        LDR.W    R0,??DataTable25_12
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable25_12
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+20
// 3382         if(tempWB < LimitLeftWBMin) tempWB = LimitLeftWBMin;
        LDR.W    R1,??DataTable25_13
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackGetLeft_9
        LDR.W    R0,??DataTable25_13
        LDRB     R0,[R0, #+0]
        B.N      ??BlackGetLeft_10
// 3383         else if(tempWB > LimitLeftWBMax) tempWB = LimitLeftWBMax;
??BlackGetLeft_9:
        LDR.W    R1,??DataTable25_14
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackGetLeft_10
        LDR.W    R0,??DataTable25_14
        LDRB     R0,[R0, #+0]
// 3384         else ;
// 3385         LimitLeftWB = tempWB;
??BlackGetLeft_10:
        LDR.W    R1,??DataTable25_3
        STRB     R0,[R1, #+0]
// 3386         
// 3387         //白点的处理，留有裕度，且有上下界。
// 3388         tempW = (BlackLeftRealW[0] + BlackLeftRealW[1]) / 2 - LimitLeftWMargin;
        LDR.W    R0,??DataTable25_15
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable25_15
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+40
// 3389         if(tempW < LimitLeftWMin) tempW = LimitLeftWMin;
        LDR.W    R1,??DataTable25_16
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackGetLeft_11
        LDR.W    R0,??DataTable25_16
        LDRB     R0,[R0, #+0]
        B.N      ??BlackGetLeft_12
// 3390         else if(tempW > LimitLeftWMax) tempW = LimitLeftWMax;
??BlackGetLeft_11:
        LDR.W    R1,??DataTable25_17
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackGetLeft_12
        LDR.W    R0,??DataTable25_17
        LDRB     R0,[R0, #+0]
// 3391         else ;
// 3392         LimitLeftW = tempW;
??BlackGetLeft_12:
        LDR.W    R1,??DataTable25_5
        STRB     R0,[R1, #+0]
// 3393         
// 3394         //黑点的处理，留有裕度，且有上下界。
// 3395         tempB = (BlackLeftRealB[0] + BlackLeftRealB[1]) / 2 + LimitLeftBMargin;
        LDR.W    R0,??DataTable25_18
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable25_18
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        ADDS     R0,R0,#+35
// 3396         if(tempB < LimitLeftBMin) tempB = LimitLeftBMin;
        LDR.W    R1,??DataTable25_19
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackGetLeft_13
        LDR.W    R0,??DataTable25_19
        LDRB     R0,[R0, #+0]
        B.N      ??BlackGetLeft_14
// 3397         else if(tempB > LimitLeftBMax) tempB = LimitLeftBMax;
??BlackGetLeft_13:
        LDR.W    R1,??DataTable25_20
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackGetLeft_14
        LDR.W    R0,??DataTable25_20
        LDRB     R0,[R0, #+0]
// 3398         else ;
// 3399         //黑色阈值不能超过白色
// 3400         if(tempB >= LimitLeftW)
??BlackGetLeft_14:
        LDR.W    R1,??DataTable25_5
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCC.N    ??BlackGetLeft_15
// 3401         {
// 3402           tempB = LimitLeftW - 1;
        LDR.W    R0,??DataTable25_5
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
// 3403         }
// 3404         else
// 3405         {
// 3406         }
// 3407         LimitLeftB = tempB; 
??BlackGetLeft_15:
        LDR.W    R1,??DataTable25_7
        STRB     R0,[R1, #+0]
// 3408          
// 3409         //对预测值的大小限定
// 3410         temp = BoundaryLimitRe(BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0], 
// 3411                                0, 
// 3412                                CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable24_10
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+3
        MLA      R0,R3,R5,R0
        LDRB     R0,[R0, #-3]
        LDR.W    R3,??DataTable24_10
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R5,R3
        LDRB     R3,[R3, #-3]
        UXTAB    R0,R3,R0
        LDR.W    R3,??DataTable24_10
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R5,R3
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
        MOVS     R4,R0
// 3413         
// 3414         //预测值更新后就刷新一次堆栈，堆栈顶部丢失。
// 3415         BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
        LDR.W    R0,??DataTable24_14
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable24_13
        STRB     R0,[R1, #+0]
// 3416         BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
        LDR.W    R0,??DataTable25_11
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable24_14
        STRB     R0,[R1, #+0]
// 3417         BlackLeftWinPredictStore2 = temp;
        LDR.W    R0,??DataTable25_11
        STRB     R4,[R0, #+0]
        B.N      ??BlackGetLeft_16
// 3418       }
// 3419       //如果没能连续两行检测黑点成功，原本打算用原位置的预测点，后来发现效果不好，所以决定按预测点的趋势走。
// 3420       //如果连续两行均采集黑线失败，则记数，记到一定值就再来一次Step1
// 3421       //如果第4阶段检测标志置位，就不用进入十字检测了。
// 3422       else if(temp3 == 1)
??BlackGetLeft_8:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.W    ??BlackGetLeft_17
// 3423       {        
// 3424         //若上一幅图是单线，则不允许开启十字。
// 3425         if(SingleBlackLastAllFlag == 1) break;        
        LDR.W    R0,??DataTable23_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.W    ??BlackGetLeft_18
// 3426         //直角黑块锁存期间，为了防止一边十字成功另一边不成功造成的中心线倾斜，所以不允许开启十字。
// 3427         if(AngleZoneConfirmLockFlag == 1) break;
??BlackGetLeft_19:
        LDR.W    R0,??DataTable25_21
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.W    ??BlackGetLeft_18
// 3428         
// 3429         //第一次检测到双线失败时，最后的几条线可能已经不太正确。
// 3430         if(index1 == 0)
??BlackGetLeft_20:
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+0
        BNE.N    ??BlackGetLeft_21
// 3431         {
// 3432           //如果储存的3个值趋势相同，也就是变化量同号，那么就按正常的来。否则就认为最后一个值已经错误。
// 3433           if(row <= CameraHight - 3)
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+58
        BGE.N    ??BlackGetLeft_22
// 3434           {
// 3435               //若前面两行没有被大跳变删除掉。
// 3436               if (BlackLeftLoc[row + 1][0] != MaxValUint8 && BlackLeftLoc[row + 2][0] != MaxValUint8)
        LDR.W    R0,??DataTable24_10
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+3]
        CMP      R0,#+255
        BEQ.N    ??BlackGetLeft_23
        LDR.W    R0,??DataTable24_10
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+6]
        CMP      R0,#+255
        BEQ.N    ??BlackGetLeft_23
// 3437               {
// 3438 
// 3439 
// 3440                   //如果黑线点够，最好还是根据实际的黑点来更新窗口值。
// 3441                   tempminus = BoundaryLimitRe(BlackLeftLoc[row + 1][0] * 3 - BlackLeftLoc[row + 2][0] * 2,
// 3442                                               0,
// 3443                                               CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable24_10
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+3
        MLA      R0,R3,R5,R0
        LDRB     R0,[R0, #+3]
        MOVS     R3,#+3
        MULS     R0,R3,R0
        LDR.W    R3,??DataTable24_10
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R5,R3
        LDRB     R3,[R3, #+6]
        SUBS     R0,R0,R3, LSL #+1
        BL       BoundaryLimitRe
// 3444                   //斜入十字不管怎么摆，左十字的上段线一定在下段线的右边。
// 3445                   tempminus = MaxRe(tempminus, BlackLeftLoc[row + 1][0]);
        LDR.W    R1,??DataTable24_10
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R5,R1
        LDRB     R1,[R1, #+3]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       MaxRe
        B.N      ??BlackGetLeft_24
// 3446               }
// 3447               else
// 3448               {
// 3449                   temp001 = BlackLeftWinPredictStore1 - BlackLeftWinPredictStore0;
??BlackGetLeft_23:
        LDR.W    R0,??DataTable24_14
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable24_13
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
// 3450                   BlackLeftWinPredictStore0 += temp001;
        LDR.W    R1,??DataTable24_13
        LDRB     R1,[R1, #+0]
        ADDS     R1,R0,R1
        LDR.W    R2,??DataTable24_13
        STRB     R1,[R2, #+0]
// 3451                   BlackLeftWinPredictStore1 += temp001;
        LDR.W    R1,??DataTable24_14
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1
        LDR.W    R1,??DataTable24_14
        STRB     R0,[R1, #+0]
// 3452                   BlackLeftWinPredictStore2 = BlackLeftWinPredictStore1 + BlackLeftWinPredictStore1 - BlackLeftWinPredictStore0;
        LDR.W    R0,??DataTable24_14
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable24_14
        LDRB     R1,[R1, #+0]
        ADDS     R0,R1,R0
        LDR.W    R1,??DataTable24_13
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable25_11
        STRB     R0,[R1, #+0]
// 3453                   tempminus = BoundaryLimitRe(BlackLeftWinPredictStore2 + BlackLeftWinPredictStore2 - BlackLeftWinPredictStore1,
// 3454                                               0,
// 3455                                               CameraRealWidth - 1);       
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable25_11
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable25_11
        LDRB     R3,[R3, #+0]
        ADDS     R0,R3,R0
        LDR.W    R3,??DataTable24_14
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
// 3456               }
// 3457           }
// 3458           else
// 3459           {
// 3460               //理论上不会走到这里。
// 3461               return 0;
// 3462           }
// 3463           
// 3464           //进来一次后就再也不进来了。
// 3465           index1++;          
??BlackGetLeft_24:
        ADDS     R9,R9,#+1
        B.N      ??BlackGetLeft_25
??BlackGetLeft_22:
        MOVS     R0,#+0
        B.N      ??BlackGetLeft_1
// 3466         }
// 3467         else
// 3468         {
// 3469           //预测点按趋势走也要限幅。
// 3470           tempminus = BoundaryLimitRe(BlackLeftWinPredictStore2 + BlackLeftWinPredictStore2 - BlackLeftWinPredictStore1,
// 3471                                       0,
// 3472                                       CameraRealWidth - 1);          
??BlackGetLeft_21:
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable25_11
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable25_11
        LDRB     R3,[R3, #+0]
        ADDS     R0,R3,R0
        LDR.W    R3,??DataTable24_14
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
// 3473         }
// 3474         //temp在这里表示窗口预测点位置。
// 3475         temp = tempminus;
??BlackGetLeft_25:
        MOVS     R4,R0
// 3476         BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
        LDR.W    R0,??DataTable24_14
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable24_13
        STRB     R0,[R1, #+0]
// 3477         BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
        LDR.W    R0,??DataTable25_11
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable24_14
        STRB     R0,[R1, #+0]
// 3478         BlackLeftWinPredictStore2 = temp;
        LDR.W    R0,??DataTable25_11
        STRB     R4,[R0, #+0]
// 3479               
// 3480         //Row1RealLastLine记录第1段黑线的最后一行。
// 3481         if(index == 0)
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+0
        BNE.N    ??BlackGetLeft_26
// 3482         {
// 3483           //进来一次后，就再也不会进来了。
// 3484           index++;
        ADDS     R8,R8,#+1
// 3485           for(i = row; i <= CameraHight - 1; i++)
        MOVS     R0,R5
        B.N      ??BlackGetLeft_27
??BlackGetLeft_28:
        ADDS     R0,R0,#+1
??BlackGetLeft_27:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+60
        BGE.N    ??BlackGetLeft_29
// 3486           {
// 3487             if(BlackLeftLoc[i][0] != MaxValUint8)
        LDR.W    R1,??DataTable24_10
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BEQ.N    ??BlackGetLeft_28
// 3488             {
// 3489               Row1RealLastLine = i;
        MOVS     R7,R0
// 3490               break;
// 3491             }
// 3492           }
// 3493           if(Row1RealLastLine >= CameraHight - 1)
??BlackGetLeft_29:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+59
        BLT.N    ??BlackGetLeft_30
// 3494           {
// 3495             Row1RealLastLine = CameraHight - 1;
        MOVS     R7,#+59
// 3496           }
// 3497           else
// 3498           {
// 3499           }
// 3500           //记录为全局变量
// 3501           BlackLeftRow1RealLastLine = Row1RealLastLine;
??BlackGetLeft_30:
        LDR.W    R0,??DataTable25_22
        STRB     R7,[R0, #+0]
// 3502         }
// 3503         
// 3504         GapCount += 2;
??BlackGetLeft_26:
        ADDS     R6,R6,#+2
// 3505         if (successRow != MaxValUint8 && BlackLeftLoc[successRow][0]<10 && BlackLeftLoc[successRow - 1][0]<10) { }
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        CMP      R10,#+255
        BEQ.N    ??BlackGetLeft_31
        LDR.W    R0,??DataTable24_10
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R10,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+10
        BGE.N    ??BlackGetLeft_31
        LDR.W    R0,??DataTable24_10
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R10,R0
        LDRB     R0,[R0, #-3]
        CMP      R0,#+10
        BLT.W    ??BlackGetLeft_16
// 3506         ///////////////////////////////进入十字重新检测的条件还要再严格一些，减少没必要的时间，比如说前面最多只允许检测到多少行。
// 3507         else if(GapCount > BlackCrossGapLine)
??BlackGetLeft_31:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+13
        BLT.N    ??BlackGetLeft_32
// 3508         {
// 3509           //再检测时的行太远了，就没必要检测了。
// 3510           if(row < BlackLeftCrossTooLowLine)
        LDR.W    R0,??DataTable25_23
        LDRB     R0,[R0, #+0]
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,R0
        BCS.N    ??BlackGetLeft_33
// 3511           {
// 3512             //扫屁股。
// 3513             for(i = row; ; i--)
        MOVS     R0,R5
        B.N      ??BlackGetLeft_34
??BlackGetLeft_35:
        SUBS     R0,R0,#+1
// 3514             {
// 3515               BlackLeftLoc[i][0] = MaxValUint8;
??BlackGetLeft_34:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable24_10
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 3516               if(i == 0) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackGetLeft_35
// 3517             }
// 3518             //跳出来。
// 3519             break;
        B.N      ??BlackGetLeft_18
// 3520           }
// 3521           else
// 3522           {
// 3523           }
// 3524           
// 3525           //进入十字重新检测后，就不允许出现第4阶段向后补线的情况。
// 3526           if(BlackLeftStep4Flag == 1)
??BlackGetLeft_33:
        LDR.N    R0,??DataTable23_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackGetLeft_36
// 3527           {
// 3528             BlackLeftStep4Flag = 3;   //向后补线出错。
        MOVS     R0,#+3
        LDR.N    R1,??DataTable23_2
        STRB     R0,[R1, #+0]
// 3529           }
// 3530           else
// 3531           {
// 3532           }
// 3533           
// 3534           //十字再检测的话，Step1Scan的线头必须够近。
// 3535           //最后只剩第0，1行没有检测的话，就不用开启十字再检测了。
// 3536           if(BlackLeftStep1ScanRow >= CameraHight - 3 && row > 3)
??BlackGetLeft_36:
        LDR.W    R0,??DataTable25_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+57
        BLT.N    ??BlackGetLeft_37
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+4
        BLT.N    ??BlackGetLeft_37
// 3537           {            
// 3538             //正常的十字再检测。
// 3539             if(BlackLeftAgainForCross(row - 2, 1, Row1RealLastLine, temp) == 0)
        MOVS     R3,R4
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R2,R7
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,#+1
        SUBS     R0,R5,#+2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackLeftAgainForCross
        CMP      R0,#+0
        BNE.N    ??BlackGetLeft_38
// 3540             {
// 3541               BlackLeftCrossDone = 1;  //十字检测失败           
        MOVS     R0,#+1
        LDR.W    R1,??DataTable24_1
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetLeft_39
// 3542             }
// 3543             else
// 3544             {
// 3545               BlackLeftCrossDone = 2;  //十字检测成功
??BlackGetLeft_38:
        MOVS     R0,#+2
        LDR.W    R1,??DataTable24_1
        STRB     R0,[R1, #+0]
// 3546             }
// 3547             break;  //十字再检测里会开窗检测到指定的最后一行，所以不用再循环了，直接跳出
??BlackGetLeft_39:
        B.N      ??BlackGetLeft_18
// 3548           }
// 3549           //线头太远，或者只剩第0，1行的时候，直接break就好，远处的行在初始化时已经置为无效值。
// 3550           else
// 3551           {
// 3552             break;
??BlackGetLeft_37:
        B.N      ??BlackGetLeft_18
// 3553           }
// 3554           
// 3555         }
// 3556         else
// 3557         {
// 3558           BlackLeftCrossDone = 0;   //十字检测未进入
??BlackGetLeft_32:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable24_1
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetLeft_16
// 3559         }
// 3560       }
// 3561       //连续两线只有一线检测成功的情况，仍然要按趋势更新窗口预测值。
// 3562       else if((temp1 == 1 && temp2 == 0) || (temp1 == 0 && temp2 == 1)) 
??BlackGetLeft_17:
        UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
        CMP      R11,#+1
        BNE.N    ??BlackGetLeft_40
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BEQ.N    ??BlackGetLeft_41
??BlackGetLeft_40:
        UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
        CMP      R11,#+0
        BNE.W    ??BlackGetLeft_16
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.W    ??BlackGetLeft_16
// 3563       {        
// 3564         
// 3565         //第一次检测到有单条线失败时，最后的几条线可能已经不太正确。
// 3566         if(index1 == 0)
??BlackGetLeft_41:
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+0
        BNE.N    ??BlackGetLeft_42
// 3567         {
// 3568           //如果储存的3个值趋势相同，也就是变化量同号，那么就按正常的来。否则就认为最后一个值已经错误。
// 3569           if(row <= CameraHight - 3)
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+58
        BGE.N    ??BlackGetLeft_43
// 3570           {
// 3571               //若前面两行没有被大跳变删除掉。
// 3572               if (BlackLeftLoc[row + 1][0] != MaxValUint8 && BlackLeftLoc[row + 2][0] != MaxValUint8)
        LDR.W    R0,??DataTable24_10
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+3]
        CMP      R0,#+255
        BEQ.N    ??BlackGetLeft_44
        LDR.W    R0,??DataTable24_10
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+6]
        CMP      R0,#+255
        BEQ.N    ??BlackGetLeft_44
// 3573               {
// 3574 
// 3575 
// 3576                   //如果黑线点够，最好还是根据实际的黑点来更新窗口值。
// 3577                   tempminus = BoundaryLimitRe(BlackLeftLoc[row + 1][0] * 3 - BlackLeftLoc[row + 2][0] * 2,
// 3578                                               0,
// 3579                                               CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable24_10
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+3
        MLA      R0,R3,R5,R0
        LDRB     R0,[R0, #+3]
        MOVS     R3,#+3
        MULS     R0,R3,R0
        LDR.W    R3,??DataTable24_10
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R5,R3
        LDRB     R3,[R3, #+6]
        SUBS     R0,R0,R3, LSL #+1
        BL       BoundaryLimitRe
// 3580                   //斜入十字不管怎么摆，左十字的上段线一定在下段线的右边。
// 3581                   tempminus = MaxRe(tempminus, BlackLeftLoc[row + 1][0]);
        LDR.W    R1,??DataTable24_10
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R5,R1
        LDRB     R1,[R1, #+3]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       MaxRe
        B.N      ??BlackGetLeft_45
// 3582               }
// 3583               else
// 3584               {
// 3585                   temp001 = BlackLeftWinPredictStore1 - BlackLeftWinPredictStore0;
??BlackGetLeft_44:
        LDR.W    R0,??DataTable24_14
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable24_13
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
// 3586                   BlackLeftWinPredictStore0 += temp001;
        LDR.W    R1,??DataTable24_13
        LDRB     R1,[R1, #+0]
        ADDS     R1,R0,R1
        LDR.W    R2,??DataTable24_13
        STRB     R1,[R2, #+0]
// 3587                   BlackLeftWinPredictStore1 += temp001;
        LDR.W    R1,??DataTable24_14
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1
        LDR.W    R1,??DataTable24_14
        STRB     R0,[R1, #+0]
// 3588                   BlackLeftWinPredictStore2 = BlackLeftWinPredictStore1 + BlackLeftWinPredictStore1 - BlackLeftWinPredictStore0;
        LDR.W    R0,??DataTable24_14
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable24_14
        LDRB     R1,[R1, #+0]
        ADDS     R0,R1,R0
        LDR.W    R1,??DataTable24_13
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable25_11
        STRB     R0,[R1, #+0]
// 3589                   tempminus = BoundaryLimitRe(BlackLeftWinPredictStore2 + BlackLeftWinPredictStore2 - BlackLeftWinPredictStore1,
// 3590                                               0,
// 3591                                               CameraRealWidth - 1);       
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable25_11
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable25_11
        LDRB     R3,[R3, #+0]
        ADDS     R0,R3,R0
        LDR.W    R3,??DataTable24_14
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
// 3592               }
// 3593           }
// 3594           else
// 3595           {
// 3596               //理论上不会走到这里。
// 3597               return 0;
// 3598           }
// 3599           
// 3600           //进来一次后就再也不进来了。
// 3601           index1++;          
??BlackGetLeft_45:
        ADDS     R9,R9,#+1
        B.N      ??BlackGetLeft_46
??BlackGetLeft_43:
        MOVS     R0,#+0
        B.N      ??BlackGetLeft_1
// 3602         }
// 3603         else
// 3604         {
// 3605           //预测点按趋势走也要限幅。
// 3606           tempminus = BoundaryLimitRe(BlackLeftWinPredictStore2 + BlackLeftWinPredictStore2 - BlackLeftWinPredictStore1,
// 3607                                       0,
// 3608                                       CameraRealWidth - 1);          
??BlackGetLeft_42:
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable25_11
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable25_11
        LDRB     R3,[R3, #+0]
        ADDS     R0,R3,R0
        LDR.W    R3,??DataTable24_14
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
// 3609         }
// 3610         //temp在这里表示窗口预测点位置。
// 3611         temp = tempminus;
??BlackGetLeft_46:
        MOVS     R4,R0
// 3612         BlackLeftWinPredictStore0 = BlackLeftWinPredictStore1;
        LDR.W    R0,??DataTable24_14
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable24_13
        STRB     R0,[R1, #+0]
// 3613         BlackLeftWinPredictStore1 = BlackLeftWinPredictStore2;
        LDR.W    R0,??DataTable25_11
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable24_14
        STRB     R0,[R1, #+0]
// 3614         BlackLeftWinPredictStore2 = temp;
        LDR.W    R0,??DataTable25_11
        STRB     R4,[R0, #+0]
// 3615       }
// 3616       //理论上不会走到这里。
// 3617       else
// 3618       {
// 3619       }
// 3620       
// 3621       if((row == 0) || (row == 1)) break;
??BlackGetLeft_16:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BEQ.N    ??BlackGetLeft_47
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+1
        BNE.W    ??BlackGetLeft_5
// 3622       
// 3623     }
// 3624     
// 3625     //第4阶段，采集到十字的前两个角，向后补线。这里有浮点运算，要严格控制调用。
// 3626     //向后补线时，必须考虑的就是十字外尾的问题。
// 3627     if(BlackLeftStep4Flag == 1)
??BlackGetLeft_47:
??BlackGetLeft_18:
        LDR.N    R0,??DataTable23_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackGetLeft_48
// 3628     {
// 3629       if(BlackLeftStep4BackLine(BlackLeftStep4StartLine, 0) == 0)
        MOVS     R1,#+0
        LDR.W    R0,??DataTable25
        LDRB     R0,[R0, #+0]
        BL       BlackLeftStep4BackLine
        CMP      R0,#+0
        BNE.N    ??BlackGetLeft_49
// 3630       {
// 3631         BlackLeftStep4Flag = 1;    //向后补线失败，有可能是点取不够，有可能是斜率不对。
        MOVS     R0,#+1
        LDR.N    R1,??DataTable23_2
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetLeft_50
// 3632         //return 0;  
// 3633       }
// 3634       else
// 3635       {
// 3636         BlackLeftStep4Flag = 2;    // 向后补线成功。
??BlackGetLeft_49:
        MOVS     R0,#+2
        LDR.N    R1,??DataTable23_2
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetLeft_50
// 3637       }
// 3638     }
// 3639     //BlackLeftStep4Flag出错的情况。
// 3640     else if(BlackLeftStep4Flag == 3)
??BlackGetLeft_48:
        LDR.N    R0,??DataTable23_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+3
        BNE.N    ??BlackGetLeft_50
// 3641     {
// 3642       //检查出错到底是为什么
// 3643       if(BlackLeftStep4ErrorCheck() == 1)
        BL       BlackLeftStep4ErrorCheck
        CMP      R0,#+1
        BNE.N    ??BlackGetLeft_50
// 3644       {        
// 3645         if(BlackLeftStep4BackLine(BlackLeftStep4StartLine, 0) == 0)
        MOVS     R1,#+0
        LDR.W    R0,??DataTable25
        LDRB     R0,[R0, #+0]
        BL       BlackLeftStep4BackLine
        CMP      R0,#+0
        BEQ.N    ??BlackGetLeft_50
// 3646         {
// 3647           //BlackLeftStep4Flag = 1;    //向后补线失败，有可能是点取不够，有可能是斜率不对。
// 3648           //return 0;  
// 3649         }
// 3650         else
// 3651         {
// 3652           BlackLeftStep4Flag = 2;    // 向后补线成功。
        MOVS     R0,#+2
        LDR.N    R1,??DataTable23_2
        STRB     R0,[R1, #+0]
// 3653         }
// 3654       }
// 3655       else
// 3656       {
// 3657       }
// 3658       
// 3659     }
// 3660     //BlackLeftStep4Flag未进入的情况。
// 3661     else
// 3662     {       
// 3663     }
// 3664 
// 3665     return 1;
??BlackGetLeft_50:
        MOVS     R0,#+1
??BlackGetLeft_1:
        POP      {R1,R4-R11,PC}   ;; return
// 3666 }
// 3667 
// 3668 
// 3669 
// 3670 //====================================右右右右右右右右右右右右右右右右右============================
// 3671 
// 3672 //======================================================================
// 3673 //函数名：BlackRightRealClear
// 3674 //功  能：右黑线提取中，对3个关键值的实际值清零
// 3675 //参  数：无
// 3676 //返  回：无
// 3677 //影  响：BlackRightRealWB[], BlackRightRealW[], BlackRightRealB[]
// 3678 //说  明：
// 3679 //      
// 3680 //             
// 3681 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 3682 void BlackRightRealClear(void)
// 3683 {
// 3684     BlackRightRealWB[0] = 0;
BlackRightRealClear:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable26
        STRB     R0,[R1, #+0]
// 3685     BlackRightRealWB[1] = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable26
        STRB     R0,[R1, #+1]
// 3686     BlackRightRealW[0] = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable26_1
        STRB     R0,[R1, #+0]
// 3687     BlackRightRealW[1] = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable26_1
        STRB     R0,[R1, #+1]
// 3688     BlackRightRealB[0] = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable26_2
        STRB     R0,[R1, #+0]
// 3689     BlackRightRealB[1] = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable26_2
        STRB     R0,[R1, #+1]
// 3690 }
        BX       LR               ;; return
// 3691 
// 3692 
// 3693 
// 3694 
// 3695 //黑线提取成功，找右黑线的线头线尾。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 3696 uint8 BlackRightHeadEndSearch(void)
// 3697 {
// 3698   uint8 i;
// 3699   //右线线头和线尾的查找
// 3700   if(BlackRightDone == 1)
BlackRightHeadEndSearch:
        LDR.W    R0,??DataTable26_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackRightHeadEndSearch_0
// 3701   { //右线线头的查找。
// 3702     for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??BlackRightHeadEndSearch_1
??BlackRightHeadEndSearch_2:
        ADDS     R0,R0,#+1
// 3703     { //找到了右线线头。
// 3704       if(BlackRightLoc[i][0] != MaxValUint8)
??BlackRightHeadEndSearch_1:
        LDR.W    R1,??DataTable26_4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BEQ.N    ??BlackRightHeadEndSearch_3
// 3705       {
// 3706         BlackRightHeadLine = i;
        LDR.W    R1,??DataTable25_10
        STRB     R0,[R1, #+0]
// 3707         break;
        B.N      ??BlackRightHeadEndSearch_4
// 3708       }
// 3709       //直到最近一行仍没有找到线头，则查找失败。
// 3710       if(i == CameraHight - 1) 
??BlackRightHeadEndSearch_3:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??BlackRightHeadEndSearch_2
// 3711       {
// 3712         BlackRightHeadLine = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable25_10
        STRB     R0,[R1, #+0]
// 3713         break;
// 3714       }
// 3715     }
// 3716     //若右线线头查找失败，就不用找右线线尾了。
// 3717     if(BlackRightHeadLine == MaxValUint8)
??BlackRightHeadEndSearch_4:
        LDR.W    R0,??DataTable25_10
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??BlackRightHeadEndSearch_5
// 3718     {
// 3719       BlackRightEndLine = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable26_5
        STRB     R0,[R1, #+0]
// 3720       BlackRightDone = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable26_3
        STRB     R0,[R1, #+0]
        B.N      ??BlackRightHeadEndSearch_6
// 3721     }
// 3722     //若右线线头查找成功，则开始找右线线尾。
// 3723     else
// 3724     {
// 3725       for(i = CameraHight - 1; ; i--)
??BlackRightHeadEndSearch_5:
        MOVS     R0,#+59
        B.N      ??BlackRightHeadEndSearch_7
??BlackRightHeadEndSearch_8:
        SUBS     R0,R0,#+1
// 3726       { //找到了右线的线尾。
// 3727         if(BlackRightLoc[i][0] != MaxValUint8)
??BlackRightHeadEndSearch_7:
        LDR.W    R1,??DataTable26_4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BEQ.N    ??BlackRightHeadEndSearch_9
// 3728         {
// 3729           BlackRightEndLine = i;
        LDR.W    R1,??DataTable26_5
        STRB     R0,[R1, #+0]
// 3730           break;
        B.N      ??BlackRightHeadEndSearch_6
// 3731         }
// 3732         //没找到右线的线尾。右线不可能有头无尾，所以均置无效值。
// 3733         if(i == BlackRightHeadLine) 
??BlackRightHeadEndSearch_9:
        LDR.W    R1,??DataTable25_10
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BNE.N    ??BlackRightHeadEndSearch_8
// 3734         {
// 3735           BlackRightHeadLine = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable25_10
        STRB     R0,[R1, #+0]
// 3736           BlackRightEndLine = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable26_5
        STRB     R0,[R1, #+0]
// 3737           break;
        B.N      ??BlackRightHeadEndSearch_6
// 3738         }
// 3739       }
// 3740     }
// 3741   }
// 3742   //若右线黑线提取失败，就不用找线头和线尾了。
// 3743   else
// 3744   {
// 3745     BlackRightHeadLine = MaxValUint8;
??BlackRightHeadEndSearch_0:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable25_10
        STRB     R0,[R1, #+0]
// 3746     BlackRightEndLine = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable26_5
        STRB     R0,[R1, #+0]
// 3747   }
// 3748   
// 3749   //本幅图像有单线时，删掉最远一个点。
// 3750   if(SingleBlackAllFlag == 1)
??BlackRightHeadEndSearch_6:
        LDR.N    R0,??DataTable23
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackRightHeadEndSearch_10
// 3751   {
// 3752     BlackRightLoc[BlackRightHeadLine][0] = MaxValUint8; //Udis数组不用改，因为线头线尾查找之后才轮到矫正函数。
        MOVS     R0,#+255
        LDR.W    R1,??DataTable26_4
        LDR.W    R2,??DataTable25_10
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+3
        MLA      R1,R3,R2,R1
        STRB     R0,[R1, #+0]
// 3753     BlackRightHeadLine += 1;
        LDR.W    R0,??DataTable25_10
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.W    R1,??DataTable25_10
        STRB     R0,[R1, #+0]
// 3754   }
// 3755   else
// 3756   {
// 3757   }
// 3758   
// 3759   return 1;
??BlackRightHeadEndSearch_10:
        MOVS     R0,#+1
        BX       LR               ;; return
// 3760 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23:
        DC32     SingleBlackAllFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_1:
        DC32     SlopeL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_2:
        DC32     BlackLeftStep4Flag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable23_3:
        DC32     SingleBlackLastAllFlag
// 3761 
// 3762 
// 3763 //======================================================================
// 3764 //函数名：BlackRightBigChangeCheck
// 3765 //功  能：右黑线提取时，大斜率检测。
// 3766 //参  数：newrow新加进来的需要判定是否有效的行, use调用时是连续2行的第几行。
// 3767 //返  回：1该行黑线成功，0该行黑线失败。
// 3768 //影  响：
// 3769 //说  明：1. 用来防止大斜率突变的坏点。
// 3770 //        2. 共5个行，取1，3，5行进行斜率计算，每进一个新行，移出一个旧行。
// 3771 //             
// 3772 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 3773 uint8 BlackRightBigChangeCheck(uint8 newrow, uint8 use)
// 3774 {
BlackRightBigChangeCheck:
        PUSH     {R4-R7}
// 3775   uint8 tempstorex, tempstorey;
// 3776   uint8 i;
// 3777   int32 tempslope1, tempslope2;
// 3778   
// 3779   //tempstorex用来储存将要移出的一行，用来检测失败时复原5行数组。
// 3780   tempstorex = BlackRightBigChangeNumx[0];
        LDR.W    R1,??DataTable27
        LDRB     R1,[R1, #+0]
// 3781   BlackRightBigChangeNumx[0] = BlackRightBigChangeNumx[1];
        LDR.W    R2,??DataTable27
        LDRB     R2,[R2, #+1]
        LDR.W    R3,??DataTable27
        STRB     R2,[R3, #+0]
// 3782   BlackRightBigChangeNumx[1] = BlackRightBigChangeNumx[2];
        LDR.W    R2,??DataTable27
        LDRB     R2,[R2, #+2]
        LDR.W    R3,??DataTable27
        STRB     R2,[R3, #+1]
// 3783   BlackRightBigChangeNumx[2] = BlackRightBigChangeNumx[3];
        LDR.W    R2,??DataTable27
        LDRB     R2,[R2, #+3]
        LDR.W    R3,??DataTable27
        STRB     R2,[R3, #+2]
// 3784   BlackRightBigChangeNumx[3] = BlackRightBigChangeNumx[4];
        LDR.W    R2,??DataTable27
        LDRB     R2,[R2, #+4]
        LDR.W    R3,??DataTable27
        STRB     R2,[R3, #+3]
// 3785   BlackRightBigChangeNumx[4] = newrow;
        LDR.W    R2,??DataTable27
        STRB     R0,[R2, #+4]
// 3786 
// 3787   tempstorey = BlackRightBigChangeNumy[0];
        LDR.W    R2,??DataTable26_6
        LDRB     R2,[R2, #+0]
// 3788   BlackRightBigChangeNumy[0] = BlackRightBigChangeNumy[1];
        LDR.W    R3,??DataTable26_6
        LDRB     R3,[R3, #+1]
        LDR.W    R4,??DataTable26_6
        STRB     R3,[R4, #+0]
// 3789   BlackRightBigChangeNumy[1] = BlackRightBigChangeNumy[2];
        LDR.W    R3,??DataTable26_6
        LDRB     R3,[R3, #+2]
        LDR.W    R4,??DataTable26_6
        STRB     R3,[R4, #+1]
// 3790   BlackRightBigChangeNumy[2] = BlackRightBigChangeNumy[3];
        LDR.W    R3,??DataTable26_6
        LDRB     R3,[R3, #+3]
        LDR.W    R4,??DataTable26_6
        STRB     R3,[R4, #+2]
// 3791   BlackRightBigChangeNumy[3] = BlackRightBigChangeNumy[4];
        LDR.W    R3,??DataTable26_6
        LDRB     R3,[R3, #+4]
        LDR.W    R4,??DataTable26_6
        STRB     R3,[R4, #+3]
// 3792   BlackRightBigChangeNumy[4] = BlackRightLoc[newrow][0];
        LDR.W    R3,??DataTable26_4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R0,R3
        LDRB     R3,[R3, #+0]
        LDR.W    R4,??DataTable26_6
        STRB     R3,[R4, #+4]
// 3793 
// 3794   //每幅图最多只进一次这个for循环，可以省时间。
// 3795   if(BlackRightBigChangeJumpFlag == 0)
        LDR.W    R3,??DataTable27_1
        LDRB     R3,[R3, #+0]
        CMP      R3,#+0
        BNE.N    ??BlackRightBigChangeCheck_0
// 3796   {  
// 3797     //储存数组的有效性判断，若不足5个数，则无法进行大斜率检测，直接返回成功。
// 3798     for(i = 0; i <= 4; i++)
        MOVS     R3,#+0
        B.N      ??BlackRightBigChangeCheck_1
??BlackRightBigChangeCheck_2:
        ADDS     R3,R3,#+1
??BlackRightBigChangeCheck_1:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+5
        BGE.N    ??BlackRightBigChangeCheck_3
// 3799     {
// 3800       if(BlackRightBigChangeNumx[i] == MaxValUint8)
        LDR.W    R4,??DataTable27
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R4,[R3, R4]
        CMP      R4,#+255
        BNE.N    ??BlackRightBigChangeCheck_2
// 3801       {
// 3802         return 1;
        MOVS     R0,#+1
        B.N      ??BlackRightBigChangeCheck_4
// 3803       }
// 3804     }
// 3805     //改变标志位，下次就不进来了。
// 3806     BlackRightBigChangeJumpFlag = 1;   
??BlackRightBigChangeCheck_3:
        MOVS     R3,#+1
        LDR.W    R4,??DataTable27_1
        STRB     R3,[R4, #+0]
// 3807   }
// 3808   //走到这里说明通过了数组有效性判断。
// 3809   
// 3810   //取1，3，5点进行斜率计算。
// 3811   //因为只有两个点，所以斜率的计算采取斜率的初始定义的方式，不采取最小二乘法，可以省很多时间。
// 3812   tempslope1 = (BlackRightBigChangeNumy[2] - BlackRightBigChangeNumy[0]) 
// 3813             * LeastSquareMulti   //乘以了这么多倍。跟最小二乘法一样。
// 3814             / (BlackRightBigChangeNumx[2] - BlackRightBigChangeNumx[0]);
??BlackRightBigChangeCheck_0:
        LDR.W    R3,??DataTable26_6
        LDRB     R3,[R3, #+2]
        LDR.W    R4,??DataTable26_6
        LDRB     R4,[R4, #+0]
        SUBS     R3,R3,R4
        MOV      R4,#+1000
        MULS     R3,R4,R3
        LDR.W    R4,??DataTable27
        LDRB     R4,[R4, #+2]
        LDR.W    R5,??DataTable27
        LDRB     R5,[R5, #+0]
        SUBS     R4,R4,R5
        SDIV     R3,R3,R4
// 3815   tempslope2 = (BlackRightBigChangeNumy[4] - BlackRightBigChangeNumy[2]) 
// 3816             * LeastSquareMulti   //乘以了这么多倍。跟最小二乘法一样。
// 3817             / (BlackRightBigChangeNumx[4] - BlackRightBigChangeNumx[2]);
        LDR.W    R4,??DataTable26_6
        LDRB     R4,[R4, #+4]
        LDR.W    R5,??DataTable26_6
        LDRB     R5,[R5, #+2]
        SUBS     R4,R4,R5
        MOV      R5,#+1000
        MULS     R4,R5,R4
        LDR.W    R5,??DataTable27
        LDRB     R5,[R5, #+4]
        LDR.W    R6,??DataTable27
        LDRB     R6,[R6, #+2]
        SUBS     R5,R5,R6
        SDIV     R4,R4,R5
// 3818   BlackRightBigChangeSlopeStore = tempslope1;
        LDR.W    R5,??DataTable27_2
        STR      R3,[R5, #+0]
// 3819   //小5点斜率储存在数组中，由于储存的是tempslope1，所以大跳变点不会记录，会出现多行相同值。
// 3820   BlackRight5Slope[BlackRight5SlopeIndex] = BlackRightBigChangeSlopeStore;
        LDR.W    R5,??DataTable27_2
        LDR      R5,[R5, #+0]
        LDR.W    R6,??DataTable27_3
        LDR.W    R7,??DataTable27_4
        LDRB     R7,[R7, #+0]
        STR      R5,[R6, R7, LSL #+2]
// 3821   BlackRight5SlopeRow[BlackRight5SlopeIndex] = newrow;
        LDR.W    R5,??DataTable27_5
        LDR.W    R6,??DataTable27_4
        LDRB     R6,[R6, #+0]
        STRB     R0,[R6, R5]
// 3822   BlackRight5SlopeIndex++;  
        LDR.W    R0,??DataTable27_4
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.W    R5,??DataTable27_4
        STRB     R0,[R5, #+0]
// 3823   //1. 前后两次的斜率是相反的。
// 3824   if(tempslope1 >= 0 && tempslope2 < 0)
        CMP      R3,#+0
        BMI.N    ??BlackRightBigChangeCheck_5
        CMP      R4,#+0
        BPL.N    ??BlackRightBigChangeCheck_5
// 3825   {
// 3826     //2. 两者差值很大很大。
// 3827     if(tempslope1 >= tempslope2 + BlackRightBigChangeSlopeLimit)
        ADDS     R0,R4,#+4000
        CMP      R3,R0
        BLT.N    ??BlackRightBigChangeCheck_6
// 3828     {
// 3829       //两者差值的确很大。不会刷新储存值。
// 3830       //if(use == 2)                    //另一种方案是在连续2行的第2行调用时才置成功标志位。
// 3831       //{
// 3832         //置成功标志位。
// 3833         BlackRightBigChangeFlag = 1;
        MOVS     R0,#+1
        LDR.W    R3,??DataTable27_6
        STRB     R0,[R3, #+0]
// 3834       //}
// 3835       //else
// 3836       //{
// 3837       //}
// 3838       //此次行不进入队列。
// 3839       BlackRightBigChangeNumx[4] = BlackRightBigChangeNumx[3];
        LDR.W    R0,??DataTable27
        LDRB     R0,[R0, #+3]
        LDR.W    R3,??DataTable27
        STRB     R0,[R3, #+4]
// 3840       BlackRightBigChangeNumx[3] = BlackRightBigChangeNumx[2];
        LDR.W    R0,??DataTable27
        LDRB     R0,[R0, #+2]
        LDR.W    R3,??DataTable27
        STRB     R0,[R3, #+3]
// 3841       BlackRightBigChangeNumx[2] = BlackRightBigChangeNumx[1];
        LDR.W    R0,??DataTable27
        LDRB     R0,[R0, #+1]
        LDR.W    R3,??DataTable27
        STRB     R0,[R3, #+2]
// 3842       BlackRightBigChangeNumx[1] = BlackRightBigChangeNumx[0];
        LDR.W    R0,??DataTable27
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable27
        STRB     R0,[R3, #+1]
// 3843       BlackRightBigChangeNumx[0] = tempstorex;
        LDR.W    R0,??DataTable27
        STRB     R1,[R0, #+0]
// 3844       BlackRightBigChangeNumy[4] = BlackRightBigChangeNumy[3];
        LDR.W    R0,??DataTable26_6
        LDRB     R0,[R0, #+3]
        LDR.W    R1,??DataTable26_6
        STRB     R0,[R1, #+4]
// 3845       BlackRightBigChangeNumy[3] = BlackRightBigChangeNumy[2];
        LDR.W    R0,??DataTable26_6
        LDRB     R0,[R0, #+2]
        LDR.W    R1,??DataTable26_6
        STRB     R0,[R1, #+3]
// 3846       BlackRightBigChangeNumy[2] = BlackRightBigChangeNumy[1];
        LDR.W    R0,??DataTable26_6
        LDRB     R0,[R0, #+1]
        LDR.W    R1,??DataTable26_6
        STRB     R0,[R1, #+2]
// 3847       BlackRightBigChangeNumy[1] = BlackRightBigChangeNumy[0];
        LDR.W    R0,??DataTable26_6
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable26_6
        STRB     R0,[R1, #+1]
// 3848       BlackRightBigChangeNumy[0] = tempstorey;
        LDR.W    R0,??DataTable26_6
        STRB     R2,[R0, #+0]
// 3849 
// 3850       //将前面3个右黑线(共4个)的值置无效值。图像上更连续。
// 3851       BlackRightLoc[BlackRightBigChangeNumx[4]][0] = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable26_4
        LDR.W    R2,??DataTable27
        LDRB     R2,[R2, #+4]
        MOVS     R3,#+3
        MLA      R1,R3,R2,R1
        STRB     R0,[R1, #+0]
// 3852       BlackRightLoc[BlackRightBigChangeNumx[3]][0] = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable26_4
        LDR.W    R2,??DataTable27
        LDRB     R2,[R2, #+3]
        MOVS     R3,#+3
        MLA      R1,R3,R2,R1
        STRB     R0,[R1, #+0]
// 3853       //BlackRightLoc[BlackRightBigChangeNumx[2]][0] = MaxValUint8;
// 3854       
// 3855       return 0;
        MOVS     R0,#+0
        B.N      ??BlackRightBigChangeCheck_4
// 3856     }
// 3857     else
// 3858     {
// 3859       //刷新斜率储存值。
// 3860       //BlackRightBigChangeSlopeStore = tempslope;
// 3861       return 1;
??BlackRightBigChangeCheck_6:
        MOVS     R0,#+1
        B.N      ??BlackRightBigChangeCheck_4
// 3862     }
// 3863   }
// 3864   //1. 前后两次的斜率是相反的。
// 3865   else if(tempslope1 < 0 && tempslope2 >= 0)
??BlackRightBigChangeCheck_5:
        CMP      R3,#+0
        BPL.N    ??BlackRightBigChangeCheck_7
        CMP      R4,#+0
        BMI.N    ??BlackRightBigChangeCheck_7
// 3866   {
// 3867     //2. 两者差值很大很大。
// 3868     if(tempslope2 >= tempslope1 + BlackRightBigChangeSlopeLimit)
        ADDS     R0,R3,#+4000
        CMP      R4,R0
        BLT.N    ??BlackRightBigChangeCheck_8
// 3869     {
// 3870       //两者差值的确很大。不会刷新储存值。
// 3871       //if(use == 2)                    //另一种方案是在连续2行的第2行调用时才置成功标志位。
// 3872       //{
// 3873         //置成功标志位。
// 3874         BlackRightBigChangeFlag = 1;
        MOVS     R0,#+1
        LDR.W    R3,??DataTable27_6
        STRB     R0,[R3, #+0]
// 3875       //}
// 3876       //else
// 3877       //{
// 3878       //}
// 3879       //此次行不进入队列。
// 3880       BlackRightBigChangeNumx[4] = BlackRightBigChangeNumx[3];
        LDR.W    R0,??DataTable27
        LDRB     R0,[R0, #+3]
        LDR.W    R3,??DataTable27
        STRB     R0,[R3, #+4]
// 3881       BlackRightBigChangeNumx[3] = BlackRightBigChangeNumx[2];
        LDR.W    R0,??DataTable27
        LDRB     R0,[R0, #+2]
        LDR.W    R3,??DataTable27
        STRB     R0,[R3, #+3]
// 3882       BlackRightBigChangeNumx[2] = BlackRightBigChangeNumx[1];
        LDR.W    R0,??DataTable27
        LDRB     R0,[R0, #+1]
        LDR.W    R3,??DataTable27
        STRB     R0,[R3, #+2]
// 3883       BlackRightBigChangeNumx[1] = BlackRightBigChangeNumx[0];
        LDR.W    R0,??DataTable27
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable27
        STRB     R0,[R3, #+1]
// 3884       BlackRightBigChangeNumx[0] = tempstorex;
        LDR.W    R0,??DataTable27
        STRB     R1,[R0, #+0]
// 3885       BlackRightBigChangeNumy[4] = BlackRightBigChangeNumy[3];
        LDR.W    R0,??DataTable26_6
        LDRB     R0,[R0, #+3]
        LDR.W    R1,??DataTable26_6
        STRB     R0,[R1, #+4]
// 3886       BlackRightBigChangeNumy[3] = BlackRightBigChangeNumy[2];
        LDR.W    R0,??DataTable26_6
        LDRB     R0,[R0, #+2]
        LDR.W    R1,??DataTable26_6
        STRB     R0,[R1, #+3]
// 3887       BlackRightBigChangeNumy[2] = BlackRightBigChangeNumy[1];
        LDR.W    R0,??DataTable26_6
        LDRB     R0,[R0, #+1]
        LDR.W    R1,??DataTable26_6
        STRB     R0,[R1, #+2]
// 3888       BlackRightBigChangeNumy[1] = BlackRightBigChangeNumy[0];
        LDR.W    R0,??DataTable26_6
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable26_6
        STRB     R0,[R1, #+1]
// 3889       BlackRightBigChangeNumy[0] = tempstorey;
        LDR.W    R0,??DataTable26_6
        STRB     R2,[R0, #+0]
// 3890       
// 3891       //将前面3个右黑线(共4个)的值置无效值。图像上更连续。
// 3892       BlackRightLoc[BlackRightBigChangeNumx[4]][0] = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable26_4
        LDR.W    R2,??DataTable27
        LDRB     R2,[R2, #+4]
        MOVS     R3,#+3
        MLA      R1,R3,R2,R1
        STRB     R0,[R1, #+0]
// 3893       BlackRightLoc[BlackRightBigChangeNumx[3]][0] = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable26_4
        LDR.W    R2,??DataTable27
        LDRB     R2,[R2, #+3]
        MOVS     R3,#+3
        MLA      R1,R3,R2,R1
        STRB     R0,[R1, #+0]
// 3894       //BlackRightLoc[BlackRightBigChangeNumx[2]][0] = MaxValUint8;   
// 3895       
// 3896       return 0;
        MOVS     R0,#+0
        B.N      ??BlackRightBigChangeCheck_4
// 3897     }
// 3898     else
// 3899     {
// 3900       //刷新斜率储存值。
// 3901       //BlackRightBigChangeSlopeStore = tempslope;
// 3902       return 1;
??BlackRightBigChangeCheck_8:
        MOVS     R0,#+1
        B.N      ??BlackRightBigChangeCheck_4
// 3903     }    
// 3904   }
// 3905   //若不相反，则判定无大斜率的跳变。返回成功。
// 3906   else
// 3907   {
// 3908     //刷新斜率储存值。
// 3909     //BlackRightBigChangeSlopeStore = tempslope;
// 3910     return 1;
??BlackRightBigChangeCheck_7:
        MOVS     R0,#+1
??BlackRightBigChangeCheck_4:
        POP      {R4-R7}
        BX       LR               ;; return
// 3911   }
// 3912   
// 3913 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable24:
        DC32     BlackLeftContinueFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable24_1:
        DC32     BlackLeftCrossDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable24_2:
        DC32     BlackLeftRollCheckFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable24_3:
        DC32     BlackLeftBigChangeJumpFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable24_4:
        DC32     BlackLeftBigChangeNumx

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable24_5:
        DC32     BlackLeftBigChangeNumy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable24_6:
        DC32     BlackLeftBigChangeFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable24_7:
        DC32     BlackLeftBigChangeSlopeStore

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable24_8:
        DC32     BlackLeftBigChangeCheckRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable24_9:
        DC32     BlackLeftBigChangeCheckAllRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable24_10:
        DC32     BlackLeftLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable24_11:
        DC32     BlackLeftPredictL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable24_12:
        DC32     BlackLeftPredictR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable24_13:
        DC32     BlackLeftWinPredictStore0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable24_14:
        DC32     BlackLeftWinPredictStore1
// 3914 
// 3915 
// 3916 //单纯的、从左往右的、一定窗口内的、扫描跳变沿的函数.可以精简Step2Win, CrossSpeWin等诸多内容。
// 3917 //返回的是跳变沿的白点所在位置。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 3918 uint8 BlackGetRightJustWin(uint8 row, int32 colleft, int32 colright)
// 3919 {
BlackGetRightJustWin:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
        MOVS     R6,R1
        MOVS     R5,R2
// 3920   uint8 abs1;
// 3921   uint8 tempwhite;
// 3922   uint8 temp1;
// 3923   
// 3924   //左右边界限幅
// 3925   colleft = BoundaryLimitRe(colleft, 0, CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        MOVS     R0,R6
        BL       BoundaryLimitRe
        MOVS     R6,R0
// 3926   colright = BoundaryLimitRe(colright, 0, CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        MOVS     R0,R5
        BL       BoundaryLimitRe
        MOVS     R5,R0
        B.N      ??BlackGetRightJustWin_0
// 3927   
// 3928   for(; colleft < colright; colleft++) 
??BlackGetRightJustWin_1:
        ADDS     R6,R6,#+1
??BlackGetRightJustWin_0:
        CMP      R6,R5
        BGE.W    ??BlackGetRightJustWin_2
// 3929   {
// 3930     //左白点与右黑点的像素差
// 3931     if(ImgNew[row][colleft] > ImgNew[row][colleft+1+BlackRightEdgeNum])
        LDR.W    R0,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        ADDS     R0,R6,R0
        LDRB     R0,[R0, #+4]
        LDR.W    R1,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        LDRB     R1,[R6, R1]
        CMP      R0,R1
        BCS.N    ??BlackGetRightJustWin_3
// 3932     {
// 3933       abs1 = ImgNew[row][colleft] - ImgNew[row][colleft+1+BlackRightEdgeNum];
        LDR.W    R0,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        LDRB     R0,[R6, R0]
        LDR.W    R1,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #+4]
        SUBS     R0,R0,R1
        B.N      ??BlackGetRightJustWin_4
// 3934     }
// 3935     else
// 3936     {
// 3937       abs1 = 0;
??BlackGetRightJustWin_3:
        MOVS     R0,#+0
// 3938     }
// 3939 
// 3940     if( //跳变沿的第一批条件：
// 3941         //黑够黑，白够白，差够大。
// 3942         //这里的3个阈值是自适应之后调整的值
// 3943           (abs1 > LimitRightWB - LimitRightWBAdjust[row]) //两者的差够大
// 3944         &&(ImgNew[row][colleft] > LimitRightW)                     //白点够白
// 3945         &&(ImgNew[row][colleft+1+BlackRightEdgeNum] < LimitRightB)                   //黑点够黑
// 3946        )
??BlackGetRightJustWin_4:
        LDR.W    R1,??DataTable28
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable28_1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R2,[R4, R2]
        SUBS     R1,R1,R2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BGE.N    ??BlackGetRightJustWin_1
        LDR.W    R0,??DataTable28_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        LDRB     R1,[R6, R1]
        CMP      R0,R1
        BCS.N    ??BlackGetRightJustWin_1
        LDR.W    R0,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        ADDS     R0,R6,R0
        LDRB     R0,[R0, #+4]
        LDR.W    R1,??DataTable29
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCS.N    ??BlackGetRightJustWin_1
// 3947     {
// 3948           //如果左边白点不够话，就不用判断白点是否满足阈值了。
// 3949           if(colleft > 2)
        CMP      R6,#+3
        BLT.N    ??BlackGetRightJustWin_5
// 3950           {
// 3951             tempwhite = ((ImgNew[row][colleft-1] > LimitRightW) && (ImgNew[row][colleft-2] > LimitRightW));
        LDR.W    R0,??DataTable28_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #-1]
        CMP      R0,R1
        BCS.N    ??BlackGetRightJustWin_6
        LDR.W    R0,??DataTable28_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #-2]
        CMP      R0,R1
        BCS.N    ??BlackGetRightJustWin_6
        MOVS     R0,#+1
        B.N      ??BlackGetRightJustWin_7
??BlackGetRightJustWin_6:
        MOVS     R0,#+0
        B.N      ??BlackGetRightJustWin_7
// 3952           }
// 3953           else
// 3954           {
// 3955             tempwhite = 1;
??BlackGetRightJustWin_5:
        MOVS     R0,#+1
// 3956           }
// 3957           
// 3958           //近处的行，向右3个点仍为黑点，向左2个点仍为白点。
// 3959           if(row > BlackMiddleLine)
??BlackGetRightJustWin_7:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+51
        BLT.N    ??BlackGetRightJustWin_8
// 3960           {
// 3961             temp1 = (
// 3962                       (ImgNew[row][colleft+2+BlackRightEdgeNum] < LimitRightB)
// 3963                     &&(ImgNew[row][colleft+3+BlackRightEdgeNum] < LimitRightB)
// 3964                     //&&(ImgNew[row][colleft+4+BlackRightEdgeNum] < LimitRightB)
// 3965                     &&(tempwhite == 1)
// 3966                     );
        LDR.W    R1,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #+5]
        LDR.W    R2,??DataTable29
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BCS.N    ??BlackGetRightJustWin_9
        LDR.W    R1,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #+6]
        LDR.W    R2,??DataTable29
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BCS.N    ??BlackGetRightJustWin_9
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??BlackGetRightJustWin_9
        MOVS     R0,#+1
        B.N      ??BlackGetRightJustWin_10
??BlackGetRightJustWin_9:
        MOVS     R0,#+0
        B.N      ??BlackGetRightJustWin_10
// 3967           }
// 3968           else
// 3969           {
// 3970             //中间的行 ，向右2个点为仍为黑点，向左1个点仍为白点。
// 3971             if(row > BlackFarLine)
??BlackGetRightJustWin_8:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+41
        BLT.N    ??BlackGetRightJustWin_11
// 3972             {
// 3973               temp1 = (
// 3974                         (ImgNew[row][colleft+2+BlackRightEdgeNum] < LimitRightB)
// 3975                       //&&(ImgNew[row][colleft+3+BlackRightEdgeNum] < LimitRightB)
// 3976                       &&(tempwhite == 1)
// 3977                       );
        LDR.W    R1,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #+5]
        LDR.W    R2,??DataTable29
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BCS.N    ??BlackGetRightJustWin_12
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??BlackGetRightJustWin_12
        MOVS     R0,#+1
        B.N      ??BlackGetRightJustWin_10
??BlackGetRightJustWin_12:
        MOVS     R0,#+0
        B.N      ??BlackGetRightJustWin_10
// 3978             }          
// 3979             else
// 3980             {
// 3981               //远处的行，向右1个点仍为黑点，向左0个点仍为白点。
// 3982               if(row > BlackFarfarLine)
??BlackGetRightJustWin_11:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+21
        BLT.N    ??BlackGetRightJustWin_13
// 3983               {
// 3984                 //temp1 = (ImgNew[row][colleft+2+BlackRightEdgeNum] < LimitRightB);
// 3985                 temp1 = 1;
        MOVS     R0,#+1
        B.N      ??BlackGetRightJustWin_10
// 3986               }
// 3987               //很远处的行，只对跳变有要求，对周围黑点无要求。
// 3988               else
// 3989               {
// 3990                 temp1 = 1;
??BlackGetRightJustWin_13:
        MOVS     R0,#+1
// 3991               }
// 3992             }
// 3993           }
// 3994           
// 3995           //跳变沿的第二批条件：
// 3996           if(temp1 == 1)
??BlackGetRightJustWin_10:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.W    ??BlackGetRightJustWin_1
// 3997           {
// 3998             //两批条件均满足，返回白点位置，不是黑点位置！
// 3999             return colleft;
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??BlackGetRightJustWin_14
// 4000             
// 4001           //break;               
// 4002           }// end of 跳变沿检测的第2批条件
// 4003     }// end of 跳变沿检测的第1批条件
// 4004     
// 4005     
// 4006     
// 4007   }// end of for循环
// 4008   
// 4009   //如果一直到窗口最左边还没有找到跳变沿，返回无效值。
// 4010   return MaxValUint8;
??BlackGetRightJustWin_2:
        MOVS     R0,#+255
??BlackGetRightJustWin_14:
        POP      {R4-R6,PC}       ;; return
// 4011     
// 4012 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25:
        DC32     BlackLeftStep4StartLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_1:
        DC32     BlackLeftCrossDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_2:
        DC32     LimitLeftHeadWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_3:
        DC32     LimitLeftWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_4:
        DC32     LimitLeftHeadW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_5:
        DC32     LimitLeftW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_6:
        DC32     LimitLeftHeadB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_7:
        DC32     LimitLeftB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_8:
        DC32     BlackLeftStep1ScanRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_9:
        DC32     BlackGetPreDir

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_10:
        DC32     BlackRightHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_11:
        DC32     BlackLeftWinPredictStore2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_12:
        DC32     BlackLeftRealWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_13:
        DC32     LimitLeftWBMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_14:
        DC32     LimitLeftWBMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_15:
        DC32     BlackLeftRealW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_16:
        DC32     LimitLeftWMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_17:
        DC32     LimitLeftWMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_18:
        DC32     BlackLeftRealB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_19:
        DC32     LimitLeftBMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_20:
        DC32     LimitLeftBMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_21:
        DC32     AngleZoneConfirmLockFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_22:
        DC32     BlackLeftRow1RealLastLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable25_23:
        DC32     BlackLeftCrossTooLowLine
// 4013 
// 4014 
// 4015 //======================================================================
// 4016 //函数名：BlackGetRightStep1Edge
// 4017 //功  能：右黑线提取中，第1阶段跳变检测函数,处理该右左线的可疑黑点
// 4018 //参  数：待检测的行号row, 第几次使用use, 黑线预处理标志preflag(1是预处理)
// 4019 //返  回：1成功 0失败
// 4020 //影  响：BlackRightRealWB[], BlackRightRealW[], BlackRightRealB[]
// 4021 //        BlackRightLoc[][]
// 4022 //说  明：1. 对第row行的跳变向右进行检测，成功就赋相应的值（有3个备用值），失败则赋255
// 4023 //        2. 两批条件均满足时。则检测成功。会有最多3个值进行记录，现阶段只用到了第1个值
// 4024 //        3. 里面有涉及3个关键值的实际值的记录，CrossFlag的情况就不用记录（也就不用更改）
// 4025 //        4. 若1个黑点也没有，或者超过3个黑点，则检测失败。
// 4026 //        5. 若要检测黑到白的跳变，或者任意跳变，改变第一批条件即可。
// 4027 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4028 uint8 BlackGetRightStep1Edge(uint8 row, uint8 use, uint8 preflag)
// 4029 {
BlackGetRightStep1Edge:
        PUSH     {R3-R7,LR}
        MOVS     R5,R0
        MOVS     R6,R1
        MOVS     R7,R2
// 4030   uint8 index, col, temp1;
// 4031   uint8 abs1;
// 4032   uint8 RightBeginCol; //右线跳变检测起点
// 4033   uint8 tempwhite;
// 4034   uint8 avgr1, avgl1;
// 4035   uint8 i;
// 4036     
// 4037   //根据上一幅有效图像的中线来预估这一幅图像的左右黑线扫描起点，右线起点需要在中线往左一个黑线宽度。 
// 4038   RightBeginCol = (uint8)MaxRe((int32)BlackRightEdgeStartCol-10,0);
        MOVS     R1,#+0
        LDR.W    R0,??DataTable29_1
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+10
        BL       MaxRe
        MOVS     R4,R0
// 4039   
// 4040   //左线开始扫描。
// 4041   //如果是预处理，也不用考虑这个情况。直接往下走就好。
// 4042   if((BlackGetPreDir == 0 || BlackGetPreDir == 2)
// 4043   &&(BlackLeftLoc[row][0] != MaxValUint8)
// 4044   &&(preflag == 0)
// 4045     )
        LDR.W    R0,??DataTable29_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??BlackGetRightStep1Edge_0
        LDR.W    R0,??DataTable29_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BNE.N    ??BlackGetRightStep1Edge_1
??BlackGetRightStep1Edge_0:
        LDR.W    R0,??DataTable29_3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??BlackGetRightStep1Edge_1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BNE.N    ??BlackGetRightStep1Edge_1
// 4046   {
// 4047     //如果上一幅图是单线，则右线扫描起点必须在左线的左边一个单线宽度。
// 4048     if(
// 4049       (row > CameraHight - 5)
// 4050     &&(SingleBlackLastAllFlag == 1)
// 4051        )
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+56
        BLT.N    ??BlackGetRightStep1Edge_2
        LDR.W    R0,??DataTable29_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackGetRightStep1Edge_2
// 4052     {
// 4053       RightBeginCol = MinRe(RightBeginCol, MaxRe(0, BlackLeftLoc[row][0] - SingleBlackWidthMax[row]));
        LDR.W    R0,??DataTable29_3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable29_5
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LDRB     R1,[R5, R1]
        SUBS     R1,R0,R1
        MOVS     R0,#+0
        BL       MaxRe
        MOVS     R1,R0
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R0,R4
        BL       MinRe
        MOVS     R4,R0
        B.N      ??BlackGetRightStep1Edge_1
// 4054     }
// 4055     //如果上一幅图不是单线，且最近四行没有采集到单线，那就视为不可能出现单线。所以右线扫描起点必须在左线的右边
// 4056     else if(
// 4057            (row <= CameraHight - 5)
// 4058          //&&(SingleBlackLastAllFlag == 0)
// 4059             )
??BlackGetRightStep1Edge_2:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+56
        BGE.N    ??BlackGetRightStep1Edge_3
// 4060     {
// 4061       RightBeginCol = MaxRe(RightBeginCol, BlackLeftLoc[row][0]);
        LDR.W    R0,??DataTable29_3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R1,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R0,R4
        BL       MaxRe
        MOVS     R4,R0
        B.N      ??BlackGetRightStep1Edge_1
// 4062     }
// 4063     else
// 4064     {
// 4065       RightBeginCol = MaxRe(RightBeginCol, BlackLeftLoc[row][0]);
??BlackGetRightStep1Edge_3:
        LDR.W    R0,??DataTable29_3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R1,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R0,R4
        BL       MaxRe
        MOVS     R4,R0
// 4066     }
// 4067     
// 4068   }
// 4069   else
// 4070   {    
// 4071   }
// 4072   
// 4073   //窗口预测值记录
// 4074   BlackRightPredictL[row] = RightBeginCol;
??BlackGetRightStep1Edge_1:
        LDR.W    R0,??DataTable29_6
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        STRB     R4,[R5, R0]
// 4075   BlackRightPredictR[row] = CameraRealWidth - 5 - BlackRightEdgeNum;
        MOVS     R0,#+242
        LDR.W    R1,??DataTable29_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        STRB     R0,[R5, R1]
// 4076   
// 4077   index = 0;         //可疑点的序号
        MOVS     R0,#+0
// 4078   //从中间到最右边扫描，隔1个点求差
// 4079   for(col = RightBeginCol; col <= CameraRealWidth - 5 - BlackRightEdgeNum; col++) 
        B.N      ??BlackGetRightStep1Edge_4
??BlackGetRightStep1Edge_5:
        ADDS     R4,R4,#+1
??BlackGetRightStep1Edge_4:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+243
        BGE.W    ??BlackGetRightStep1Edge_6
// 4080   {
// 4081       //左白点与右黑点的像素差
// 4082       if(ImgNew[row][col] > ImgNew[row][col+1+BlackRightEdgeNum])
        LDR.W    R1,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R5,R1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R1,R4,R1
        LDRB     R1,[R1, #+4]
        LDR.W    R2,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R5,R2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R2,[R4, R2]
        CMP      R1,R2
        BCS.N    ??BlackGetRightStep1Edge_7
// 4083       {
// 4084         abs1 = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum];
        LDR.W    R1,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R5,R1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R1,[R4, R1]
        LDR.W    R2,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R5,R2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R2,R4,R2
        LDRB     R2,[R2, #+4]
        SUBS     R1,R1,R2
        B.N      ??BlackGetRightStep1Edge_8
// 4085       }
// 4086       else
// 4087       {
// 4088         abs1 = 0;
??BlackGetRightStep1Edge_7:
        MOVS     R1,#+0
// 4089       }
// 4090       
// 4091       if( //跳变沿的第一批条件：
// 4092           //黑够黑，白够白，差够大。
// 4093           //这里的3个阈值为初始值，不是自适应之后调整的值。
// 4094           (abs1 > LimitRightWB - LimitRightWBAdjust[row]) //两者的差够大
// 4095         &&(ImgNew[row][col] > LimitRightW)                     //白点够白
// 4096         &&(ImgNew[row][col+1+BlackRightEdgeNum] < LimitRightB) //黑点够黑
// 4097          )
??BlackGetRightStep1Edge_8:
        LDR.W    R2,??DataTable28
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable28_1
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LDRB     R3,[R5, R3]
        SUBS     R2,R2,R3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R2,R1
        BGE.N    ??BlackGetRightStep1Edge_5
        LDR.W    R1,??DataTable28_2
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R5,R2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R2,[R4, R2]
        CMP      R1,R2
        BCS.N    ??BlackGetRightStep1Edge_5
        LDR.W    R1,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R5,R1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R1,R4,R1
        LDRB     R1,[R1, #+4]
        LDR.W    R2,??DataTable29
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BCS.N    ??BlackGetRightStep1Edge_5
// 4098       {         
// 4099           //左边没有白点的话就不会判断白点是否满足阈值了。
// 4100           if(col > 2)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+3
        BLT.N    ??BlackGetRightStep1Edge_9
// 4101           {
// 4102             tempwhite = ((ImgNew[row][col-1] > LimitRightW) && (ImgNew[row][col-2] > LimitRightW));
        LDR.W    R1,??DataTable28_2
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R5,R2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R2,R4,R2
        LDRB     R2,[R2, #-1]
        CMP      R1,R2
        BCS.N    ??BlackGetRightStep1Edge_10
        LDR.W    R1,??DataTable28_2
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R5,R2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R2,R4,R2
        LDRB     R2,[R2, #-2]
        CMP      R1,R2
        BCS.N    ??BlackGetRightStep1Edge_10
        MOVS     R1,#+1
        B.N      ??BlackGetRightStep1Edge_11
??BlackGetRightStep1Edge_10:
        MOVS     R1,#+0
        B.N      ??BlackGetRightStep1Edge_11
// 4103           }
// 4104           else
// 4105           {
// 4106             tempwhite = 1;
??BlackGetRightStep1Edge_9:
        MOVS     R1,#+1
// 4107           }
// 4108           
// 4109           //跳变沿的第二批条件：
// 4110           //近处的行，向右3个点仍为黑点，向左2个点仍为白点。
// 4111           if(row > BlackMiddleLine)
??BlackGetRightStep1Edge_11:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+51
        BLT.N    ??BlackGetRightStep1Edge_12
// 4112           {
// 4113             temp1 = (
// 4114                       (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB)
// 4115                     &&(ImgNew[row][col+3+BlackRightEdgeNum] < LimitRightB)
// 4116                     &&(ImgNew[row][col+4+BlackRightEdgeNum] < LimitRightB)
// 4117                     &&(tempwhite == 1)
// 4118                     );
        LDR.W    R2,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R5,R2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R2,R4,R2
        LDRB     R2,[R2, #+5]
        LDR.W    R3,??DataTable29
        LDRB     R3,[R3, #+0]
        CMP      R2,R3
        BCS.N    ??BlackGetRightStep1Edge_13
        LDR.W    R2,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R5,R2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R2,R4,R2
        LDRB     R2,[R2, #+6]
        LDR.W    R3,??DataTable29
        LDRB     R3,[R3, #+0]
        CMP      R2,R3
        BCS.N    ??BlackGetRightStep1Edge_13
        LDR.W    R2,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R5,R2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R2,R4,R2
        LDRB     R2,[R2, #+7]
        LDR.W    R3,??DataTable29
        LDRB     R3,[R3, #+0]
        CMP      R2,R3
        BCS.N    ??BlackGetRightStep1Edge_13
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??BlackGetRightStep1Edge_13
        MOVS     R1,#+1
        B.N      ??BlackGetRightStep1Edge_14
??BlackGetRightStep1Edge_13:
        MOVS     R1,#+0
        B.N      ??BlackGetRightStep1Edge_14
// 4119           }
// 4120           else
// 4121           {
// 4122             if(row > BlackFarLine)
??BlackGetRightStep1Edge_12:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+41
        BLT.N    ??BlackGetRightStep1Edge_15
// 4123             {
// 4124               //中间的行，向右2个点仍为黑点，向左1个点仍为白点。
// 4125               temp1 = (
// 4126                         (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB)
// 4127                       &&(ImgNew[row][col+3+BlackRightEdgeNum] < LimitRightB)
// 4128                       &&(tempwhite == 1)
// 4129                       );
        LDR.W    R2,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R5,R2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R2,R4,R2
        LDRB     R2,[R2, #+5]
        LDR.W    R3,??DataTable29
        LDRB     R3,[R3, #+0]
        CMP      R2,R3
        BCS.N    ??BlackGetRightStep1Edge_16
        LDR.W    R2,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R5,R2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R2,R4,R2
        LDRB     R2,[R2, #+6]
        LDR.W    R3,??DataTable29
        LDRB     R3,[R3, #+0]
        CMP      R2,R3
        BCS.N    ??BlackGetRightStep1Edge_16
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??BlackGetRightStep1Edge_16
        MOVS     R1,#+1
        B.N      ??BlackGetRightStep1Edge_14
??BlackGetRightStep1Edge_16:
        MOVS     R1,#+0
        B.N      ??BlackGetRightStep1Edge_14
// 4130             }
// 4131             else
// 4132             {
// 4133               //远处的行，向右1个点仍为黑点，向左0个点仍为白点。
// 4134               if(row > BlackFarfarLine)
??BlackGetRightStep1Edge_15:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+21
        BLT.N    ??BlackGetRightStep1Edge_17
// 4135               {
// 4136                 temp1 = (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB);
        LDR.W    R1,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R5,R1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R1,R4,R1
        LDRB     R1,[R1, #+5]
        LDR.W    R2,??DataTable29
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BCS.N    ??BlackGetRightStep1Edge_18
        MOVS     R1,#+1
        B.N      ??BlackGetRightStep1Edge_14
??BlackGetRightStep1Edge_18:
        MOVS     R1,#+0
        B.N      ??BlackGetRightStep1Edge_14
// 4137               }
// 4138               //很远处的行，只对跳变有要求，对周围黑点无要求。
// 4139               else
// 4140               {
// 4141                 temp1 = 1;
??BlackGetRightStep1Edge_17:
        MOVS     R1,#+1
// 4142               }             
// 4143             }
// 4144           }
// 4145           
// 4146           if(temp1)
??BlackGetRightStep1Edge_14:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BEQ.W    ??BlackGetRightStep1Edge_5
// 4147           {
// 4148               //跳变检测成功，取黑点
// 4149               BlackRightLoc[row][index] = col + 1 + BlackRightEdgeNum;          
        LDR.W    R1,??DataTable26_4
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R5,R1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R2,R4,#+4
        STRB     R2,[R0, R1]
// 4150               index++;
        ADDS     R0,R0,#+1
// 4151               break;
// 4152             
// 4153           }    //end of 跳变沿的第二批条件
// 4154       }   //end of 跳变沿的第一批条件
// 4155   }// end of 从中间到最左边扫描，隔1个点求差
// 4156   
// 4157   //1个可疑黑点也没有，则报错。
// 4158   if(index == 0)
??BlackGetRightStep1Edge_6:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackGetRightStep1Edge_19
// 4159   {
// 4160     //如果是黑线预处理的调用，也不用更新这几个值。
// 4161     if(preflag == 0)
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BNE.N    ??BlackGetRightStep1Edge_20
// 4162     {
// 4163       //对3个关键值的实际值清零
// 4164       BlackRightRealClear();
        BL       BlackRightRealClear
// 4165     }
// 4166       
// 4167     //该行定位黑线失败，赋无效值
// 4168     BlackRightLoc[row][0] = MaxValUint8;
??BlackGetRightStep1Edge_20:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable26_4
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R5,R1
        STRB     R0,[R1, #+0]
// 4169     return 0;
        MOVS     R0,#+0
        B.N      ??BlackGetRightStep1Edge_21
// 4170   }
// 4171   
// 4172   //不是黑线预处理的调用，则需要进行大跳变的检测。
// 4173   if(preflag == 0)
??BlackGetRightStep1Edge_19:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BNE.W    ??BlackGetRightStep1Edge_22
// 4174   {
// 4175     //最终确认前，需要对大斜率进行检测。
// 4176     if(BlackRightBigChangeCheck(row, use) == 1)
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackRightBigChangeCheck
        CMP      R0,#+1
        BNE.W    ??BlackGetRightStep1Edge_23
// 4177     {
// 4178       //从左线开始的扫描。单线一定出现在BlackGetPreDir == 0的情况。
// 4179       //若已经确认为单线了，就不用再次确认了。
// 4180       if(
// 4181         (SingleBlackAllFlag == 0) 
// 4182       &&(BlackGetPreDir == 0 || BlackGetPreDir == 2)   //0713文件夹里的error002.txt里的第31幅图过渡到第32幅图时，若BlackGetPreDir不等于2的话，会出问题。
// 4183         )
        LDR.W    R0,??DataTable31
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.W    ??BlackGetRightStep1Edge_22
        LDR.W    R0,??DataTable29_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??BlackGetRightStep1Edge_24
        LDR.W    R0,??DataTable29_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BNE.W    ??BlackGetRightStep1Edge_22
// 4184       {
// 4185         //若该行左右黑线均检测成功，且右线在左线的左边一定范围内，则该行判定为单线。
// 4186         if((BlackLeftLoc[row][0] != MaxValUint8)
// 4187          &&(BlackRightLoc[row][0] != MaxValUint8)
// 4188          &&(BlackRightLoc[row][0] < BlackLeftLoc[row][0])
// 4189          &&(BlackRightLoc[row][0] - BlackLeftLoc[row][0] < SingleBlackWidthMax[row]) //结果是负数也会满足，所以必须小于。
// 4190         )
??BlackGetRightStep1Edge_24:
        LDR.W    R0,??DataTable29_3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.W    ??BlackGetRightStep1Edge_25
        LDR.N    R0,??DataTable26_4
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.W    ??BlackGetRightStep1Edge_25
        LDR.N    R0,??DataTable26_4
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable29_3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R5,R1
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCS.W    ??BlackGetRightStep1Edge_25
        LDR.N    R0,??DataTable26_4
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable29_3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R5,R1
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable29_5
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LDRB     R1,[R5, R1]
        CMP      R0,R1
        BGE.W    ??BlackGetRightStep1Edge_25
// 4191         {
// 4192           //检查5个白点的平均值是否相近，若相近，则是单线，若不相近，则置无效值。
// 4193           if(
// 4194             (BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 5 < 0)
// 4195           ||(BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 5 > CameraRealWidth - 1)
// 4196             )
        LDR.N    R0,??DataTable26_4
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+9
        CMP      R0,#+0
        BMI.N    ??BlackGetRightStep1Edge_26
        LDR.W    R0,??DataTable29_3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+9
        CMP      R0,#+250
        BLT.N    ??BlackGetRightStep1Edge_27
// 4197           {
// 4198             //不哆5个点。
// 4199             //因为进行过大跳变，所以要清除。只针对最近几行。
// 4200             if(row > CameraHight - 5)
??BlackGetRightStep1Edge_26:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+56
        BLT.N    ??BlackGetRightStep1Edge_28
// 4201             {
// 4202                 for(i = 0; i <= 4; i++)
        MOVS     R0,#+0
        B.N      ??BlackGetRightStep1Edge_29
// 4203                 {
// 4204                     BlackRightBigChangeNumx[i] = MaxValUint8;
??BlackGetRightStep1Edge_30:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable27
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 4205                     BlackRightBigChangeNumy[i] = MaxValUint8;
        MOVS     R1,#+255
        LDR.N    R2,??DataTable26_6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 4206                 }
        ADDS     R0,R0,#+1
??BlackGetRightStep1Edge_29:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+5
        BLT.N    ??BlackGetRightStep1Edge_30
// 4207                 BlackRightBigChangeJumpFlag = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable27_1
        STRB     R0,[R1, #+0]
// 4208             }
// 4209             else
// 4210             {
// 4211             }
// 4212             //该行定位黑线失败，赋无效值
// 4213             BlackRightLoc[row][0] = MaxValUint8;
??BlackGetRightStep1Edge_28:
        MOVS     R0,#+255
        LDR.N    R1,??DataTable26_4
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R5,R1
        STRB     R0,[R1, #+0]
// 4214             return 0;
        MOVS     R0,#+0
        B.N      ??BlackGetRightStep1Edge_21
// 4215           }
// 4216           else
// 4217           {
// 4218             //该行右线的白点平均值
// 4219             avgr1 = (ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 1]
// 4220                    + ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 2]
// 4221                    + ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 3]
// 4222                    + ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 4]
// 4223                    + ImgNew[row][BlackRightLoc[row][0] - 1 - BlackRightEdgeNum - 5])
// 4224                    / 5;
??BlackGetRightStep1Edge_27:
        LDR.W    R0,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R5,R0
        LDR.N    R1,??DataTable26_4
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R5,R1
        LDRB     R1,[R1, #+0]
        ADDS     R0,R1,R0
        LDRB     R0,[R0, #-5]
        LDR.W    R1,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R5,R1
        LDR.N    R2,??DataTable26_4
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R5,R2
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #-6]
        UXTAB    R0,R1,R0
        LDR.W    R1,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R5,R1
        LDR.N    R2,??DataTable26_4
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R5,R2
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #-7]
        UXTAB    R0,R0,R1
        LDR.W    R1,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R5,R1
        LDR.N    R2,??DataTable26_4
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R5,R2
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #-8]
        UXTAB    R0,R0,R1
        LDR.W    R1,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R5,R1
        LDR.N    R2,??DataTable26_4
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R5,R2
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #-9]
        UXTAB    R0,R0,R1
        MOVS     R1,#+5
        SDIV     R0,R0,R1
// 4225             //该行左线的白点平均值
// 4226             avgl1 = (ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 1]
// 4227                    + ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 2]
// 4228                    + ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 3]
// 4229                    + ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 4]
// 4230                    + ImgNew[row][BlackLeftLoc[row][0] + 1 + BlackLeftEdgeNum + 5])
// 4231                    / 5;    
        LDR.W    R1,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R5,R1
        LDR.W    R2,??DataTable29_3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R5,R2
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #+5]
        LDR.W    R2,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R5,R2
        LDR.W    R3,??DataTable29_3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R12,#+3
        MLA      R3,R12,R5,R3
        LDRB     R3,[R3, #+0]
        ADDS     R2,R3,R2
        LDRB     R2,[R2, #+6]
        UXTAB    R1,R2,R1
        LDR.W    R2,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R5,R2
        LDR.W    R3,??DataTable29_3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R12,#+3
        MLA      R3,R12,R5,R3
        LDRB     R3,[R3, #+0]
        ADDS     R2,R3,R2
        LDRB     R2,[R2, #+7]
        UXTAB    R1,R1,R2
        LDR.N    R2,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R5,R2
        LDR.W    R3,??DataTable29_3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R12,#+3
        MLA      R3,R12,R5,R3
        LDRB     R3,[R3, #+0]
        ADDS     R2,R3,R2
        LDRB     R2,[R2, #+8]
        UXTAB    R1,R1,R2
        LDR.N    R2,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R5,R2
        LDR.W    R3,??DataTable29_3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R12,#+3
        MLA      R3,R12,R5,R3
        LDRB     R3,[R3, #+0]
        ADDS     R2,R3,R2
        LDRB     R2,[R2, #+9]
        UXTAB    R1,R1,R2
        MOVS     R2,#+5
        SDIV     R1,R1,R2
// 4232             if(AbsInt(avgr1 - avgl1) < 20)
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        SUBS     R0,R0,R1
        BL       AbsInt
        CMP      R0,#+20
        BGE.N    ??BlackGetRightStep1Edge_31
// 4233             {
// 4234               //5个白点之间的差别够小，单线判断成功。
// 4235               SingleBlackFlag[row] = 1;      
        MOVS     R0,#+1
        LDR.W    R1,??DataTable32
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        STRB     R0,[R5, R1]
// 4236               //SingleBlackAllFlag = 1;   //总幅图像的单线标志，只要有一行检测单线成功，则置1.
// 4237             }
// 4238             else
// 4239             {
// 4240               //5个白点之间的差别太大，单线判断失败。
// 4241               //因为进行过大跳变，所以要清除。只针对最近几行。
// 4242               if(row > CameraHight - 5)
// 4243               {
// 4244                   for(i = 0; i <= 4; i++)
// 4245                   {
// 4246                       BlackRightBigChangeNumx[i] = MaxValUint8;
// 4247                       BlackRightBigChangeNumy[i] = MaxValUint8;
// 4248                   }
// 4249                   BlackRightBigChangeJumpFlag = 0;
// 4250               }
// 4251               else
// 4252               {
// 4253               }
// 4254               
// 4255               //该行定位黑线失败，赋无效值
// 4256               BlackRightLoc[row][0] = MaxValUint8;
// 4257               return 0;              
// 4258             }
// 4259           }          
// 4260         }
// 4261         else
// 4262         {
// 4263           //否则该行单线标志为0.
// 4264           SingleBlackFlag[row] = 0;
// 4265         }
// 4266       }
// 4267       //从右线开始的扫描，右线不用检测是否有单线，左线去检测即可。
// 4268       else
// 4269       {
// 4270       }
// 4271       
// 4272       //没有报错，就会走到这里，黑点查找成功，会有1，2，3个黑点
// 4273       //return 1;
// 4274     }
// 4275     else
// 4276     {
// 4277       //没通过大跳变检测。
// 4278       BlackRightBigChangeCheckRow[row] = 1;
// 4279       BlackRightBigChangeCheckAllRow = 1;
// 4280       
// 4281       //return 1;
// 4282       
// 4283       //该行定位黑线失败，赋无效值
// 4284       BlackRightLoc[row][0] = MaxValUint8;
// 4285       return 0;
// 4286     }
// 4287   }
// 4288   //是黑线预处理的调用，不需大跳变的检测，直接返回成功。
// 4289   else
// 4290   {
// 4291     //return 1;
// 4292   }
// 4293 
// 4294   //如果是黑线预处理的调用，也不用更新这几个值。
// 4295   if(preflag == 0)
??BlackGetRightStep1Edge_22:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BNE.W    ??BlackGetRightStep1Edge_32
// 4296   {
// 4297     //进入这里说明跳变沿的二批条件均满足，进入黑点记录阶段
// 4298     //记录3个关键值的实际信息，作为后面的参考。
// 4299     if(use == 1)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+1
        BNE.N    ??BlackGetRightStep1Edge_33
// 4300     {
// 4301       BlackRightRealWB[0] = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum]; 
        LDR.N    R0,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R5,R0
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R0,[R4, R0]
        LDR.N    R1,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R5,R1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R1,R4,R1
        LDRB     R1,[R1, #+4]
        SUBS     R0,R0,R1
        LDR.N    R1,??DataTable26
        STRB     R0,[R1, #+0]
// 4302       BlackRightRealW[0] = ImgNew[row][col];
        LDR.N    R0,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R5,R0
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R0,[R4, R0]
        LDR.N    R1,??DataTable26_1
        STRB     R0,[R1, #+0]
// 4303       BlackRightRealB[0] = ImgNew[row][col+1+BlackRightEdgeNum];
        LDR.N    R0,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R5,R0
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R0,R4,R0
        LDRB     R0,[R0, #+4]
        LDR.W    R1,??DataTable32_1
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetRightStep1Edge_32
// 4304     }
??BlackGetRightStep1Edge_31:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+56
        BLT.N    ??BlackGetRightStep1Edge_34
        MOVS     R0,#+0
        B.N      ??BlackGetRightStep1Edge_35
??BlackGetRightStep1Edge_36:
        MOVS     R1,#+255
        LDR.N    R2,??DataTable27
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
        MOVS     R1,#+255
        LDR.N    R2,??DataTable26_6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
        ADDS     R0,R0,#+1
??BlackGetRightStep1Edge_35:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+5
        BLT.N    ??BlackGetRightStep1Edge_36
        MOVS     R0,#+0
        LDR.N    R1,??DataTable27_1
        STRB     R0,[R1, #+0]
??BlackGetRightStep1Edge_34:
        MOVS     R0,#+255
        LDR.N    R1,??DataTable26_4
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R5,R1
        STRB     R0,[R1, #+0]
        MOVS     R0,#+0
        B.N      ??BlackGetRightStep1Edge_21
??BlackGetRightStep1Edge_25:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable32
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        STRB     R0,[R5, R1]
        B.N      ??BlackGetRightStep1Edge_22
??BlackGetRightStep1Edge_23:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable32_2
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        STRB     R0,[R5, R1]
        MOVS     R0,#+1
        LDR.W    R1,??DataTable32_3
        STRB     R0,[R1, #+0]
        MOVS     R0,#+255
        LDR.N    R1,??DataTable26_4
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R5,R1
        STRB     R0,[R1, #+0]
        MOVS     R0,#+0
        B.N      ??BlackGetRightStep1Edge_21
// 4305     else if(use == 2)
??BlackGetRightStep1Edge_33:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+2
        BNE.N    ??BlackGetRightStep1Edge_32
// 4306     {
// 4307       BlackRightRealWB[1] = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum]; 
        LDR.N    R0,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R5,R0
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R0,[R4, R0]
        LDR.N    R1,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R5,R1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R1,R4,R1
        LDRB     R1,[R1, #+4]
        SUBS     R0,R0,R1
        LDR.N    R1,??DataTable26
        STRB     R0,[R1, #+1]
// 4308       BlackRightRealW[1] = ImgNew[row][col];
        LDR.N    R0,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R5,R0
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R0,[R4, R0]
        LDR.N    R1,??DataTable26_1
        STRB     R0,[R1, #+1]
// 4309       BlackRightRealB[1] = ImgNew[row][col+1+BlackRightEdgeNum];
        LDR.N    R0,??DataTable27_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R5,R0
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R0,R4,R0
        LDRB     R0,[R0, #+4]
        LDR.W    R1,??DataTable32_1
        STRB     R0,[R1, #+1]
// 4310     }
// 4311     else
// 4312     {
// 4313     }
// 4314   }
// 4315   
// 4316   return 1;
??BlackGetRightStep1Edge_32:
        MOVS     R0,#+1
??BlackGetRightStep1Edge_21:
        POP      {R1,R4-R7,PC}    ;; return
// 4317 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26:
        DC32     BlackRightRealWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26_1:
        DC32     BlackRightRealW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26_2:
        DC32     BlackRightRealB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26_3:
        DC32     BlackRightDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26_4:
        DC32     BlackRightLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26_5:
        DC32     BlackRightEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable26_6:
        DC32     BlackRightBigChangeNumy
// 4318 
// 4319 
// 4320 //======================================================================
// 4321 //函数名：BlackGetRightStep2Win
// 4322 //功  能：右黑线提取中，第2阶段窗口内跳变检测函数
// 4323 //参  数：待处理行号row, 窗口大小win, 预测的跳变点的位置predict, 第几次使用use.
// 4324 //返  回：1成功  0失败
// 4325 //影  响：BlackRightLoc[][0]
// 4326 //说  明：1. 满足两批条件，才能检测成功。只有一个点的记录。
// 4327 //        2. 窗口内没有检测到，则检测失败。
// 4328 //        3. 窗缩小可以减少一定的时间，但如果遇到斜率过大的情况，就有可能检测不到。     
// 4329 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4330 uint8 BlackGetRightStep2Win(uint8 row, uint8 win, uint8 predict, uint8 use)
// 4331 {
BlackGetRightStep2Win:
        PUSH     {R3-R7,LR}
        MOVS     R4,R0
        MOVS     R5,R3
// 4332   uint8 col, temp;
// 4333 
// 4334   //在规划好的窗口内，从左往右查找跳变沿
// 4335   //防止溢出
// 4336   //对右边界的限制 
// 4337   if((predict + win) >= (CameraRealWidth - 5 - BlackRightEdgeNum)) 
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTAB    R0,R1,R2
        CMP      R0,#+242
        BLT.N    ??BlackGetRightStep2Win_0
// 4338   {
// 4339     temp = CameraRealWidth - 5 - BlackRightEdgeNum;
        MOVS     R6,#+242
        B.N      ??BlackGetRightStep2Win_1
// 4340   }  
// 4341   else
// 4342   {
// 4343     temp = predict + win;
??BlackGetRightStep2Win_0:
        ADDS     R6,R1,R2
// 4344   }
// 4345   //对左边界的限制
// 4346   if(predict <= win)
??BlackGetRightStep2Win_1:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R1,R2
        BCC.N    ??BlackGetRightStep2Win_2
// 4347   {
// 4348     col = 0;
        MOVS     R7,#+0
        B.N      ??BlackGetRightStep2Win_3
// 4349   }
// 4350   else
// 4351   {
// 4352     col = predict - win;  
??BlackGetRightStep2Win_2:
        SUBS     R7,R2,R1
// 4353   }
// 4354   //左线开始扫描且没有出现单线时，右线的扫描左边界必须在该行有效左黑线的右边。
// 4355   if((BlackGetPreDir == 0 || BlackGetPreDir == 2)
// 4356   &&(SingleBlackAllFlag == 0)
// 4357   &&(BlackLeftLoc[row][0] != MaxValUint8)
// 4358     )
??BlackGetRightStep2Win_3:
        LDR.W    R0,??DataTable29_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??BlackGetRightStep2Win_4
        LDR.W    R0,??DataTable29_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BNE.N    ??BlackGetRightStep2Win_5
??BlackGetRightStep2Win_4:
        LDR.W    R0,??DataTable31
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??BlackGetRightStep2Win_5
        LDR.W    R0,??DataTable29_3
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??BlackGetRightStep2Win_5
// 4359   {
// 4360     col = MaxRe(col, BlackLeftLoc[row][0]);
        LDR.W    R0,??DataTable29_3
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R1,[R0, #+0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R0,R7
        BL       MaxRe
        MOVS     R7,R0
// 4361   }
// 4362   else
// 4363   {
// 4364   }
// 4365   
// 4366   //窗口预测值记录
// 4367   BlackRightPredictL[row] = col;
??BlackGetRightStep2Win_5:
        LDR.W    R0,??DataTable29_6
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R7,[R4, R0]
// 4368   BlackRightPredictR[row] = temp;
        LDR.W    R0,??DataTable29_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R6,[R4, R0]
// 4369   
// 4370   //左边界在右边界的右边，直接返回失败。
// 4371   if(col >= temp) return 0;
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R7,R6
        BCC.N    ??BlackGetRightStep2Win_6
        MOVS     R0,#+0
        B.N      ??BlackGetRightStep2Win_7
// 4372    
// 4373   //开窗扫描跳变沿
// 4374   col = BlackGetRightJustWin(row, col, temp);
??BlackGetRightStep2Win_6:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MOVS     R2,R6
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R1,R7
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetRightJustWin
        MOVS     R7,R0
// 4375   if(col != MaxValUint8)
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+255
        BEQ.N    ??BlackGetRightStep2Win_8
// 4376   {
// 4377     //两批条件均满足，直接记录该点为黑线，返回即可
// 4378     BlackRightLoc[row][0] = col + 1 + BlackRightEdgeNum;
        ADDS     R0,R7,#+4
        LDR.W    R1,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 4379              
// 4380     //最终确认前，需要对大斜率进行检测。
// 4381     if(BlackRightBigChangeCheck(row, use) == 0)
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackRightBigChangeCheck
        CMP      R0,#+0
        BNE.N    ??BlackGetRightStep2Win_9
// 4382     {
// 4383       //没通过大跳变检测。
// 4384       BlackRightBigChangeCheckRow[row] = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable32_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R0,[R4, R1]
// 4385       BlackRightBigChangeCheckAllRow = 1;             
        MOVS     R0,#+1
        LDR.W    R1,??DataTable32_3
        STRB     R0,[R1, #+0]
// 4386       
// 4387       BlackRightLoc[row][0] = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 4388       return 0;
        MOVS     R0,#+0
        B.N      ??BlackGetRightStep2Win_7
// 4389     }
// 4390     else
// 4391     {
// 4392     }
// 4393     
// 4394     
// 4395     //记录3个关键值的实际信息，作为后面的参考。
// 4396     if(use == 1)
??BlackGetRightStep2Win_9:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+1
        BNE.N    ??BlackGetRightStep2Win_10
// 4397     {
// 4398       BlackRightRealWB[0] = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum]; 
        LDR.N    R0,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R0,[R7, R0]
        LDR.N    R1,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R1,R7,R1
        LDRB     R1,[R1, #+4]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable32_4
        STRB     R0,[R1, #+0]
// 4399       BlackRightRealW[0] = ImgNew[row][col];
        LDR.N    R0,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R0,[R7, R0]
        LDR.W    R1,??DataTable32_5
        STRB     R0,[R1, #+0]
// 4400       BlackRightRealB[0] = ImgNew[row][col+1+BlackRightEdgeNum];
        LDR.N    R0,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R0,R7,R0
        LDRB     R0,[R0, #+4]
        LDR.W    R1,??DataTable32_1
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetRightStep2Win_11
// 4401     }
// 4402     else if(use == 2)
??BlackGetRightStep2Win_10:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+2
        BNE.N    ??BlackGetRightStep2Win_11
// 4403     {
// 4404       BlackRightRealWB[1] = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum]; 
        LDR.N    R0,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R0,[R7, R0]
        LDR.N    R1,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R1,R7,R1
        LDRB     R1,[R1, #+4]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable32_4
        STRB     R0,[R1, #+1]
// 4405       BlackRightRealW[1] = ImgNew[row][col];
        LDR.N    R0,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDRB     R0,[R7, R0]
        LDR.W    R1,??DataTable32_5
        STRB     R0,[R1, #+1]
// 4406       BlackRightRealB[1] = ImgNew[row][col+1+BlackRightEdgeNum];
        LDR.N    R0,??DataTable27_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        ADDS     R0,R7,R0
        LDRB     R0,[R0, #+4]
        LDR.W    R1,??DataTable32_1
        STRB     R0,[R1, #+1]
// 4407     }
// 4408     else
// 4409     {
// 4410     }
// 4411       
// 4412     return 1;   
??BlackGetRightStep2Win_11:
        MOVS     R0,#+1
        B.N      ??BlackGetRightStep2Win_7
// 4413   }
// 4414   else
// 4415   {
// 4416     //窗口内没有扫描到跳变沿，该行的黑线位置记为无效值，返回0失败.
// 4417     BlackRightLoc[row][0] = MaxValUint8;
??BlackGetRightStep2Win_8:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 4418     return 0;
        MOVS     R0,#+0
??BlackGetRightStep2Win_7:
        POP      {R1,R4-R7,PC}    ;; return
// 4419   }
// 4420 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27:
        DC32     BlackRightBigChangeNumx

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_1:
        DC32     BlackRightBigChangeJumpFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_2:
        DC32     BlackRightBigChangeSlopeStore

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_3:
        DC32     BlackRight5Slope

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_4:
        DC32     BlackRight5SlopeIndex

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_5:
        DC32     BlackRight5SlopeRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_6:
        DC32     BlackRightBigChangeFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_7:
        DC32     ImgNew
// 4421 
// 4422 
// 4423 
// 4424 //======================================================================
// 4425 //函数名：BlackGetRightStep1Scan
// 4426 //功  能：右黑线提取中，第1阶段的行扫描函数
// 4427 //参  数：扫描起始行FirstLine, 扫描结束行LastLine
// 4428 //返  回：0~CameraHight - 1行数 255采集失败
// 4429 //影  响：BlackRightRealWB[], BlackRightRealW[], BlackRightRealB[], BlackRightLoc[][],
// 4430 //        LimitRightWB, LimitRightW, LimitRightB
// 4431 //说  明：1. 可用于正常地第1阶段行扫描，也可用于十字再检测时的行扫描
// 4432 //        2. 正常第1阶段扫描时，会更改3个关键阈值的值。
// 4433 //             
// 4434 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4435 uint8 BlackGetRightStep1Scan(uint8 FirstLine, uint8 LastLine, uint8 CrossFlag)
// 4436 {
BlackGetRightStep1Scan:
        PUSH     {R3-R9,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
// 4437     uint8 row, temp1, temp2;
// 4438     uint8 abs1;
// 4439     uint8 tempWB, tempW, tempB;
// 4440     uint8 flag, i;
// 4441     
// 4442     flag = 0;
        MOVS     R7,#+0
// 4443     //最近的BlackStep1Size行用差值法找黑线
// 4444     for(row = FirstLine; row > LastLine; row -= 2)
        MOV      R8,R4
        B.N      ??BlackGetRightStep1Scan_0
// 4445     {
// 4446       //判断是否连续两行检测到跳变，可疑黑点有3个点，暂取其中一个
// 4447       temp1 = BlackGetRightStep1Edge(row, 1, 0);
// 4448       temp2 = BlackGetRightStep1Edge(row-1, 2, 0);
// 4449       if(temp1 == 1 && temp2 == 1)//这里可以这么写，不用嵌套if，因为&&的特点
// 4450       {
// 4451         abs1 = AbsRe(BlackRightLoc[row-1][0], BlackRightLoc[row][0]);
// 4452         //进一步判断连续两行的黑点的间隔是否够小，且暂取第1个可疑黑点。
// 4453         if(abs1 < BlackRightStep1ScanMinus)
// 4454         {
// 4455           //检测到了连续的黑线，停止差值法找跳变沿，节省时间，下面进入第2阶段                                     
// 4456           //如果不是十字再检测的情况，就更新一下实际的3个关键值，否则不更新。
// 4457           if(CrossFlag == 1)
// 4458             {           
// 4459               //差值的处理，留有裕度，且有上下界。
// 4460               tempWB = (BlackRightRealWB[0] + BlackRightRealWB[1]) / 2 - LimitRightWBMargin; 
// 4461               if(tempWB < LimitRightWBMin) tempWB = LimitRightWBMin;
// 4462               else if(tempWB > LimitRightWBMax) tempWB = LimitRightWBMax;
// 4463               else ;
// 4464               LimitRightWB = tempWB;
// 4465               
// 4466               //白点的处理，留有裕度，且有上下界。
// 4467               tempW = (BlackRightRealW[0] + BlackRightRealW[1]) / 2 - LimitRightWMargin;
// 4468               if(tempW < LimitRightWMin) tempW = LimitRightWMin;
// 4469               else if(tempW > LimitRightWMax) tempW = LimitRightWMax;
// 4470               else ;
// 4471               LimitRightW = tempW;
// 4472               
// 4473               //黑点的处理，留有裕度，且有上下界。
// 4474               tempB = (BlackRightRealB[0] + BlackRightRealB[1]) / 2 + LimitRightBMargin;
// 4475               if(tempB < LimitRightBMin) tempB = LimitRightBMin;
// 4476               else if(tempB > LimitRightBMax) tempB = LimitRightBMax;
// 4477               else ;
// 4478               //黑色阈值不能超过白色
// 4479               if(tempB >= LimitRightW)
// 4480               {
// 4481                 tempB = LimitRightW - 1;
// 4482               }
// 4483               else
// 4484               {
// 4485               }             
// 4486               LimitRightB = tempB;           
// 4487             }
// 4488           break;
// 4489         }
// 4490         else
// 4491         {
// 4492           //连续两行相差的列太大，视为错误点。
// 4493           BlackRightLoc[row][0] = MaxValUint8;
// 4494           BlackRightLoc[row-1][0] = MaxValUint8;
// 4495           //大跳变检测数组的复位。
// 4496           BlackRightBigChangeNumx[3] = MaxValUint8;
// 4497           BlackRightBigChangeNumx[4] = MaxValUint8;
// 4498           BlackRightBigChangeNumy[3] = MaxValUint8;
// 4499           BlackRightBigChangeNumy[4] = MaxValUint8;
// 4500           BlackRightBigChangeJumpFlag = 0;
// 4501         }
// 4502       }
// 4503       else if(temp1 == 0 && temp2 == 1)
// 4504       {
// 4505         //走到这里，说明双黑线检测成功之前有双线之一采集成功。
// 4506         flag = 1;
// 4507       }
// 4508       else if(temp1 == 1 && temp2 == 0)
??BlackGetRightStep1Scan_1:
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+1
        BNE.N    ??BlackGetRightStep1Scan_2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackGetRightStep1Scan_2
// 4509       {
// 4510         //走到这里，说明双黑线检测成功之前有双线之一采集成功。
// 4511         flag = 1;
        MOVS     R7,#+1
// 4512       }
??BlackGetRightStep1Scan_2:
        SUBS     R8,R8,#+2
??BlackGetRightStep1Scan_0:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R5,R8
        BCS.W    ??BlackGetRightStep1Scan_3
        MOVS     R2,#+0
        MOVS     R1,#+1
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetRightStep1Edge
        MOV      R9,R0
        MOVS     R2,#+0
        MOVS     R1,#+2
        SUBS     R0,R8,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetRightStep1Edge
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+1
        BNE.W    ??BlackGetRightStep1Scan_4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.W    ??BlackGetRightStep1Scan_4
        LDR.W    R0,??DataTable33
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R1,[R0, #+0]
        LDR.W    R0,??DataTable33
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R2,#+3
        MLA      R0,R2,R8,R0
        LDRB     R0,[R0, #-3]
        BL       AbsRe
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+8
        BGE.N    ??BlackGetRightStep1Scan_5
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+1
        BNE.N    ??BlackGetRightStep1Scan_6
        LDR.W    R0,??DataTable32_4
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable32_4
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+20
        LDR.W    R1,??DataTable33_1
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackGetRightStep1Scan_7
        LDR.W    R0,??DataTable33_1
        LDRB     R0,[R0, #+0]
        B.N      ??BlackGetRightStep1Scan_8
??BlackGetRightStep1Scan_7:
        LDR.W    R1,??DataTable33_2
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackGetRightStep1Scan_8
        LDR.W    R0,??DataTable33_2
        LDRB     R0,[R0, #+0]
??BlackGetRightStep1Scan_8:
        LDR.N    R1,??DataTable28
        STRB     R0,[R1, #+0]
        LDR.W    R0,??DataTable32_5
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable32_5
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+40
        LDR.W    R1,??DataTable33_3
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackGetRightStep1Scan_9
        LDR.W    R0,??DataTable33_3
        LDRB     R0,[R0, #+0]
        B.N      ??BlackGetRightStep1Scan_10
??BlackGetRightStep1Scan_9:
        LDR.W    R1,??DataTable33_4
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackGetRightStep1Scan_10
        LDR.W    R0,??DataTable33_4
        LDRB     R0,[R0, #+0]
??BlackGetRightStep1Scan_10:
        LDR.N    R1,??DataTable28_2
        STRB     R0,[R1, #+0]
        LDR.W    R0,??DataTable32_1
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable32_1
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        ADDS     R0,R0,#+35
        LDR.W    R1,??DataTable33_5
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackGetRightStep1Scan_11
        LDR.W    R0,??DataTable33_5
        LDRB     R0,[R0, #+0]
        B.N      ??BlackGetRightStep1Scan_12
??BlackGetRightStep1Scan_11:
        LDR.W    R1,??DataTable33_6
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackGetRightStep1Scan_12
        LDR.W    R0,??DataTable33_6
        LDRB     R0,[R0, #+0]
??BlackGetRightStep1Scan_12:
        LDR.N    R1,??DataTable28_2
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCC.N    ??BlackGetRightStep1Scan_13
        LDR.N    R0,??DataTable28_2
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
??BlackGetRightStep1Scan_13:
        LDR.N    R1,??DataTable29
        STRB     R0,[R1, #+0]
// 4513       else
// 4514       {
// 4515       }
// 4516     }   
// 4517     
// 4518     //检测了BlackStep1Size行也没有检测到连续的黑线，说明黑线检测失败
// 4519     if(row <= LastLine)
??BlackGetRightStep1Scan_6:
??BlackGetRightStep1Scan_3:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R5,R8
        BCC.N    ??BlackGetRightStep1Scan_14
// 4520     {
// 4521       return MaxValUint8;
        MOVS     R0,#+255
        B.N      ??BlackGetRightStep1Scan_15
// 4522     }               
??BlackGetRightStep1Scan_5:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable33
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R8,R1
        STRB     R0,[R1, #+0]
        MOVS     R0,#+255
        LDR.W    R1,??DataTable33
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R8,R1
        STRB     R0,[R1, #-3]
        MOVS     R0,#+255
        LDR.W    R1,??DataTable31_1
        STRB     R0,[R1, #+3]
        MOVS     R0,#+255
        LDR.W    R1,??DataTable31_1
        STRB     R0,[R1, #+4]
        MOVS     R0,#+255
        LDR.W    R1,??DataTable33_7
        STRB     R0,[R1, #+3]
        MOVS     R0,#+255
        LDR.W    R1,??DataTable33_7
        STRB     R0,[R1, #+4]
        MOVS     R0,#+0
        LDR.W    R1,??DataTable34
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetRightStep1Scan_2
??BlackGetRightStep1Scan_4:
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+0
        BNE.W    ??BlackGetRightStep1Scan_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.W    ??BlackGetRightStep1Scan_1
        MOVS     R7,#+1
        B.N      ??BlackGetRightStep1Scan_2
// 4523     else
// 4524     {
// 4525         //双黑线检测成功 且 双黑线检测成功之前有双线之一采集成功。
// 4526         if(flag == 1)
??BlackGetRightStep1Scan_14:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+1
        BNE.N    ??BlackGetRightStep1Scan_16
// 4527         {
// 4528             //把前面的双线之一都去掉。
// 4529             for(i = FirstLine; ; i--)
        B.N      ??BlackGetRightStep1Scan_17
// 4530             {
// 4531                 if(i == row) break;
// 4532                 BlackRightLoc[i][0] = MaxValUint8;
??BlackGetRightStep1Scan_18:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
        SUBS     R4,R4,#+1
??BlackGetRightStep1Scan_17:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R4,R8
        BNE.N    ??BlackGetRightStep1Scan_18
// 4533                 
// 4534             }
// 4535             
// 4536             //第一次scan
// 4537             if(CrossFlag == 1)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+1
        BNE.N    ??BlackGetRightStep1Scan_16
// 4538             {
// 4539               //把前3个大斜率检测储存值都去掉，后面2个不用，因为是对的。
// 4540               for(i = 0; i <= 2; i++)
        MOVS     R4,#+0
        B.N      ??BlackGetRightStep1Scan_19
// 4541               {
// 4542                   BlackRightBigChangeNumx[i] = MaxValUint8;
??BlackGetRightStep1Scan_20:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable31_1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R0,[R4, R1]
// 4543                   BlackRightBigChangeNumy[i] = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable33_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R0,[R4, R1]
// 4544                   BlackRightBigChangeJumpFlag = 0; //小细节。
        MOVS     R0,#+0
        LDR.W    R1,??DataTable34
        STRB     R0,[R1, #+0]
// 4545               }
        ADDS     R4,R4,#+1
??BlackGetRightStep1Scan_19:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+3
        BLT.N    ??BlackGetRightStep1Scan_20
// 4546             }
// 4547             else
// 4548             {
// 4549             }
// 4550             
// 4551         }
// 4552         else
// 4553         {
// 4554 
// 4555         }
// 4556         
// 4557         return row;
??BlackGetRightStep1Scan_16:
        MOV      R0,R8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
??BlackGetRightStep1Scan_15:
        POP      {R1,R4-R9,PC}    ;; return
// 4558     }
// 4559   
// 4560 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable28:
        DC32     LimitRightWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable28_1:
        DC32     LimitRightWBAdjust

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable28_2:
        DC32     LimitRightW
// 4561 
// 4562 
// 4563 //======================================================================
// 4564 //函数名：BlackRightCrossStep3
// 4565 //功  能：右线提取中，十字检测第3阶段，脑补线函数
// 4566 //参  数：第1段有效黑线的最后一行FirstLine， 第2段有效黑线的第一行LastLine
// 4567 //返  回：1成功 0失败
// 4568 //影  响：BlackRightLoc[][0]
// 4569 //说  明：1. 这里有一些浮点运算，会占时间，在调用本函数时要慎重，尽量不要用。
// 4570 //        2. 这里的两点间连线的思路很不错，float强转和uint8强转用得很好。
// 4571 //             
// 4572 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4573 uint8 BlackRightCrossStep3(uint8 FirstLine, uint8 LastLine)
// 4574 {
BlackRightCrossStep3:
        PUSH     {R4-R7}
// 4575   int32 delta_x, delta_y, delta, index;
// 4576   uint8 row, temp1, temp2;
// 4577   uint8 i;
// 4578   //uint8 temp3, temp4, flag1, flag2;
// 4579   
// 4580   //超始行比结束行还高，报错！
// 4581   if(LastLine >= FirstLine)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCC.N    ??BlackRightCrossStep3_0
// 4582   {
// 4583     //uart_sendN(UART0, (uint8 *)"\nError In BlackRightCrossStep3!", 31);
// 4584     return 0;  
        MOVS     R0,#+0
        B.N      ??BlackRightCrossStep3_1
// 4585   }
// 4586   
// 4587   //有可能出现被大斜率检测删掉的情况，这种情况下该行黑线判断为错误，就不进行十字补线了。
// 4588   if(BlackRightLoc[LastLine][0] == MaxValUint8)
??BlackRightCrossStep3_0:
        LDR.W    R2,??DataTable33
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BNE.N    ??BlackRightCrossStep3_2
// 4589   {
// 4590     //返回失败前扫屁股
// 4591     for(i = FirstLine - 1; ; i--)
        SUBS     R0,R0,#+1
        B.N      ??BlackRightCrossStep3_3
??BlackRightCrossStep3_4:
        SUBS     R0,R0,#+1
// 4592     {
// 4593       BlackRightLoc[i][0] = MaxValUint8;
??BlackRightCrossStep3_3:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable33
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 4594       if(i == 0) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackRightCrossStep3_4
// 4595     }
// 4596     
// 4597     return 0;
        MOVS     R0,#+0
        B.N      ??BlackRightCrossStep3_1
// 4598   }
// 4599   else
// 4600   {
// 4601   }
// 4602   
// 4603   temp1 = BlackRightLoc[FirstLine][0];
??BlackRightCrossStep3_2:
        LDR.W    R2,??DataTable33
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R4,[R2, #+0]
// 4604   temp2 = BlackRightLoc[LastLine][0];
        LDR.W    R2,??DataTable33
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
// 4605   
// 4606   /*
// 4607   flag1 = 1;
// 4608   flag2 = 1;
// 4609   //确认这两个点是直角处的点，也就是往右6个点仍为黑点
// 4610   if(temp1 <= (CameraRealWidth - 9))
// 4611   {
// 4612     temp3 = (
// 4613             (ImgNew[FirstLine+1][temp1+6] < LimitRightB)
// 4614           &&(ImgNew[FirstLine+1][temp1+7] < LimitRightB)
// 4615           &&(ImgNew[FirstLine+1][temp1+8] < LimitRightB)
// 4616           );
// 4617     if(temp3)
// 4618     {
// 4619       flag1 = 0;  
// 4620     }
// 4621   }
// 4622   
// 4623   if(temp2 <= (CameraRealWidth - 9))
// 4624   {
// 4625     temp4 = (
// 4626             (ImgNew[LastLine-1][temp2+6] < LimitRightB)
// 4627           &&(ImgNew[LastLine-1][temp2+7] < LimitRightB)
// 4628           &&(ImgNew[LastLine-1][temp2+8] < LimitRightB)
// 4629           );
// 4630     if(temp4)
// 4631     {
// 4632       flag2 = 0;  
// 4633     }
// 4634   }
// 4635   
// 4636   if((flag1 == 0) || (flag2 == 0))
// 4637   {
// 4638     return 0;  
// 4639   }
// 4640   
// 4641   */
// 4642   
// 4643   delta_y = FirstLine - LastLine;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        SUBS     R3,R0,R1
// 4644   
// 4645   
// 4646   //斜率向右
// 4647   if(temp1 < temp2)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R4,R2
        BCS.N    ??BlackRightCrossStep3_5
// 4648   {
// 4649     //放大BlackRightCrossStep3Multi倍
// 4650     delta_x = temp2 - temp1;
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        SUBS     R2,R2,R4
// 4651     delta = delta_x * BlackRightCrossStep3Multi / delta_y; 
        MOV      R4,#+1000
        MULS     R2,R4,R2
        SDIV     R3,R2,R3
// 4652     
// 4653     index = 1;
        MOVS     R4,#+1
// 4654     for(row = FirstLine - 1; row >= LastLine + 1; row-- )
        SUBS     R2,R0,#+1
??BlackRightCrossStep3_6:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADDS     R5,R1,#+1
        CMP      R2,R5
        BLT.N    ??BlackRightCrossStep3_7
// 4655     {
// 4656       //每次右移一点点
// 4657       BlackRightLoc[row][0] = (uint8)(BlackRightLoc[FirstLine][0] + delta * index / BlackRightCrossStep3Multi);
        LDR.W    R5,??DataTable33
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R0,R5
        LDRB     R5,[R5, #+0]
        MUL      R6,R4,R3
        MOV      R7,#+1000
        SDIV     R6,R6,R7
        ADDS     R5,R6,R5
        LDR.W    R6,??DataTable33
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R7,#+3
        MLA      R6,R7,R2,R6
        STRB     R5,[R6, #+0]
// 4658       index += 1;
        ADDS     R4,R4,#+1
// 4659     }
        SUBS     R2,R2,#+1
        B.N      ??BlackRightCrossStep3_6
// 4660   }
// 4661   //斜率向左
// 4662   else if(temp1 > temp2)
??BlackRightCrossStep3_5:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R2,R4
        BCS.N    ??BlackRightCrossStep3_8
// 4663   {
// 4664     //放大BlackRightCrossStep3Multi倍
// 4665     delta_x = temp1 - temp2;
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        SUBS     R2,R4,R2
// 4666     delta = delta_x * BlackRightCrossStep3Multi / delta_y;
        MOV      R4,#+1000
        MULS     R2,R4,R2
        SDIV     R3,R2,R3
// 4667     
// 4668     index = 1;
        MOVS     R4,#+1
// 4669     for(row = FirstLine - 1; row >= LastLine + 1; row-- )
        SUBS     R2,R0,#+1
??BlackRightCrossStep3_9:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADDS     R5,R1,#+1
        CMP      R2,R5
        BLT.N    ??BlackRightCrossStep3_7
// 4670     {
// 4671       //每次右移一点点
// 4672       BlackRightLoc[row][0] = (uint8)(BlackRightLoc[FirstLine][0] - delta * index / BlackRightCrossStep3Multi);
        LDR.W    R5,??DataTable33
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R0,R5
        LDRB     R5,[R5, #+0]
        MUL      R6,R4,R3
        MOV      R7,#+1000
        SDIV     R6,R6,R7
        SUBS     R5,R5,R6
        LDR.W    R6,??DataTable33
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R7,#+3
        MLA      R6,R7,R2,R6
        STRB     R5,[R6, #+0]
// 4673       index += 1;
        ADDS     R4,R4,#+1
// 4674     }
        SUBS     R2,R2,#+1
        B.N      ??BlackRightCrossStep3_9
// 4675   }
// 4676   //斜率直走，这个不太可能出现
// 4677   else
// 4678   {
// 4679     for(row = FirstLine - 1; row >= LastLine + 1; row-- )
??BlackRightCrossStep3_8:
        SUBS     R2,R0,#+1
        B.N      ??BlackRightCrossStep3_10
// 4680     {
// 4681       //赋相同的值
// 4682       BlackRightLoc[row][0] = temp1;
??BlackRightCrossStep3_11:
        LDR.W    R0,??DataTable33
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R3,#+3
        MLA      R0,R3,R2,R0
        STRB     R4,[R0, #+0]
// 4683     }
        SUBS     R2,R2,#+1
??BlackRightCrossStep3_10:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADDS     R0,R1,#+1
        CMP      R2,R0
        BGE.N    ??BlackRightCrossStep3_11
// 4684   }
// 4685   
// 4686   return 1;
??BlackRightCrossStep3_7:
        MOVS     R0,#+1
??BlackRightCrossStep3_1:
        POP      {R4-R7}
        BX       LR               ;; return
// 4687     
// 4688 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29:
        DC32     LimitRightB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_1:
        DC32     BlackRightEdgeStartCol

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_2:
        DC32     BlackGetPreDir

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_3:
        DC32     BlackLeftLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_4:
        DC32     SingleBlackLastAllFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_5:
        DC32     SingleBlackWidthMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_6:
        DC32     BlackRightPredictL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable29_7:
        DC32     BlackRightPredictR
// 4689 
// 4690 //======================================================================
// 4691 //函数名：BlackRightCrossConfirm
// 4692 //功  能：十字再检测时 ，线头有效性的确认。
// 4693 //参  数：第1段黑线的真实结束行Row1RealLastLine，第2段黑线的真实起始行Row2RealFirstLine
// 4694 //返  回：1成功 0失败
// 4695 //影  响：无
// 4696 //说  明：1. 为了应对270度弯道十字误检测而诞生，编写过程中没有过多考虑其它情况。
// 4697 //      
// 4698 //             
// 4699 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4700 uint8 BlackRightCrossConfirm(uint8 Row1RealLastLine, uint8 Row2RealFirstLine)
// 4701 {
BlackRightCrossConfirm:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+12
        MOVS     R4,R1
// 4702   uint8 row, index;
// 4703   uint8 x[BlackCrossConfirmNum];
// 4704   uint8 y[BlackCrossConfirmNum];
// 4705   
// 4706   int32 a0, a1, temp;
// 4707   
// 4708   //1. 先进行第二段黑线起始点方向判定，若不满足右十字该有方向，则判定为错误点。直接返回0.
// 4709   if(BlackRightLoc[Row2RealFirstLine][0] < BlackRightLoc[Row2RealFirstLine-1][0]) 
        LDR.W    R1,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R4,R2
        LDRB     R2,[R2, #-3]
        CMP      R1,R2
        BCS.N    ??BlackRightCrossConfirm_0
// 4710   {
// 4711     return 0;
        MOVS     R0,#+0
        B.N      ??BlackRightCrossConfirm_1
// 4712   }
// 4713   //2. 再进行第二段黑线起始两点的斜率判定，也就是对两点的列差作限定，太大则有可能是大弯回弯。针对回弯十字误补。
// 4714   else if((BlackRightLoc[Row2RealFirstLine][0] > BlackRightLoc[Row2RealFirstLine-1][0])
// 4715    &&(BlackRightLoc[Row2RealFirstLine][0] - BlackRightLoc[Row2RealFirstLine-1][0] >= 3)
// 4716     )
??BlackRightCrossConfirm_0:
        LDR.W    R1,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #-3]
        LDR.W    R2,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R4,R2
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BCS.N    ??BlackRightCrossConfirm_2
        LDR.W    R1,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R4,R2
        LDRB     R2,[R2, #-3]
        SUBS     R1,R1,R2
        CMP      R1,#+3
        BLT.N    ??BlackRightCrossConfirm_2
// 4717   {
// 4718     return 0;
        MOVS     R0,#+0
        B.N      ??BlackRightCrossConfirm_1
// 4719   }
// 4720   //3. 再对上一幅图的左线斜率和左线头进行检查。这里的左线斜率与左线头因为还没更新，所以是上一幅图的。针对回弯十字误补。
// 4721   else if((SlopeL + BlackCrossConfirmSlopeLimit < 0) //上一幅图的左线斜率很大。
// 4722    &&(BlackLeftHeadLine < BlackCrossConfirmHeadLineLimit) //上一幅图的左线线头比较高。（防止因为线特别短而造成的斜率不准确）
// 4723      )
??BlackRightCrossConfirm_2:
        LDR.W    R1,??DataTable34_1
        LDR      R1,[R1, #+0]
        ADDW     R1,R1,#+3000
        CMP      R1,#+0
        BPL.N    ??BlackRightCrossConfirm_3
        LDR.W    R1,??DataTable34_2
        LDRB     R1,[R1, #+0]
        CMP      R1,#+40
        BGE.N    ??BlackRightCrossConfirm_3
// 4724   {
// 4725     return 0;
        MOVS     R0,#+0
        B.N      ??BlackRightCrossConfirm_1
// 4726   }
// 4727   else
// 4728   {
// 4729   }
// 4730   
// 4731   //第一段黑线太短，无法检测正确性时，检查要补的行是不是够长，如果够长，就视为正确。
// 4732   //if(Row1RealLastLine >= CameraHight - 5 && Row2RealFirstLine > Row1RealLastLine + BlackRightCrossConfirmGapLine) return 1;
// 4733   //if(Row1RealLastLine >= CameraHight - 5) return 0;
// 4734   
// 4735   //以左上角为原点，向下为x轴正方向（0~49），向右为y轴正方向(0~249)
// 4736   index = 0;
??BlackRightCrossConfirm_3:
        MOVS     R1,#+0
// 4737   for(row = Row1RealLastLine; ; row++)
        B.N      ??BlackRightCrossConfirm_4
??BlackRightCrossConfirm_5:
        ADDS     R0,R0,#+1
// 4738   {
// 4739     //有效行的记录
// 4740     if(BlackRightLoc[row][0] != MaxValUint8)
??BlackRightCrossConfirm_4:
        LDR.W    R2,??DataTable33
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BEQ.N    ??BlackRightCrossConfirm_6
// 4741     {
// 4742       y[index] = BlackRightLoc[row][0];
        LDR.W    R2,??DataTable33
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        ADD      R3,SP,#+0
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R2,[R1, R3]
// 4743       x[index] = row;
        ADD      R2,SP,#+4
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R0,[R1, R2]
// 4744       index++;
        ADDS     R1,R1,#+1
// 4745     }
// 4746     //点数够多，则跳出。
// 4747     if(index == BlackCrossConfirmNum) break;
??BlackRightCrossConfirm_6:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??BlackRightCrossConfirm_7
// 4748     //直到最低行仍没有凑够足够的点数，说明第一段有效黑线太短.
// 4749     if(row == CameraHight - 1) 
// 4750     {
// 4751       if(index == 0) return 0;
// 4752       //判断第二段黑点起点是不是在第一段黑点末尾的左边一定范围内
// 4753       if(BlackRightLoc[Row2RealFirstLine][0] < y[0] && y[0] - BlackRightLoc[Row2RealFirstLine][0] < 50)
// 4754       {
// 4755         return 1;
// 4756       }
// 4757       else
// 4758       {
// 4759         return 0;
// 4760       }      
// 4761     }
// 4762     else
// 4763     {
// 4764     }
// 4765   }
// 4766   
// 4767   //最小二乘法
// 4768   //y = a0 + a1 * x
// 4769   a1 = LeastSquarea1(x, y, BlackCrossConfirmNum);
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
        BL       LeastSquarea1
        MOVS     R5,R0
// 4770   
// 4771   //判断斜率是不是从左下到右上，如果是，则返回失败。
// 4772   if(a1 + BlackRightCrossConfirmSlopeLimit < 0) return 0;
        ADDW     R0,R5,#+1100
        CMP      R0,#+0
        BPL.N    ??BlackRightCrossConfirm_8
        MOVS     R0,#+0
        B.N      ??BlackRightCrossConfirm_1
??BlackRightCrossConfirm_7:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??BlackRightCrossConfirm_5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??BlackRightCrossConfirm_9
        MOVS     R0,#+0
        B.N      ??BlackRightCrossConfirm_1
??BlackRightCrossConfirm_9:
        LDR.W    R0,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        LDRB     R1,[SP, #+0]
        CMP      R0,R1
        BCS.N    ??BlackRightCrossConfirm_10
        LDRB     R0,[SP, #+0]
        LDR.W    R1,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+50
        BGE.N    ??BlackRightCrossConfirm_10
        MOVS     R0,#+1
        B.N      ??BlackRightCrossConfirm_1
??BlackRightCrossConfirm_10:
        MOVS     R0,#+0
        B.N      ??BlackRightCrossConfirm_1
// 4773   
// 4774   a0 = LeastSquarea0(x, y, a1, BlackCrossConfirmNum);
??BlackRightCrossConfirm_8:
        MOVS     R3,#+4
        MOVS     R2,R5
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
        BL       LeastSquarea0
// 4775   
// 4776   //temp为第2段黑线起始行本应该在的位置。
// 4777   temp = (a0 + a1 * Row2RealFirstLine) / LeastSquareMulti;
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MLA      R0,R4,R5,R0
        MOV      R1,#+1000
        SDIV     R0,R0,R1
// 4778 
// 4779   //把这个点限定在窗内
// 4780   if(
// 4781     (BlackRightLoc[Row2RealFirstLine][0] > temp - BlackCrossConfirmWin)  //向左的值太大的话，会在“下双上单”的时候出现十字误补线。
// 4782   &&(BlackRightLoc[Row2RealFirstLine][0] < temp + BlackCrossConfirmWin)  
// 4783     )
        SUBS     R1,R0,#+40
        LDR.W    R2,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R4,R2
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BGE.N    ??BlackRightCrossConfirm_11
        LDR.W    R1,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,#+40
        CMP      R1,R0
        BGE.N    ??BlackRightCrossConfirm_11
// 4784   {
// 4785     return 1;
        MOVS     R0,#+1
        B.N      ??BlackRightCrossConfirm_1
// 4786   }
// 4787   else
// 4788   {
// 4789     return 0;
??BlackRightCrossConfirm_11:
        MOVS     R0,#+0
??BlackRightCrossConfirm_1:
        POP      {R1-R5,PC}       ;; return
// 4790   }
// 4791     
// 4792   
// 4793 }
// 4794 
// 4795 
// 4796 
// 4797 //======================================================================
// 4798 //函数名：BlackGetRightCrossSpeWin
// 4799 //功  能：右黑线十字再检测时，窗口的特殊扫描
// 4800 //参  数：待处理行号row, 窗口左边界colleft, 窗口右边界colright, 第几次使用use.
// 4801 //返  回：1成功  0失败
// 4802 //影  响：BlackRightLoc[][0]
// 4803 //说  明：1. 满足两批条件，才能检测成功。只有一个点的记录。
// 4804 //        2. 窗口内没有检测到，则检测失败。
// 4805 //        3. 跟普通窗口扫描不一样，前者输入变量是预测值和窗口大小，后者是左右边界。  
// 4806 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4807 uint8 BlackGetRightCrossSpeWin(uint8 row, uint8 colleft, uint8 colright, uint8 use)
// 4808 {
BlackGetRightCrossSpeWin:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
        MOVS     R0,R1
        MOVS     R6,R2
        MOVS     R5,R3
// 4809   uint8 col;
// 4810 
// 4811   //在规划好的窗口内，从左往右查找跳变沿
// 4812   //防止溢出
// 4813   //对右边界的限制 
// 4814   if(colright >= (CameraRealWidth - 5 - BlackRightEdgeNum)) 
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+242
        BLT.N    ??BlackGetRightCrossSpeWin_0
// 4815   {
// 4816     colright = CameraRealWidth - 5 - BlackRightEdgeNum;
        MOVS     R6,#+242
// 4817   }  
// 4818   else
// 4819   {
// 4820   }
// 4821   
// 4822   //左线开始扫描时，若该幅图像没有单线，则右线扫描的左边界必须在该行有效左黑线的右边。
// 4823   if((BlackGetPreDir == 0 || BlackGetPreDir == 2)
// 4824    &&(SingleBlackAllFlag == 0)
// 4825    &&(BlackLeftLoc[row][0] != MaxValUint8)
// 4826      )
??BlackGetRightCrossSpeWin_0:
        LDR.W    R1,??DataTable34_3
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BEQ.N    ??BlackGetRightCrossSpeWin_1
        LDR.W    R1,??DataTable34_3
        LDRB     R1,[R1, #+0]
        CMP      R1,#+2
        BNE.N    ??BlackGetRightCrossSpeWin_2
??BlackGetRightCrossSpeWin_1:
        LDR.N    R1,??DataTable31
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BNE.N    ??BlackGetRightCrossSpeWin_2
        LDR.W    R1,??DataTable34_4
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BEQ.N    ??BlackGetRightCrossSpeWin_2
// 4827   {
// 4828     colleft = MaxRe(colleft, BlackLeftLoc[row][0]);
        LDR.W    R1,??DataTable34_4
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       MaxRe
// 4829   }
// 4830   else
// 4831   {
// 4832   }
// 4833   
// 4834   //窗口预测值记录
// 4835   BlackRightPredictL[row] = colleft;
??BlackGetRightCrossSpeWin_2:
        LDR.W    R1,??DataTable34_5
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R0,[R4, R1]
// 4836   BlackRightPredictR[row] = colright;
        LDR.W    R1,??DataTable34_6
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R6,[R4, R1]
// 4837   
// 4838   //若左边界在右边界右边，直接返回失败。
// 4839   if(colleft >= colright) return 0;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R0,R6
        BCC.N    ??BlackGetRightCrossSpeWin_3
        MOVS     R0,#+0
        B.N      ??BlackGetRightCrossSpeWin_4
// 4840   
// 4841   //开窗扫描跳变沿
// 4842   col = BlackGetRightJustWin(row, colleft, colright);
??BlackGetRightCrossSpeWin_3:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MOVS     R2,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R1,R0
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetRightJustWin
        MOVS     R6,R0
// 4843   if(col != MaxValUint8)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+255
        BEQ.N    ??BlackGetRightCrossSpeWin_5
// 4844   {
// 4845     //两批条件均满足，直接记录该点为黑线，返回即可
// 4846     BlackRightLoc[row][0] = col + 1 + BlackRightEdgeNum;
        ADDS     R0,R6,#+4
        LDR.W    R1,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 4847     
// 4848     //最终确认前，需要对大斜率进行检测。
// 4849     if(BlackRightBigChangeCheck(row, use) == 0)
        MOVS     R1,R5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackRightBigChangeCheck
        CMP      R0,#+0
        BNE.N    ??BlackGetRightCrossSpeWin_6
// 4850     {
// 4851       //没通过大跳变检测。
// 4852       BlackRightBigChangeCheckRow[row] = 1;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable32_2
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        STRB     R0,[R4, R1]
// 4853       BlackRightBigChangeCheckAllRow = 1;             
        MOVS     R0,#+1
        LDR.N    R1,??DataTable32_3
        STRB     R0,[R1, #+0]
// 4854       
// 4855       BlackRightLoc[row][0] = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 4856       return 0;
        MOVS     R0,#+0
        B.N      ??BlackGetRightCrossSpeWin_4
// 4857     }
// 4858     else
// 4859     {
// 4860     }
// 4861     
// 4862     //记录3个关键值的实际信息，作为后面的参考。
// 4863     if(use == 1)
??BlackGetRightCrossSpeWin_6:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+1
        BNE.N    ??BlackGetRightCrossSpeWin_7
// 4864     {
// 4865       BlackRightRealWB[0] = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum]; 
        LDR.W    R0,??DataTable34_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRB     R0,[R6, R0]
        LDR.W    R1,??DataTable34_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #+4]
        SUBS     R0,R0,R1
        LDR.N    R1,??DataTable32_4
        STRB     R0,[R1, #+0]
// 4866       BlackRightRealW[0] = ImgNew[row][col];
        LDR.W    R0,??DataTable34_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRB     R0,[R6, R0]
        LDR.N    R1,??DataTable32_5
        STRB     R0,[R1, #+0]
// 4867       BlackRightRealB[0] = ImgNew[row][col+1+BlackRightEdgeNum];
        LDR.W    R0,??DataTable34_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R0,R6,R0
        LDRB     R0,[R0, #+4]
        LDR.N    R1,??DataTable32_1
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetRightCrossSpeWin_8
// 4868     }
// 4869     else if(use == 2)
??BlackGetRightCrossSpeWin_7:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+2
        BNE.N    ??BlackGetRightCrossSpeWin_8
// 4870     {
// 4871       BlackRightRealWB[1] = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum]; 
        LDR.W    R0,??DataTable34_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRB     R0,[R6, R0]
        LDR.W    R1,??DataTable34_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #+4]
        SUBS     R0,R0,R1
        LDR.N    R1,??DataTable32_4
        STRB     R0,[R1, #+1]
// 4872       BlackRightRealW[1] = ImgNew[row][col];
        LDR.W    R0,??DataTable34_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRB     R0,[R6, R0]
        LDR.N    R1,??DataTable32_5
        STRB     R0,[R1, #+1]
// 4873       BlackRightRealB[1] = ImgNew[row][col+1+BlackRightEdgeNum];
        LDR.W    R0,??DataTable34_7
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R0,R6,R0
        LDRB     R0,[R0, #+4]
        LDR.N    R1,??DataTable32_1
        STRB     R0,[R1, #+1]
// 4874     }
// 4875     else
// 4876     {
// 4877     }
// 4878       
// 4879     return 1;
??BlackGetRightCrossSpeWin_8:
        MOVS     R0,#+1
        B.N      ??BlackGetRightCrossSpeWin_4
// 4880   }
// 4881   else
// 4882   {
// 4883     //窗口内没有检测到跳变沿，该行黑线置无效值，返回0失败。
// 4884     BlackRightLoc[row][0] = MaxValUint8;
??BlackGetRightCrossSpeWin_5:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 4885     return 0;   
        MOVS     R0,#+0
??BlackGetRightCrossSpeWin_4:
        POP      {R4-R6,PC}       ;; return
// 4886   }
// 4887 
// 4888 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31:
        DC32     SingleBlackAllFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable31_1:
        DC32     BlackRightBigChangeNumx
// 4889 
// 4890 
// 4891 
// 4892 //======================================================================
// 4893 //函数名：BlackGetRightCrossSpeScan
// 4894 //功  能：十字再检测时，右线头的特殊扫描
// 4895 //参  数：第2段黑线的预测起始行Row2FirstLine， 第2段黑线的预测结束行Row2LastLine，
// 4896 //        最近一次的窗口预测值LastWinPredict
// 4897 //返  回：MaxValUint8失败，否则成功。
// 4898 //影  响：
// 4899 //说  明：
// 4900 //      
// 4901 //             
// 4902 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 4903 uint8 BlackGetRightCrossSpeScan(uint8 Row2FirstLine, uint8 Row2LastLine, uint8 LastWinPredict)
// 4904 {
BlackGetRightCrossSpeScan:
        PUSH     {R4-R8,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R0,R2
// 4905   uint8 row;
// 4906   uint8 temp1, temp2, temppredict, tempminus;
// 4907   uint8 colleft, colright;
// 4908   uint8 i;
// 4909   
// 4910   //最近一次的窗口预测值。
// 4911   temppredict = LastWinPredict;
// 4912   
// 4913   //colright的确定
// 4914   //对于右黑线扫描，colright表示之前所有有效右黑线的最右点。
// 4915   //找第1个有效右黑线。
// 4916   for(i = Row2FirstLine+1; ; i++)
        ADDS     R1,R4,#+1
        B.N      ??BlackGetRightCrossSpeScan_0
??BlackGetRightCrossSpeScan_1:
        ADDS     R1,R1,#+1
// 4917   {
// 4918     if(BlackRightLoc[i][0] != MaxValUint8)
??BlackGetRightCrossSpeScan_0:
        LDR.W    R2,??DataTable33
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BEQ.N    ??BlackGetRightCrossSpeScan_2
// 4919     {
// 4920       colright = BlackRightLoc[i][0];
        LDR.W    R2,??DataTable33
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R1,R3,R1,R2
        LDRB     R6,[R1, #+0]
// 4921       break;
// 4922     }
// 4923     else
// 4924     {
// 4925     }
// 4926     //若一直到最近一行仍没有有效左黑线，则返回失败。理论上不可能走到这里。
// 4927     if(i == CameraHight - 1) return MaxValUint8;
// 4928   }
// 4929   //暂时不用最右边的左黑线，也就相当于用最左边的左黑线。
// 4930 //  //找最右的有效右黑线。
// 4931 //  for( ; ; i++)
// 4932 //  {
// 4933 //    if(BlackRightLoc[i][0] != MaxValUint8)
// 4934 //    {
// 4935 //      if(BlackRightLoc[i][0] > colright)
// 4936 //      {
// 4937 //        colright = BlackRightLoc[i][0];
// 4938 //      }
// 4939 //      else
// 4940 //      {
// 4941 //      }
// 4942 //    }
// 4943 //    else
// 4944 //    {
// 4945 //    }
// 4946 //    
// 4947 //    if(i == CameraHight - 1) break;
// 4948 //  }
// 4949   
// 4950   for(row = Row2FirstLine; ; row -= 2)
        B.N      ??BlackGetRightCrossSpeScan_3
??BlackGetRightCrossSpeScan_2:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+59
        BNE.N    ??BlackGetRightCrossSpeScan_1
        MOVS     R0,#+255
        B.N      ??BlackGetRightCrossSpeScan_4
??BlackGetRightCrossSpeScan_5:
        SUBS     R4,R4,#+2
// 4951   {
// 4952     //colleft的确定
// 4953     colleft = BoundaryLimitRe(temppredict - BlackRightWinVal * 2,
// 4954                               0,
// 4955                               CameraRealWidth - 1); 
??BlackGetRightCrossSpeScan_3:
        MOVS     R2,#+249
        MOVS     R1,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        SUBS     R0,R0,#+30
        BL       BoundaryLimitRe
        MOV      R8,R0
// 4956     //为了防止窗口有错，所以最右边不得大于BlackRightEdgeStartColOffset。
// 4957     colleft = MinRe(colleft, CameraRealWidth / 2 - 1 - BlackRightEdgeStartColOffset[row]);
        LDR.W    R0,??DataTable36
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDRB     R0,[R4, R0]
        RSBS     R1,R0,#+124
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOV      R0,R8
        BL       MinRe
        MOV      R8,R0
// 4958     
// 4959     //连续2行检测黑点。
// 4960     temp1 = BlackGetRightCrossSpeWin(row, colleft, colright, 1);
        MOVS     R3,#+1
        MOVS     R2,R6
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOV      R1,R8
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetRightCrossSpeWin
        MOVS     R7,R0
// 4961     temp2 = BlackGetRightCrossSpeWin(row-1, colleft, colright, 2);
        MOVS     R3,#+2
        MOVS     R2,R6
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOV      R1,R8
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        SUBS     R0,R4,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetRightCrossSpeWin
// 4962     //连续2行开窗检测黑点成功，则线头检测成功。跳出。
// 4963     if(temp1 == 1 && temp2 == 1)
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+1
        BNE.N    ??BlackGetRightCrossSpeScan_6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??BlackGetRightCrossSpeScan_6
// 4964     {
// 4965       return row;
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        B.N      ??BlackGetRightCrossSpeScan_4
// 4966     }
// 4967     //连续2行开窗检测黑线失败，则窗口预测点继续变化，继续开窗检测。
// 4968     else if(temp1 == 0 && temp2 == 0)
??BlackGetRightCrossSpeScan_6:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BNE.N    ??BlackGetRightCrossSpeScan_7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackGetRightCrossSpeScan_7
// 4969     {
// 4970       //预测点按趋势走也要限幅。
// 4971       tempminus = BoundaryLimitRe(BlackRightWinPredictStore2 + BlackRightWinPredictStore2 - BlackRightWinPredictStore1,
// 4972                                   0,
// 4973                                   CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable38
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable38
        LDRB     R3,[R3, #+0]
        ADDS     R0,R3,R0
        LDR.W    R3,??DataTable37
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
// 4974       //temp在这里表示窗口预测点位置。
// 4975       temppredict = tempminus;
// 4976       BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
        LDR.W    R1,??DataTable37
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable37_1
        STRB     R1,[R2, #+0]
// 4977       BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
        LDR.W    R1,??DataTable38
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable37
        STRB     R1,[R2, #+0]
// 4978       BlackRightWinPredictStore2 = temppredict;      
        LDR.W    R1,??DataTable38
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetRightCrossSpeScan_8
// 4979     }
// 4980     //其中一行开窗检测成功，则当作干扰点，窗口预测点继续变化，继续开窗检测。
// 4981     else
// 4982     {
// 4983       //当作干扰点滤掉。
// 4984       BlackRightLoc[row][0] = MaxValUint8;
??BlackGetRightCrossSpeScan_7:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #+0]
// 4985       BlackRightLoc[row-1][0] = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable33
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        STRB     R0,[R1, #-3]
// 4986       
// 4987       //预测点按趋势走也要限幅。
// 4988       tempminus = BoundaryLimitRe(BlackRightWinPredictStore2 + BlackRightWinPredictStore2 - BlackRightWinPredictStore1,
// 4989                                   0,
// 4990                                   CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable38
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable38
        LDRB     R3,[R3, #+0]
        ADDS     R0,R3,R0
        LDR.W    R3,??DataTable37
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
// 4991       //temp在这里表示窗口预测点位置。
// 4992       temppredict = tempminus;
// 4993       BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
        LDR.W    R1,??DataTable37
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable37_1
        STRB     R1,[R2, #+0]
// 4994       BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
        LDR.W    R1,??DataTable38
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable37
        STRB     R1,[R2, #+0]
// 4995       BlackRightWinPredictStore2 = temppredict;         
        LDR.W    R1,??DataTable38
        STRB     R0,[R1, #+0]
// 4996     }
// 4997       
// 4998       
// 4999       
// 5000     //一直到第Row2LastLine行也没有连续2行检测成功，则返回失败。
// 5001     if(row == Row2LastLine) 
??BlackGetRightCrossSpeScan_8:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R4,R5
        BNE.W    ??BlackGetRightCrossSpeScan_5
// 5002     {
// 5003       return MaxValUint8;
        MOVS     R0,#+255
??BlackGetRightCrossSpeScan_4:
        POP      {R4-R8,PC}       ;; return
// 5004     }
// 5005     else
// 5006     {
// 5007     }
// 5008   }
// 5009  
// 5010 
// 5011 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32:
        DC32     SingleBlackFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_1:
        DC32     BlackRightRealB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_2:
        DC32     BlackRightBigChangeCheckRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_3:
        DC32     BlackRightBigChangeCheckAllRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_4:
        DC32     BlackRightRealWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable32_5:
        DC32     BlackRightRealW
// 5012 
// 5013 
// 5014 
// 5015 
// 5016 //======================================================================
// 5017 //函数名：BlackRightAgainForCross
// 5018 //功  能：右黑线提取中，针对十字的再检测程序
// 5019 //参  数：第2段黑线的预测起始行Row2FirstLine， 第2段黑线的预测结束行Row2LastLine，
// 5020 //        第1段黑线的实际结束行Row1RealLastLine, 最近一次的窗口预测值LastWinPredict
// 5021 //返  回：1成功 0失败
// 5022 //影  响：BlackRightLoc[][]。 （不会影响那几个阈值。）
// 5023 //说  明：1. 本函数会调用浮点运算的函数，预计花费较多时间，调用入口需谨慎。
// 5024 //        2. 本函数仅影响了BlackRightLoc[][]，以后也应该保持。
// 5025 //             
// 5026 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 5027 uint8 BlackRightAgainForCross(uint8 Row2FirstLine, uint8 Row2LastLine, uint8 Row1RealLastLine, uint8 LastWinPredict)
// 5028 {
BlackRightAgainForCross:
        PUSH     {R3-R9,LR}
        MOVS     R6,R0
        MOVS     R4,R1
        MOVS     R5,R2
// 5029     uint8 row, temp, temp1, temp2;
// 5030     uint8 Row2RealFirstLine; //第2段黑线的真实起始行
// 5031     uint8 i;
// 5032     
// 5033     uint8 tempWB, tempW, tempB;
// 5034     uint8 tempminus;
// 5035     
// 5036     //第1段黑线的真实结束行有可能因为大跳变被删掉，所以需要重新查找并更新。
// 5037     for(i = Row1RealLastLine; i <= CameraHight - 1; i++)
        MOVS     R0,R5
        B.N      ??BlackRightAgainForCross_0
??BlackRightAgainForCross_1:
        ADDS     R0,R0,#+1
??BlackRightAgainForCross_0:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+60
        BGE.N    ??BlackRightAgainForCross_2
// 5038     {
// 5039       if(BlackRightLoc[i][0] != MaxValUint8)
        LDR.W    R1,??DataTable38_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BEQ.N    ??BlackRightAgainForCross_1
// 5040       {
// 5041         Row1RealLastLine = i;
        MOVS     R5,R0
// 5042         break;
// 5043       }
// 5044       else
// 5045       {
// 5046       }
// 5047     }
// 5048     //由于直角黑块不允许检测十字再补线，所以当第1段黑线真实结束行的斜上方有黑块时，不允许补线。
// 5049     //取5列。
// 5050     for(i = 0; i <= 5; i++)
??BlackRightAgainForCross_2:
        MOVS     R0,#+0
        B.N      ??BlackRightAgainForCross_3
??BlackRightAgainForCross_4:
        ADDS     R0,R0,#+1
??BlackRightAgainForCross_3:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+6
        BGE.N    ??BlackRightAgainForCross_5
// 5051     {
// 5052       if(ImgNew[Row1RealLastLine - 4][BlackRightLoc[Row1RealLastLine][0] - 5 - i] < LimitRightB) //往远5行。斜左上方。
        LDR.W    R1,??DataTable34_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R5,R1
        LDR.W    R2,??DataTable38_1
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R7,#+3
        MLA      R2,R7,R5,R2
        LDRB     R2,[R2, #+0]
        SUBS     R2,R2,#+5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        SUBS     R2,R2,R0
        ADDS     R1,R2,R1
        SUBS     R1,R1,#+1000
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable37_2
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BCS.N    ??BlackRightAgainForCross_6
// 5053       {
// 5054         return 0;
        MOVS     R0,#+0
        B.N      ??BlackRightAgainForCross_7
// 5055       }
// 5056       else if(ImgNew[Row1RealLastLine - 5][BlackRightLoc[Row1RealLastLine][0] - 5 - i] < LimitRightB) //往远5行。斜左上方。
??BlackRightAgainForCross_6:
        LDR.W    R1,??DataTable34_7
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R5,R1
        LDR.W    R2,??DataTable38_1
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R7,#+3
        MLA      R2,R7,R5,R2
        LDRB     R2,[R2, #+0]
        SUBS     R2,R2,#+5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        SUBS     R2,R2,R0
        ADDS     R1,R2,R1
        SUBW     R1,R1,#+1250
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable37_2
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BCS.N    ??BlackRightAgainForCross_4
// 5057       {
// 5058         return 0;
        MOVS     R0,#+0
        B.N      ??BlackRightAgainForCross_7
// 5059       }
// 5060       else
// 5061       {
// 5062       }      
// 5063     }
// 5064     
// 5065     //十字再检测第1阶段，找线头。
// 5066     //temp = BlackGetRightStep1Scan(Row2FirstLine, Row2LastLine, 0); //第3个参数0表示是十字再检测，不用更新3个关键值
// 5067     
// 5068     //十字再检测第1阶段，找线头，不采用Scan的方式，采用Win的方式。
// 5069     temp = BlackGetRightCrossSpeScan(Row2FirstLine, Row2LastLine, LastWinPredict);
??BlackRightAgainForCross_5:
        MOVS     R2,R3
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,R4
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R6
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetRightCrossSpeScan
        MOV      R8,R0
// 5070     
// 5071     //线头查找失败，或找到最远两行（继续执行后面会数组超出界限），就直接判定为失败。
// 5072     if(
// 5073       (temp == MaxValUint8)
// 5074     ||(temp <= 1)
// 5075     ||(BlackAgainForCrossFar10CutSwitch == 1 && temp <= 9)  //当远10行删除开关开启时，且十字再检测时的第2段黑线线头在最远的10行，则十字再检测失败。
// 5076       )
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+255
        BEQ.N    ??BlackRightAgainForCross_8
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+2
        BLT.N    ??BlackRightAgainForCross_8
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+10
        BGE.N    ??BlackRightAgainForCross_9
// 5077     {
// 5078       //扫屁股工作。        //i >= Row2LastLine
// 5079       for(i = Row2FirstLine; ; i--)
??BlackRightAgainForCross_8:
        MOVS     R0,R6
        B.N      ??BlackRightAgainForCross_10
??BlackRightAgainForCross_11:
        SUBS     R0,R0,#+1
// 5080       {
// 5081         BlackRightLoc[i][0] = MaxValUint8;
??BlackRightAgainForCross_10:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable38_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 5082         if(i == 0) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackRightAgainForCross_11
// 5083       }
// 5084       return 0;  
        MOVS     R0,#+0
        B.N      ??BlackRightAgainForCross_7
// 5085     }
// 5086     else 
// 5087     {
// 5088       ////////////////如果要注释，就从这里开始注释
// 5089       
// 5090       //十字再检测的线头不在限定的范围内，认为是干扰点，不用顺着线头找线了，直接退出。
// 5091       if(BlackRightCrossConfirm(Row1RealLastLine+1, temp) == 0)
??BlackRightAgainForCross_9:
        MOV      R1,R8
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADDS     R0,R5,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackRightCrossConfirm
        CMP      R0,#+0
        BNE.N    ??BlackRightAgainForCross_12
// 5092       { //扫屁股工作。         //i >= (temp-1)
// 5093         BlackRightCrossConfirmFlag = 1;  //右十字线头标志确认失败，超出预想范围。
        MOVS     R0,#+1
        LDR.W    R1,??DataTable38_2
        STRB     R0,[R1, #+0]
// 5094         for(i = Row2FirstLine; ; i--)
        MOVS     R0,R6
        B.N      ??BlackRightAgainForCross_13
??BlackRightAgainForCross_14:
        SUBS     R0,R0,#+1
// 5095         {
// 5096           BlackRightLoc[i][0] = MaxValUint8;
??BlackRightAgainForCross_13:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable38_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 5097           if(i == 0) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackRightAgainForCross_14
// 5098         }
// 5099         return 0;
        MOVS     R0,#+0
        B.N      ??BlackRightAgainForCross_7
// 5100       }
// 5101       //十字再检测的线头的确在限定的范围内，可以继续。
// 5102       else
// 5103       {
// 5104         BlackRightCrossConfirmFlag = 2;  //右十字线头标志确认成功。
??BlackRightAgainForCross_12:
        MOVS     R0,#+2
        LDR.W    R1,??DataTable38_2
        STRB     R0,[R1, #+0]
// 5105         row = temp;
        MOV      R7,R8
// 5106       }
// 5107       
// 5108       ////////////////如果要注释，就从这里结束注释
// 5109       
// 5110       //暂时不用confirm函数，如果要用的话 ，就把后面这句话去掉，前面注释去掉。
// 5111       //row = temp;
// 5112     }
// 5113     
// 5114     Row2RealFirstLine = row; //记录第2段黑线的真实起始行
        MOVS     R6,R7
// 5115     
// 5116     //十字再检测第2阶段，顺着线头找线。
// 5117     //temp为预测的黑点位置
// 5118     temp = BoundaryLimitRe(BlackRightLoc[row-1][0] + BlackRightLoc[row-1][0] - BlackRightLoc[row][0],
// 5119                            0,
// 5120                            CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable38_1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R3,#+3
        MLA      R0,R3,R7,R0
        LDRB     R0,[R0, #-3]
        LDR.W    R3,??DataTable38_1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R12,#+3
        MLA      R3,R12,R7,R3
        LDRB     R3,[R3, #-3]
        UXTAB    R0,R3,R0
        LDR.W    R3,??DataTable38_1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R12,#+3
        MLA      R3,R12,R7,R3
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
        MOV      R8,R0
// 5121     //预测值更新后就刷新一次堆栈，堆栈顶部丢失。
// 5122     BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
        LDR.W    R0,??DataTable37
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable37_1
        STRB     R0,[R1, #+0]
// 5123     BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
        LDR.W    R0,??DataTable38
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable37
        STRB     R0,[R1, #+0]
// 5124     BlackRightWinPredictStore2 = temp;
        LDR.W    R0,??DataTable38
        STRB     R8,[R0, #+0]
// 5125     
// 5126     //从最近的认证行到取最远的行
// 5127     for(row -= 2; ; row -= 2)
        SUBS     R7,R7,#+2
        B.N      ??BlackRightAgainForCross_15
??BlackRightAgainForCross_16:
        SUBS     R7,R7,#+2
// 5128     {
// 5129       //连续2行检测黑点
// 5130       temp1 = BlackGetRightStep2Win(row, BlackRightWinVal, temp, 1);
??BlackRightAgainForCross_15:
        MOVS     R3,#+1
        MOV      R2,R8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,#+15
        MOVS     R0,R7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetRightStep2Win
        MOV      R9,R0
// 5131       temp2 = BlackGetRightStep2Win(row-1, BlackRightWinVal, temp, 2);
        MOVS     R3,#+2
        MOV      R2,R8
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,#+15
        SUBS     R0,R7,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetRightStep2Win
// 5132       
// 5133       //若连续2行的黑点检测成功，则更新3个阈值，更新预测点的位置
// 5134       if(temp1 && temp2) 
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+0
        BEQ.W    ??BlackRightAgainForCross_17
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BEQ.W    ??BlackRightAgainForCross_17
// 5135       {
// 5136         //差值的处理，留有裕度，且有上下界。
// 5137         tempWB = (BlackRightRealWB[0] + BlackRightRealWB[1]) / 2 - LimitRightWBMargin; 
        LDR.W    R0,??DataTable38_3
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable38_3
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+20
// 5138         if(tempWB < LimitRightWBMin) tempWB = LimitRightWBMin;
        LDR.N    R1,??DataTable33_1
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackRightAgainForCross_18
        LDR.N    R0,??DataTable33_1
        LDRB     R0,[R0, #+0]
        B.N      ??BlackRightAgainForCross_19
// 5139         else if(tempWB > LimitRightWBMax) tempWB = LimitRightWBMax;
??BlackRightAgainForCross_18:
        LDR.N    R1,??DataTable33_2
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackRightAgainForCross_19
        LDR.N    R0,??DataTable33_2
        LDRB     R0,[R0, #+0]
// 5140         else ;
// 5141         LimitRightWB = tempWB;
??BlackRightAgainForCross_19:
        LDR.W    R1,??DataTable38_4
        STRB     R0,[R1, #+0]
// 5142         
// 5143         //白点的处理，留有裕度，且有上下界。
// 5144         tempW = (BlackRightRealW[0] + BlackRightRealW[1]) / 2 - LimitRightWMargin;
        LDR.W    R0,??DataTable38_5
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable38_5
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+40
// 5145         if(tempW < LimitRightWMin) tempW = LimitRightWMin;
        LDR.N    R1,??DataTable33_3
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackRightAgainForCross_20
        LDR.N    R0,??DataTable33_3
        LDRB     R0,[R0, #+0]
        B.N      ??BlackRightAgainForCross_21
// 5146         else if(tempW > LimitRightWMax) tempW = LimitRightWMax;
??BlackRightAgainForCross_20:
        LDR.N    R1,??DataTable33_4
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackRightAgainForCross_21
        LDR.N    R0,??DataTable33_4
        LDRB     R0,[R0, #+0]
// 5147         else ;
// 5148         LimitRightW = tempW;
??BlackRightAgainForCross_21:
        LDR.W    R1,??DataTable38_6
        STRB     R0,[R1, #+0]
// 5149         
// 5150         //黑点的处理，留有裕度，且有上下界。
// 5151         tempB = (BlackRightRealB[0] + BlackRightRealB[1]) / 2 + LimitRightBMargin;
        LDR.W    R0,??DataTable38_7
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable38_7
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        ADDS     R0,R0,#+35
// 5152         if(tempB < LimitRightBMin) tempB = LimitRightBMin;
        LDR.N    R1,??DataTable33_5
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackRightAgainForCross_22
        LDR.N    R0,??DataTable33_5
        LDRB     R0,[R0, #+0]
        B.N      ??BlackRightAgainForCross_23
// 5153         else if(tempB > LimitRightBMax) tempB = LimitRightBMax;
??BlackRightAgainForCross_22:
        LDR.N    R1,??DataTable33_6
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackRightAgainForCross_23
        LDR.N    R0,??DataTable33_6
        LDRB     R0,[R0, #+0]
// 5154         else ;
// 5155         //黑色阈值不能超过白色
// 5156         if(tempB >= LimitRightW)
??BlackRightAgainForCross_23:
        LDR.W    R1,??DataTable38_6
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCC.N    ??BlackRightAgainForCross_24
// 5157         {
// 5158           tempB = LimitRightW - 1;
        LDR.W    R0,??DataTable38_6
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
// 5159         }
// 5160         else
// 5161         {
// 5162         }              
// 5163         LimitRightB = tempB;     
??BlackRightAgainForCross_24:
        LDR.W    R1,??DataTable37_2
        STRB     R0,[R1, #+0]
// 5164         
// 5165         //对预测值的更新。
// 5166         temp = BoundaryLimitRe(BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0],
// 5167                                0,
// 5168                                CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable38_1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R3,#+3
        MLA      R0,R3,R7,R0
        LDRB     R0,[R0, #-3]
        LDR.W    R3,??DataTable38_1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R12,#+3
        MLA      R3,R12,R7,R3
        LDRB     R3,[R3, #-3]
        UXTAB    R0,R3,R0
        LDR.W    R3,??DataTable38_1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R12,#+3
        MLA      R3,R12,R7,R3
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
        MOV      R8,R0
// 5169         //预测值更新后就刷新一次堆栈，堆栈顶部丢失。
// 5170         BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
        LDR.W    R0,??DataTable37
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable37_1
        STRB     R0,[R1, #+0]
// 5171         BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
        LDR.W    R0,??DataTable38
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable37
        STRB     R0,[R1, #+0]
// 5172         BlackRightWinPredictStore2 = temp;
        LDR.W    R0,??DataTable38
        STRB     R8,[R0, #+0]
        B.N      ??BlackRightAgainForCross_25
// 5173       }
// 5174       //如果没能连续两行检测黑点成功，原本打算用原位置的预测点，后来发现效果不好，所以决定按预测点的趋势走。
// 5175       else
// 5176       {        
// 5177         //预测点按趋势走也要限幅。
// 5178         tempminus = BoundaryLimitRe(BlackRightWinPredictStore2 + BlackRightWinPredictStore2 - BlackRightWinPredictStore1,
// 5179                                     0,
// 5180                                     CameraRealWidth - 1);
??BlackRightAgainForCross_17:
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable38
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable38
        LDRB     R3,[R3, #+0]
        ADDS     R0,R3,R0
        LDR.W    R3,??DataTable37
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
        MOV      R8,R0
// 5181         //temp在这里表示窗口预测点位置。
// 5182         temp = tempminus;
// 5183         BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
        LDR.W    R0,??DataTable37
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable37_1
        STRB     R0,[R1, #+0]
// 5184         BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
        LDR.W    R0,??DataTable38
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable37
        STRB     R0,[R1, #+0]
// 5185         BlackRightWinPredictStore2 = temp;
        LDR.W    R0,??DataTable38
        STRB     R8,[R0, #+0]
// 5186       }
// 5187       
// 5188       if((row == Row2LastLine) || (row == Row2LastLine+1)) break;      
??BlackRightAgainForCross_25:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R7,R4
        BEQ.N    ??BlackRightAgainForCross_26
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        ADDS     R0,R4,#+1
        CMP      R7,R0
        BNE.W    ??BlackRightAgainForCross_16
// 5189     }
// 5190     
// 5191     //检查是否因大斜率而被削头。如果有，则更新头的位置，如果没有，则正常补线。
// 5192     if (BlackRightLoc[Row1RealLastLine][0] == MaxValUint8)
??BlackRightAgainForCross_26:
        LDR.W    R0,??DataTable38_1
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??BlackRightAgainForCross_27
// 5193     {
// 5194 
// 5195         //头足够高，找回头。
// 5196         for (i = Row1RealLastLine; ; i++)
        MOVS     R0,R5
        B.N      ??BlackRightAgainForCross_28
??BlackRightAgainForCross_29:
        ADDS     R0,R0,#+1
// 5197         {
// 5198             if (BlackRightLoc[i][0] != MaxValUint8)
??BlackRightAgainForCross_28:
        LDR.W    R1,??DataTable38_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BEQ.N    ??BlackRightAgainForCross_30
// 5199             {
// 5200                 Row1RealLastLine = i;
        MOVS     R5,R0
// 5201                 break;
// 5202             }
// 5203             else
// 5204             {
// 5205             }
// 5206             //直到最后一行也没有找到有效行，不用补线，直接返回1.
// 5207             if (i == CameraHight - 1) return 1;
// 5208         }
// 5209 
// 5210         //十字再检测第3阶段，脑补两段线的接线。
// 5211         if (BlackRightCrossStep3(Row1RealLastLine, Row2RealFirstLine) == 0)
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackRightCrossStep3
        CMP      R0,#+0
        BNE.N    ??BlackRightAgainForCross_31
// 5212         {
// 5213             return 0;
        MOVS     R0,#+0
        B.N      ??BlackRightAgainForCross_7
// 5214         }
??BlackRightAgainForCross_30:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??BlackRightAgainForCross_29
        MOVS     R0,#+1
        B.N      ??BlackRightAgainForCross_7
// 5215 
// 5216     }
// 5217     else
// 5218     {
// 5219         //没有被大斜率削头。
// 5220         //十字再检测第3阶段，脑补两段线的接线。
// 5221         if (BlackRightCrossStep3(Row1RealLastLine, Row2RealFirstLine) == 0)
??BlackRightAgainForCross_27:
        MOVS     R1,R6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackRightCrossStep3
        CMP      R0,#+0
        BNE.N    ??BlackRightAgainForCross_31
// 5222         {
// 5223             return 0;
        MOVS     R0,#+0
        B.N      ??BlackRightAgainForCross_7
// 5224         }
// 5225     }
// 5226     
// 5227     return 1;
??BlackRightAgainForCross_31:
        MOVS     R0,#+1
??BlackRightAgainForCross_7:
        POP      {R1,R4-R9,PC}    ;; return
// 5228         
// 5229 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33:
        DC32     BlackRightLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33_1:
        DC32     LimitRightWBMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33_2:
        DC32     LimitRightWBMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33_3:
        DC32     LimitRightWMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33_4:
        DC32     LimitRightWMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33_5:
        DC32     LimitRightBMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33_6:
        DC32     LimitRightBMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable33_7:
        DC32     BlackRightBigChangeNumy
// 5230 
// 5231 
// 5232 //======================================================================
// 5233 //函数名：BlackRightStep4BackLine
// 5234 //功  能：右黑线提取中，第4阶段十字向后补线函数。
// 5235 //参  数：Step4StartLine开始行,flag标志0表示正常调用，1表示单线错误的调用
// 5236 //返  回：1成功 0失败
// 5237 //影  响：BlackRightLoc[][0]
// 5238 //说  明：1. 这里引用了float型的函数，有可能占用较长的时间。
// 5239 //        2. 想要减少时间，可以把宏定义BlackBackLineNum减至3或者2.
// 5240 //        3. 单线错误的调用时，不用检测十字外尾
// 5241 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 5242 uint8 BlackRightStep4BackLine(uint8 Step4StartLine, uint8 flag)
// 5243 {
BlackRightStep4BackLine:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+12
        MOVS     R4,R0
// 5244   uint8 row;
// 5245   uint8 i, index;
// 5246   uint8 x[BlackBackLineNum];   //取多少个点在一开始有定义。
// 5247   uint8 y[BlackBackLineNum];
// 5248   uint8 j;
// 5249   uint8 temp1;
// 5250   uint8 tempend;
// 5251   
// 5252   int32 temp;
// 5253   int32 a0;
// 5254   int32 a1;
// 5255   
// 5256   //正常调用时，需要检测十字外尾
// 5257   if(flag == 0)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.W    ??BlackRightStep4BackLine_0
// 5258   {
// 5259     //十字外尾处理
// 5260     //第1阶段的线头比较高的话，就开始十字外尾检测。否则不用管。
// 5261     if(BlackRightStep1ScanRow < BlackRightCrossTailRowLimit)
        LDR.W    R0,??DataTable38_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+50
        BGE.W    ??BlackRightStep4BackLine_1
// 5262     {
// 5263       //检查线头处的斜率是不是很大，若很大，则怀疑有十字外尾。否则不用管。
// 5264       //这里用的斜率是十字外尾专用斜率。
// 5265       if(BlackRight5Slope[0] > BlackRightCrossTailSlopeLimit)
        LDR.W    R0,??DataTable38_9
        LDR      R0,[R0, #+0]
        MOVW     R1,#+3401
        CMP      R0,R1
        BLT.W    ??BlackRightStep4BackLine_2
// 5266       {
// 5267         //十字外尾标志置位。
// 5268         BlackRightCrossTailFlag = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable38_10
        STRB     R0,[R1, #+0]
// 5269         BlackRightHeadEndSearch();
        BL       BlackRightHeadEndSearch
// 5270         if (BlackRightEndLine - BlackRightHeadLine <= 5 && BlackLeftHeadLine != MaxValUint8 && BlackLeftEndLine != MaxValUint8)
        LDR.W    R0,??DataTable38_11
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable38_12
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BGE.N    ??BlackRightStep4BackLine_3
        LDR.N    R0,??DataTable34_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??BlackRightStep4BackLine_3
        LDR.W    R0,??DataTable38_13
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??BlackRightStep4BackLine_3
// 5271         {
// 5272             //这种情况有可能是回弯导致的，过滤掉
// 5273             for (i = BlackRightHeadLine; i <= BlackRightEndLine; i++)
        LDR.W    R0,??DataTable38_12
        LDRB     R0,[R0, #+0]
        B.N      ??BlackRightStep4BackLine_4
// 5274             {
// 5275                 BlackRightLoc[i][0] = MaxValUint8;
??BlackRightStep4BackLine_5:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable38_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 5276             }
        ADDS     R0,R0,#+1
??BlackRightStep4BackLine_4:
        LDR.W    R1,??DataTable38_11
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackRightStep4BackLine_5
// 5277             return 0;
        MOVS     R0,#+0
        B.N      ??BlackRightStep4BackLine_6
// 5278         }
// 5279         else if (BlackRight5Slope[0] == MaxValInt16)
??BlackRightStep4BackLine_3:
        LDR.W    R0,??DataTable38_9
        LDR      R0,[R0, #+0]
        MOVW     R1,#+32767
        CMP      R0,R1
        BNE.N    ??BlackRightStep4BackLine_7
// 5280         {
// 5281             //这种情况有可能是回弯导致的，过滤掉
// 5282             for (i = 0; i <= 59; i++)
        MOVS     R0,#+0
        B.N      ??BlackRightStep4BackLine_8
// 5283             {
// 5284                 BlackRightLoc[i][0] = MaxValUint8;
??BlackRightStep4BackLine_9:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable38_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 5285             }
        ADDS     R0,R0,#+1
??BlackRightStep4BackLine_8:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+60
        BLT.N    ??BlackRightStep4BackLine_9
// 5286             return 0;
        MOVS     R0,#+0
        B.N      ??BlackRightStep4BackLine_6
// 5287         }
// 5288         //5Slope数组有可能已经删掉了一些黑点，所以也要参考实际的有效黑点数。
// 5289         if(BlackRightEndLine - BlackRightHeadLine - 4 < 0 || BlackRight5SlopeIndex - 1 < 0)
??BlackRightStep4BackLine_7:
        LDR.W    R0,??DataTable38_11
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable38_12
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+4
        CMP      R0,#+0
        BMI.N    ??BlackRightStep4BackLine_10
        LDR.W    R0,??DataTable38_14
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        CMP      R0,#+0
        BPL.N    ??BlackRightStep4BackLine_11
// 5290         {
// 5291           return 0;
??BlackRightStep4BackLine_10:
        MOVS     R0,#+0
        B.N      ??BlackRightStep4BackLine_6
// 5292         }
// 5293         else
// 5294         {
// 5295         }        
// 5296         tempend = MinRe(BlackRightEndLine - BlackRightHeadLine - 4, BlackRight5SlopeIndex - 1);
??BlackRightStep4BackLine_11:
        LDR.W    R0,??DataTable38_14
        LDRB     R0,[R0, #+0]
        SUBS     R1,R0,#+1
        LDR.W    R0,??DataTable38_11
        LDRB     R0,[R0, #+0]
        LDR.W    R2,??DataTable38_12
        LDRB     R2,[R2, #+0]
        SUBS     R0,R0,R2
        SUBS     R0,R0,#+4
        BL       MinRe
        MOVS     R1,R0
// 5297         //开始消除十字外尾，找十字外尾的处理最远行。
// 5298         for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??BlackRightStep4BackLine_12
??BlackRightStep4BackLine_13:
        ADDS     R0,R0,#+1
// 5299         {
// 5300           //找斜率在直道范围内的。这里用的斜率是判断为直道的斜率。
// 5301           if(BlackRight5Slope[i] < PathJudgeStraightSlopeLimit)
??BlackRightStep4BackLine_12:
        LDR.W    R2,??DataTable38_9
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDR      R2,[R2, R0, LSL #+2]
        MOVW     R3,#+2100
        CMP      R2,R3
        BGE.N    ??BlackRightStep4BackLine_14
// 5302           {
// 5303             BlackRightCrossTailEndLine = BlackRight5SlopeRow[i];
        LDR.W    R1,??DataTable38_15
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDRB     R0,[R0, R1]
        LDR.W    R1,??DataTable38_16
        STRB     R0,[R1, #+0]
// 5304             break;
// 5305           }
// 5306           
// 5307           if(i == tempend) return 0;  //一直都很斜，则有可能是回弯，直接返回失败。
// 5308           //按理说不会走到这里，因为回弯会导致向后补线出错，向后补线出错后进来本函数时会先检查出错的原因BlackRightStep4ErrorCheck()，会检测斜率是不是都是直线，若不是则不会进来。
// 5309         }
// 5310         //向近处4个点，也就是“5”点斜率的计算末尾。
// 5311         BlackRightCrossTailEndLine += 4;
        LDR.W    R0,??DataTable38_16
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+4
        LDR.W    R1,??DataTable38_16
        STRB     R0,[R1, #+0]
// 5312         //取最开始采到的行
// 5313         i = MinRe(BlackRight5SlopeRow[0] + 4, CameraHight - 1);
        MOVS     R1,#+59
        LDR.W    R0,??DataTable38_15
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+4
        BL       MinRe
// 5314         i = MaxRe(BlackRightStep1ScanRow, i);
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R1,R0
        LDR.W    R0,??DataTable38_8
        LDRB     R0,[R0, #+0]
        BL       MaxRe
// 5315         if(i >= BlackRightCrossTailEndLine)
        LDR.W    R1,??DataTable38_16
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCC.N    ??BlackRightStep4BackLine_0
        B.N      ??BlackRightStep4BackLine_15
??BlackRightStep4BackLine_14:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R0,R1
        BNE.N    ??BlackRightStep4BackLine_13
        MOVS     R0,#+0
        B.N      ??BlackRightStep4BackLine_6
// 5316         {
// 5317           //开始删除十字外尾。
// 5318           for(; ; i--)
??BlackRightStep4BackLine_16:
        SUBS     R0,R0,#+1
// 5319           {
// 5320             BlackRightLoc[i][0] = MaxValUint8;
??BlackRightStep4BackLine_15:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable38_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 5321             if(i == BlackRightCrossTailEndLine) break;
        LDR.W    R1,??DataTable38_16
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BNE.N    ??BlackRightStep4BackLine_16
// 5322           }
// 5323           //修改向后补线的起点。
// 5324           Step4StartLine = BlackRightCrossTailEndLine - 1;
        LDR.W    R0,??DataTable38_16
        LDRB     R0,[R0, #+0]
        SUBS     R4,R0,#+1
        B.N      ??BlackRightStep4BackLine_0
// 5325         }
// 5326         else
// 5327         {
// 5328         }
// 5329       }
// 5330       else
// 5331       {
// 5332         //没有十字外尾。
// 5333         BlackRightCrossTailFlag = 0;      
??BlackRightStep4BackLine_2:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable38_10
        STRB     R0,[R1, #+0]
        B.N      ??BlackRightStep4BackLine_0
// 5334       }
// 5335     }
// 5336     else
// 5337     {    
// 5338       //没有十字外尾。
// 5339       BlackRightCrossTailFlag = 0;
??BlackRightStep4BackLine_1:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable38_10
        STRB     R0,[R1, #+0]
// 5340     }
// 5341   }
// 5342   //单线错误调用时，就不用检测十字外尾了。
// 5343   else
// 5344   {
// 5345   }  
// 5346   
// 5347 
// 5348   //正常的十字向后补线
// 5349   if(Step4StartLine - BlackBackLineNum - BlackBackLineNum < 0)
??BlackRightStep4BackLine_0:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        SUBS     R0,R4,#+8
        CMP      R0,#+0
        BPL.N    ??BlackRightStep4BackLine_17
// 5350   {
// 5351     temp1 = 0;  
        MOVS     R2,#+0
        B.N      ??BlackRightStep4BackLine_18
// 5352   }
// 5353   else
// 5354   {
// 5355     temp1 = Step4StartLine - BlackBackLineNum - BlackBackLineNum;
??BlackRightStep4BackLine_17:
        SUBS     R2,R4,#+8
// 5356   }
// 5357   
// 5358   //取BlackBackLineNum个点作为最小二乘法的基准点。
// 5359   //以左上角为原点，向下为x轴正方向，向右为y轴正方向
// 5360   index = 0;
??BlackRightStep4BackLine_18:
        MOVS     R1,#+0
// 5361   for(i = Step4StartLine; ; i--)
        MOVS     R0,R4
        B.N      ??BlackRightStep4BackLine_19
??BlackRightStep4BackLine_20:
        SUBS     R0,R0,#+1
// 5362   {
// 5363     if(BlackRightLoc[i][0] != MaxValUint8)
??BlackRightStep4BackLine_19:
        LDR.W    R3,??DataTable38_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R5,#+3
        MLA      R3,R5,R0,R3
        LDRB     R3,[R3, #+0]
        CMP      R3,#+255
        BEQ.N    ??BlackRightStep4BackLine_21
// 5364     {
// 5365       y[index] = BlackRightLoc[i][0];
        LDR.W    R3,??DataTable38_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R5,#+3
        MLA      R3,R5,R0,R3
        LDRB     R3,[R3, #+0]
        ADD      R5,SP,#+0
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R3,[R1, R5]
// 5366       x[index] = i;
        ADD      R3,SP,#+4
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R0,[R1, R3]
// 5367       index++;
        ADDS     R1,R1,#+1
// 5368     }
// 5369     if(index == BlackBackLineNum)
??BlackRightStep4BackLine_21:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??BlackRightStep4BackLine_22
// 5370     {
// 5371       break;  
// 5372     }
// 5373     if(i == temp1)
// 5374     {
// 5375       return 0;
// 5376     }
// 5377   }
// 5378   
// 5379   //最小二乘法
// 5380   //y = a0 + a1 * x
// 5381   a1 = LeastSquarea1(x, y, BlackBackLineNum);
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
        BL       LeastSquarea1
        MOVS     R5,R0
// 5382   /*
// 5383    //如果直线是从左上到右下，则说明是取到了错误的线，不必再补线，全数组清零。
// 5384   if(a1 + BlackRightBackLineSlope < 0)
// 5385   {
// 5386     for(row = Step4StartLine; ; row--)
// 5387     {
// 5388       BlackRightLoc[row][0] = MaxValUint8;
// 5389       if(row == 0) break;
// 5390     }
// 5391     return 0;
// 5392   }
// 5393   //否则继续。
// 5394   else
// 5395   {
// 5396   }
// 5397   */
// 5398   
// 5399   //直着补，不是顺着补。
// 5400   /*
// 5401   for (row = Step4StartLine + 1; row <= CameraHight - 1; row++)
// 5402   {
// 5403     BlackRightLoc[row][0] = BlackRightLoc[Step4StartLine][0];
// 5404   }
// 5405   */
// 5406   
// 5407   //顺着补，不是直着补。
// 5408   a0 = LeastSquarea0(x, y, a1, BlackBackLineNum);
        MOVS     R3,#+4
        MOVS     R2,R5
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
        BL       LeastSquarea0
// 5409   
// 5410   for(row = Step4StartLine + 1; row <= CameraHight - 1; row++)
        ADDS     R1,R4,#+1
        B.N      ??BlackRightStep4BackLine_23
??BlackRightStep4BackLine_22:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R0,R2
        BNE.N    ??BlackRightStep4BackLine_20
        MOVS     R0,#+0
        B.N      ??BlackRightStep4BackLine_6
// 5411   {
// 5412     //补线也有个度，向右和向左都不能补出范围。
// 5413     temp = (a0 + a1 * row) / LeastSquareMulti;
// 5414     if(temp >= CameraRealWidth-1)
// 5415     {
// 5416       //BlackRightLoc[row][0] = CameraRealWidth - 1;
// 5417       //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。
// 5418       for(j = row; ; j++)
// 5419       {
// 5420         BlackRightLoc[j][0] = CameraRealWidth-1;
// 5421         if(j == CameraHight - 1) break;
// 5422       }
// 5423       break;
// 5424     }
// 5425     else if(temp <= 0)
// 5426     {
// 5427       //BlackRightLoc[row][0] = 0;
// 5428       //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。我
// 5429       for(j = row; ; j++)
// 5430       {
// 5431         BlackRightLoc[j][0] = 0;
// 5432         if(j == CameraHight - 1) break;
// 5433       }
// 5434       break;
// 5435     }
// 5436     else
// 5437     {
// 5438       BlackRightLoc[row][0] = (uint8)(temp); 
??BlackRightStep4BackLine_24:
        LDR.W    R3,??DataTable38_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R1,R3
        STRB     R2,[R3, #+0]
// 5439     }
        ADDS     R1,R1,#+1
??BlackRightStep4BackLine_23:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+60
        BGE.N    ??BlackRightStep4BackLine_25
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MLA      R2,R1,R5,R0
        MOV      R3,#+1000
        SDIV     R2,R2,R3
        CMP      R2,#+249
        BLT.N    ??BlackRightStep4BackLine_26
        B.N      ??BlackRightStep4BackLine_27
??BlackRightStep4BackLine_28:
        ADDS     R1,R1,#+1
??BlackRightStep4BackLine_27:
        MOVS     R0,#+249
        LDR.W    R2,??DataTable38_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        STRB     R0,[R2, #+0]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+59
        BNE.N    ??BlackRightStep4BackLine_28
        B.N      ??BlackRightStep4BackLine_25
??BlackRightStep4BackLine_26:
        CMP      R2,#+1
        BGE.N    ??BlackRightStep4BackLine_24
        B.N      ??BlackRightStep4BackLine_29
??BlackRightStep4BackLine_30:
        ADDS     R1,R1,#+1
??BlackRightStep4BackLine_29:
        MOVS     R0,#+0
        LDR.W    R2,??DataTable38_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        STRB     R0,[R2, #+0]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+59
        BNE.N    ??BlackRightStep4BackLine_30
// 5440   }
// 5441   
// 5442   
// 5443   
// 5444   return 1;
??BlackRightStep4BackLine_25:
        MOVS     R0,#+1
??BlackRightStep4BackLine_6:
        POP      {R1-R5,PC}       ;; return
// 5445   
// 5446 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable34:
        DC32     BlackRightBigChangeJumpFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable34_1:
        DC32     SlopeL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable34_2:
        DC32     BlackLeftHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable34_3:
        DC32     BlackGetPreDir

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable34_4:
        DC32     BlackLeftLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable34_5:
        DC32     BlackRightPredictL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable34_6:
        DC32     BlackRightPredictR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable34_7:
        DC32     ImgNew
// 5447 
// 5448 
// 5449 
// 5450 
// 5451 //右黑线连续性补线

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 5452 uint8 BlackRightContinueAdd(void)
// 5453 {
BlackRightContinueAdd:
        PUSH     {R4-R6}
// 5454     uint8 row, i, j;
// 5455     uint8 tempfirst, templast;
// 5456     uint8 fangHuiWanFlag = 0;
        MOVS     R4,#+0
// 5457     uint8 fangDuanLieFlag = 0;
        MOVS     R3,#+0
// 5458     
// 5459     //右黑线连续性补线
// 5460     //只有右黑线采集成功才补线
// 5461     if(BlackRightDone == 1)
        LDR.W    R0,??DataTable38_17
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??BlackRightContinueAdd_0
// 5462     {        
// 5463         //找线尾
// 5464         for(row = CameraHight - 1; ; row--)
        MOVS     R0,#+59
        B.N      ??BlackRightContinueAdd_1
??BlackRightContinueAdd_2:
        SUBS     R0,R0,#+1
// 5465         {
// 5466           if(BlackRightLoc[row][0] != MaxValUint8)
??BlackRightContinueAdd_1:
        LDR.W    R1,??DataTable38_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BEQ.N    ??BlackRightContinueAdd_3
// 5467           {
// 5468             break;
// 5469           }
// 5470           else
// 5471           {
// 5472           }
// 5473           
// 5474           if(row == 0)
// 5475           {
// 5476             BlackRightDone = 0;
// 5477             return 0;
// 5478           }
// 5479         }
// 5480         
// 5481         //给线头线尾初始化为无效值。
// 5482         tempfirst = MaxValUint8;
        MOVS     R1,#+255
// 5483         templast = MaxValUint8;
        MOVS     R2,#+255
        B.N      ??BlackRightContinueAdd_4
??BlackRightContinueAdd_3:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackRightContinueAdd_2
        MOVS     R0,#+0
        LDR.W    R1,??DataTable38_17
        STRB     R0,[R1, #+0]
        MOVS     R0,#+0
        B.N      ??BlackRightContinueAdd_5
// 5484                 
// 5485         //开始补线
// 5486         for (; ; row--)
??BlackRightContinueAdd_6:
        SUBS     R0,R0,#+1
// 5487         {
// 5488             if (BlackRightLoc[row][0] == MaxValUint8)
??BlackRightContinueAdd_4:
        LDR.W    R2,??DataTable38_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BNE.N    ??BlackRightContinueAdd_7
// 5489             {
// 5490                 if (tempfirst == MaxValUint8)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+255
        BNE.W    ??BlackRightContinueAdd_8
// 5491                 {
// 5492                     //若线头为无效值，就记录为线头。
// 5493                     tempfirst = row + 1;
        ADDS     R1,R0,#+1
// 5494                     break;
        B.N      ??BlackRightContinueAdd_0
// 5495                 }
// 5496                 else
// 5497                 {
// 5498                 }
// 5499             }
// 5500             else
// 5501             {
// 5502                 if (tempfirst != MaxValUint8)
??BlackRightContinueAdd_7:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+255
        BEQ.W    ??BlackRightContinueAdd_8
// 5503                 {
// 5504                     //若线头已经有赋值，则开始记录线尾。
// 5505                     templast = row;
        MOVS     R2,R0
// 5506                     
// 5507                     if (templast > 5)
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+6
        BLT.N    ??BlackRightContinueAdd_9
// 5508                     {
// 5509                         if (BlackRightLoc[templast - 1][0] != MaxValUint8 && BlackRightLoc[templast - 2][0] != MaxValUint8 && BlackRightLoc[templast - 3][0] != MaxValUint8
// 5510                             && BlackRightLoc[templast - 4][0] != MaxValUint8 )
        LDR.W    R3,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R2,R3
        LDRB     R3,[R3, #-3]
        CMP      R3,#+255
        BEQ.N    ??BlackRightContinueAdd_10
        LDR.W    R3,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R2,R3
        LDRB     R3,[R3, #-6]
        CMP      R3,#+255
        BEQ.N    ??BlackRightContinueAdd_10
        LDR.W    R3,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R2,R3
        LDRB     R3,[R3, #-9]
        CMP      R3,#+255
        BEQ.N    ??BlackRightContinueAdd_10
        LDR.W    R3,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R2,R3
        LDRB     R3,[R3, #-12]
        CMP      R3,#+255
        BEQ.N    ??BlackRightContinueAdd_10
// 5511                         {
// 5512                             fangDuanLieFlag = 0;
        MOVS     R3,#+0
        B.N      ??BlackRightContinueAdd_11
// 5513                         }
// 5514                         else
// 5515                         {
// 5516                             fangDuanLieFlag = 1;
??BlackRightContinueAdd_10:
        MOVS     R3,#+1
        B.N      ??BlackRightContinueAdd_11
// 5517                         }
// 5518                     }
// 5519                     else
// 5520                     {
// 5521                         fangDuanLieFlag = 1;
??BlackRightContinueAdd_9:
        MOVS     R3,#+1
// 5522                     }
// 5523                     if (templast >= 8)
??BlackRightContinueAdd_11:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+8
        BLT.N    ??BlackRightContinueAdd_12
// 5524                     {
// 5525                         if (BlackRightLoc[templast - 1][0] != MaxValUint8 && BlackRightLoc[templast - 2][0] != MaxValUint8 && BlackRightLoc[templast - 3][0] != MaxValUint8
// 5526                             && BlackRightLoc[templast - 4][0] != MaxValUint8 && BlackRightLoc[templast - 5][0] != MaxValUint8
// 5527                                 && BlackRightLoc[templast - 6][0] != MaxValUint8 && BlackRightLoc[templast - 7][0] != MaxValUint8 && BlackRightLoc[templast - 8][0] != MaxValUint8)
        LDR.W    R4,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R2,R4
        LDRB     R4,[R4, #-3]
        CMP      R4,#+255
        BEQ.N    ??BlackRightContinueAdd_13
        LDR.W    R4,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R2,R4
        LDRB     R4,[R4, #-6]
        CMP      R4,#+255
        BEQ.N    ??BlackRightContinueAdd_13
        LDR.W    R4,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R2,R4
        LDRB     R4,[R4, #-9]
        CMP      R4,#+255
        BEQ.N    ??BlackRightContinueAdd_13
        LDR.W    R4,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R2,R4
        LDRB     R4,[R4, #-12]
        CMP      R4,#+255
        BEQ.N    ??BlackRightContinueAdd_13
        LDR.W    R4,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R2,R4
        LDRB     R4,[R4, #-15]
        CMP      R4,#+255
        BEQ.N    ??BlackRightContinueAdd_13
        LDR.W    R4,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R2,R4
        LDRB     R4,[R4, #-18]
        CMP      R4,#+255
        BEQ.N    ??BlackRightContinueAdd_13
        LDR.W    R4,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R2,R4
        LDRB     R4,[R4, #-21]
        CMP      R4,#+255
        BEQ.N    ??BlackRightContinueAdd_13
        LDR.W    R4,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R2,R4
        LDRB     R4,[R4, #-24]
        CMP      R4,#+255
        BEQ.N    ??BlackRightContinueAdd_13
// 5528                         {
// 5529                             fangHuiWanFlag = 0;
        MOVS     R4,#+0
        B.N      ??BlackRightContinueAdd_14
// 5530                         }
// 5531                         else
// 5532                         {
// 5533                             fangHuiWanFlag = 1;
??BlackRightContinueAdd_13:
        MOVS     R4,#+1
        B.N      ??BlackRightContinueAdd_14
// 5534                         }
// 5535                     }
// 5536                     else
// 5537                     {
// 5538                         fangHuiWanFlag = 1;
??BlackRightContinueAdd_12:
        MOVS     R4,#+1
// 5539                     }
// 5540                     
// 5541                     if((BlackRightLoc[tempfirst][0]>=235&&BlackRightLoc[templast][0]>=235) && (tempfirst - templast) <= 12)
??BlackRightContinueAdd_14:
        LDR.W    R5,??DataTable38_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R1,R5
        LDRB     R5,[R5, #+0]
        CMP      R5,#+235
        BLT.N    ??BlackRightContinueAdd_15
        LDR.W    R5,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R2,R5
        LDRB     R5,[R5, #+0]
        CMP      R5,#+235
        BLT.N    ??BlackRightContinueAdd_15
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        SUBS     R5,R1,R2
        CMP      R5,#+13
        BGE.N    ??BlackRightContinueAdd_15
// 5542                     {
// 5543                         //这种情况是防止黑线太靠镜头边界导致黑线不成功的
// 5544                         for (j = tempfirst - 1; ; j--)
        SUBS     R3,R1,#+1
        B.N      ??BlackRightContinueAdd_16
??BlackRightContinueAdd_17:
        SUBS     R3,R3,#+1
// 5545                         {
// 5546                             BlackRightLoc[j][0] = (BlackRightLoc[tempfirst][0] + BlackRightLoc[templast][0]) / 2;
??BlackRightContinueAdd_16:
        LDR.W    R4,??DataTable38_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R1,R4
        LDRB     R4,[R4, #+0]
        LDR.W    R5,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R2,R5
        LDRB     R5,[R5, #+0]
        ADDS     R4,R5,R4
        MOVS     R5,#+2
        SDIV     R4,R4,R5
        LDR.W    R5,??DataTable38_1
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R3,R5
        STRB     R4,[R5, #+0]
// 5547                             if (j == templast + 1) break;
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        ADDS     R4,R2,#+1
        CMP      R3,R4
        BNE.N    ??BlackRightContinueAdd_17
        B.N      ??BlackRightContinueAdd_18
// 5548                         }
// 5549                     }
// 5550                     else if ((BlackRightLoc[tempfirst][0] >= 235 && BlackRightLoc[templast][0] >= 235) && (tempfirst - templast) <20
// 5551                              && (BlackRightLoc[10][0] != MaxValUint8 || BlackRightLoc[9][0] != MaxValUint8 || BlackRightLoc[8][0] != MaxValUint8 || BlackRightLoc[7][0] != MaxValUint8 || BlackRightLoc[6][0] != MaxValUint8)
// 5552                              && fangHuiWanFlag == 0)
??BlackRightContinueAdd_15:
        LDR.W    R5,??DataTable38_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R1,R5
        LDRB     R5,[R5, #+0]
        CMP      R5,#+235
        BLT.N    ??BlackRightContinueAdd_19
        LDR.W    R5,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R2,R5
        LDRB     R5,[R5, #+0]
        CMP      R5,#+235
        BLT.N    ??BlackRightContinueAdd_19
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        SUBS     R5,R1,R2
        CMP      R5,#+20
        BGE.N    ??BlackRightContinueAdd_19
        LDR.W    R5,??DataTable38_1
        LDRB     R5,[R5, #+30]
        CMP      R5,#+255
        BNE.N    ??BlackRightContinueAdd_20
        LDR.W    R5,??DataTable38_1
        LDRB     R5,[R5, #+27]
        CMP      R5,#+255
        BNE.N    ??BlackRightContinueAdd_20
        LDR.W    R5,??DataTable38_1
        LDRB     R5,[R5, #+24]
        CMP      R5,#+255
        BNE.N    ??BlackRightContinueAdd_20
        LDR.W    R5,??DataTable38_1
        LDRB     R5,[R5, #+21]
        CMP      R5,#+255
        BNE.N    ??BlackRightContinueAdd_20
        LDR.W    R5,??DataTable38_1
        LDRB     R5,[R5, #+18]
        CMP      R5,#+255
        BEQ.N    ??BlackRightContinueAdd_19
??BlackRightContinueAdd_20:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BNE.N    ??BlackRightContinueAdd_19
// 5553                     {
// 5554                         //这种情况是防止黑线太靠镜头边界导致黑线不成功的
// 5555                         for (j = tempfirst - 1; ; j--)
        SUBS     R3,R1,#+1
        B.N      ??BlackRightContinueAdd_21
??BlackRightContinueAdd_22:
        SUBS     R3,R3,#+1
// 5556                         {
// 5557                             BlackRightLoc[j][0] = (BlackRightLoc[tempfirst][0] + BlackRightLoc[templast][0]) / 2;
??BlackRightContinueAdd_21:
        LDR.W    R4,??DataTable38_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R1,R4
        LDRB     R4,[R4, #+0]
        LDR.W    R5,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R2,R5
        LDRB     R5,[R5, #+0]
        ADDS     R4,R5,R4
        MOVS     R5,#+2
        SDIV     R4,R4,R5
        LDR.W    R5,??DataTable38_1
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R3,R5
        STRB     R4,[R5, #+0]
// 5558                             if (j == templast + 1) break;
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        ADDS     R4,R2,#+1
        CMP      R3,R4
        BNE.N    ??BlackRightContinueAdd_22
        B.N      ??BlackRightContinueAdd_18
// 5559                         }
// 5560                     }
// 5561                     else if ((BlackRightLoc[tempfirst][0] >= 235 && BlackRightLoc[templast][0] >= 235) && (tempfirst - templast) <= 35
// 5562                              && (BlackRightLoc[6][0] != MaxValUint8 || BlackRightLoc[7][0] != MaxValUint8 || BlackRightLoc[8][0] != MaxValUint8 || BlackRightLoc[10][0] != MaxValUint8 || BlackRightLoc[9][0] != MaxValUint8)
// 5563                              && fangHuiWanFlag == 0)
??BlackRightContinueAdd_19:
        LDR.W    R5,??DataTable38_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R1,R5
        LDRB     R5,[R5, #+0]
        CMP      R5,#+235
        BLT.N    ??BlackRightContinueAdd_23
        LDR.W    R5,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R2,R5
        LDRB     R5,[R5, #+0]
        CMP      R5,#+235
        BLT.N    ??BlackRightContinueAdd_23
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        SUBS     R5,R1,R2
        CMP      R5,#+36
        BGE.N    ??BlackRightContinueAdd_23
        LDR.N    R5,??DataTable38_1
        LDRB     R5,[R5, #+18]
        CMP      R5,#+255
        BNE.N    ??BlackRightContinueAdd_24
        LDR.N    R5,??DataTable38_1
        LDRB     R5,[R5, #+21]
        CMP      R5,#+255
        BNE.N    ??BlackRightContinueAdd_24
        LDR.N    R5,??DataTable38_1
        LDRB     R5,[R5, #+24]
        CMP      R5,#+255
        BNE.N    ??BlackRightContinueAdd_24
        LDR.N    R5,??DataTable38_1
        LDRB     R5,[R5, #+30]
        CMP      R5,#+255
        BNE.N    ??BlackRightContinueAdd_24
        LDR.N    R5,??DataTable38_1
        LDRB     R5,[R5, #+27]
        CMP      R5,#+255
        BEQ.N    ??BlackRightContinueAdd_23
??BlackRightContinueAdd_24:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BNE.N    ??BlackRightContinueAdd_23
// 5564                     {
// 5565                         //这种情况是防止黑线太靠镜头边界导致黑线不成功的
// 5566                         for (j = tempfirst - 1; ; j--)
        SUBS     R3,R1,#+1
        B.N      ??BlackRightContinueAdd_25
??BlackRightContinueAdd_26:
        SUBS     R3,R3,#+1
// 5567                         {
// 5568                             BlackRightLoc[j][0] = (BlackRightLoc[tempfirst][0] + BlackRightLoc[templast][0]) / 2;
??BlackRightContinueAdd_25:
        LDR.N    R4,??DataTable38_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R1,R4
        LDRB     R4,[R4, #+0]
        LDR.N    R5,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R2,R5
        LDRB     R5,[R5, #+0]
        ADDS     R4,R5,R4
        MOVS     R5,#+2
        SDIV     R4,R4,R5
        LDR.N    R5,??DataTable38_1
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R3,R5
        STRB     R4,[R5, #+0]
// 5569                             if (j == templast + 1) break;
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        ADDS     R4,R2,#+1
        CMP      R3,R4
        BNE.N    ??BlackRightContinueAdd_26
        B.N      ??BlackRightContinueAdd_18
// 5570                         }
// 5571                     }
// 5572                     //防边线断裂的
// 5573                     else if (tempfirst - templast <= 5 && fangDuanLieFlag == 0)
??BlackRightContinueAdd_23:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        SUBS     R4,R1,R2
        CMP      R4,#+6
        BGE.N    ??BlackRightContinueAdd_27
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BNE.N    ??BlackRightContinueAdd_27
// 5574                     {
// 5575                         for (j = tempfirst - 1; ; j--)
        SUBS     R3,R1,#+1
        B.N      ??BlackRightContinueAdd_28
??BlackRightContinueAdd_29:
        SUBS     R3,R3,#+1
// 5576                         {
// 5577                             BlackRightLoc[j][0] = (BlackRightLoc[tempfirst][0] + BlackRightLoc[templast][0]) / 2;
??BlackRightContinueAdd_28:
        LDR.N    R4,??DataTable38_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R1,R4
        LDRB     R4,[R4, #+0]
        LDR.N    R5,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R2,R5
        LDRB     R5,[R5, #+0]
        ADDS     R4,R5,R4
        MOVS     R5,#+2
        SDIV     R4,R4,R5
        LDR.N    R5,??DataTable38_1
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R3,R5
        STRB     R4,[R5, #+0]
// 5578                             if (j == templast + 1) break;
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        ADDS     R4,R2,#+1
        CMP      R3,R4
        BNE.N    ??BlackRightContinueAdd_29
        B.N      ??BlackRightContinueAdd_18
// 5579                         }
// 5580                     }
// 5581                     else if(tempfirst - templast >= 3) 
??BlackRightContinueAdd_27:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        SUBS     R3,R1,R2
        CMP      R3,#+3
        BLT.N    ??BlackRightContinueAdd_30
// 5582                     {
// 5583                       //两者相差太多，则后面的行全部视为错误。
// 5584                       for(i = tempfirst - 1; ; i--)
        SUBS     R0,R1,#+1
        B.N      ??BlackRightContinueAdd_31
??BlackRightContinueAdd_32:
        SUBS     R0,R0,#+1
// 5585                       {
// 5586                         BlackRightLoc[i][0] = MaxValUint8;
??BlackRightContinueAdd_31:
        MOVS     R1,#+255
        LDR.N    R2,??DataTable38_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 5587                         if(i == 0) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackRightContinueAdd_32
// 5588                       }
// 5589                       //右黑线连续性标志出错。
// 5590                       BlackRightContinueFlag = 2;
        MOVS     R0,#+2
        LDR.W    R1,??DataTable40
        STRB     R0,[R1, #+0]
// 5591                       return 0;
        MOVS     R0,#+0
        B.N      ??BlackRightContinueAdd_5
// 5592                     }
// 5593                     else
// 5594                     {
// 5595                       //一共才1或2个点，直接插值就行。
// 5596                       for(j = tempfirst - 1; ; j--)
??BlackRightContinueAdd_30:
        SUBS     R3,R1,#+1
        B.N      ??BlackRightContinueAdd_33
??BlackRightContinueAdd_34:
        SUBS     R3,R3,#+1
// 5597                       {
// 5598                         BlackRightLoc[j][0] = (BlackRightLoc[tempfirst][0] + BlackRightLoc[templast][0]) / 2;
??BlackRightContinueAdd_33:
        LDR.N    R4,??DataTable38_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R5,#+3
        MLA      R4,R5,R1,R4
        LDRB     R4,[R4, #+0]
        LDR.N    R5,??DataTable38_1
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R2,R5
        LDRB     R5,[R5, #+0]
        ADDS     R4,R5,R4
        MOVS     R5,#+2
        SDIV     R4,R4,R5
        LDR.N    R5,??DataTable38_1
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R6,#+3
        MLA      R5,R6,R3,R5
        STRB     R4,[R5, #+0]
// 5599                         if(j == templast + 1) break;
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        ADDS     R4,R2,#+1
        CMP      R3,R4
        BNE.N    ??BlackRightContinueAdd_34
// 5600                       }
// 5601                     }
// 5602                     tempfirst = MaxValUint8;
??BlackRightContinueAdd_18:
        MOVS     R1,#+255
// 5603                     templast = MaxValUint8;
        MOVS     R2,#+255
// 5604                     //右黑线连续性标志置0，不连续。
// 5605                     BlackRightContinueFlag = 0;
        MOVS     R2,#+0
        LDR.W    R3,??DataTable40
        STRB     R2,[R3, #+0]
// 5606                 }
// 5607                 else
// 5608                 {
// 5609                 }
// 5610             }
// 5611 
// 5612             if (row == 0) break;
??BlackRightContinueAdd_8:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.W    ??BlackRightContinueAdd_6
// 5613         }
// 5614     }
// 5615     else
// 5616     {
// 5617     }    
// 5618     
// 5619     return 1;
??BlackRightContinueAdd_0:
        MOVS     R0,#+1
??BlackRightContinueAdd_5:
        POP      {R4-R6}
        BX       LR               ;; return
// 5620 }
// 5621 
// 5622 
// 5623 
// 5624 //右黑线的回弯特殊检测。进来前BlackRightDone已经置为1了。
// 5625 //进来前已经进行左、右黑线的斜曲率检测。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 5626 uint8 BlackRightRollCheck(void)
// 5627 {
// 5628   uint8 temp1, temp2, temp3;
// 5629   
// 5630   //当前为单线，不进行回弯特殊检测。
// 5631   if(SingleBlackAllFlag == 1) return 1;
BlackRightRollCheck:
        LDR.W    R0,??DataTable40_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackRightRollCheck_0
        MOVS     R0,#+1
        B.N      ??BlackRightRollCheck_1
// 5632   
// 5633   //斜率确认。
// 5634   //若无效，直接确认。
// 5635   if(SlopeR == MaxValInt16)
??BlackRightRollCheck_0:
        LDR.W    R0,??DataTable40_2
        LDR      R0,[R0, #+0]
        MOVW     R1,#+32767
        CMP      R0,R1
        BNE.N    ??BlackRightRollCheck_2
// 5636   {
// 5637     temp1 = 1;
        MOVS     R0,#+1
        B.N      ??BlackRightRollCheck_3
// 5638   }
// 5639   else
// 5640   {
// 5641     //斜率的确太大。
// 5642     if(SlopeR > BlackRightRollSlopeLimit)
??BlackRightRollCheck_2:
        LDR.W    R0,??DataTable40_2
        LDR      R0,[R0, #+0]
        CMP      R0,#+2000
        BLE.N    ??BlackRightRollCheck_4
// 5643     {
// 5644       temp1 = 1;
        MOVS     R0,#+1
        B.N      ??BlackRightRollCheck_3
// 5645     }
// 5646     //斜率不大。
// 5647     else
// 5648     {
// 5649       temp1 = 0;
??BlackRightRollCheck_4:
        MOVS     R0,#+0
// 5650     }
// 5651   }
// 5652   
// 5653   //线长度确认。
// 5654   //若无效，直接确认。
// 5655   if(BlackRightHeadLine == MaxValUint8 || BlackRightEndLine == MaxValUint8)
??BlackRightRollCheck_3:
        LDR.N    R1,??DataTable38_12
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BEQ.N    ??BlackRightRollCheck_5
        LDR.N    R1,??DataTable38_11
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BNE.N    ??BlackRightRollCheck_6
// 5656   {
// 5657     temp2 = 1;
??BlackRightRollCheck_5:
        MOVS     R1,#+1
        B.N      ??BlackRightRollCheck_7
// 5658   }
// 5659   else
// 5660   {
// 5661     //线确实很短。
// 5662     if(BlackRightEndLine - BlackRightHeadLine < BlackRightRollLengthLimit)
??BlackRightRollCheck_6:
        LDR.N    R1,??DataTable38_11
        LDRB     R1,[R1, #+0]
        LDR.N    R2,??DataTable38_12
        LDRB     R2,[R2, #+0]
        SUBS     R1,R1,R2
        CMP      R1,#+8
        BGE.N    ??BlackRightRollCheck_8
// 5663     {
// 5664       temp2 = 1;
        MOVS     R1,#+1
        B.N      ??BlackRightRollCheck_7
// 5665     }
// 5666     //线很长。
// 5667     else
// 5668     {
// 5669       temp2 = 0;
??BlackRightRollCheck_8:
        MOVS     R1,#+0
// 5670     }
// 5671   }
// 5672   
// 5673   /*
// 5674   //左线斜率确认。
// 5675   //左线必须是右上到左下的，也就是负的斜率。而且斜率要求绝对值比较大。才能说明是270等大弯。
// 5676   if(SlopeL == MaxValInt16)
// 5677   {
// 5678     temp3 = 1;    
// 5679   }
// 5680   else
// 5681   {
// 5682     if(SlopeL + BlackRightRollSlopeLLimit < 0)
// 5683     {
// 5684       temp3 = 1;
// 5685     }
// 5686     else
// 5687     {
// 5688       temp3 = 0;
// 5689     }
// 5690   }  
// 5691   */
// 5692   temp3 = 1;
??BlackRightRollCheck_7:
        MOVS     R2,#+1
// 5693   
// 5694   if(
// 5695     (BlackRightStep4Flag == 3 || SingleBlackLastAllFlag == 1)   //右向后补线标志，出错。或者因为上幅图像是单线，无法开启十字，无法置向后补线出错。
// 5696   &&(BlackRightCrossDone == 1 || BlackRightCrossDone == 0)   //右十字标志，失败。或者未进入（线尾过高不会进行十字再检测）。
// 5697   &&(temp1 == 1)                //斜率很大。
// 5698   &&(temp2 == 1)                //线很短。
// 5699   &&(temp3 == 1)                //右线
// 5700     )
        LDR.W    R3,??DataTable40_3
        LDRB     R3,[R3, #+0]
        CMP      R3,#+3
        BEQ.N    ??BlackRightRollCheck_9
        LDR.W    R3,??DataTable40_4
        LDRB     R3,[R3, #+0]
        CMP      R3,#+1
        BNE.N    ??BlackRightRollCheck_10
??BlackRightRollCheck_9:
        LDR.W    R3,??DataTable40_5
        LDRB     R3,[R3, #+0]
        CMP      R3,#+1
        BEQ.N    ??BlackRightRollCheck_11
        LDR.W    R3,??DataTable40_5
        LDRB     R3,[R3, #+0]
        CMP      R3,#+0
        BNE.N    ??BlackRightRollCheck_10
??BlackRightRollCheck_11:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??BlackRightRollCheck_10
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??BlackRightRollCheck_10
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.N    ??BlackRightRollCheck_10
// 5701   {
// 5702     //检测到回弯，返回0.
// 5703     return 0;   
        MOVS     R0,#+0
        B.N      ??BlackRightRollCheck_1
// 5704   }
// 5705   else
// 5706   {
// 5707     //没检测到回弯，返回1.
// 5708     return 1;
??BlackRightRollCheck_10:
        MOVS     R0,#+1
??BlackRightRollCheck_1:
        BX       LR               ;; return
// 5709   }
// 5710 
// 5711 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable36:
        DC32     BlackRightEdgeStartColOffset
// 5712 
// 5713 //向后补线标志出错时的检查，这个函数是防止回弯的很重要的函数。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 5714 uint8 BlackRightStep4ErrorCheck(void)
// 5715 {
BlackRightStep4ErrorCheck:
        PUSH     {R4,LR}
// 5716   uint8 i;
// 5717   
// 5718   //检查斜率是不是都满足直线
// 5719   for(i = 0; ; i++)
        MOVS     R4,#+0
        B.N      ??BlackRightStep4ErrorCheck_0
??BlackRightStep4ErrorCheck_1:
        ADDS     R4,R4,#+1
// 5720   {
// 5721     if(BlackRight5Slope[i] == MaxValInt16) return 0;
??BlackRightStep4ErrorCheck_0:
        LDR.N    R0,??DataTable38_9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R0,[R0, R4, LSL #+2]
        MOVW     R1,#+32767
        CMP      R0,R1
        BNE.N    ??BlackRightStep4ErrorCheck_2
        MOVS     R0,#+0
        B.N      ??BlackRightStep4ErrorCheck_3
// 5722     
// 5723     if(AbsInt(BlackRight5Slope[i]) > PathJudgeStraightSlopeLimit)
??BlackRightStep4ErrorCheck_2:
        LDR.N    R0,??DataTable38_9
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R0,[R0, R4, LSL #+2]
        BL       AbsInt
        MOVW     R1,#+2101
        CMP      R0,R1
        BLT.N    ??BlackRightStep4ErrorCheck_4
// 5724     {
// 5725       return 0;
        MOVS     R0,#+0
        B.N      ??BlackRightStep4ErrorCheck_3
// 5726     }
// 5727     else
// 5728     {      
// 5729     }
// 5730     
// 5731     if(i == 5) break;
??BlackRightStep4ErrorCheck_4:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+5
        BNE.N    ??BlackRightStep4ErrorCheck_1
// 5732   }
// 5733   
// 5734   return 1;
        MOVS     R0,#+1
??BlackRightStep4ErrorCheck_3:
        POP      {R4,PC}          ;; return
// 5735   
// 5736 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable37:
        DC32     BlackRightWinPredictStore1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable37_1:
        DC32     BlackRightWinPredictStore0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable37_2:
        DC32     LimitRightB
// 5737 
// 5738 
// 5739 
// 5740 //右黑线提取前的参数初始化赋值

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 5741 uint8 BlackGetRightParaInit(void)
// 5742 {
// 5743   uint8 i;  
// 5744   
// 5745   //右线连续性标志。默认为1连续。
// 5746   BlackRightContinueFlag = 1;  
BlackGetRightParaInit:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable40
        STRB     R0,[R1, #+0]
// 5747   
// 5748   //采集成功标志位
// 5749   BlackRightDone = 1;  
        MOVS     R0,#+1
        LDR.N    R1,??DataTable38_17
        STRB     R0,[R1, #+0]
// 5750  
// 5751   //右十字线头标志。0未进入，1超范围，2成功。
// 5752   BlackRightCrossConfirmFlag = 0;  //默认为未进入。  
        MOVS     R0,#+0
        LDR.N    R1,??DataTable38_2
        STRB     R0,[R1, #+0]
// 5753   
// 5754   //小5点斜率储存数组置初始值。
// 5755   BlackRight5SlopeIndex = 0;  
        MOVS     R0,#+0
        LDR.N    R1,??DataTable38_14
        STRB     R0,[R1, #+0]
// 5756   for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??BlackGetRightParaInit_0
??BlackGetRightParaInit_1:
        ADDS     R0,R0,#+1
// 5757   {
// 5758       BlackRight5Slope[i] = MaxValInt16;
??BlackGetRightParaInit_0:
        MOVW     R1,#+32767
        LDR.N    R2,??DataTable38_9
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STR      R1,[R2, R0, LSL #+2]
// 5759       BlackRight5SlopeRow[i] = MaxValUint8;
        MOVS     R1,#+255
        LDR.N    R2,??DataTable38_15
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 5760       if(i == CameraHight - 1) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??BlackGetRightParaInit_1
// 5761   }  
// 5762   
// 5763   //回弯检测
// 5764   BlackRightRollCheckFlag = 0;        //检测到回弯。
        MOVS     R0,#+0
        LDR.W    R1,??DataTable40_6
        STRB     R0,[R1, #+0]
// 5765   BlackRightBigChangeJumpFlag = 0;    //回弯跳过标志。
        MOVS     R0,#+0
        LDR.W    R1,??DataTable40_7
        STRB     R0,[R1, #+0]
// 5766 
// 5767   //大斜率检测时，每幅图像的初始值初始化为无效值。
// 5768   for(i = 0; i <= 4; i++)
        MOVS     R0,#+0
        B.N      ??BlackGetRightParaInit_2
// 5769   {
// 5770     BlackRightBigChangeNumx[i] = MaxValUint8;
??BlackGetRightParaInit_3:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable40_8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 5771     BlackRightBigChangeNumy[i] = MaxValUint8; 
        MOVS     R1,#+255
        LDR.W    R2,??DataTable40_9
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 5772   }
        ADDS     R0,R0,#+1
??BlackGetRightParaInit_2:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+5
        BLT.N    ??BlackGetRightParaInit_3
// 5773   BlackRightBigChangeFlag = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable40_10
        STRB     R0,[R1, #+0]
// 5774   BlackRightBigChangeSlopeStore = MaxValInt16;
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable40_11
        STR      R0,[R1, #+0]
// 5775 
// 5776   //大斜率检测时，每行的大跳变标志置0.
// 5777   for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??BlackGetRightParaInit_4
??BlackGetRightParaInit_5:
        ADDS     R0,R0,#+1
// 5778   {
// 5779     BlackRightBigChangeCheckRow[i] = 0;
??BlackGetRightParaInit_4:
        MOVS     R1,#+0
        LDR.W    R2,??DataTable40_12
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 5780     if(i == CameraHight - 1) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??BlackGetRightParaInit_5
// 5781   }
// 5782   BlackRightBigChangeCheckAllRow = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable40_13
        STRB     R0,[R1, #+0]
// 5783 
// 5784   //右黑线储存数组初始化为无效值。
// 5785   for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??BlackGetRightParaInit_6
??BlackGetRightParaInit_7:
        ADDS     R0,R0,#+1
// 5786   {
// 5787     BlackRightLoc[i][0] = MaxValUint8;
??BlackGetRightParaInit_6:
        MOVS     R1,#+255
        LDR.N    R2,??DataTable38_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 5788     if(i == CameraHight - 1) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??BlackGetRightParaInit_7
// 5789   }
// 5790 
// 5791   //十字外尾
// 5792   BlackRightCrossTailFlag = 2;       //十字外尾标志，0失败，1确认，2未进入。
        MOVS     R0,#+2
        LDR.N    R1,??DataTable38_10
        STRB     R0,[R1, #+0]
// 5793 
// 5794   //窗口预测值管理
// 5795   for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??BlackGetRightParaInit_8
??BlackGetRightParaInit_9:
        ADDS     R0,R0,#+1
// 5796   {
// 5797     BlackRightPredictL[i] = MaxValUint8;
??BlackGetRightParaInit_8:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable40_14
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 5798     BlackRightPredictR[i] = MaxValUint8; 
        MOVS     R1,#+255
        LDR.W    R2,??DataTable40_15
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 5799     if(i == CameraHight - 1) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??BlackGetRightParaInit_9
// 5800   }
// 5801 
// 5802   //窗口预测储存值
// 5803   BlackRightWinPredictStore0 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable40_16
        STRB     R0,[R1, #+0]
// 5804   BlackRightWinPredictStore1 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable40_17
        STRB     R0,[R1, #+0]
// 5805   BlackRightWinPredictStore2 = MaxValUint8;
        MOVS     R0,#+255
        LDR.N    R1,??DataTable38
        STRB     R0,[R1, #+0]
// 5806   
// 5807   //第4阶段进入标志置为未进入。
// 5808   BlackRightStep4Flag = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable40_3
        STRB     R0,[R1, #+0]
// 5809   BlackRightStep4StartLine = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable40_18
        STRB     R0,[R1, #+0]
// 5810   //默认十字检测标志置为未进入。
// 5811   BlackRightCrossDone = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable40_5
        STRB     R0,[R1, #+0]
// 5812     
// 5813   return 1;
        MOVS     R0,#+1
        BX       LR               ;; return
// 5814 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38:
        DC32     BlackRightWinPredictStore2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_1:
        DC32     BlackRightLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_2:
        DC32     BlackRightCrossConfirmFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_3:
        DC32     BlackRightRealWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_4:
        DC32     LimitRightWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_5:
        DC32     BlackRightRealW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_6:
        DC32     LimitRightW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_7:
        DC32     BlackRightRealB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_8:
        DC32     BlackRightStep1ScanRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_9:
        DC32     BlackRight5Slope

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_10:
        DC32     BlackRightCrossTailFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_11:
        DC32     BlackRightEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_12:
        DC32     BlackRightHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_13:
        DC32     BlackLeftEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_14:
        DC32     BlackRight5SlopeIndex

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_15:
        DC32     BlackRight5SlopeRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_16:
        DC32     BlackRightCrossTailEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable38_17:
        DC32     BlackRightDone
// 5815 
// 5816 
// 5817 //======================================================================
// 5818 //函数名：BlackGetRight
// 5819 //功  能：右黑线提取算法
// 5820 //参  数：无
// 5821 //返  回：1成功 0失败
// 5822 //影  响：BlackRightCrossDone，BlackRightLoc[][],
// 5823 //        BlackRightRealWB[], BlackRightRealW[], BlackRightRealB[],
// 5824 //        LimitRightWB, LimitRightW, LimitRightB
// 5825 //说  明：1. 暂时可以处理直道，弯道，十字路口3种情况。2014.11.10
// 5826 //      
// 5827 //       
// 5828 //       
// 5829 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 5830 uint8 BlackGetRight(void)
// 5831 {
BlackGetRight:
        PUSH     {R3-R11,LR}
// 5832     uint8 row, temp, temp1, temp2, temp3, i;
// 5833     uint8 GapCount, Row1RealLastLine, index, index1;
// 5834     uint8 tempWB, tempW, tempB;
// 5835     uint8 tempminus;
// 5836     uint8 successRow = MaxValUint8;
        MOV      R10,#+255
// 5837     
// 5838     int temp001;
// 5839     
// 5840     //右黑线提取时的参数初始化赋值
// 5841     BlackGetRightParaInit();     
        BL       BlackGetRightParaInit
// 5842     
// 5843     //第1阶段。这1阶段有可能会返回黑线提取失败
// 5844     
// 5845     //每幅有效图像的线头的3个阈值单独储存。Step1Scan前调用前一幅有效图像保存的3个阈值。
// 5846     LimitRightWB = LimitRightHeadWB;
        LDR.W    R0,??DataTable40_19
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable40_20
        STRB     R0,[R1, #+0]
// 5847     LimitRightW = LimitRightHeadW;
        LDR.W    R0,??DataTable40_21
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable40_22
        STRB     R0,[R1, #+0]
// 5848     LimitRightB = LimitRightHeadB;
        LDR.W    R0,??DataTable40_23
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable40_24
        STRB     R0,[R1, #+0]
// 5849             
// 5850     temp = BlackGetRightStep1Scan(CameraHight - 1, CameraHight - BlackStep1Size - 1, 1);
        MOVS     R2,#+1
        MOVS     R1,#+11
        MOVS     R0,#+59
        BL       BlackGetRightStep1Scan
        MOVS     R4,R0
// 5851     BlackRightStep1ScanRow = temp;
        LDR.W    R0,??DataTable40_25
        STRB     R4,[R0, #+0]
// 5852     
// 5853     //左线开始扫描的情况下，右线尾比左线头高，直接返回失败。增加后面这个条件是为了防止十字误判。
// 5854 //    if(
// 5855 //       (BlackGetPreDir == 0 || BlackGetPreDir == 2)
// 5856 //     &&(temp <= BlackLeftHeadLine)
// 5857 //     &&(BlackLeftHeadLine < CameraHight - 7)
// 5858 //      )
// 5859 //    {
// 5860 //        BlackRightLoc[temp][0] = MaxValUint8;
// 5861 //        BlackRightLoc[temp - 1][0] = MaxValUint8;
// 5862 //        return 0;
// 5863 //    }
// 5864 //    else
// 5865 //    {
// 5866 //    }
// 5867     
// 5868     if(temp == MaxValUint8)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+255
        BNE.N    ??BlackGetRight_0
// 5869     {
// 5870       return 0;
        MOVS     R0,#+0
        B.N      ??BlackGetRight_1
// 5871     }
// 5872     else
// 5873     {   
// 5874       //每幅有效图像的线头的3个阈值单独储存。若线头提取成功，则该幅图像有效，线头3个阈值更新。
// 5875       LimitRightHeadWB = LimitRightWB;
??BlackGetRight_0:
        LDR.W    R0,??DataTable40_20
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable40_19
        STRB     R0,[R1, #+0]
// 5876       LimitRightHeadW = LimitRightW;
        LDR.W    R0,??DataTable40_22
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable40_21
        STRB     R0,[R1, #+0]
// 5877       LimitRightHeadB = LimitRightB;
        LDR.W    R0,??DataTable40_24
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable40_23
        STRB     R0,[R1, #+0]
// 5878       
// 5879       row = temp;
        MOVS     R5,R4
// 5880       //如果起始线头的位置非常高，就认为是十字的前两个角，需要进入第4阶段向后补线。    
// 5881       if(row < CameraHight - BlackRightBackLineStart)
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+12
        BGE.N    ??BlackGetRight_2
// 5882       {
// 5883         BlackRightStep4Flag = 1;             //默认为失败。
        MOVS     R0,#+1
        LDR.W    R1,??DataTable40_3
        STRB     R0,[R1, #+0]
// 5884         BlackRightStep4StartLine = row;
        LDR.W    R0,??DataTable40_18
        STRB     R5,[R0, #+0]
// 5885       }
// 5886 
// 5887     }
// 5888       
// 5889     //第2阶段。到了这一阶段，已经不会返回黑线提取失败 
// 5890     //下面开始利用斜率找黑点。
// 5891     //上次已经处理完了第row-1行，下一次要处理第row-2行
// 5892     //BlackRightSlope();
// 5893     
// 5894     //temp为预测的黑点位置
// 5895     //对预测值进行限定。
// 5896     temp = BoundaryLimitRe(BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0],
// 5897                            0,
// 5898                            CameraRealWidth - 1);    
??BlackGetRight_2:
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable40_26
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+3
        MLA      R0,R3,R5,R0
        LDRB     R0,[R0, #-3]
        LDR.W    R3,??DataTable40_26
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R5,R3
        LDRB     R3,[R3, #-3]
        UXTAB    R0,R3,R0
        LDR.W    R3,??DataTable40_26
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R5,R3
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
        MOVS     R4,R0
// 5899     //预测值更新后就刷新一次堆栈，堆栈顶部丢失。
// 5900     BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
        LDR.W    R0,??DataTable40_17
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable40_16
        STRB     R0,[R1, #+0]
// 5901     BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
        LDR.W    R0,??DataTable40_27
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable40_17
        STRB     R0,[R1, #+0]
// 5902     BlackRightWinPredictStore2 = temp;
        LDR.W    R0,??DataTable40_27
        STRB     R4,[R0, #+0]
// 5903         
// 5904     index = 0;
        MOVS     R8,#+0
// 5905     index1 = 0;
        MOVS     R9,#+0
// 5906     
// 5907     GapCount = 0;  //连续多少行没有采到黑线
        MOVS     R6,#+0
// 5908     successRow = MaxValUint8; //记录最后一次成功的行
        MOV      R10,#+255
// 5909     //从最近的认证行到取最远的行
// 5910     for(row -= 2; ; row -= 2)
        SUBS     R5,R5,#+2
        B.N      ??BlackGetRight_3
??BlackGetRight_4:
        SUBS     R5,R5,#+2
// 5911     {  
// 5912       //连续2行检测黑点位置。     
// 5913       //近处的行已经将单线标志置位，则检测到左黑线头即可返回。
// 5914       if(SingleBlackAllFlag == 1 && row < BlackLeftHeadLine) return 1;
??BlackGetRight_3:
        LDR.W    R0,??DataTable40_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackGetRight_5
        LDR.W    R0,??DataTable40_28
        LDRB     R0,[R0, #+0]
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,R0
        BCS.N    ??BlackGetRight_5
        MOVS     R0,#+1
        B.N      ??BlackGetRight_1
// 5915       temp1 = BlackGetRightStep2Win(row, BlackRightWinVal, temp, 1);
??BlackGetRight_5:
        MOVS     R3,#+1
        MOVS     R2,R4
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,#+15
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetRightStep2Win
        MOV      R11,R0
// 5916       if(SingleBlackAllFlag == 1 && row - 1 < BlackLeftHeadLine) return 1;
        LDR.W    R0,??DataTable40_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackGetRight_6
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        SUBS     R0,R5,#+1
        LDR.W    R1,??DataTable40_28
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BGE.N    ??BlackGetRight_6
        MOVS     R0,#+1
        B.N      ??BlackGetRight_1
// 5917       temp2 = BlackGetRightStep2Win(row-1, BlackRightWinVal, temp, 2);
??BlackGetRight_6:
        MOVS     R3,#+2
        MOVS     R2,R4
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,#+15
        SUBS     R0,R5,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetRightStep2Win
// 5918       
// 5919       temp3 = (
// 5920               (temp1 == 0)
// 5921             &&(temp2 == 0)
// 5922             //&&(BlackRightStep4Flag == 0)
// 5923               );
        UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
        CMP      R11,#+0
        BNE.N    ??BlackGetRight_7
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackGetRight_7
        MOVS     R1,#+1
        B.N      ??BlackGetRight_8
??BlackGetRight_7:
        MOVS     R1,#+0
// 5924       //若连续2行的黑点检测成功，则更新3个阈值，更新预测点的位置
// 5925       if(temp1 == 1 && temp2 == 1) 
??BlackGetRight_8:
        UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
        CMP      R11,#+1
        BNE.W    ??BlackGetRight_9
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.W    ??BlackGetRight_9
// 5926       {
// 5927         //只要连续采集到双黑线，则两个标志位重置为0.
// 5928         index = 0;
        MOVS     R8,#+0
// 5929         index1 = 0;
        MOVS     R9,#+0
// 5930         successRow = row;
        MOV      R10,R5
// 5931       
// 5932         //差值的处理，留有裕度，且有上下界。
// 5933         tempWB = (BlackRightRealWB[0] + BlackRightRealWB[1]) / 2 - LimitRightWBMargin; 
        LDR.W    R0,??DataTable40_29
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable40_29
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+20
// 5934         if(tempWB < LimitRightWBMin) tempWB = LimitRightWBMin;
        LDR.W    R1,??DataTable40_30
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackGetRight_10
        LDR.W    R0,??DataTable40_30
        LDRB     R0,[R0, #+0]
        B.N      ??BlackGetRight_11
// 5935         else if(tempWB > LimitRightWBMax) tempWB = LimitRightWBMax;
??BlackGetRight_10:
        LDR.W    R1,??DataTable40_31
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackGetRight_11
        LDR.W    R0,??DataTable40_31
        LDRB     R0,[R0, #+0]
// 5936         else ;
// 5937         LimitRightWB = tempWB;
??BlackGetRight_11:
        LDR.W    R1,??DataTable40_20
        STRB     R0,[R1, #+0]
// 5938         
// 5939         //白点的处理，留有裕度，且有上下界。
// 5940         tempW = (BlackRightRealW[0] + BlackRightRealW[1]) / 2 - LimitRightWMargin;
        LDR.W    R0,??DataTable40_32
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable40_32
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+40
// 5941         if(tempW < LimitRightWMin) tempW = LimitRightWMin;
        LDR.W    R1,??DataTable40_33
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackGetRight_12
        LDR.W    R0,??DataTable40_33
        LDRB     R0,[R0, #+0]
        B.N      ??BlackGetRight_13
// 5942         else if(tempW > LimitRightWMax) tempW = LimitRightWMax;
??BlackGetRight_12:
        LDR.W    R1,??DataTable40_34
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackGetRight_13
        LDR.W    R0,??DataTable40_34
        LDRB     R0,[R0, #+0]
// 5943         else ;
// 5944         LimitRightW = tempW;
??BlackGetRight_13:
        LDR.W    R1,??DataTable40_22
        STRB     R0,[R1, #+0]
// 5945         
// 5946         //黑点的处理，留有裕度，且有上下界。
// 5947         tempB = (BlackRightRealB[0] + BlackRightRealB[1]) / 2 + LimitRightBMargin;
        LDR.W    R0,??DataTable40_35
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable40_35
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        ADDS     R0,R0,#+35
// 5948         if(tempB < LimitRightBMin) tempB = LimitRightBMin;
        LDR.W    R1,??DataTable40_36
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCS.N    ??BlackGetRight_14
        LDR.W    R0,??DataTable40_36
        LDRB     R0,[R0, #+0]
        B.N      ??BlackGetRight_15
// 5949         else if(tempB > LimitRightBMax) tempB = LimitRightBMax;
??BlackGetRight_14:
        LDR.W    R1,??DataTable40_37
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??BlackGetRight_15
        LDR.W    R0,??DataTable40_37
        LDRB     R0,[R0, #+0]
// 5950         else ;
// 5951         //黑色阈值不能超过白色
// 5952         if(tempB >= LimitRightW)
??BlackGetRight_15:
        LDR.W    R1,??DataTable40_22
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BCC.N    ??BlackGetRight_16
// 5953         {
// 5954           tempB = LimitRightW - 1;
        LDR.W    R0,??DataTable40_22
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
// 5955         }
// 5956         else
// 5957         {
// 5958         }             
// 5959         LimitRightB = tempB;   
??BlackGetRight_16:
        LDR.W    R1,??DataTable40_24
        STRB     R0,[R1, #+0]
// 5960          
// 5961         //对预测值进行限定。
// 5962         temp = BoundaryLimitRe(BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0],
// 5963                                0,
// 5964                                CameraRealWidth - 1); 
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable40_26
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+3
        MLA      R0,R3,R5,R0
        LDRB     R0,[R0, #-3]
        LDR.W    R3,??DataTable40_26
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R5,R3
        LDRB     R3,[R3, #-3]
        UXTAB    R0,R3,R0
        LDR.W    R3,??DataTable40_26
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R5,R3
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
        MOVS     R4,R0
// 5965         //预测值更新后就刷新一次堆栈，堆栈顶部丢失。
// 5966         BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
        LDR.W    R0,??DataTable40_17
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable40_16
        STRB     R0,[R1, #+0]
// 5967         BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
        LDR.W    R0,??DataTable40_27
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable40_17
        STRB     R0,[R1, #+0]
// 5968         BlackRightWinPredictStore2 = temp;        
        LDR.W    R0,??DataTable40_27
        STRB     R4,[R0, #+0]
        B.N      ??BlackGetRight_17
// 5969       }
// 5970       //如果没能连续两行检测黑点成功，原本打算用原位置的预测点，后来发现效果不好，所以决定按预测点的趋势走。
// 5971       //如果连续两行均采集黑线失败，则记数，记到一定值就再来一次Step1
// 5972       //如果第4阶段检测标志置位，就不用进入十字检测了。
// 5973       else if(temp3 == 1)
??BlackGetRight_9:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.W    ??BlackGetRight_18
// 5974       {
// 5975         //若上一幅图是单线，则不允许开启十字。
// 5976         if(SingleBlackLastAllFlag == 1) break;        
        LDR.W    R0,??DataTable40_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.W    ??BlackGetRight_19
// 5977         //直角黑块锁存期间，为了防止一边十字成功另一边不成功造成的中心线倾斜，所以不允许开启十字。
// 5978         if(AngleZoneConfirmLockFlag == 1) break;
??BlackGetRight_20:
        LDR.W    R0,??DataTable40_38
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.W    ??BlackGetRight_19
// 5979         
// 5980         //第一次检测到双线失败时，最后的几条线可能已经不太正确。
// 5981         if(index1 == 0)
??BlackGetRight_21:
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+0
        BNE.N    ??BlackGetRight_22
// 5982         {
// 5983           //如果储存的3个值趋势相同，也就是变化量同号，那么就按正常的来。否则就认为最后一个值已经错误。
// 5984           if(row <= CameraHight - 3)
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+58
        BGE.N    ??BlackGetRight_23
// 5985           {
// 5986               if (BlackRightLoc[row + 1][0] != MaxValUint8 && BlackRightLoc[row + 2][0] != MaxValUint8)
        LDR.W    R0,??DataTable40_26
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+3]
        CMP      R0,#+255
        BEQ.N    ??BlackGetRight_24
        LDR.W    R0,??DataTable40_26
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+6]
        CMP      R0,#+255
        BEQ.N    ??BlackGetRight_24
// 5987               {
// 5988                   //如果黑线点够，最好还是根据实际的黑点来更新窗口值。
// 5989                   tempminus = BoundaryLimitRe(BlackRightLoc[row + 1][0] * 3 - BlackRightLoc[row + 2][0] * 2,
// 5990                                               0,
// 5991                                               CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable40_26
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+3
        MLA      R0,R3,R5,R0
        LDRB     R0,[R0, #+3]
        MOVS     R3,#+3
        MULS     R0,R3,R0
        LDR.W    R3,??DataTable40_26
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R5,R3
        LDRB     R3,[R3, #+6]
        SUBS     R0,R0,R3, LSL #+1
        BL       BoundaryLimitRe
// 5992                   //斜入十字不管怎么摆，右十字的上段线一定在下段线的左边。
// 5993                   tempminus = MinRe(tempminus, BlackRightLoc[row + 1][0]);
        LDR.W    R1,??DataTable40_26
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R5,R1
        LDRB     R1,[R1, #+3]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       MinRe
        B.N      ??BlackGetRight_25
// 5994               }
// 5995               else
// 5996               {
// 5997                   temp001 = BlackRightWinPredictStore1 - BlackRightWinPredictStore0;
??BlackGetRight_24:
        LDR.W    R0,??DataTable40_17
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable40_16
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
// 5998                   BlackRightWinPredictStore0 += temp001;
        LDR.W    R1,??DataTable40_16
        LDRB     R1,[R1, #+0]
        ADDS     R1,R0,R1
        LDR.W    R2,??DataTable40_16
        STRB     R1,[R2, #+0]
// 5999                   BlackRightWinPredictStore1 += temp001;
        LDR.W    R1,??DataTable40_17
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1
        LDR.W    R1,??DataTable40_17
        STRB     R0,[R1, #+0]
// 6000                   BlackRightWinPredictStore2 = BlackRightWinPredictStore1 + BlackRightWinPredictStore1 - BlackRightWinPredictStore0;
        LDR.W    R0,??DataTable40_17
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable40_17
        LDRB     R1,[R1, #+0]
        ADDS     R0,R1,R0
        LDR.W    R1,??DataTable40_16
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable40_27
        STRB     R0,[R1, #+0]
// 6001                   tempminus = BoundaryLimitRe(BlackRightWinPredictStore2 + BlackRightWinPredictStore2 - BlackRightWinPredictStore1,
// 6002                                               0,
// 6003                                               CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable40_27
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable40_27
        LDRB     R3,[R3, #+0]
        ADDS     R0,R3,R0
        LDR.W    R3,??DataTable40_17
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
// 6004               }
// 6005           }
// 6006           else
// 6007           {
// 6008               //理论上不会走到这里。
// 6009               return 0;
// 6010               
// 6011               /*
// 6012               //实在不行就根据Store的值来更新吧。
// 6013               //以上上次的窗口预测值为基准，加上2个上上次和上上上次的差。
// 6014               tempminus = BoundaryLimitRe(BlackRightWinPredictStore1 * 3 - BlackRightWinPredictStore0 * 2,
// 6015                                           0,
// 6016                                           CameraRealWidth - 1);
// 6017               //斜入十字不管怎么摆，右十字的上段线一定在下段线的左边。
// 6018               tempminus = MinRe(tempminus, BlackRightLoc[row + 1][0]);
// 6019             */
// 6020           }
// 6021           
// 6022           //进来一次后就再也不进来了。
// 6023           index1++;          
??BlackGetRight_25:
        ADDS     R9,R9,#+1
        B.N      ??BlackGetRight_26
??BlackGetRight_23:
        MOVS     R0,#+0
        B.N      ??BlackGetRight_1
// 6024         }
// 6025         else
// 6026         {
// 6027           //预测点按趋势走也要限幅。
// 6028           tempminus = BoundaryLimitRe(BlackRightWinPredictStore2 + BlackRightWinPredictStore2 - BlackRightWinPredictStore1,
// 6029                                       0,
// 6030                                       CameraRealWidth - 1);          
??BlackGetRight_22:
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable40_27
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable40_27
        LDRB     R3,[R3, #+0]
        ADDS     R0,R3,R0
        LDR.W    R3,??DataTable40_17
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
// 6031         }
// 6032         //temp在这里表示窗口预测点位置。
// 6033         temp = tempminus;
??BlackGetRight_26:
        MOVS     R4,R0
// 6034         BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
        LDR.W    R0,??DataTable40_17
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable40_16
        STRB     R0,[R1, #+0]
// 6035         BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
        LDR.W    R0,??DataTable40_27
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable40_17
        STRB     R0,[R1, #+0]
// 6036         BlackRightWinPredictStore2 = temp;        
        LDR.W    R0,??DataTable40_27
        STRB     R4,[R0, #+0]
// 6037         
// 6038         //Row1RealLastLine记录第1段黑线的最后一行。
// 6039         if(index == 0)
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+0
        BNE.N    ??BlackGetRight_27
// 6040         {          
// 6041           //进来一次后，就再也不会进来了。
// 6042           index++;
        ADDS     R8,R8,#+1
// 6043           for(i = row; i <= CameraHight - 1; i++)
        MOVS     R0,R5
        B.N      ??BlackGetRight_28
??BlackGetRight_29:
        ADDS     R0,R0,#+1
??BlackGetRight_28:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+60
        BGE.N    ??BlackGetRight_30
// 6044           {
// 6045             if(BlackRightLoc[i][0] != MaxValUint8)
        LDR.W    R1,??DataTable40_26
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        CMP      R1,#+255
        BEQ.N    ??BlackGetRight_29
// 6046             {
// 6047               Row1RealLastLine = i;
        MOVS     R7,R0
// 6048               break;
// 6049             }
// 6050           }
// 6051           if(Row1RealLastLine >= CameraHight - 1)
??BlackGetRight_30:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+59
        BLT.N    ??BlackGetRight_31
// 6052           {
// 6053             Row1RealLastLine = CameraHight - 1;
        MOVS     R7,#+59
// 6054           }
// 6055           else
// 6056           {
// 6057           }
// 6058           //记录为全局变量
// 6059           BlackRightRow1RealLastLine = Row1RealLastLine;
??BlackGetRight_31:
        LDR.W    R0,??DataTable40_39
        STRB     R7,[R0, #+0]
// 6060         }
// 6061         
// 6062         GapCount += 2;
??BlackGetRight_27:
        ADDS     R6,R6,#+2
// 6063         if (successRow != MaxValUint8 && BlackRightLoc[successRow][0] >240 && BlackRightLoc[successRow - 1][0] >240) { }
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        CMP      R10,#+255
        BEQ.N    ??BlackGetRight_32
        LDR.W    R0,??DataTable40_26
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R10,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+241
        BLT.N    ??BlackGetRight_32
        LDR.W    R0,??DataTable40_26
        UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R10,R0
        LDRB     R0,[R0, #-3]
        CMP      R0,#+241
        BGE.W    ??BlackGetRight_17
// 6064         ///////////////////////////////进入十字重新检测的条件还要再严格一些，减少没必要的时间，比如说前面最多只允许检测到多少行。
// 6065         else if(GapCount > BlackCrossGapLine)
??BlackGetRight_32:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+13
        BLT.N    ??BlackGetRight_33
// 6066         {
// 6067           //再检测时的行太远了，就没必要检测了。
// 6068           if(row < BlackRightCrossTooLowLine)
        LDR.W    R0,??DataTable40_40
        LDRB     R0,[R0, #+0]
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,R0
        BCS.N    ??BlackGetRight_34
// 6069           {
// 6070             //扫屁股。
// 6071             for(i = row; ; i--)
        MOVS     R0,R5
        B.N      ??BlackGetRight_35
??BlackGetRight_36:
        SUBS     R0,R0,#+1
// 6072             {
// 6073               BlackRightLoc[i][0] = MaxValUint8;
??BlackGetRight_35:
        MOVS     R1,#+255
        LDR.N    R2,??DataTable40_26
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 6074               if(i == 0) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BlackGetRight_36
// 6075             }
// 6076             //跳出来。
// 6077             break;
        B.N      ??BlackGetRight_19
// 6078           }
// 6079           else
// 6080           {
// 6081           }
// 6082           
// 6083           //进入十字重新检测后，就不允许出现第4阶段向后补线的情况。
// 6084           if(BlackRightStep4Flag == 1)
// 6085           {
// 6086             //BlackRightStep4Flag = 3;   //向后补线出错。
// 6087             
// 6088             //直接跳出来的作法。不太好。
// 6089             /*
// 6090             BlackRightCrossDone = 1;   //十字检测失败。
// 6091             //扫屁股。
// 6092             for(i = row; ; i--)
// 6093             {
// 6094               BlackRightLoc[i][0] = MaxValUint8;
// 6095               if(i == 0) break;
// 6096             }
// 6097             //跳出来。
// 6098             break;
// 6099             */
// 6100           }
// 6101           else
// 6102           {
// 6103           }
// 6104           
// 6105           //十字再检测的话，Step1Scan的线头必须够近。
// 6106           //最后只剩第0，1行没有检测的话，就不用开启十字再检测了。
// 6107           if(BlackRightStep1ScanRow >= CameraHight - 3 && row > 3)
??BlackGetRight_34:
        LDR.N    R0,??DataTable40_25
        LDRB     R0,[R0, #+0]
        CMP      R0,#+57
        BLT.N    ??BlackGetRight_37
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+4
        BLT.N    ??BlackGetRight_37
// 6108           {
// 6109             //正常的十字再检测。
// 6110             if(BlackRightAgainForCross(row - 2, 1, Row1RealLastLine, temp) == 0)
        MOVS     R3,R4
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        MOVS     R2,R7
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R1,#+1
        SUBS     R0,R5,#+2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackRightAgainForCross
        CMP      R0,#+0
        BNE.N    ??BlackGetRight_38
// 6111             {
// 6112               BlackRightCrossDone = 1;  //十字检测失败            
        MOVS     R0,#+1
        LDR.N    R1,??DataTable40_5
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetRight_39
// 6113             }
// 6114             else
// 6115             {
// 6116               BlackRightCrossDone = 2;  //十字检测成功
??BlackGetRight_38:
        MOVS     R0,#+2
        LDR.N    R1,??DataTable40_5
        STRB     R0,[R1, #+0]
// 6117             }
// 6118             break;  //十字再检测里会开窗检测到指定的最后一行，所以不用再循环了，直接跳出
??BlackGetRight_39:
        B.N      ??BlackGetRight_19
// 6119           }
// 6120           //线头太远，或者只剩第0，1行的时候，直接break就好，远处的行在初始化时已经置为无效值。
// 6121           else
// 6122           {
// 6123             break;
??BlackGetRight_37:
        B.N      ??BlackGetRight_19
// 6124           }
// 6125         }
// 6126         else
// 6127         {
// 6128            BlackRightCrossDone = 0;    //十字检测未进入
??BlackGetRight_33:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable40_5
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetRight_17
// 6129         }
// 6130       
// 6131       }
// 6132       //连续两线只有一线检测成功的情况，仍然要按趋势更新窗口预测值。
// 6133       else if((temp1 == 1 && temp2 == 0) || (temp1 == 0 && temp2 == 1)) 
??BlackGetRight_18:
        UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
        CMP      R11,#+1
        BNE.N    ??BlackGetRight_40
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BEQ.N    ??BlackGetRight_41
??BlackGetRight_40:
        UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
        CMP      R11,#+0
        BNE.N    ??BlackGetRight_17
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??BlackGetRight_17
// 6134       {   
// 6135         //第一次检测到有单线失败时，最后的几条线可能已经不太正确。
// 6136         if(index1 == 0)
??BlackGetRight_41:
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+0
        BNE.N    ??BlackGetRight_42
// 6137         {
// 6138           //如果储存的3个值趋势相同，也就是变化量同号，那么就按正常的来。否则就认为最后一个值已经错误。
// 6139           if(row <= CameraHight - 3)
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+58
        BGE.N    ??BlackGetRight_43
// 6140           {
// 6141               if (BlackRightLoc[row + 1][0] != MaxValUint8 && BlackRightLoc[row + 2][0] != MaxValUint8)
        LDR.N    R0,??DataTable40_26
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+3]
        CMP      R0,#+255
        BEQ.N    ??BlackGetRight_44
        LDR.N    R0,??DataTable40_26
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+6]
        CMP      R0,#+255
        BEQ.N    ??BlackGetRight_44
// 6142               {
// 6143                   //如果黑线点够，最好还是根据实际的黑点来更新窗口值。
// 6144                   tempminus = BoundaryLimitRe(BlackRightLoc[row + 1][0] * 3 - BlackRightLoc[row + 2][0] * 2,
// 6145                                               0,
// 6146                                               CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.N    R0,??DataTable40_26
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R3,#+3
        MLA      R0,R3,R5,R0
        LDRB     R0,[R0, #+3]
        MOVS     R3,#+3
        MULS     R0,R3,R0
        LDR.N    R3,??DataTable40_26
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R5,R3
        LDRB     R3,[R3, #+6]
        SUBS     R0,R0,R3, LSL #+1
        BL       BoundaryLimitRe
// 6147                   //斜入十字不管怎么摆，右十字的上段线一定在下段线的左边。
// 6148                   tempminus = MinRe(tempminus, BlackRightLoc[row + 1][0]);
        LDR.N    R1,??DataTable40_26
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R5,R1
        LDRB     R1,[R1, #+3]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       MinRe
        B.N      ??BlackGetRight_45
// 6149               }
// 6150               else
// 6151               {
// 6152                   temp001 = BlackRightWinPredictStore1 - BlackRightWinPredictStore0;
??BlackGetRight_44:
        LDR.N    R0,??DataTable40_17
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable40_16
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
// 6153                   BlackRightWinPredictStore0 += temp001;
        LDR.N    R1,??DataTable40_16
        LDRB     R1,[R1, #+0]
        ADDS     R1,R0,R1
        LDR.N    R2,??DataTable40_16
        STRB     R1,[R2, #+0]
// 6154                   BlackRightWinPredictStore1 += temp001;
        LDR.N    R1,??DataTable40_17
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1
        LDR.N    R1,??DataTable40_17
        STRB     R0,[R1, #+0]
// 6155                   BlackRightWinPredictStore2 = BlackRightWinPredictStore1 + BlackRightWinPredictStore1 - BlackRightWinPredictStore0;
        LDR.N    R0,??DataTable40_17
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable40_17
        LDRB     R1,[R1, #+0]
        ADDS     R0,R1,R0
        LDR.N    R1,??DataTable40_16
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        LDR.N    R1,??DataTable40_27
        STRB     R0,[R1, #+0]
// 6156                   tempminus = BoundaryLimitRe(BlackRightWinPredictStore2 + BlackRightWinPredictStore2 - BlackRightWinPredictStore1,
// 6157                                               0,
// 6158                                               CameraRealWidth - 1);
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.N    R0,??DataTable40_27
        LDRB     R0,[R0, #+0]
        LDR.N    R3,??DataTable40_27
        LDRB     R3,[R3, #+0]
        ADDS     R0,R3,R0
        LDR.N    R3,??DataTable40_17
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
// 6159               }
// 6160           }
// 6161           else
// 6162           {
// 6163               //理论上不会走到这里。
// 6164               return 0;
// 6165               
// 6166               /*
// 6167               //实在不行就根据Store的值来更新吧。
// 6168               //以上上次的窗口预测值为基准，加上2个上上次和上上上次的差。
// 6169               tempminus = BoundaryLimitRe(BlackRightWinPredictStore1 * 3 - BlackRightWinPredictStore0 * 2,
// 6170                                           0,
// 6171                                           CameraRealWidth - 1);
// 6172               //斜入十字不管怎么摆，右十字的上段线一定在下段线的左边。
// 6173               tempminus = MinRe(tempminus, BlackRightLoc[row + 1][0]);
// 6174               */
// 6175           }
// 6176           
// 6177           //进来一次后就再也不进来了。
// 6178           index1++;          
??BlackGetRight_45:
        ADDS     R9,R9,#+1
        B.N      ??BlackGetRight_46
??BlackGetRight_43:
        MOVS     R0,#+0
        B.N      ??BlackGetRight_1
// 6179         }
// 6180         else
// 6181         {
// 6182           //预测点按趋势走也要限幅。
// 6183           tempminus = BoundaryLimitRe(BlackRightWinPredictStore2 + BlackRightWinPredictStore2 - BlackRightWinPredictStore1,
// 6184                                       0,
// 6185                                       CameraRealWidth - 1);          
??BlackGetRight_42:
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.N    R0,??DataTable40_27
        LDRB     R0,[R0, #+0]
        LDR.N    R3,??DataTable40_27
        LDRB     R3,[R3, #+0]
        ADDS     R0,R3,R0
        LDR.N    R3,??DataTable40_17
        LDRB     R3,[R3, #+0]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
// 6186         }
// 6187         //temp在这里表示窗口预测点位置。
// 6188         temp = tempminus;
??BlackGetRight_46:
        MOVS     R4,R0
// 6189         BlackRightWinPredictStore0 = BlackRightWinPredictStore1;
        LDR.N    R0,??DataTable40_17
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable40_16
        STRB     R0,[R1, #+0]
// 6190         BlackRightWinPredictStore1 = BlackRightWinPredictStore2;
        LDR.N    R0,??DataTable40_27
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable40_17
        STRB     R0,[R1, #+0]
// 6191         BlackRightWinPredictStore2 = temp;
        LDR.N    R0,??DataTable40_27
        STRB     R4,[R0, #+0]
// 6192       }
// 6193       //理论上不会走到这里。
// 6194       else
// 6195       {       
// 6196       }
// 6197       
// 6198       
// 6199       if((row == 0) || (row == 1)) break;
??BlackGetRight_17:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BEQ.N    ??BlackGetRight_47
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+1
        BNE.W    ??BlackGetRight_4
// 6200       
// 6201     }
// 6202     
// 6203     
// 6204     //第4阶段，采集到十字的前两个角，向后补线。这里有浮点运算，要严格控制调用。
// 6205     if(BlackRightStep4Flag == 1)
??BlackGetRight_47:
??BlackGetRight_19:
        LDR.N    R0,??DataTable40_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackGetRight_48
// 6206     {
// 6207       if(BlackRightStep4BackLine(BlackRightStep4StartLine, 0) == 0)
        MOVS     R1,#+0
        LDR.N    R0,??DataTable40_18
        LDRB     R0,[R0, #+0]
        BL       BlackRightStep4BackLine
        CMP      R0,#+0
        BNE.N    ??BlackGetRight_49
// 6208       {
// 6209         BlackRightStep4Flag = 1;   //向后补线失败，有可能是点取不够，有可能是斜率不对。
        MOVS     R0,#+1
        LDR.N    R1,??DataTable40_3
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetRight_50
// 6210         //return 0;  
// 6211       }
// 6212       else
// 6213       {
// 6214         BlackRightStep4Flag = 2;   //向后补线成功。
??BlackGetRight_49:
        MOVS     R0,#+2
        LDR.N    R1,??DataTable40_3
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetRight_50
// 6215       }
// 6216     }
// 6217     //BlackRightStep4Flag出错的情况。
// 6218     else if(BlackRightStep4Flag == 3)
??BlackGetRight_48:
        LDR.N    R0,??DataTable40_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+3
        BNE.N    ??BlackGetRight_50
// 6219     {
// 6220       //检查向后补线出错到底是为什么
// 6221       if(BlackRightStep4ErrorCheck() == 1)
        BL       BlackRightStep4ErrorCheck
        CMP      R0,#+1
        BNE.N    ??BlackGetRight_50
// 6222       {      
// 6223         if(BlackRightStep4BackLine(BlackRightStep4StartLine, 0) == 0)
        MOVS     R1,#+0
        LDR.N    R0,??DataTable40_18
        LDRB     R0,[R0, #+0]
        BL       BlackRightStep4BackLine
        CMP      R0,#+0
        BEQ.N    ??BlackGetRight_50
// 6224         {
// 6225           //BlackRightStep4Flag = 1;   //向后补线失败，有可能是点取不够，有可能是斜率不对。
// 6226           //return 0;  
// 6227         }
// 6228         else
// 6229         {
// 6230           BlackRightStep4Flag = 2;   //向后补线成功。
        MOVS     R0,#+2
        LDR.N    R1,??DataTable40_3
        STRB     R0,[R1, #+0]
// 6231         }
// 6232       }
// 6233       else
// 6234       {
// 6235       }
// 6236     }
// 6237     //BlackRightStep4Flag未进入的情况。
// 6238     else
// 6239     {
// 6240     }
// 6241 
// 6242     return 1;
??BlackGetRight_50:
        MOVS     R0,#+1
??BlackGetRight_1:
        POP      {R1,R4-R11,PC}   ;; return
// 6243 
// 6244 }
// 6245 
// 6246 
// 6247 
// 6248 
// 6249 //黑线提取预处理

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 6250 uint8 BlackGetPre(void)
// 6251 {
BlackGetPre:
        PUSH     {R4,LR}
// 6252   uint8 temp1, temp2;
// 6253   
// 6254   //如果是障碍特殊处理期间，黑线从控制线开始扫描。
// 6255   if(BrickSpeDealFlag == 1)
        LDR.W    R0,??DataTable41
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackGetPre_0
// 6256   {
// 6257     //左障碍，固定从右线开始扫描。
// 6258     if(BrickSpeDealDir == 0)
        LDR.W    R0,??DataTable41_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??BlackGetPre_1
// 6259     {
// 6260       BlackGetPreDir = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable41_2
        STRB     R0,[R1, #+0]
        B.N      ??BlackGetPre_2
// 6261     }
// 6262     //右障碍，固定从左线开始扫描。
// 6263     else
// 6264     {
// 6265       BlackGetPreDir = 0;
??BlackGetPre_1:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable41_2
        STRB     R0,[R1, #+0]
// 6266     }
// 6267     
// 6268     return 1;
??BlackGetPre_2:
        MOVS     R0,#+1
        B.N      ??BlackGetPre_3
// 6269   }
// 6270   else
// 6271   {
// 6272   }
// 6273   
// 6274   //先预扫描左线
// 6275   BlackGetLeftParaInit();  //参数初始化
??BlackGetPre_0:
        BL       BlackGetLeftParaInit
// 6276   temp1 = BlackGetLeftStep1Edge(CameraHight - 1, 1, 1);  //第三个参数1表示是黑线预处理
        MOVS     R2,#+1
        MOVS     R1,#+1
        MOVS     R0,#+59
        BL       BlackGetLeftStep1Edge
        MOVS     R4,R0
// 6277   temp2 = BlackGetLeftStep1Edge(CameraHight - 2, 2, 1);  //第三个参数1表示是黑线预处理
        MOVS     R2,#+1
        MOVS     R1,#+2
        MOVS     R0,#+58
        BL       BlackGetLeftStep1Edge
// 6278   if(
// 6279     (temp1 == 1)
// 6280   &&(temp2 == 1)
// 6281   &&(AbsInt(BlackLeftLoc[CameraHight - 1][0] - BlackLeftLoc[CameraHight - 2][0]) < BlackLeftStep1ScanMinus)  //两点列差不能太大。
// 6282     )
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+1
        BNE.N    ??BlackGetPre_4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??BlackGetPre_4
        LDR.W    R0,??DataTable41_3
        LDRB     R0,[R0, #+177]
        LDR.W    R1,??DataTable41_3
        LDRB     R1,[R1, #+174]
        SUBS     R0,R0,R1
        BL       AbsInt
        CMP      R0,#+8
        BGE.N    ??BlackGetPre_4
// 6283   {
// 6284     //左线采集线头成功，从左线开始扫描。 
// 6285     BlackGetPreDir = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable41_2
        STRB     R0,[R1, #+0]
// 6286     return 1;
        MOVS     R0,#+1
        B.N      ??BlackGetPre_3
// 6287   }
// 6288   else
// 6289   {
// 6290     //有可能一行采集成功，所以要扫尾。
// 6291     BlackLeftLoc[CameraHight - 1][0] = MaxValUint8;
??BlackGetPre_4:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable41_3
        STRB     R0,[R1, #+177]
// 6292     BlackLeftLoc[CameraHight - 2][0] = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable41_3
        STRB     R0,[R1, #+174]
// 6293   }
// 6294   
// 6295   //左线头扫描失败，则扫描右线头
// 6296   BlackGetRightParaInit();  //参数初始化
        BL       BlackGetRightParaInit
// 6297   temp1 = BlackGetRightStep1Edge(CameraHight - 1, 1, 1);  //第三个参数1表示是黑线预处理
        MOVS     R2,#+1
        MOVS     R1,#+1
        MOVS     R0,#+59
        BL       BlackGetRightStep1Edge
        MOVS     R4,R0
// 6298   temp2 = BlackGetRightStep1Edge(CameraHight - 2, 2, 1);  //第三个参数1表示是黑线预处理
        MOVS     R2,#+1
        MOVS     R1,#+2
        MOVS     R0,#+58
        BL       BlackGetRightStep1Edge
// 6299   if(
// 6300     (temp1 == 1)
// 6301   &&(temp2 == 1)
// 6302   &&(AbsInt(BlackRightLoc[CameraHight - 1][0] - BlackRightLoc[CameraHight - 2][0]) < BlackRightStep1ScanMinus)  //两点列差不能太大。
// 6303     )
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+1
        BNE.N    ??BlackGetPre_5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??BlackGetPre_5
        LDR.N    R0,??DataTable40_26
        LDRB     R0,[R0, #+177]
        LDR.N    R1,??DataTable40_26
        LDRB     R1,[R1, #+174]
        SUBS     R0,R0,R1
        BL       AbsInt
        CMP      R0,#+8
        BGE.N    ??BlackGetPre_5
// 6304   {
// 6305     //右线头采集成功，从右线开始扫描。
// 6306     BlackGetPreDir = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable41_2
        STRB     R0,[R1, #+0]
// 6307     return 1;    
        MOVS     R0,#+1
        B.N      ??BlackGetPre_3
// 6308   }
// 6309   else
// 6310   {
// 6311     //有可能一行采集成功，所以要扫尾。
// 6312     BlackRightLoc[CameraHight - 1][0] = MaxValUint8;
??BlackGetPre_5:
        MOVS     R0,#+255
        LDR.N    R1,??DataTable40_26
        STRB     R0,[R1, #+177]
// 6313     BlackRightLoc[CameraHight - 2][0] = MaxValUint8;    
        MOVS     R0,#+255
        LDR.N    R1,??DataTable40_26
        STRB     R0,[R1, #+174]
// 6314     
// 6315     //两线线头均采集失败，则应该是十字，仍然从左线开始扫描。
// 6316     BlackGetPreDir = 2;
        MOVS     R0,#+2
        LDR.W    R1,??DataTable41_2
        STRB     R0,[R1, #+0]
// 6317     return 1;
        MOVS     R0,#+1
??BlackGetPre_3:
        POP      {R4,PC}          ;; return
// 6318   }
// 6319 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40:
        DC32     BlackRightContinueFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_1:
        DC32     SingleBlackAllFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_2:
        DC32     SlopeR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_3:
        DC32     BlackRightStep4Flag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_4:
        DC32     SingleBlackLastAllFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_5:
        DC32     BlackRightCrossDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_6:
        DC32     BlackRightRollCheckFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_7:
        DC32     BlackRightBigChangeJumpFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_8:
        DC32     BlackRightBigChangeNumx

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_9:
        DC32     BlackRightBigChangeNumy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_10:
        DC32     BlackRightBigChangeFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_11:
        DC32     BlackRightBigChangeSlopeStore

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_12:
        DC32     BlackRightBigChangeCheckRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_13:
        DC32     BlackRightBigChangeCheckAllRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_14:
        DC32     BlackRightPredictL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_15:
        DC32     BlackRightPredictR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_16:
        DC32     BlackRightWinPredictStore0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_17:
        DC32     BlackRightWinPredictStore1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_18:
        DC32     BlackRightStep4StartLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_19:
        DC32     LimitRightHeadWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_20:
        DC32     LimitRightWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_21:
        DC32     LimitRightHeadW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_22:
        DC32     LimitRightW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_23:
        DC32     LimitRightHeadB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_24:
        DC32     LimitRightB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_25:
        DC32     BlackRightStep1ScanRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_26:
        DC32     BlackRightLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_27:
        DC32     BlackRightWinPredictStore2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_28:
        DC32     BlackLeftHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_29:
        DC32     BlackRightRealWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_30:
        DC32     LimitRightWBMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_31:
        DC32     LimitRightWBMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_32:
        DC32     BlackRightRealW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_33:
        DC32     LimitRightWMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_34:
        DC32     LimitRightWMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_35:
        DC32     BlackRightRealB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_36:
        DC32     LimitRightBMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_37:
        DC32     LimitRightBMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_38:
        DC32     AngleZoneConfirmLockFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_39:
        DC32     BlackRightRow1RealLastLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_40:
        DC32     BlackRightCrossTooLowLine
// 6320 
// 6321 
// 6322 
// 6323 //黑线检测最后一步，找单线错误。///////////////////////////////这种检测单线错误的方法对浅色或者白色地板，效果会很差。
// 6324 //1正常（没检测到单线错误，或检测到单线错误并成功处理），0出错（这幅图像直接会判定为失败）

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 6325 uint8 BlackSingleSpeCheck(void)   
// 6326 {
BlackSingleSpeCheck:
        PUSH     {R3-R7,LR}
// 6327   uint8 temp1, temp2, index1;
// 6328   uint8 tempstep1row = MaxValUint8;
        MOVS     R4,#+255
// 6329   int avgr1, avgr2, avgl1, avgl2;
// 6330   int i;
// 6331   
// 6332   //两线都成功，不是单线。
// 6333   if(
// 6334      (BlackLeftDone == 1)
// 6335    &&(BlackRightDone == 1)
// 6336      )
        LDR.W    R0,??DataTable41_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??BlackSingleSpeCheck_0
        LDR.W    R0,??DataTable41_5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??BlackSingleSpeCheck_0
// 6337   {
// 6338     //检查左线悬空，注意不要在十字误判。
// 6339     if(
// 6340        (BlackRightStep1ScanRow == CameraHight - 1 && BlackLeftStep1ScanRow < CameraHight - 1) //左线尾较远，右线尾最近行。 
// 6341      &&(BlackRightLoc[BlackRightStep1ScanRow][0] != MaxValUint8 && BlackLeftLoc[BlackLeftStep1ScanRow][0] != MaxValUint8) //没有被大跳变滤掉 
// 6342      &&(BlackRightLoc[BlackRightStep1ScanRow-1][0] != MaxValUint8 && BlackLeftLoc[BlackLeftStep1ScanRow-1][0] != MaxValUint8) //没有被大跳变滤掉 
// 6343      &&(BlackRightLoc[BlackRightStep1ScanRow-2][0] != MaxValUint8 && BlackLeftLoc[BlackLeftStep1ScanRow-2][0] != MaxValUint8) //没有被大跳变滤掉   
// 6344        )
        LDR.W    R0,??DataTable42
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BNE.W    ??BlackSingleSpeCheck_1
        LDR.W    R0,??DataTable41_6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BGE.W    ??BlackSingleSpeCheck_1
        LDR.W    R0,??DataTable42_1
        LDR.W    R1,??DataTable42
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.W    ??BlackSingleSpeCheck_1
        LDR.W    R0,??DataTable41_3
        LDR.W    R1,??DataTable41_6
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.W    ??BlackSingleSpeCheck_1
        LDR.W    R0,??DataTable42_1
        LDR.W    R1,??DataTable42
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #-3]
        CMP      R0,#+255
        BEQ.W    ??BlackSingleSpeCheck_1
        LDR.W    R0,??DataTable41_3
        LDR.W    R1,??DataTable41_6
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #-3]
        CMP      R0,#+255
        BEQ.W    ??BlackSingleSpeCheck_1
        LDR.W    R0,??DataTable42_1
        LDR.W    R1,??DataTable42
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #-6]
        CMP      R0,#+255
        BEQ.W    ??BlackSingleSpeCheck_1
        LDR.W    R0,??DataTable41_3
        LDR.W    R1,??DataTable41_6
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #-6]
        CMP      R0,#+255
        BEQ.W    ??BlackSingleSpeCheck_1
// 6345     {
// 6346       //1. 检查左线的左边一个单线宽度内是不是有右线。      
// 6347       if(
// 6348         (BlackLeftLoc[BlackLeftStep1ScanRow-1][0] > SingleBlackWidthMax[BlackLeftStep1ScanRow-1] * 1)
// 6349       &&(BlackLeftLoc[BlackLeftStep1ScanRow-2][0] > SingleBlackWidthMax[BlackLeftStep1ScanRow-2] * 1) //左线头不能太靠左，至少要留出1个单线宽度。 
// 6350       &&(BlackLeftLoc[BlackLeftStep1ScanRow-1][0] < CameraRealWidth / 2 + 60)  
// 6351       &&(BlackLeftLoc[BlackLeftStep1ScanRow-2][0] < CameraRealWidth / 2 + 60)  //左线不能太靠右，大致要在左半边屏内。
// 6352         )
        LDR.W    R0,??DataTable42_2
        LDR.W    R1,??DataTable41_6
        LDRB     R1,[R1, #+0]
        ADDS     R0,R1,R0
        LDRB     R0,[R0, #-1]
        LDR.W    R1,??DataTable41_3
        LDR.W    R2,??DataTable41_6
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+3
        MLA      R1,R3,R2,R1
        LDRB     R1,[R1, #-3]
        CMP      R0,R1
        BCS.W    ??BlackSingleSpeCheck_2
        LDR.W    R0,??DataTable42_2
        LDR.W    R1,??DataTable41_6
        LDRB     R1,[R1, #+0]
        ADDS     R0,R1,R0
        LDRB     R0,[R0, #-2]
        LDR.W    R1,??DataTable41_3
        LDR.W    R2,??DataTable41_6
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+3
        MLA      R1,R3,R2,R1
        LDRB     R1,[R1, #-6]
        CMP      R0,R1
        BCS.W    ??BlackSingleSpeCheck_2
        LDR.W    R0,??DataTable41_3
        LDR.W    R1,??DataTable41_6
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #-3]
        CMP      R0,#+185
        BGE.W    ??BlackSingleSpeCheck_2
        LDR.W    R0,??DataTable41_3
        LDR.W    R1,??DataTable41_6
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #-6]
        CMP      R0,#+185
        BGE.W    ??BlackSingleSpeCheck_2
// 6353       {
// 6354         //开一个单线宽度的窗来检测是不是有右线。temp1和temp2为右黑线的白点位置。
// 6355         temp1 = BlackGetRightJustWin(BlackLeftStep1ScanRow-1, 
// 6356                                      BlackLeftLoc[BlackLeftStep1ScanRow-1][0] - SingleBlackWidthMax[BlackLeftStep1ScanRow-1], //最多最多跨过15列，所以20列应该够。
// 6357                                      BlackLeftLoc[BlackLeftStep1ScanRow-1][0]);
        LDR.W    R0,??DataTable41_3
        LDR.W    R1,??DataTable41_6
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R2,[R0, #-3]
        LDR.W    R0,??DataTable41_3
        LDR.W    R1,??DataTable41_6
        LDRB     R1,[R1, #+0]
        MOVS     R3,#+3
        MLA      R0,R3,R1,R0
        LDRB     R0,[R0, #-3]
        LDR.W    R1,??DataTable42_2
        LDR.W    R3,??DataTable41_6
        LDRB     R3,[R3, #+0]
        ADDS     R1,R3,R1
        LDRB     R1,[R1, #-1]
        SUBS     R1,R0,R1
        LDR.W    R0,??DataTable41_6
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetRightJustWin
        MOVS     R6,R0
// 6358         temp2 = BlackGetRightJustWin(BlackLeftStep1ScanRow-2, 
// 6359                                      BlackLeftLoc[BlackLeftStep1ScanRow-2][0] - SingleBlackWidthMax[BlackLeftStep1ScanRow-2], //最多最多跨过15列，所以20列应该够。
// 6360                                      BlackLeftLoc[BlackLeftStep1ScanRow-2][0]);
        LDR.W    R0,??DataTable41_3
        LDR.W    R1,??DataTable41_6
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R2,[R0, #-6]
        LDR.W    R0,??DataTable41_3
        LDR.W    R1,??DataTable41_6
        LDRB     R1,[R1, #+0]
        MOVS     R3,#+3
        MLA      R0,R3,R1,R0
        LDRB     R0,[R0, #-6]
        LDR.W    R1,??DataTable42_2
        LDR.W    R3,??DataTable41_6
        LDRB     R3,[R3, #+0]
        ADDS     R1,R3,R1
        LDRB     R1,[R1, #-2]
        SUBS     R1,R0,R1
        LDR.W    R0,??DataTable41_6
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetRightJustWin
        MOVS     R5,R0
// 6361         //必须连续两行有右黑线。而且两个黑点所在列不能相差太大。 
// 6362         if(temp1 != MaxValUint8 && temp2 != MaxValUint8 && AbsInt(temp1 - temp2) < 8)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+255
        BEQ.W    ??BlackSingleSpeCheck_2
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+255
        BEQ.W    ??BlackSingleSpeCheck_2
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        SUBS     R0,R6,R5
        BL       AbsInt
        CMP      R0,#+8
        BGE.W    ??BlackSingleSpeCheck_2
// 6363         {          
// 6364           //第一行右线的白点平均值
// 6365           avgr1 = (ImgNew[BlackLeftStep1ScanRow-1][temp1 - 1]
// 6366                  + ImgNew[BlackLeftStep1ScanRow-1][temp1 - 2]
// 6367                  + ImgNew[BlackLeftStep1ScanRow-1][temp1 - 3]
// 6368                  + ImgNew[BlackLeftStep1ScanRow-1][temp1 - 4]
// 6369                  + ImgNew[BlackLeftStep1ScanRow-1][temp1 - 5])
// 6370                  / 5;
        LDR.W    R0,??DataTable42_3
        LDR.W    R1,??DataTable41_6
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+250
        MLA      R0,R2,R1,R0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R0,R6,R0
        LDRB     R0,[R0, #-251]
        LDR.W    R1,??DataTable42_3
        LDR.W    R2,??DataTable41_6
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+250
        MLA      R1,R3,R2,R1
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #-252]
        UXTAB    R0,R1,R0
        LDR.W    R1,??DataTable42_3
        LDR.W    R2,??DataTable41_6
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+250
        MLA      R1,R3,R2,R1
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #-253]
        UXTAB    R0,R0,R1
        LDR.W    R1,??DataTable42_3
        LDR.W    R2,??DataTable41_6
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+250
        MLA      R1,R3,R2,R1
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #-254]
        UXTAB    R0,R0,R1
        LDR.W    R1,??DataTable42_3
        LDR.W    R2,??DataTable41_6
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+250
        MLA      R1,R3,R2,R1
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #-255]
        UXTAB    R0,R0,R1
        MOVS     R1,#+5
        SDIV     R0,R0,R1
// 6371           //第一行左线的白点平均值
// 6372           avgl1 = (ImgNew[BlackLeftStep1ScanRow-1][BlackLeftLoc[BlackLeftStep1ScanRow-1][0] + 1 + BlackLeftEdgeNum + 1]
// 6373                  + ImgNew[BlackLeftStep1ScanRow-1][BlackLeftLoc[BlackLeftStep1ScanRow-1][0] + 1 + BlackLeftEdgeNum + 2]
// 6374                  + ImgNew[BlackLeftStep1ScanRow-1][BlackLeftLoc[BlackLeftStep1ScanRow-1][0] + 1 + BlackLeftEdgeNum + 3]
// 6375                  + ImgNew[BlackLeftStep1ScanRow-1][BlackLeftLoc[BlackLeftStep1ScanRow-1][0] + 1 + BlackLeftEdgeNum + 4]
// 6376                  + ImgNew[BlackLeftStep1ScanRow-1][BlackLeftLoc[BlackLeftStep1ScanRow-1][0] + 1 + BlackLeftEdgeNum + 5])
// 6377                  / 5;          
        LDR.W    R1,??DataTable42_3
        LDR.W    R2,??DataTable41_6
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+250
        MLA      R1,R3,R2,R1
        LDR.W    R2,??DataTable41_3
        LDR.W    R3,??DataTable41_6
        LDRB     R3,[R3, #+0]
        MOVS     R6,#+3
        MLA      R2,R6,R3,R2
        LDRB     R2,[R2, #-3]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #-245]
        LDR.W    R2,??DataTable42_3
        LDR.W    R3,??DataTable41_6
        LDRB     R3,[R3, #+0]
        MOVS     R6,#+250
        MLA      R2,R6,R3,R2
        LDR.W    R3,??DataTable41_3
        LDR.W    R6,??DataTable41_6
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+3
        MLA      R3,R7,R6,R3
        LDRB     R3,[R3, #-3]
        ADDS     R2,R3,R2
        LDRB     R2,[R2, #-244]
        UXTAB    R1,R2,R1
        LDR.W    R2,??DataTable42_3
        LDR.W    R3,??DataTable41_6
        LDRB     R3,[R3, #+0]
        MOVS     R6,#+250
        MLA      R2,R6,R3,R2
        LDR.W    R3,??DataTable41_3
        LDR.W    R6,??DataTable41_6
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+3
        MLA      R3,R7,R6,R3
        LDRB     R3,[R3, #-3]
        ADDS     R2,R3,R2
        LDRB     R2,[R2, #-243]
        UXTAB    R1,R1,R2
        LDR.W    R2,??DataTable42_3
        LDR.W    R3,??DataTable41_6
        LDRB     R3,[R3, #+0]
        MOVS     R6,#+250
        MLA      R2,R6,R3,R2
        LDR.W    R3,??DataTable41_3
        LDR.W    R6,??DataTable41_6
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+3
        MLA      R3,R7,R6,R3
        LDRB     R3,[R3, #-3]
        ADDS     R2,R3,R2
        LDRB     R2,[R2, #-242]
        UXTAB    R1,R1,R2
        LDR.W    R2,??DataTable42_3
        LDR.W    R3,??DataTable41_6
        LDRB     R3,[R3, #+0]
        MOVS     R6,#+250
        MLA      R2,R6,R3,R2
        LDR.W    R3,??DataTable41_3
        LDR.W    R6,??DataTable41_6
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+3
        MLA      R3,R7,R6,R3
        LDRB     R3,[R3, #-3]
        ADDS     R2,R3,R2
        LDRB     R2,[R2, #-241]
        UXTAB    R1,R1,R2
        MOVS     R2,#+5
        SDIV     R1,R1,R2
// 6378           //第二行右线的白点平均值
// 6379           avgr2 = (ImgNew[BlackLeftStep1ScanRow-2][temp2 - 1]
// 6380                  + ImgNew[BlackLeftStep1ScanRow-2][temp2 - 2]
// 6381                  + ImgNew[BlackLeftStep1ScanRow-2][temp2 - 3]
// 6382                  + ImgNew[BlackLeftStep1ScanRow-2][temp2 - 4]
// 6383                  + ImgNew[BlackLeftStep1ScanRow-2][temp2 - 5])
// 6384                  / 5;
        LDR.W    R2,??DataTable42_3
        LDR.W    R3,??DataTable41_6
        LDRB     R3,[R3, #+0]
        MOVS     R6,#+250
        MLA      R2,R6,R3,R2
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R2,R5,R2
        SUBW     R2,R2,#+501
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable42_3
        LDR.W    R6,??DataTable41_6
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+250
        MLA      R3,R7,R6,R3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R3,R5,R3
        SUBS     R3,R3,#+502
        LDRB     R3,[R3, #+0]
        UXTAB    R2,R3,R2
        LDR.W    R3,??DataTable42_3
        LDR.W    R6,??DataTable41_6
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+250
        MLA      R3,R7,R6,R3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R3,R5,R3
        SUBW     R3,R3,#+503
        LDRB     R3,[R3, #+0]
        UXTAB    R2,R2,R3
        LDR.W    R3,??DataTable42_3
        LDR.W    R6,??DataTable41_6
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+250
        MLA      R3,R7,R6,R3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R3,R5,R3
        SUBS     R3,R3,#+504
        LDRB     R3,[R3, #+0]
        UXTAB    R2,R2,R3
        LDR.W    R3,??DataTable42_3
        LDR.W    R6,??DataTable41_6
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+250
        MLA      R3,R7,R6,R3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R3,R5,R3
        SUBW     R3,R3,#+505
        LDRB     R3,[R3, #+0]
        UXTAB    R2,R2,R3
        MOVS     R3,#+5
        SDIV     R5,R2,R3
// 6385           //第二行左线的白点平均值
// 6386           avgl2 = (ImgNew[BlackLeftStep1ScanRow-2][BlackLeftLoc[BlackLeftStep1ScanRow-2][0] + 1 + BlackLeftEdgeNum + 1]
// 6387                  + ImgNew[BlackLeftStep1ScanRow-2][BlackLeftLoc[BlackLeftStep1ScanRow-2][0] + 1 + BlackLeftEdgeNum + 2]
// 6388                  + ImgNew[BlackLeftStep1ScanRow-2][BlackLeftLoc[BlackLeftStep1ScanRow-2][0] + 1 + BlackLeftEdgeNum + 3]
// 6389                  + ImgNew[BlackLeftStep1ScanRow-2][BlackLeftLoc[BlackLeftStep1ScanRow-2][0] + 1 + BlackLeftEdgeNum + 4]
// 6390                  + ImgNew[BlackLeftStep1ScanRow-2][BlackLeftLoc[BlackLeftStep1ScanRow-2][0] + 1 + BlackLeftEdgeNum + 5])
// 6391                  / 5;          
        LDR.W    R2,??DataTable42_3
        LDR.W    R3,??DataTable41_6
        LDRB     R3,[R3, #+0]
        MOVS     R6,#+250
        MLA      R2,R6,R3,R2
        LDR.W    R3,??DataTable41_3
        LDR.W    R6,??DataTable41_6
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+3
        MLA      R3,R7,R6,R3
        LDRB     R3,[R3, #-6]
        ADDS     R2,R3,R2
        SUBW     R2,R2,#+495
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable42_3
        LDR.W    R6,??DataTable41_6
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+250
        MLA      R3,R7,R6,R3
        LDR.W    R6,??DataTable41_3
        LDR.W    R7,??DataTable41_6
        LDRB     R7,[R7, #+0]
        MOVS     R12,#+3
        MLA      R6,R12,R7,R6
        LDRB     R6,[R6, #-6]
        ADDS     R3,R6,R3
        SUBS     R3,R3,#+494
        LDRB     R3,[R3, #+0]
        UXTAB    R2,R3,R2
        LDR.W    R3,??DataTable42_3
        LDR.W    R6,??DataTable41_6
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+250
        MLA      R3,R7,R6,R3
        LDR.W    R6,??DataTable41_3
        LDR.W    R7,??DataTable41_6
        LDRB     R7,[R7, #+0]
        MOVS     R12,#+3
        MLA      R6,R12,R7,R6
        LDRB     R6,[R6, #-6]
        ADDS     R3,R6,R3
        SUBW     R3,R3,#+493
        LDRB     R3,[R3, #+0]
        UXTAB    R2,R2,R3
        LDR.W    R3,??DataTable42_3
        LDR.W    R6,??DataTable41_6
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+250
        MLA      R3,R7,R6,R3
        LDR.W    R6,??DataTable41_3
        LDR.W    R7,??DataTable41_6
        LDRB     R7,[R7, #+0]
        MOVS     R12,#+3
        MLA      R6,R12,R7,R6
        LDRB     R6,[R6, #-6]
        ADDS     R3,R6,R3
        SUBS     R3,R3,#+492
        LDRB     R3,[R3, #+0]
        UXTAB    R2,R2,R3
        LDR.W    R3,??DataTable42_3
        LDR.W    R6,??DataTable41_6
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+250
        MLA      R3,R7,R6,R3
        LDR.W    R6,??DataTable41_3
        LDR.W    R7,??DataTable41_6
        LDRB     R7,[R7, #+0]
        MOVS     R12,#+3
        MLA      R6,R12,R7,R6
        LDRB     R6,[R6, #-6]
        ADDS     R3,R6,R3
        SUBW     R3,R3,#+491
        LDRB     R3,[R3, #+0]
        UXTAB    R2,R2,R3
        MOVS     R3,#+5
        SDIV     R6,R2,R3
// 6392           
// 6393           //最后一步，确认两者的白色点的平均值差别非常小。  /////////////////////此时若地板为浅色或者白色，就挂了。
// 6394           if(AbsInt(avgr1 - avgl1) < 15 && AbsInt(avgr2 - avgl2) < 15)
        SUBS     R0,R0,R1
        BL       AbsInt
        CMP      R0,#+15
        BGE.N    ??BlackSingleSpeCheck_2
        SUBS     R0,R5,R6
        BL       AbsInt
        CMP      R0,#+15
        BGE.N    ??BlackSingleSpeCheck_2
// 6395           {
// 6396             BlackSingleFlag = 1;        //单线错误标志置位。
        MOVS     R0,#+1
        LDR.W    R1,??DataTable42_4
        STRB     R0,[R1, #+0]
// 6397             BlackSingleDir = 0;         //表示是左线悬空的情况。
        MOVS     R0,#+0
        LDR.W    R1,??DataTable42_5
        STRB     R0,[R1, #+0]
// 6398           }
// 6399           else
// 6400           {
// 6401           }
// 6402         }
// 6403         else
// 6404         {
// 6405         }
// 6406       }
// 6407       else
// 6408       {
// 6409       }
// 6410       
// 6411       //查看单线错误标志
// 6412       if(BlackSingleFlag == 1)
??BlackSingleSpeCheck_2:
        LDR.W    R0,??DataTable42_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??BlackSingleSpeCheck_0
// 6413       {
// 6414         //确定是单线错误后，先把右黑线全置无效值。
// 6415         for(i = 0; ; i++)
        MOVS     R5,#+0
        B.N      ??BlackSingleSpeCheck_3
??BlackSingleSpeCheck_4:
        ADDS     R5,R5,#+1
// 6416         {
// 6417           BlackRightLoc[i][0] = MaxValUint8;           
??BlackSingleSpeCheck_3:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable42_1
        MOVS     R2,#+3
        MLA      R1,R2,R5,R1
        STRB     R0,[R1, #+0]
// 6418           if(i == CameraHight - 1) break;
        CMP      R5,#+59
        BNE.N    ??BlackSingleSpeCheck_4
// 6419         }
// 6420         
// 6421         index1 = 0;
        MOVS     R7,#+0
// 6422         //然后从左线尾所在行开始开窗扫右线，一直到左线头所在行或者有未采到的行。
// 6423         for(i = BlackLeftStep1ScanRow; ; i--)
        LDR.W    R0,??DataTable41_6
        LDRB     R5,[R0, #+0]
        B.N      ??BlackSingleSpeCheck_5
??BlackSingleSpeCheck_6:
        SUBS     R5,R5,#+1
// 6424         {
// 6425           temp1 = BlackGetRightJustWin(i, 
// 6426                                        BlackLeftLoc[i][0] - SingleBlackWidthMax[i], //最多最多跨过15列，所以20列应该够。
// 6427                                        BlackLeftLoc[i][0]);            
??BlackSingleSpeCheck_5:
        LDR.W    R0,??DataTable41_3
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R2,[R0, #+0]
        LDR.W    R0,??DataTable41_3
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable42_2
        LDRB     R1,[R5, R1]
        SUBS     R1,R0,R1
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetRightJustWin
        MOVS     R6,R0
// 6428           if(temp1 != MaxValUint8)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+255
        BEQ.N    ??BlackSingleSpeCheck_7
// 6429           {
// 6430             //该行扫描右黑线成功
// 6431             BlackRightLoc[i][0] = temp1 + 1 + BlackRightEdgeNum;
        ADDS     R0,R6,#+4
        LDR.W    R1,??DataTable42_1
        MOVS     R2,#+3
        MLA      R1,R2,R5,R1
        STRB     R0,[R1, #+0]
// 6432             //记录右黑线扫描成功的最近行。
// 6433             if(index1 == 0)
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BNE.N    ??BlackSingleSpeCheck_8
// 6434             {
// 6435               tempstep1row = i;
        MOVS     R4,R5
// 6436               index1++;
        ADDS     R7,R7,#+1
// 6437             }
// 6438             else
// 6439             {
// 6440             }
// 6441           }
// 6442           else
// 6443           {
// 6444             //一旦没有采到，再远的行就不要了，直接退出。
// 6445             break;
// 6446           }
// 6447           //到左线头了，退出
// 6448           if(i == BlackLeftHeadLine) break;
??BlackSingleSpeCheck_8:
        LDR.W    R0,??DataTable42_6
        LDRB     R0,[R0, #+0]
        CMP      R5,R0
        BNE.N    ??BlackSingleSpeCheck_6
// 6449         }
// 6450         
// 6451         //检测不到有效右黑线，返回失败。
// 6452         if(tempstep1row == MaxValUint8) return 0;
??BlackSingleSpeCheck_9:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+255
        BNE.N    ??BlackSingleSpeCheck_10
        MOVS     R0,#+0
        B.N      ??BlackSingleSpeCheck_11
??BlackSingleSpeCheck_7:
        B.N      ??BlackSingleSpeCheck_9
// 6453         
// 6454         //往远几行开始，向后补线。第2个输入参数是1。
// 6455         //不管左线之间的向后补线是否成功，都要放远几个点重新向后补一次
// 6456         if(BlackLeftStep4BackLine(BlackLeftStep1ScanRow - 2, 1) == 1 && BlackRightStep4BackLine(tempstep1row - 2, 1) == 1)
??BlackSingleSpeCheck_10:
        MOVS     R1,#+1
        LDR.W    R0,??DataTable41_6
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackLeftStep4BackLine
        CMP      R0,#+1
        BNE.N    ??BlackSingleSpeCheck_12
        MOVS     R1,#+1
        SUBS     R0,R4,#+2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackRightStep4BackLine
        CMP      R0,#+1
        BEQ.W    ??BlackSingleSpeCheck_0
// 6457         {
// 6458         }
// 6459         else
// 6460         {
// 6461           //如果补线没有成功（有可能是点太少），那就直接返回失败，这幅图像直接判定为失败。
// 6462           return 0;
??BlackSingleSpeCheck_12:
        MOVS     R0,#+0
        B.N      ??BlackSingleSpeCheck_11
// 6463         }           
// 6464         
// 6465         //置单线标志位SingleBlackAllFlag(用于CenterLineGet)。     
// 6466         //SingleBlackAllFlag = 1;     
// 6467         
// 6468       }
// 6469       //单线错误标志没有置位，不用作任何处理。
// 6470       else
// 6471       {
// 6472       }
// 6473         
// 6474     }
// 6475     //检查右线悬空，注意不要在十字误判。
// 6476     else if(
// 6477        (BlackLeftStep1ScanRow == CameraHight - 1 && BlackRightStep1ScanRow < CameraHight - 1) //右线尾较远，左线尾最近行。 
// 6478      &&(BlackRightLoc[BlackRightStep1ScanRow][0] != MaxValUint8 && BlackLeftLoc[BlackLeftStep1ScanRow][0] != MaxValUint8) //没有被大跳变滤掉 
// 6479      &&(BlackRightLoc[BlackRightStep1ScanRow-1][0] != MaxValUint8 && BlackLeftLoc[BlackLeftStep1ScanRow-1][0] != MaxValUint8) //没有被大跳变滤掉 
// 6480      &&(BlackRightLoc[BlackRightStep1ScanRow-2][0] != MaxValUint8 && BlackLeftLoc[BlackLeftStep1ScanRow-2][0] != MaxValUint8) //没有被大跳变滤掉   
// 6481        )
??BlackSingleSpeCheck_1:
        LDR.W    R0,??DataTable41_6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BNE.W    ??BlackSingleSpeCheck_0
        LDR.W    R0,??DataTable42
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BGE.W    ??BlackSingleSpeCheck_0
        LDR.W    R0,??DataTable42_1
        LDR.W    R1,??DataTable42
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.W    ??BlackSingleSpeCheck_0
        LDR.W    R0,??DataTable41_3
        LDR.W    R1,??DataTable41_6
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.W    ??BlackSingleSpeCheck_0
        LDR.W    R0,??DataTable42_1
        LDR.W    R1,??DataTable42
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #-3]
        CMP      R0,#+255
        BEQ.W    ??BlackSingleSpeCheck_0
        LDR.W    R0,??DataTable41_3
        LDR.W    R1,??DataTable41_6
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #-3]
        CMP      R0,#+255
        BEQ.W    ??BlackSingleSpeCheck_0
        LDR.W    R0,??DataTable42_1
        LDR.W    R1,??DataTable42
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #-6]
        CMP      R0,#+255
        BEQ.W    ??BlackSingleSpeCheck_0
        LDR.W    R0,??DataTable41_3
        LDR.W    R1,??DataTable41_6
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #-6]
        CMP      R0,#+255
        BEQ.W    ??BlackSingleSpeCheck_0
// 6482     {
// 6483       //1. 检查右线的右边一个单线宽度内是不是有左线。      
// 6484       if(
// 6485         (BlackRightLoc[BlackRightStep1ScanRow-1][0] < CameraRealWidth - 1 - SingleBlackWidthMax[BlackRightStep1ScanRow-1] * 1)
// 6486       &&(BlackRightLoc[BlackRightStep1ScanRow-2][0] < CameraRealWidth - 1 - SingleBlackWidthMax[BlackRightStep1ScanRow-2] * 1) //右线头不能太靠右，至少要留出1个单线宽度。 
// 6487       &&(BlackRightLoc[BlackRightStep1ScanRow-1][0] > CameraRealWidth / 2 - 60)  
// 6488       &&(BlackRightLoc[BlackRightStep1ScanRow-2][0] > CameraRealWidth / 2 - 60)  //右线不能太靠左，大致要在右半边屏内。
// 6489         )
        LDR.W    R0,??DataTable42_1
        LDR.W    R1,??DataTable42
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #-3]
        LDR.W    R1,??DataTable42_2
        LDR.W    R2,??DataTable42
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #-1]
        RSBS     R1,R1,#+249
        CMP      R0,R1
        BGE.W    ??BlackSingleSpeCheck_13
        LDR.W    R0,??DataTable42_1
        LDR.W    R1,??DataTable42
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #-6]
        LDR.W    R1,??DataTable42_2
        LDR.W    R2,??DataTable42
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #-2]
        RSBS     R1,R1,#+249
        CMP      R0,R1
        BGE.W    ??BlackSingleSpeCheck_13
        LDR.W    R0,??DataTable42_1
        LDR.W    R1,??DataTable42
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #-3]
        CMP      R0,#+66
        BLT.W    ??BlackSingleSpeCheck_13
        LDR.W    R0,??DataTable42_1
        LDR.W    R1,??DataTable42
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #-6]
        CMP      R0,#+66
        BLT.W    ??BlackSingleSpeCheck_13
// 6490       {
// 6491         //开一个单线宽度的窗来检测是不是有左线。temp1和temp2为左黑线的白点位置。
// 6492         temp1 = BlackGetLeftJustWin(BlackRightStep1ScanRow-1, 
// 6493                                      BlackRightLoc[BlackRightStep1ScanRow-1][0], //最多最多跨过15列，所以20列应该够。
// 6494                                      BlackRightLoc[BlackRightStep1ScanRow-1][0] + SingleBlackWidthMax[BlackRightStep1ScanRow-1]);
        LDR.W    R0,??DataTable42_1
        LDR.W    R1,??DataTable42
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #-3]
        LDR.W    R1,??DataTable42_2
        LDR.W    R2,??DataTable42
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #-1]
        UXTAB    R2,R1,R0
        LDR.W    R0,??DataTable42_1
        LDR.W    R1,??DataTable42
        LDRB     R1,[R1, #+0]
        MOVS     R3,#+3
        MLA      R0,R3,R1,R0
        LDRB     R1,[R0, #-3]
        LDR.W    R0,??DataTable42
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetLeftJustWin
        MOVS     R6,R0
// 6495         temp2 = BlackGetLeftJustWin(BlackRightStep1ScanRow-2, 
// 6496                                      BlackRightLoc[BlackRightStep1ScanRow-2][0], //最多最多跨过15列，所以20列应该够。
// 6497                                      BlackRightLoc[BlackRightStep1ScanRow-2][0] + SingleBlackWidthMax[BlackRightStep1ScanRow-2]);
        LDR.W    R0,??DataTable42_1
        LDR.W    R1,??DataTable42
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #-6]
        LDR.W    R1,??DataTable42_2
        LDR.W    R2,??DataTable42
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #-2]
        UXTAB    R2,R1,R0
        LDR.W    R0,??DataTable42_1
        LDR.W    R1,??DataTable42
        LDRB     R1,[R1, #+0]
        MOVS     R3,#+3
        MLA      R0,R3,R1,R0
        LDRB     R1,[R0, #-6]
        LDR.W    R0,??DataTable42
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetLeftJustWin
        MOVS     R5,R0
// 6498         //必须连续两行有左黑线。而且两个黑点所在列不能相差太大。 
// 6499         if(temp1 != MaxValUint8 && temp2 != MaxValUint8 && AbsInt(temp1 - temp2) < 8)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+255
        BEQ.W    ??BlackSingleSpeCheck_13
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+255
        BEQ.W    ??BlackSingleSpeCheck_13
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        SUBS     R0,R6,R5
        BL       AbsInt
        CMP      R0,#+8
        BGE.W    ??BlackSingleSpeCheck_13
// 6500         {          
// 6501           //第一行左线的白点平均值
// 6502           avgr1 = (ImgNew[BlackRightStep1ScanRow-1][temp1 + 1]
// 6503                  + ImgNew[BlackRightStep1ScanRow-1][temp1 + 2]
// 6504                  + ImgNew[BlackRightStep1ScanRow-1][temp1 + 3]
// 6505                  + ImgNew[BlackRightStep1ScanRow-1][temp1 + 4]
// 6506                  + ImgNew[BlackRightStep1ScanRow-1][temp1 + 5])
// 6507                  / 5;
        LDR.W    R0,??DataTable42_3
        LDR.W    R1,??DataTable42
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+250
        MLA      R0,R2,R1,R0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R0,R6,R0
        LDRB     R0,[R0, #-249]
        LDR.W    R1,??DataTable42_3
        LDR.W    R2,??DataTable42
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+250
        MLA      R1,R3,R2,R1
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #-248]
        UXTAB    R0,R1,R0
        LDR.W    R1,??DataTable42_3
        LDR.W    R2,??DataTable42
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+250
        MLA      R1,R3,R2,R1
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #-247]
        UXTAB    R0,R0,R1
        LDR.W    R1,??DataTable42_3
        LDR.W    R2,??DataTable42
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+250
        MLA      R1,R3,R2,R1
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #-246]
        UXTAB    R0,R0,R1
        LDR.W    R1,??DataTable42_3
        LDR.W    R2,??DataTable42
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+250
        MLA      R1,R3,R2,R1
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        ADDS     R1,R6,R1
        LDRB     R1,[R1, #-245]
        UXTAB    R0,R0,R1
        MOVS     R1,#+5
        SDIV     R0,R0,R1
// 6508           //第一行右线的白点平均值
// 6509           avgl1 = (ImgNew[BlackRightStep1ScanRow-1][BlackRightLoc[BlackRightStep1ScanRow-1][0] - 1 - BlackRightEdgeNum - 1]
// 6510                  + ImgNew[BlackRightStep1ScanRow-1][BlackRightLoc[BlackRightStep1ScanRow-1][0] - 1 - BlackRightEdgeNum - 2]
// 6511                  + ImgNew[BlackRightStep1ScanRow-1][BlackRightLoc[BlackRightStep1ScanRow-1][0] - 1 - BlackRightEdgeNum - 3]
// 6512                  + ImgNew[BlackRightStep1ScanRow-1][BlackRightLoc[BlackRightStep1ScanRow-1][0] - 1 - BlackRightEdgeNum - 4]
// 6513                  + ImgNew[BlackRightStep1ScanRow-1][BlackRightLoc[BlackRightStep1ScanRow-1][0] - 1 - BlackRightEdgeNum - 5])
// 6514                  / 5;
        LDR.W    R1,??DataTable42_3
        LDR.W    R2,??DataTable42
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+250
        MLA      R1,R3,R2,R1
        LDR.W    R2,??DataTable42_1
        LDR.W    R3,??DataTable42
        LDRB     R3,[R3, #+0]
        MOVS     R6,#+3
        MLA      R2,R6,R3,R2
        LDRB     R2,[R2, #-3]
        ADDS     R1,R2,R1
        LDRB     R1,[R1, #-255]
        LDR.W    R2,??DataTable42_3
        LDR.W    R3,??DataTable42
        LDRB     R3,[R3, #+0]
        MOVS     R6,#+250
        MLA      R2,R6,R3,R2
        LDR.W    R3,??DataTable42_1
        LDR.W    R6,??DataTable42
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+3
        MLA      R3,R7,R6,R3
        LDRB     R3,[R3, #-3]
        ADDS     R2,R3,R2
        SUBS     R2,R2,#+256
        LDRB     R2,[R2, #+0]
        UXTAB    R1,R2,R1
        LDR.W    R2,??DataTable42_3
        LDR.W    R3,??DataTable42
        LDRB     R3,[R3, #+0]
        MOVS     R6,#+250
        MLA      R2,R6,R3,R2
        LDR.W    R3,??DataTable42_1
        LDR.W    R6,??DataTable42
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+3
        MLA      R3,R7,R6,R3
        LDRB     R3,[R3, #-3]
        ADDS     R2,R3,R2
        SUBW     R2,R2,#+257
        LDRB     R2,[R2, #+0]
        UXTAB    R1,R1,R2
        LDR.W    R2,??DataTable42_3
        LDR.W    R3,??DataTable42
        LDRB     R3,[R3, #+0]
        MOVS     R6,#+250
        MLA      R2,R6,R3,R2
        LDR.W    R3,??DataTable42_1
        LDR.W    R6,??DataTable42
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+3
        MLA      R3,R7,R6,R3
        LDRB     R3,[R3, #-3]
        ADDS     R2,R3,R2
        SUBS     R2,R2,#+258
        LDRB     R2,[R2, #+0]
        UXTAB    R1,R1,R2
        LDR.W    R2,??DataTable42_3
        LDR.W    R3,??DataTable42
        LDRB     R3,[R3, #+0]
        MOVS     R6,#+250
        MLA      R2,R6,R3,R2
        LDR.W    R3,??DataTable42_1
        LDR.W    R6,??DataTable42
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+3
        MLA      R3,R7,R6,R3
        LDRB     R3,[R3, #-3]
        ADDS     R2,R3,R2
        SUBW     R2,R2,#+259
        LDRB     R2,[R2, #+0]
        UXTAB    R1,R1,R2
        MOVS     R2,#+5
        SDIV     R1,R1,R2
// 6515           //第二行左线的白点平均值
// 6516           avgr2 = (ImgNew[BlackRightStep1ScanRow-2][temp2 + 1]
// 6517                  + ImgNew[BlackRightStep1ScanRow-2][temp2 + 2]
// 6518                  + ImgNew[BlackRightStep1ScanRow-2][temp2 + 3]
// 6519                  + ImgNew[BlackRightStep1ScanRow-2][temp2 + 4]
// 6520                  + ImgNew[BlackRightStep1ScanRow-2][temp2 + 5])
// 6521                  / 5;
        LDR.W    R2,??DataTable42_3
        LDR.W    R3,??DataTable42
        LDRB     R3,[R3, #+0]
        MOVS     R6,#+250
        MLA      R2,R6,R3,R2
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R2,R5,R2
        SUBW     R2,R2,#+499
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable42_3
        LDR.W    R6,??DataTable42
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+250
        MLA      R3,R7,R6,R3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R3,R5,R3
        SUBS     R3,R3,#+498
        LDRB     R3,[R3, #+0]
        UXTAB    R2,R3,R2
        LDR.W    R3,??DataTable42_3
        LDR.W    R6,??DataTable42
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+250
        MLA      R3,R7,R6,R3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R3,R5,R3
        SUBW     R3,R3,#+497
        LDRB     R3,[R3, #+0]
        UXTAB    R2,R2,R3
        LDR.W    R3,??DataTable42_3
        LDR.W    R6,??DataTable42
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+250
        MLA      R3,R7,R6,R3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R3,R5,R3
        SUBS     R3,R3,#+496
        LDRB     R3,[R3, #+0]
        UXTAB    R2,R2,R3
        LDR.W    R3,??DataTable42_3
        LDR.W    R6,??DataTable42
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+250
        MLA      R3,R7,R6,R3
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        ADDS     R3,R5,R3
        SUBW     R3,R3,#+495
        LDRB     R3,[R3, #+0]
        UXTAB    R2,R2,R3
        MOVS     R3,#+5
        SDIV     R5,R2,R3
// 6522           //第二行右线的白点平均值
// 6523           avgl2 = (ImgNew[BlackRightStep1ScanRow-2][BlackRightLoc[BlackRightStep1ScanRow-2][0] - 1 - BlackRightEdgeNum - 1]
// 6524                  + ImgNew[BlackRightStep1ScanRow-2][BlackRightLoc[BlackRightStep1ScanRow-2][0] - 1 - BlackRightEdgeNum - 2]
// 6525                  + ImgNew[BlackRightStep1ScanRow-2][BlackRightLoc[BlackRightStep1ScanRow-2][0] - 1 - BlackRightEdgeNum - 3]
// 6526                  + ImgNew[BlackRightStep1ScanRow-2][BlackRightLoc[BlackRightStep1ScanRow-2][0] - 1 - BlackRightEdgeNum - 4]
// 6527                  + ImgNew[BlackRightStep1ScanRow-2][BlackRightLoc[BlackRightStep1ScanRow-2][0] - 1 - BlackRightEdgeNum - 5])
// 6528                  / 5;      
        LDR.W    R2,??DataTable42_3
        LDR.W    R3,??DataTable42
        LDRB     R3,[R3, #+0]
        MOVS     R6,#+250
        MLA      R2,R6,R3,R2
        LDR.W    R3,??DataTable42_1
        LDR.W    R6,??DataTable42
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+3
        MLA      R3,R7,R6,R3
        LDRB     R3,[R3, #-6]
        ADDS     R2,R3,R2
        SUBW     R2,R2,#+505
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable42_3
        LDR.W    R6,??DataTable42
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+250
        MLA      R3,R7,R6,R3
        LDR.W    R6,??DataTable42_1
        LDR.W    R7,??DataTable42
        LDRB     R7,[R7, #+0]
        MOVS     R12,#+3
        MLA      R6,R12,R7,R6
        LDRB     R6,[R6, #-6]
        ADDS     R3,R6,R3
        SUBS     R3,R3,#+506
        LDRB     R3,[R3, #+0]
        UXTAB    R2,R3,R2
        LDR.W    R3,??DataTable42_3
        LDR.W    R6,??DataTable42
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+250
        MLA      R3,R7,R6,R3
        LDR.W    R6,??DataTable42_1
        LDR.W    R7,??DataTable42
        LDRB     R7,[R7, #+0]
        MOVS     R12,#+3
        MLA      R6,R12,R7,R6
        LDRB     R6,[R6, #-6]
        ADDS     R3,R6,R3
        SUBW     R3,R3,#+507
        LDRB     R3,[R3, #+0]
        UXTAB    R2,R2,R3
        LDR.W    R3,??DataTable42_3
        LDR.W    R6,??DataTable42
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+250
        MLA      R3,R7,R6,R3
        LDR.W    R6,??DataTable42_1
        LDR.W    R7,??DataTable42
        LDRB     R7,[R7, #+0]
        MOVS     R12,#+3
        MLA      R6,R12,R7,R6
        LDRB     R6,[R6, #-6]
        ADDS     R3,R6,R3
        SUBS     R3,R3,#+508
        LDRB     R3,[R3, #+0]
        UXTAB    R2,R2,R3
        LDR.W    R3,??DataTable42_3
        LDR.N    R6,??DataTable42
        LDRB     R6,[R6, #+0]
        MOVS     R7,#+250
        MLA      R3,R7,R6,R3
        LDR.N    R6,??DataTable42_1
        LDR.N    R7,??DataTable42
        LDRB     R7,[R7, #+0]
        MOVS     R12,#+3
        MLA      R6,R12,R7,R6
        LDRB     R6,[R6, #-6]
        ADDS     R3,R6,R3
        SUBW     R3,R3,#+509
        LDRB     R3,[R3, #+0]
        UXTAB    R2,R2,R3
        MOVS     R3,#+5
        SDIV     R6,R2,R3
// 6529           
// 6530           //最后一步，确认两者的白色点的平均值差别非常小。  /////////////////////此时若地板为浅色或者白色，就挂了。
// 6531           if(AbsInt(avgr1 - avgl1) < 15 && AbsInt(avgr2 - avgl2) < 15)
        SUBS     R0,R0,R1
        BL       AbsInt
        CMP      R0,#+15
        BGE.N    ??BlackSingleSpeCheck_13
        SUBS     R0,R5,R6
        BL       AbsInt
        CMP      R0,#+15
        BGE.N    ??BlackSingleSpeCheck_13
// 6532           {
// 6533             BlackSingleFlag = 1;        //单线错误标志置位。
        MOVS     R0,#+1
        LDR.N    R1,??DataTable42_4
        STRB     R0,[R1, #+0]
// 6534             BlackSingleDir = 1;         //表示是右线悬空的情况。
        MOVS     R0,#+1
        LDR.N    R1,??DataTable42_5
        STRB     R0,[R1, #+0]
// 6535           }
// 6536           else
// 6537           {
// 6538           }
// 6539         }
// 6540         else
// 6541         {
// 6542         }
// 6543       }
// 6544       else
// 6545       {
// 6546       }
// 6547       
// 6548       //查看单线错误标志
// 6549       if(BlackSingleFlag == 1)
??BlackSingleSpeCheck_13:
        LDR.N    R0,??DataTable42_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackSingleSpeCheck_0
// 6550       {
// 6551         //确定是单线错误后，先把左黑线全置无效值。
// 6552         for(i = 0; ; i++)
        MOVS     R5,#+0
        B.N      ??BlackSingleSpeCheck_14
??BlackSingleSpeCheck_15:
        ADDS     R5,R5,#+1
// 6553         {
// 6554           BlackLeftLoc[i][0] = MaxValUint8;           
??BlackSingleSpeCheck_14:
        MOVS     R0,#+255
        LDR.N    R1,??DataTable41_3
        MOVS     R2,#+3
        MLA      R1,R2,R5,R1
        STRB     R0,[R1, #+0]
// 6555           if(i == CameraHight - 1) break;
        CMP      R5,#+59
        BNE.N    ??BlackSingleSpeCheck_15
// 6556         }
// 6557         
// 6558         index1 = 0;
        MOVS     R7,#+0
// 6559         //然后从右线尾所在行开始开窗扫右线，一直到左线头所在行或者有未采到的行。
// 6560         for(i = BlackRightStep1ScanRow; ; i--)
        LDR.N    R0,??DataTable42
        LDRB     R5,[R0, #+0]
        B.N      ??BlackSingleSpeCheck_16
??BlackSingleSpeCheck_17:
        SUBS     R5,R5,#+1
// 6561         {
// 6562           temp1 = BlackGetLeftJustWin(i, 
// 6563                                       BlackRightLoc[i][0], //最多最多跨过15列，所以20列应该够。
// 6564                                       BlackRightLoc[i][0] + SingleBlackWidthMax[i]);            
??BlackSingleSpeCheck_16:
        LDR.N    R0,??DataTable42_1
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable42_2
        LDRB     R1,[R5, R1]
        ADDS     R2,R1,R0
        LDR.N    R0,??DataTable42_1
        MOVS     R1,#+3
        MLA      R0,R1,R5,R0
        LDRB     R1,[R0, #+0]
        MOVS     R0,R5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackGetLeftJustWin
        MOVS     R6,R0
// 6565           if(temp1 != MaxValUint8)
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+255
        BEQ.N    ??BlackSingleSpeCheck_18
// 6566           {
// 6567             //该行扫描左黑线成功
// 6568             BlackLeftLoc[i][0] = temp1 - 1 - BlackLeftEdgeNum;
        SUBS     R0,R6,#+4
        LDR.N    R1,??DataTable41_3
        MOVS     R2,#+3
        MLA      R1,R2,R5,R1
        STRB     R0,[R1, #+0]
// 6569             //记录左黑线扫描成功的最近行。
// 6570             if(index1 == 0)
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BNE.N    ??BlackSingleSpeCheck_19
// 6571             {
// 6572               tempstep1row = i;
        MOVS     R4,R5
// 6573               index1++;
        ADDS     R7,R7,#+1
// 6574             }
// 6575             else
// 6576             {
// 6577             }
// 6578           }
// 6579           else
// 6580           {
// 6581             //一旦没有采到，再远的行就不要了，直接退出。
// 6582             break;
// 6583           }
// 6584           //到右线头了，退出
// 6585           if(i == BlackRightHeadLine) break;
??BlackSingleSpeCheck_19:
        LDR.W    R0,??DataTable43
        LDRB     R0,[R0, #+0]
        CMP      R5,R0
        BNE.N    ??BlackSingleSpeCheck_17
// 6586         }
// 6587         
// 6588         //检测不到有效左黑线，返回失败。
// 6589         if(tempstep1row == MaxValUint8) return 0;
??BlackSingleSpeCheck_20:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+255
        BNE.N    ??BlackSingleSpeCheck_21
        MOVS     R0,#+0
        B.N      ??BlackSingleSpeCheck_11
??BlackSingleSpeCheck_18:
        B.N      ??BlackSingleSpeCheck_20
// 6590          
// 6591         //往远几行开始，向后补线。第2个输入参数是1。
// 6592         //不管右线之间的向后补线是否成功，都要放远几个点重新向后补一次
// 6593         if(BlackRightStep4BackLine(BlackRightStep1ScanRow - 2, 1) == 1 && BlackLeftStep4BackLine(tempstep1row - 2, 1) == 1)
??BlackSingleSpeCheck_21:
        MOVS     R1,#+1
        LDR.N    R0,??DataTable42
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackRightStep4BackLine
        CMP      R0,#+1
        BNE.N    ??BlackSingleSpeCheck_22
        MOVS     R1,#+1
        SUBS     R0,R4,#+2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BlackLeftStep4BackLine
        CMP      R0,#+1
        BEQ.N    ??BlackSingleSpeCheck_0
// 6594         {
// 6595         }
// 6596         else
// 6597         {
// 6598           //如果补线没有成功（有可能是点太少），那就直接返回失败，这幅图像直接判定为失败。
// 6599           return 0;
??BlackSingleSpeCheck_22:
        MOVS     R0,#+0
        B.N      ??BlackSingleSpeCheck_11
// 6600         }           
// 6601         
// 6602         //置单线标志位SingleBlackAllFlag(用于CenterLineGet)。     
// 6603         //SingleBlackAllFlag = 1;
// 6604         
// 6605       }
// 6606       //单线错误标志没有置位，不用作任何处理。
// 6607       else
// 6608       {
// 6609       }
// 6610     }
// 6611     else
// 6612     {
// 6613     }
// 6614   }
// 6615   else
// 6616   {
// 6617   }
// 6618   
// 6619   return 1;
??BlackSingleSpeCheck_0:
        MOVS     R0,#+1
??BlackSingleSpeCheck_11:
        POP      {R1,R4-R7,PC}    ;; return
// 6620 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41:
        DC32     BrickSpeDealFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_1:
        DC32     BrickSpeDealDir

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_2:
        DC32     BlackGetPreDir

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_3:
        DC32     BlackLeftLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_4:
        DC32     BlackLeftDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_5:
        DC32     BlackRightDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_6:
        DC32     BlackLeftStep1ScanRow
// 6621  
// 6622 
// 6623 
// 6624 
// 6625 //大跳变最终检测，基本上是针对直角黑块斜入。
// 6626 //返回1表示检测到大跳变，0表示没有检测到或没必要检测。 
// 6627 //有FLASH烧写进来的开关控制，如果发现比赛赛道的直角黑块基本没有斜入的情况，那就关掉。
// 6628 //直角黑块误判
// 6629 //1. 5Slope数组，同号（左线同为负号，右线同为正号），但相差大于等于2500。
// 6630 //   离直角黑块比较近的时候，一般相差3000及以上，但离得比较远的时候，有可能相差2500。
// 6631 //2. 在5SlopeRow数组里可以找到相应的行，从该行（比如说是第13行），则最好把13、14、15、16（17）都删掉。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 6632 uint8 BlackBigChangeFinalCheck(void)
// 6633 {
// 6634   //BlackLeft5Slope[]数组和BlackLeft5SlopeRow[]数组的下标为0~BlackLeft5SlopeIndex-1
// 6635   //普通的BigChange中，出错的阈值是BlackLeftBigChangeSlopeLimit=4000左右（不是绝对值之差，就是两数之差）。
// 6636   uint8 i, row;
// 6637   uint8 tempend1, tempend2;
// 6638   
// 6639   return 0;         //不需要这个检测了，所以关闭
BlackBigChangeFinalCheck:
        MOVS     R0,#+0
        BX       LR               ;; return
// 6640   
// 6641   //1. 要求两线都成功
// 6642   if(BlackLeftDone == 1 && BlackRightDone == 1)
// 6643   {
// 6644   }
// 6645   else
// 6646   {
// 6647     return 0;
// 6648   }
// 6649   
// 6650   //2. 要求线头必须都在最近行。
// 6651   //左线开始扫描时
// 6652   if(BlackGetPreDir == 0 || BlackGetPreDir == 2)
// 6653   {
// 6654     if(BlackLeftStep1ScanRow == CameraHight - 1 && BlackRightStep1ScanRow >= CameraHight - 5)
// 6655     {
// 6656     }
// 6657     else
// 6658     {
// 6659       //线头太高，不用检测大跳变错误。
// 6660       return 0;
// 6661     }
// 6662   }
// 6663   //右线开始扫描时
// 6664   else
// 6665   {
// 6666     if(BlackRightStep1ScanRow == CameraHight - 1 && BlackLeftStep1ScanRow >= CameraHight - 5)
// 6667     {
// 6668     }
// 6669     else
// 6670     {
// 6671       //线头太高，不用检测大跳变错误。
// 6672       return 0;
// 6673     }    
// 6674   }
// 6675   
// 6676   //左线
// 6677   //左线出现直角黑块的大跳变，左线一定是右上到左下。斜率一定是负的。
// 6678   if(SlopeL < 0 && BlackLeftEndLine - BlackLeftHeadLine - 5 > 0 && BlackLeft5SlopeIndex - 2 > 0)
// 6679   {
// 6680     //5Slope数组有可能已经删掉了一些黑点，所以也要参考实际的有效黑点数。
// 6681     tempend1 = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 5, BlackLeft5SlopeIndex - 2);
// 6682     //轮询5Slope数组
// 6683     for(i = 0; ; i++)
// 6684     {
// 6685       //左线的直角黑块误判都是负号。
// 6686       if(
// 6687         (BlackLeft5Slope[i] < 0)
// 6688       &&(BlackLeft5Slope[i+1] < 0)
// 6689       &&(BlackLeft5Slope[i] - BlackLeft5Slope[i+1] >= BlackBigChangeFinalCheckSlopeLimit)     //i+1比i小2500以上。不能是">"
// 6690         )
// 6691       {
// 6692         //检测到直角黑块大跳变，跳出。
// 6693         break;
// 6694       }
// 6695       else
// 6696       {      
// 6697       }
// 6698       
// 6699       //到数组最后一个，跳出。
// 6700       if(i == tempend1) break;
// 6701     }
// 6702     
// 6703     //检测到直角黑块大跳变。
// 6704     if(i != tempend1)
// 6705     {
// 6706       //要删掉4行，至少要有4行。
// 6707       if(i > 4)
// 6708       {
// 6709         row = BlackLeft5SlopeRow[i+1] + 3;
// 6710         //十字检测未进入或失败时，是需要检测最终大跳变的。
// 6711         //若十字检测成功，且row在第1段黑线真实结束行的远处时，不需要检测，防止因十字补线带来的斜率突变。
// 6712         if(BlackLeftCrossDone == 2 && row < BlackLeftRow1RealLastLine)
// 6713         {
// 6714           //返回不需要检测
// 6715           return 0;
// 6716         }
// 6717         else
// 6718         {
// 6719         }
// 6720         
// 6721         //删掉从倒退4行开始的往远处的所有行。
// 6722         for(; ; row--)
// 6723         {
// 6724           BlackLeftLoc[row][0] = MaxValUint8;
// 6725           
// 6726           if(row == 0) break;
// 6727         }
// 6728   
// 6729         //置标志位。左线最终大跳变。
// 6730         BlackBigChangeFinalCheckFlag = 1;
// 6731         //返回1检测成功。
// 6732         return 1;
// 6733       }
// 6734       else
// 6735       {     
// 6736       }
// 6737     }
// 6738     //没检测到直角黑块大跳变，不作任何处理。
// 6739     else
// 6740     {    
// 6741     }
// 6742   }
// 6743   else
// 6744   {
// 6745   }
// 6746   
// 6747   //右线
// 6748   //右线出现直角黑块的大跳变，右线一定是左上到右下。斜率一定是正的。
// 6749   if(SlopeR > 0 && BlackRightEndLine - BlackRightHeadLine - 5 > 0 && BlackRight5SlopeIndex - 2 > 0)
// 6750   {
// 6751     //5Slope数组有可能已经删掉了一些黑点，所以也要参考实际的有效黑点数。
// 6752     tempend2 = MinRe(BlackRightEndLine - BlackRightHeadLine - 5, BlackRight5SlopeIndex - 2);
// 6753     //轮询5Slope数组
// 6754     for(i = 0; ; i++)
// 6755     {
// 6756       //右线的直角黑块误判都是正号。
// 6757       if(
// 6758         (BlackRight5Slope[i] > 0)
// 6759       &&(BlackRight5Slope[i+1] > 0)
// 6760       &&(BlackRight5Slope[i+1] - BlackRight5Slope[i] >= BlackBigChangeFinalCheckSlopeLimit)     //i+1比i大2500以上。不能是">"
// 6761         )
// 6762       {
// 6763         //检测到直角黑块大跳变，跳出。
// 6764         break;
// 6765       }
// 6766       else
// 6767       {      
// 6768       }
// 6769       
// 6770       //到数组最后一个，跳出。
// 6771       if(i == tempend2) break;
// 6772     }
// 6773     
// 6774     //检测到直角黑块大跳变。
// 6775     if(i != tempend2)
// 6776     {
// 6777       //要删掉4行，至少要有4行。
// 6778       if(i > 4)
// 6779       {        
// 6780         row = BlackRight5SlopeRow[i+1] + 3;
// 6781         //十字检测未进入或失败时，是需要检测最终大跳变的。
// 6782         //若十字检测成功，且row在第1段黑线真实结束行的远处时，不需要检测，防止因十字补线带来的斜率突变。
// 6783         if(BlackRightCrossDone == 2 && row < BlackRightRow1RealLastLine)
// 6784         {
// 6785           //返回不需要检测
// 6786           return 0;
// 6787         }
// 6788         else
// 6789         {
// 6790         }
// 6791         
// 6792         //删掉从倒退4行开始的往远处的所有行。
// 6793         for(; ; row--)
// 6794         {
// 6795           BlackRightLoc[row][0] = MaxValUint8;
// 6796           
// 6797           if(row == 0) break;
// 6798         }
// 6799         
// 6800         //置标志位。右线最终大跳变。
// 6801         BlackBigChangeFinalCheckFlag = 2;
// 6802         //返回1检测成功。      
// 6803         return 1;
// 6804       }
// 6805       else
// 6806       {     
// 6807       }
// 6808     }
// 6809     //没检测到直角黑块大跳变，不作任何处理。
// 6810     else
// 6811     {    
// 6812     }  
// 6813   }
// 6814   else
// 6815   {
// 6816   }
// 6817   
// 6818   //常态为0，即没检测到或没必要检测
// 6819   return 0;
// 6820 }
// 6821 
// 6822 
// 6823 ////斜入直角黑块
// 6824 ////返回1表示检测到，0表示没有检测到。
// 6825 //uint8 BlackAngleZoneSpeCheck(void)
// 6826 //{
// 6827 //  uint8 temp1, temp2, i;
// 6828 //  
// 6829 //  //先检测右边有没有斜入的直角黑块。
// 6830 //  //1. 初步检测
// 6831 //  if(
// 6832 //    (BlackLeftDone == 1 && BlackRightDone == 1)
// 6833 //  &&(SlopeL + 3000 < 0)
// 6834 //  &&(SlopeR > 0)
// 6835 //  &&(CURVEL > 0)
// 6836 //  &&(CURVER < 0)
// 6837 //  &&(BlackGetPreDir == 0)
// 6838 //  &&(BlackLeftStep1ScanRow == CameraHight - 1)
// 6839 //  &&(AbsInt(BlackLeftHeadLine - BlackRightHeadLine) < 5)
// 6840 //    )
// 6841 //  {
// 6842 //    //2. 左线头之前的5Slope均为负
// 6843 //    //左线
// 6844 //    //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
// 6845 //    if(BlackLeftEndLine - BlackLeftHeadLine - 4 < 0 || BlackLeft5SlopeIndex - 1 < 0)
// 6846 //    {
// 6847 //      return 0;
// 6848 //    }
// 6849 //    else
// 6850 //    {        
// 6851 //    }
// 6852 //    temp1 = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 4, BlackLeft5SlopeIndex - 1);
// 6853 //    
// 6854 //    //逐个判断小5点斜率是否满足条件
// 6855 //    for(i = 0; ; i++)
// 6856 //    {
// 6857 //      if(BlackLeft5Slope[i] > 0) //一旦有正的，马上返回失败。
// 6858 //      {
// 6859 //        return 0;
// 6860 //      }
// 6861 //
// 6862 //      if(i == temp1) break;
// 6863 //    }
// 6864 //    //3. 右线头之前的5Slope均为正
// 6865 //    //右线
// 6866 //    //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
// 6867 //    if(BlackRightEndLine - BlackRightHeadLine - 4 < 0 || BlackRight5SlopeIndex - 1 < 0)
// 6868 //    {
// 6869 //      return 0;
// 6870 //    }
// 6871 //    else
// 6872 //    {        
// 6873 //    }
// 6874 //    temp2 = MinRe(BlackRightEndLine - BlackRightHeadLine - 4, BlackRight5SlopeIndex - 1);
// 6875 //    
// 6876 //    //逐个判断小5点斜率是否满足条件
// 6877 //    for(i = 0; ; i++)
// 6878 //    {
// 6879 //      if(BlackRight5Slope[i] < 0) //一旦有负的，马上返回失败。
// 6880 //      {
// 6881 //        return 0;
// 6882 //      }
// 6883 //
// 6884 //      if(i == temp2) break;
// 6885 //    }
// 6886 //    //4. 存在有行的宽度很小。
// 6887 //    temp1 = MinRe(BlackLeftEndLine, BlackRightEndLine);   //尾
// 6888 //    temp2 = MaxRe(BlackLeftHeadLine, BlackRightHeadLine); //头
// 6889 //    if(temp1 < temp2) 
// 6890 //    {
// 6891 //      return 0;
// 6892 //    }
// 6893 //    else
// 6894 //    {
// 6895 //      for(i = temp1; ; i--)
// 6896 //      {
// 6897 //        if(BlackRightLoc[i][0] - BlackLeftLoc[i][0] < 80) break;
// 6898 //        
// 6899 //        if(i == temp2) break;
// 6900 //      }
// 6901 //      
// 6902 //      //确认存在宽度很小的行
// 6903 //      if(i != temp2)
// 6904 //      {
// 6905 //        BlackAngleZoneSpeCheckFlag = 1; //标志位
// 6906 //        BlackAngleZoneSpeCheckDir = 1;  //右边有这样的情况
// 6907 //        return 1;
// 6908 //      }
// 6909 //      else
// 6910 //      {
// 6911 //      }
// 6912 //    }
// 6913 //  }
// 6914 //  //右边没有斜入的黑块，接着检测左边有没有斜入的黑块。
// 6915 //  else
// 6916 //  {
// 6917 //  }
// 6918 //  
// 6919 //
// 6920 //  //先检测左边有没有斜入的直角黑块。
// 6921 //  //1. 初步检测
// 6922 //  if(
// 6923 //    (BlackLeftDone == 1 && BlackRightDone == 1)
// 6924 //  &&(SlopeL < 0)
// 6925 //  &&(SlopeR > 3000)
// 6926 //  &&(CURVEL > 0)
// 6927 //  &&(CURVER < 0)
// 6928 //  &&(BlackRightStep1ScanRow >= CameraHight - 5)
// 6929 //  &&(AbsInt(BlackLeftHeadLine - BlackRightHeadLine) < 5)
// 6930 //    )
// 6931 //  {
// 6932 //    //2. 左线头之前的5Slope均为负
// 6933 //    //左线
// 6934 //    //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
// 6935 //    if(BlackLeftEndLine - BlackLeftHeadLine - 4 < 0 || BlackLeft5SlopeIndex - 1 < 0)
// 6936 //    {
// 6937 //      return 0;
// 6938 //    }
// 6939 //    else
// 6940 //    {        
// 6941 //    }
// 6942 //    temp1 = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 4, BlackLeft5SlopeIndex - 1);
// 6943 //    
// 6944 //    //逐个判断小5点斜率是否满足条件
// 6945 //    for(i = 0; ; i++)
// 6946 //    {
// 6947 //      if(BlackLeft5Slope[i] > 0) //一旦有正的，马上返回失败。
// 6948 //      {
// 6949 //        return 0;
// 6950 //      }
// 6951 //
// 6952 //      if(i == temp1) break;
// 6953 //    }
// 6954 //    //3. 右线头之前的5Slope均为正
// 6955 //    //右线
// 6956 //    //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
// 6957 //    if(BlackRightEndLine - BlackRightHeadLine - 4 < 0 || BlackRight5SlopeIndex - 1 < 0)
// 6958 //    {
// 6959 //      return 0;
// 6960 //    }
// 6961 //    else
// 6962 //    {        
// 6963 //    }
// 6964 //    temp2 = MinRe(BlackRightEndLine - BlackRightHeadLine - 4, BlackRight5SlopeIndex - 1);
// 6965 //    
// 6966 //    //逐个判断小5点斜率是否满足条件
// 6967 //    for(i = 0; ; i++)
// 6968 //    {
// 6969 //      if(BlackRight5Slope[i] < 0) //一旦有负的，马上返回失败。
// 6970 //      {
// 6971 //        return 0;
// 6972 //      }
// 6973 //
// 6974 //      if(i == temp2) break;
// 6975 //    }
// 6976 //    //4. 存在有行的宽度很小。
// 6977 //    temp1 = MinRe(BlackLeftEndLine, BlackRightEndLine);   //尾
// 6978 //    temp2 = MaxRe(BlackLeftHeadLine, BlackRightHeadLine); //头
// 6979 //    if(temp1 < temp2) 
// 6980 //    {
// 6981 //      return 0;
// 6982 //    }
// 6983 //    else
// 6984 //    {
// 6985 //      for(i = temp1; ; i--)
// 6986 //      {
// 6987 //        if(BlackRightLoc[i][0] - BlackLeftLoc[i][0] < 80) break;
// 6988 //        
// 6989 //        if(i == temp2) break;
// 6990 //      }
// 6991 //      
// 6992 //      //确认存在宽度很小的行
// 6993 //      if(i != temp2)
// 6994 //      {
// 6995 //        BlackAngleZoneSpeCheckFlag = 1; //标志位
// 6996 //        BlackAngleZoneSpeCheckDir = 0;  //左边有这样的情况
// 6997 //        return 1;
// 6998 //      }
// 6999 //      else
// 7000 //      {
// 7001 //      }
// 7002 //    }
// 7003 //  }
// 7004 //  //右边没有斜入的黑块，接着检测左边有没有斜入的黑块。
// 7005 //  else
// 7006 //  {
// 7007 //  }
// 7008 //  
// 7009 //  
// 7010 //  //常态为没检测到。
// 7011 //  return 0;
// 7012 //}
// 7013 
// 7014 
// 7015 
// 7016 //======================================================================
// 7017 //函数名：BlackGet
// 7018 //功  能：黑线提取程序
// 7019 //参  数：无
// 7020 //返  回：1成功 0失败
// 7021 //影  响：见具体的左、右黑线算法
// 7022 //说  明：1. 学长的黑线提取算法有很多输入参数，用以对不同环境下的黑线进行提取，可以效仿
// 7023 //        2. 左右黑线分开提取，但右黑线提取的起始点以左黑线提取的结果为准（前提是左黑线提取成功）。
// 7024 //        3. 为了防止光线的突变，左右黑线各有2次机会，第2次机会将会把3个关键值赋成原始值再试一次。
// 7025 //           如果不是光线的原因，3个关键值会变回来。
// 7026 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 7027 uint8 BlackGet(void)
// 7028 {
BlackGet:
        PUSH     {R7,LR}
// 7029     uint8 i;
// 7030     uint8 tempBlackAngleZoneSpeCheck;       //斜入直角黑块储存位
// 7031     uint8 tempBlackBigChangeFinalCheck; //最终大跳变检测储存位。
// 7032     uint8 tempBlackSingleSpeCheck;      //单线错误检测储存位。
// 7033     //uint8 tempLWB, tempLW, tempLB;
// 7034     //uint8 tempRWB, tempRW, tempRB;
// 7035 
// 7036     //黑线提取预处理。决定先扫描哪条线
// 7037     BlackGetPre();    
        BL       BlackGetPre
// 7038     
// 7039     //预处理左线头成功或左右线头均失败时，从左线开始扫描。
// 7040     if(BlackGetPreDir == 0 || BlackGetPreDir == 2)
        LDR.W    R0,??DataTable43_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??BlackGet_0
        LDR.W    R0,??DataTable43_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BNE.N    ??BlackGet_1
// 7041     {
// 7042       //左黑线提取，成功则返回1，失败则返回0.
// 7043       if(BlackGetLeft() == 0)
??BlackGet_0:
        BL       BlackGetLeft
        CMP      R0,#+0
        BNE.N    ??BlackGet_2
// 7044       {
// 7045         BlackLeftDone = 0;                  //左黑线提取失败
        MOVS     R0,#+0
        LDR.W    R1,??DataTable43_2
        STRB     R0,[R1, #+0]
// 7046         BlackLeftHeadLine = MaxValUint8;    //左线头置无效值。
        MOVS     R0,#+255
        LDR.N    R1,??DataTable42_6
        STRB     R0,[R1, #+0]
// 7047         BlackLeftEndLine = MaxValUint8;    //左线尾置无效值。
        MOVS     R0,#+255
        LDR.W    R1,??DataTable43_3
        STRB     R0,[R1, #+0]
        B.N      ??BlackGet_3
// 7048       }
// 7049       else
// 7050       {
// 7051         //先进行左黑线连续性补线
// 7052         BlackLeftContinueAdd();
??BlackGet_2:
        BL       BlackLeftContinueAdd
// 7053         //再进行左黑线线头线尾查找
// 7054         BlackLeftHeadEndSearch();
        BL       BlackLeftHeadEndSearch
// 7055   
// 7056       }    
// 7057       
// 7058       //右黑线提取，成功则返回1，失败则返回0.
// 7059       //如果是右障碍特殊处理，则右黑线函数不用执行，直接置为失败。
// 7060       if(
// 7061         (BrickSpeDealFlag == 1 && BrickSpeDealDir == 1)
// 7062       ||(BlackGetRight() == 0)
// 7063         )
??BlackGet_3:
        LDR.W    R0,??DataTable43_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackGet_4
        LDR.W    R0,??DataTable43_5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??BlackGet_5
??BlackGet_4:
        BL       BlackGetRight
        CMP      R0,#+0
        BNE.N    ??BlackGet_6
// 7064       {
// 7065         BlackRightDone = 0;                  //右黑线提取失败
??BlackGet_5:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable43_6
        STRB     R0,[R1, #+0]
// 7066         BlackRightHeadLine = MaxValUint8;    //右线头置无效值。      
        MOVS     R0,#+255
        LDR.W    R1,??DataTable43
        STRB     R0,[R1, #+0]
        B.N      ??BlackGet_7
// 7067       }
// 7068       else
// 7069       {
// 7070         //先进行右黑线连续性补线
// 7071         BlackRightContinueAdd();
??BlackGet_6:
        BL       BlackRightContinueAdd
// 7072         //再进行右黑线线头线尾查找
// 7073         BlackRightHeadEndSearch();
        BL       BlackRightHeadEndSearch
        B.N      ??BlackGet_7
// 7074       }
// 7075     }
// 7076     //右线头成功，从右线开始扫描。
// 7077     else
// 7078     {
// 7079       //右黑线提取，成功则返回1，失败则返回0.
// 7080       if(BlackGetRight() == 0)
??BlackGet_1:
        BL       BlackGetRight
        CMP      R0,#+0
        BNE.N    ??BlackGet_8
// 7081       {
// 7082         BlackRightDone = 0;                  //右黑线提取失败
        MOVS     R0,#+0
        LDR.W    R1,??DataTable43_6
        STRB     R0,[R1, #+0]
// 7083         BlackRightHeadLine = MaxValUint8;    //右线头置无效值。      
        MOVS     R0,#+255
        LDR.W    R1,??DataTable43
        STRB     R0,[R1, #+0]
        B.N      ??BlackGet_9
// 7084       }
// 7085       else
// 7086       {
// 7087         //先进行右黑线连续性补线
// 7088         BlackRightContinueAdd();
??BlackGet_8:
        BL       BlackRightContinueAdd
// 7089         //再进行右黑线线头线尾查找
// 7090         BlackRightHeadEndSearch();
        BL       BlackRightHeadEndSearch
// 7091       }
// 7092       
// 7093       //左黑线提取，成功则返回1，失败则返回0.
// 7094       //如果是左障碍特殊处理，则左黑线函数不用执行，直接置为失败。
// 7095       if(
// 7096         (BrickSpeDealFlag == 1 && BrickSpeDealDir == 0)
// 7097       ||(BlackGetLeft() == 0)
// 7098         )
??BlackGet_9:
        LDR.W    R0,??DataTable43_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackGet_10
        LDR.W    R0,??DataTable43_5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??BlackGet_11
??BlackGet_10:
        BL       BlackGetLeft
        CMP      R0,#+0
        BNE.N    ??BlackGet_12
// 7099       {
// 7100         BlackLeftDone = 0;                  //左黑线提取失败
??BlackGet_11:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable43_2
        STRB     R0,[R1, #+0]
// 7101         BlackLeftHeadLine = MaxValUint8;    //左线头置无效值。
        MOVS     R0,#+255
        LDR.N    R1,??DataTable42_6
        STRB     R0,[R1, #+0]
// 7102         BlackLeftEndLine = MaxValUint8;    //左线尾置无效值。
        MOVS     R0,#+255
        LDR.W    R1,??DataTable43_3
        STRB     R0,[R1, #+0]
        B.N      ??BlackGet_7
// 7103       }
// 7104       else
// 7105       {
// 7106         //先进行左黑线连续性补线
// 7107         BlackLeftContinueAdd();
??BlackGet_12:
        BL       BlackLeftContinueAdd
// 7108         //再进行左黑线线头线尾查找
// 7109         BlackLeftHeadEndSearch();
        BL       BlackLeftHeadEndSearch
// 7110   
// 7111       }
// 7112     }
// 7113      
// 7114     //左、右黑线均提取失败，则黑线提取失败。
// 7115     if((BlackLeftDone == 0) && (BlackRightDone == 0))
??BlackGet_7:
        LDR.W    R0,??DataTable43_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??BlackGet_13
        LDR.W    R0,??DataTable43_6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??BlackGet_13
// 7116     {
// 7117       return 0;
        MOVS     R0,#+0
        B.N      ??BlackGet_14
// 7118     }
// 7119     else
// 7120     {
// 7121       //左右黑线畸变矫正
// 7122       BlackUdis();
??BlackGet_13:
        BL       BlackUdis
// 7123       
// 7124       //只要有一边成功就可以进来。
// 7125       //由于回弯要用到斜率，所以提前计算。
// 7126       //曲率、斜率求取的标志位，1成功，0失败。
// 7127       CurveSlopeFlagL = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable43_7
        STRB     R0,[R1, #+0]
// 7128       CurveSlopeFlagR = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable43_8
        STRB     R0,[R1, #+0]
// 7129       //左黑线的曲率、斜率的求取。  
// 7130       if(CurveSlopeGetLeft() == 0)
        BL       CurveSlopeGetLeft
        CMP      R0,#+0
        BNE.N    ??BlackGet_15
// 7131       {
// 7132         CurveSlopeFlagL = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable43_7
        STRB     R0,[R1, #+0]
// 7133         //uart_sendN(UART0, (uint8 *)"\nCurveSlopeGetLeft() Failed!", 28);
// 7134       }
// 7135       else
// 7136       {
// 7137       }
// 7138       
// 7139       //右黑线的曲率、斜率的求取。  
// 7140       if(CurveSlopeGetRight() == 0)
??BlackGet_15:
        BL       CurveSlopeGetRight
        CMP      R0,#+0
        BNE.N    ??BlackGet_16
// 7141       {
// 7142         CurveSlopeFlagR = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable43_8
        STRB     R0,[R1, #+0]
// 7143         //uart_sendN(UART0, (uint8 *)"\nCurveSlopeGetRight() Failed!", 29);
// 7144       }
// 7145       else
// 7146       {
// 7147       }
// 7148       
// 7149       //左线提取成功则进行左回弯检测
// 7150       if(BlackLeftDone == 1)
??BlackGet_16:
        LDR.W    R0,??DataTable43_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackGet_17
// 7151       {
// 7152         //左回弯特殊检测。
// 7153         if(BlackLeftRollCheck() == 0)
        BL       BlackLeftRollCheck
        CMP      R0,#+0
        BNE.N    ??BlackGet_17
// 7154         {
// 7155           BlackLeftRollCheckFlag = 1;         //检测到回弯。
        MOVS     R0,#+1
        LDR.W    R1,??DataTable43_9
        STRB     R0,[R1, #+0]
// 7156           BlackLeftDone = 0;                  //左黑线提取失败
        MOVS     R0,#+0
        LDR.W    R1,??DataTable43_2
        STRB     R0,[R1, #+0]
// 7157           //清除所有值。
// 7158           for(i = BlackLeftEndLine; ; i--)
        LDR.W    R0,??DataTable43_3
        LDRB     R0,[R0, #+0]
        B.N      ??BlackGet_18
??BlackGet_19:
        SUBS     R0,R0,#+1
// 7159           {
// 7160             BlackLeftLoc[i][0] = MaxValUint8;
??BlackGet_18:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable43_10
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 7161             if(i == BlackLeftHeadLine) break;
        LDR.N    R1,??DataTable42_6
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BNE.N    ??BlackGet_19
// 7162           }
// 7163           BlackLeftHeadLine = MaxValUint8;    //左线头置无效值。
        MOVS     R0,#+255
        LDR.N    R1,??DataTable42_6
        STRB     R0,[R1, #+0]
// 7164           BlackLeftEndLine = MaxValUint8;     //左线尾置无效值。
        MOVS     R0,#+255
        LDR.W    R1,??DataTable43_3
        STRB     R0,[R1, #+0]
// 7165         }
// 7166         else
// 7167         {
// 7168         }
// 7169       }
// 7170       //左线提取失败就不用进行左回弯检测了
// 7171       else
// 7172       {
// 7173       }
// 7174       
// 7175       //右线提取成功则进行右回弯检测
// 7176       if(BlackRightDone == 1)
??BlackGet_17:
        LDR.W    R0,??DataTable43_6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BlackGet_20
// 7177       {
// 7178         //右回弯特殊检测。
// 7179         if(BlackRightRollCheck() == 0)
        BL       BlackRightRollCheck
        CMP      R0,#+0
        BNE.N    ??BlackGet_20
// 7180         {
// 7181           BlackRightRollCheckFlag = 1;         //检测到回弯。
        MOVS     R0,#+1
        LDR.W    R1,??DataTable43_11
        STRB     R0,[R1, #+0]
// 7182           BlackRightDone = 0;                  //右黑线提取失败
        MOVS     R0,#+0
        LDR.W    R1,??DataTable43_6
        STRB     R0,[R1, #+0]
// 7183           //清除所有值。
// 7184           for(i = BlackRightEndLine; ; i--)
        LDR.W    R0,??DataTable43_12
        LDRB     R0,[R0, #+0]
        B.N      ??BlackGet_21
??BlackGet_22:
        SUBS     R0,R0,#+1
// 7185           {
// 7186             BlackRightLoc[i][0] = MaxValUint8;
??BlackGet_21:
        MOVS     R1,#+255
        LDR.N    R2,??DataTable42_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 7187             if(i == BlackRightHeadLine) break;
        LDR.W    R1,??DataTable43
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BNE.N    ??BlackGet_22
// 7188           }
// 7189           BlackRightHeadLine = MaxValUint8;    //右线头置无效值。
        MOVS     R0,#+255
        LDR.W    R1,??DataTable43
        STRB     R0,[R1, #+0]
// 7190           BlackRightEndLine = MaxValUint8;     //右线尾置无效值。
        MOVS     R0,#+255
        LDR.W    R1,??DataTable43_12
        STRB     R0,[R1, #+0]
// 7191         }
// 7192         else
// 7193         {
// 7194         }
// 7195       }
// 7196       //右线提取失败就不用进行右回弯检测了
// 7197       else
// 7198       {
// 7199       }
// 7200       
// 7201     }
// 7202     
// 7203     //若处在特殊赛道锁存或者特殊控制阶段，则不用进行大跳变最终检测 和 单线错误检测
// 7204     if(AngleConfirmLockFlag == 1 || AngleSpeDealFlag == 1 || BrickConfirmLockFlag == 1 || BrickSpeDealFlag == 1)
??BlackGet_20:
        LDR.W    R0,??DataTable43_13
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??BlackGet_23
        LDR.W    R0,??DataTable43_14
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??BlackGet_23
        LDR.W    R0,??DataTable43_15
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??BlackGet_23
        LDR.W    R0,??DataTable43_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??BlackGet_23
// 7205     {
// 7206     }
// 7207     else
// 7208     {
// 7209       //斜入直角黑块检测
// 7210       tempBlackAngleZoneSpeCheck = 0;
        MOVS     R1,#+0
// 7211 //      if(BlackAngleZoneSpeCheckSwitch == 1)
// 7212 //      {
// 7213 //        //1表示检测到斜入直角黑块，0表示没有检测到。
// 7214 //        tempBlackAngleZoneSpeCheck = BlackAngleZoneSpeCheck();
// 7215 //      }
// 7216 //      else
// 7217 //      {
// 7218 //      }
// 7219 
// 7220       //大跳变最终检测.
// 7221       tempBlackBigChangeFinalCheck = 0;
        MOVS     R0,#+0
// 7222       if(tempBlackAngleZoneSpeCheck == 0 && BlackBigChangeFinalCheckSwitch == 1)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??BlackGet_24
// 7223       {
// 7224         //1表示检测到，0表示没检测到。
// 7225         tempBlackBigChangeFinalCheck = BlackBigChangeFinalCheck();
        BL       BlackBigChangeFinalCheck
// 7226         //大跳变检测成功，重新找线头线尾，作畸变矫正，计算整条线的斜率、曲率，
// 7227         if(tempBlackBigChangeFinalCheck == 1)
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??BlackGet_24
// 7228         {
// 7229           //左黑线线头线尾查找
// 7230           BlackLeftHeadEndSearch();
        BL       BlackLeftHeadEndSearch
// 7231           //右黑线线头线尾查找
// 7232           BlackRightHeadEndSearch();
        BL       BlackRightHeadEndSearch
// 7233           
// 7234           //左右黑线畸变矫正
// 7235           BlackUdis();
        BL       BlackUdis
// 7236           
// 7237           //只要有一边成功就可以进来。
// 7238           //由于回弯要用到斜率，所以提前计算。
// 7239           //曲率、斜率求取的标志位，1成功，0失败。
// 7240           CurveSlopeFlagL = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable43_7
        STRB     R0,[R1, #+0]
// 7241           CurveSlopeFlagR = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable43_8
        STRB     R0,[R1, #+0]
// 7242           //左黑线的曲率、斜率的求取。  
// 7243           if(CurveSlopeGetLeft() == 0)
        BL       CurveSlopeGetLeft
        CMP      R0,#+0
        BNE.N    ??BlackGet_25
// 7244           {
// 7245             CurveSlopeFlagL = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable43_7
        STRB     R0,[R1, #+0]
// 7246             //uart_sendN(UART0, (uint8 *)"\nCurveSlopeGetLeft() Failed!", 28);
// 7247           }
// 7248           else
// 7249           {
// 7250           }
// 7251           
// 7252           //右黑线的曲率、斜率的求取。  
// 7253           if(CurveSlopeGetRight() == 0)
??BlackGet_25:
        BL       CurveSlopeGetRight
        CMP      R0,#+0
        BNE.N    ??BlackGet_24
// 7254           {
// 7255             CurveSlopeFlagR = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable43_8
        STRB     R0,[R1, #+0]
// 7256             //uart_sendN(UART0, (uint8 *)"\nCurveSlopeGetRight() Failed!", 29);
// 7257           }
// 7258           else
// 7259           {
// 7260           }          
// 7261         }
// 7262         else
// 7263         {
// 7264         }
// 7265       }
// 7266       else
// 7267       {        
// 7268       }
// 7269       
// 7270       if(tempBlackAngleZoneSpeCheck == 1 || tempBlackBigChangeFinalCheck == 1)
// 7271       {
// 7272         //前面的斜入直角黑块或大跳变已经检测成功了，就不用检测单线错误，两种针对的情况完全不同，关键在于线头线尾、畸变矫正、斜曲率计算最好不要重复，浪费时间。
// 7273       }
// 7274       /*
// 7275       else
// 7276       {
// 7277         //黑线检测最后一步，找单线错误。
// 7278         //单线错误比较差劲，出错了，这幅图就直接判定为错图。   
// 7279         tempBlackSingleSpeCheck = BlackSingleSpeCheck();
// 7280         if(tempBlackSingleSpeCheck == 0)
// 7281         {
// 7282           BlackLeftDone = 0;
// 7283           BlackLeftHeadLine = MaxValUint8;
// 7284           BlackLeftEndLine = MaxValUint8;
// 7285           BlackRightDone = 0;
// 7286           BlackRightHeadLine = MaxValUint8;
// 7287           BlackRightEndLine = MaxValUint8;          
// 7288           
// 7289           return 0;
// 7290         }
// 7291         else
// 7292         {
// 7293           //检测到了单线错误，重新找线头线尾，作畸变矫正，计算整条线的斜率、曲率，
// 7294           if(BlackSingleFlag == 1)
// 7295           {
// 7296             //左黑线线头线尾查找
// 7297             BlackLeftHeadEndSearch();
// 7298             //右黑线线头线尾查找
// 7299             BlackRightHeadEndSearch();
// 7300             
// 7301             //左右黑线畸变矫正
// 7302             BlackUdis();
// 7303             
// 7304             //只要有一边成功就可以进来。
// 7305             //由于回弯要用到斜率，所以提前计算。
// 7306             //曲率、斜率求取的标志位，1成功，0失败。
// 7307             CurveSlopeFlagL = 1;
// 7308             CurveSlopeFlagR = 1;
// 7309             //左黑线的曲率、斜率的求取。  
// 7310             if(CurveSlopeGetLeft() == 0)
// 7311             {
// 7312               CurveSlopeFlagL = 0;
// 7313               //uart_sendN(UART0, (uint8 *)"\nCurveSlopeGetLeft() Failed!", 28);
// 7314             }
// 7315             else
// 7316             {
// 7317             }
// 7318             
// 7319             //右黑线的曲率、斜率的求取。  
// 7320             if(CurveSlopeGetRight() == 0)
// 7321             {
// 7322               CurveSlopeFlagR = 0;
// 7323               //uart_sendN(UART0, (uint8 *)"\nCurveSlopeGetRight() Failed!", 29);
// 7324             }
// 7325             else
// 7326             {
// 7327             }
// 7328           }
// 7329           //没有检测到单线错误，不用作处理。
// 7330           else
// 7331           {
// 7332           }
// 7333         }
// 7334       }*/          
// 7335     }
// 7336 
// 7337     
// 7338     return 1;
??BlackGet_24:
??BlackGet_23:
        MOVS     R0,#+1
??BlackGet_14:
        POP      {R1,PC}          ;; return
// 7339 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable42:
        DC32     BlackRightStep1ScanRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable42_1:
        DC32     BlackRightLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable42_2:
        DC32     SingleBlackWidthMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable42_3:
        DC32     ImgNew

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable42_4:
        DC32     BlackSingleFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable42_5:
        DC32     BlackSingleDir

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable42_6:
        DC32     BlackLeftHeadLine
// 7340 
// 7341 
// 7342 //针对单线错误的中心线重新处理

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 7343 uint8 CenterLineGetSingleWrongAdd(void)
// 7344 {
CenterLineGetSingleWrongAdd:
        PUSH     {R4-R8,LR}
        SUB      SP,SP,#+16
// 7345   uint8 row, i;
// 7346   uint8 temp;
// 7347   uint8 flag1, flag2;
// 7348   uint8 tempflag1;
// 7349   uint8 tempway1;
// 7350   uint8 x[CenterForwardLineNum];   //中心线向前补线计算斜率时，x坐标，表示第几行。。
// 7351   int16 y[CenterForwardLineNum];   //中心线向前补线计算斜率时，y坐标，表示中心线位置。
// 7352   int32 a1, a0;    //中心线向前补线时，最小二乘法的斜率和纵截距。
// 7353   
// 7354   float slope;
// 7355   
// 7356   //中心线数组的重新初始化
// 7357   for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??CenterLineGetSingleWrongAdd_0
??CenterLineGetSingleWrongAdd_1:
        ADDS     R0,R0,#+1
// 7358   {
// 7359     CenterLineLoc[i] = MaxValInt16;
??CenterLineGetSingleWrongAdd_0:
        MOVW     R1,#+32767
        LDR.W    R2,??DataTable43_16
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRH     R1,[R2, R0, LSL #+1]
// 7360     if(i == CameraHight - 1) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??CenterLineGetSingleWrongAdd_1
// 7361   }
// 7362   
// 7363   //左线悬空，右线有效。
// 7364   if(RoadHalfWidthWrongDir == 0)
        LDR.W    R0,??DataTable43_17
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.W    ??CenterLineGetSingleWrongAdd_2
// 7365   {
// 7366     //若右线的线头线尾无效，则直接返回失败。
// 7367     if(BlackRightHeadLine == MaxValUint8 || BlackRightEndLine == MaxValUint8)
        LDR.W    R0,??DataTable43
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGetSingleWrongAdd_3
        LDR.W    R0,??DataTable43_12
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CenterLineGetSingleWrongAdd_4
// 7368     {
// 7369       return 0;
??CenterLineGetSingleWrongAdd_3:
        MOVS     R0,#+0
        B.N      ??CenterLineGetSingleWrongAdd_5
// 7370     }
// 7371     else
// 7372     {
// 7373     }
// 7374        
// 7375     flag1 = 1;
??CenterLineGetSingleWrongAdd_4:
        MOVS     R0,#+1
// 7376     flag2 = 1;
        MOVS     R0,#+1
// 7377     
// 7378     //中心线的线尾取左线的线尾即可。
// 7379     CenterHeadLine = BlackRightHeadLine;   //线头取左线的线头，注意这不是实际的线头。
        LDR.W    R0,??DataTable43
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable43_18
        STRB     R0,[R1, #+0]
// 7380     //CenterHeadLine = 0;                    //线头因为要固定补到第0行，所以直接置0.
// 7381     CenterEndLine = BlackRightEndLine;
        LDR.W    R0,??DataTable43_12
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable43_19
        STRB     R0,[R1, #+0]
// 7382     
// 7383     //首先看线头是否大于BlackControlLineLow行
// 7384     if(BlackRightHeadLine >= BlackControlLineLow)
        LDR.W    R0,??DataTable43
        LDRB     R0,[R0, #+0]
        CMP      R0,#+26
        BLT.N    ??CenterLineGetSingleWrongAdd_6
// 7385     {
// 7386       flag1 = 0;     
        MOVS     R0,#+0
// 7387     }
// 7388     else
// 7389     {
// 7390     }
// 7391     
// 7392     //右线尾小于CameraHight - 1行。
// 7393     if(BlackRightEndLine < CameraHight - 1)
??CenterLineGetSingleWrongAdd_6:
        LDR.W    R0,??DataTable43_12
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BGE.N    ??CenterLineGetSingleWrongAdd_7
// 7394     {
// 7395       //只有右线成功，而且右线尾还那么远，真心没法继续。直接返回失败。
// 7396       //if(BlackRightEndLine < CameraHight - 1 - BlackRightBackLineStart)
// 7397       if(BlackRightEndLine <= BlackControlLineLow)  
        LDR.W    R0,??DataTable43_12
        LDRB     R0,[R0, #+0]
        CMP      R0,#+27
        BGE.N    ??CenterLineGetSingleWrongAdd_7
// 7398       {
// 7399         flag2 = 0;
        MOVS     R0,#+0
// 7400         return 0;
        MOVS     R0,#+0
        B.N      ??CenterLineGetSingleWrongAdd_5
// 7401       }
// 7402       //右线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackRightEndLine。
// 7403       else
// 7404       {
// 7405       }
// 7406     }
// 7407     //右线尾等于CameraHight - 1，直接取BlackRightEndLine
// 7408     else
// 7409     {
// 7410     }
// 7411     
// 7412     //丢失另一根线的时候，先根据斜率估算出半宽，若没有上一次双线图像时的赛道半宽大，则直接用上一次双线的赛道半宽。
// 7413     //求5行的斜率。
// 7414     if(BlackRightEndLine - BlackRightHeadLine > 5)
??CenterLineGetSingleWrongAdd_7:
        LDR.W    R0,??DataTable43_12
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable43
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGetSingleWrongAdd_8
// 7415     {
// 7416       slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
// 7417                     (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
        LDR.W    R0,??DataTable43_20
        LDR.W    R1,??DataTable43_12
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??DataTable43_20
        LDR.W    R2,??DataTable43_12
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable43_21  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.W    R0,??DataTable43_20
        LDR.W    R1,??DataTable43_12
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.W    R1,??DataTable43_20
        LDR.W    R2,??DataTable43_12
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGetSingleWrongAdd_9
// 7418     }
// 7419     else
// 7420     {
// 7421       slope = 0;
??CenterLineGetSingleWrongAdd_8:
        MOVS     R0,#+0
// 7422     }
// 7423     //赛道半宽
// 7424     temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
??CenterLineGetSingleWrongAdd_9:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,#+0
        LDR.W    R3,??DataTable43_21  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable43_22  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
// 7425     //取最大值
// 7426     RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
        LDR.W    R1,??DataTable43_23
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       MaxRe
        LDR.W    R1,??DataTable43_23
        STRB     R0,[R1, #+0]
// 7427     
// 7428     tempflag1 = 0;
        MOVS     R4,#+0
// 7429     tempway1 = 0;
        MOVS     R5,#+0
// 7430     //根据赛道宽度估计出中心线的线头。
// 7431     CenterLineLoc[BlackRightEndLine] = BlackUdisRightLocation[BlackRightEndLine].x - RoadHalfWidth;
        LDR.W    R0,??DataTable43_20
        LDR.W    R1,??DataTable43_12
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??DataTable43_23
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable43_16
        LDR.W    R2,??DataTable43_12
        LDRB     R2,[R2, #+0]
        STRH     R0,[R1, R2, LSL #+1]
// 7432     //根据右线的走势估计出中心线。中心线是个int16型矩阵，有正负。
// 7433     for(row = BlackRightEndLine - 1; ;row--)
        LDR.W    R0,??DataTable43_12
        LDRB     R0,[R0, #+0]
        SUBS     R8,R0,#+1
        B.N      ??CenterLineGetSingleWrongAdd_10
??CenterLineGetSingleWrongAdd_11:
        SUBS     R8,R8,#+1
// 7434     {
// 7435       //右线有效时。根据右线的趋势补线。
// 7436       if(BlackRightLoc[row][0] != MaxValUint8)
??CenterLineGetSingleWrongAdd_10:
        LDR.W    R0,??DataTable43_24
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGetSingleWrongAdd_12
// 7437       {
// 7438         tempflag1 = 0;
        MOVS     R4,#+0
// 7439         CenterLineLoc[row] = CenterLineLoc[row+1] + BlackUdisRightLocation[row].x - BlackUdisRightLocation[row+1].x;
        LDR.W    R0,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R0,R0,R8, LSL #+1
        LDRH     R0,[R0, #+2]
        LDR.W    R1,??DataTable43_20
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R1,[R1, R8, LSL #+3]
        ADDS     R0,R1,R0
        LDR.W    R1,??DataTable43_20
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R1,R1,R8, LSL #+3
        LDR      R1,[R1, #+8]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGetSingleWrongAdd_13
// 7440       }
// 7441       //右线无效时。根据最后两行的中心线趋势补线。
// 7442       else
// 7443       {
// 7444           //当右线无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
// 7445           if(tempflag1 == 0)
??CenterLineGetSingleWrongAdd_12:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BNE.N    ??CenterLineGetSingleWrongAdd_14
// 7446           {
// 7447             //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
// 7448             tempflag1 = 1;
        MOVS     R4,#+1
// 7449             //最后几行行数够多，可以采用最小二乘法的方式。
// 7450             if(row + CenterForwardLineNum <= CameraHight - 1)
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R0,R8,#+4
        CMP      R0,#+60
        BGE.N    ??CenterLineGetSingleWrongAdd_15
// 7451             {
// 7452               tempway1 = 0;
        MOVS     R5,#+0
// 7453               //进行最小二乘法系数的计算。
// 7454               for(i = 0; i < CenterForwardLineNum; i++)
        MOVS     R0,#+0
        B.N      ??CenterLineGetSingleWrongAdd_16
// 7455               {
// 7456                 x[i] = row + i + 1;
??CenterLineGetSingleWrongAdd_17:
        ADDS     R1,R0,R8
        ADDS     R1,R1,#+1
        ADD      R2,SP,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 7457                 y[i] = CenterLineLoc[row + i + 1];
        LDR.W    R1,??DataTable43_16
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTAB    R2,R0,R8
        ADDS     R1,R1,R2, LSL #+1
        LDRH     R1,[R1, #+2]
        ADD      R2,SP,#+4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRH     R1,[R2, R0, LSL #+1]
// 7458               }
        ADDS     R0,R0,#+1
??CenterLineGetSingleWrongAdd_16:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+4
        BLT.N    ??CenterLineGetSingleWrongAdd_17
// 7459               a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a1
        MOVS     R6,R0
// 7460               a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
        MOVS     R3,#+4
        MOVS     R2,R6
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a0
        MOVS     R7,R0
        B.N      ??CenterLineGetSingleWrongAdd_14
// 7461             }
// 7462             //最后几行的行数不够多，采用最后两行趋势补线的方式。
// 7463             else
// 7464             {
// 7465               tempway1 = 1;
??CenterLineGetSingleWrongAdd_15:
        MOVS     R5,#+1
// 7466             }
// 7467           }
// 7468           else
// 7469           {
// 7470           }
// 7471         
// 7472           //确认补线方式后，开始补线。
// 7473           if(tempway1 == 0)
??CenterLineGetSingleWrongAdd_14:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??CenterLineGetSingleWrongAdd_18
// 7474           {
// 7475             //最小二乘法的方式。
// 7476             CenterLineLoc[row] = (a0 + a1 * row) / LeastSquareMulti;
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MLA      R0,R8,R6,R7
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGetSingleWrongAdd_13
// 7477           }
// 7478           else
// 7479           {
// 7480             //最近2行。
// 7481             if(row == CameraHight - 1 || row == CameraHight - 2)
??CenterLineGetSingleWrongAdd_18:
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+59
        BEQ.N    ??CenterLineGetSingleWrongAdd_19
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+58
        BNE.N    ??CenterLineGetSingleWrongAdd_20
// 7482             {
// 7483               CenterLineLoc[row] = BlackUdisRightLocation[row].x - RoadHalfWidth;
??CenterLineGetSingleWrongAdd_19:
        LDR.W    R0,??DataTable43_20
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R0,[R0, R8, LSL #+3]
        LDR.W    R1,??DataTable43_23
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGetSingleWrongAdd_13
// 7484             }
// 7485             //不是最近2行。
// 7486             else
// 7487             {
// 7488               //最后两行的方式。
// 7489               CenterLineLoc[row] = CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2];
??CenterLineGetSingleWrongAdd_20:
        LDR.N    R0,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R0,R0,R8, LSL #+1
        LDRH     R0,[R0, #+2]
        LDR.N    R1,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R1,R1,R8, LSL #+1
        LDRH     R1,[R1, #+2]
        ADDS     R0,R1,R0
        LDR.N    R1,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R1,R1,R8, LSL #+1
        LDRH     R1,[R1, #+4]
        SUBS     R0,R0,R1
        LDR.N    R1,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
// 7490             }
// 7491           }
// 7492         }
// 7493       
// 7494         if(row == 0) break;
??CenterLineGetSingleWrongAdd_13:
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+0
        BNE.W    ??CenterLineGetSingleWrongAdd_11
// 7495       }
// 7496     
// 7497       
// 7498     
// 7499     //对未处理的行的中心线置无效值。
// 7500     //底部置无效值。顶部不用处理。
// 7501     if(CenterEndLine != CameraHight - 1)
        LDR.N    R0,??DataTable43_19
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BEQ.W    ??CenterLineGetSingleWrongAdd_21
// 7502     {
// 7503       for(row = CameraHight - 1; ; row--)
        MOVS     R8,#+59
        B.N      ??CenterLineGetSingleWrongAdd_22
// 7504       {
// 7505         if(row == CenterEndLine) break;       
// 7506         CenterLineLoc[row] = MaxValInt16;
??CenterLineGetSingleWrongAdd_23:
        MOVW     R0,#+32767
        LDR.N    R1,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        SUBS     R8,R8,#+1
??CenterLineGetSingleWrongAdd_22:
        LDR.N    R0,??DataTable43_19
        LDRB     R0,[R0, #+0]
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,R0
        BNE.N    ??CenterLineGetSingleWrongAdd_23
        B.N      ??CenterLineGetSingleWrongAdd_21
// 7507       }
// 7508     }
// 7509     else
// 7510     {
// 7511     }
// 7512   }
// 7513   //右线悬空，左线有效。
// 7514   else
// 7515   {
// 7516     //若左线的线头线尾无效，则直接返回失败。
// 7517     if(BlackLeftHeadLine == MaxValUint8 || BlackLeftEndLine == MaxValUint8)
??CenterLineGetSingleWrongAdd_2:
        LDR.N    R0,??DataTable43_25
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGetSingleWrongAdd_24
        LDR.N    R0,??DataTable43_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CenterLineGetSingleWrongAdd_25
// 7518     {
// 7519       return 0;
??CenterLineGetSingleWrongAdd_24:
        MOVS     R0,#+0
        B.N      ??CenterLineGetSingleWrongAdd_5
// 7520     }
// 7521     else
// 7522     {
// 7523     }
// 7524     
// 7525     flag1 = 1;
??CenterLineGetSingleWrongAdd_25:
        MOVS     R0,#+1
// 7526     flag2 = 1;
        MOVS     R0,#+1
// 7527     
// 7528     //中心线的线尾取左线的线尾即可。
// 7529     CenterHeadLine = BlackLeftHeadLine;     //线头取左线的线头，注意这不是实际的线头。
        LDR.N    R0,??DataTable43_25
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable43_18
        STRB     R0,[R1, #+0]
// 7530     //CenterHeadLine = 0;   //线头因为要固定补到第0行，所以直接置0.
// 7531     CenterEndLine = BlackLeftEndLine;
        LDR.N    R0,??DataTable43_3
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable43_19
        STRB     R0,[R1, #+0]
// 7532     
// 7533     //首先看线头是否大于BlackControlLineLow行
// 7534     if(BlackLeftHeadLine >= BlackControlLineLow)
        LDR.N    R0,??DataTable43_25
        LDRB     R0,[R0, #+0]
        CMP      R0,#+26
        BLT.N    ??CenterLineGetSingleWrongAdd_26
// 7535     {
// 7536       flag1 = 0;
        MOVS     R0,#+0
// 7537     }
// 7538     else
// 7539     {
// 7540     }
// 7541     
// 7542     //左线尾小于CameraHight - 1行。
// 7543     if(BlackLeftEndLine < CameraHight - 1)
??CenterLineGetSingleWrongAdd_26:
        LDR.N    R0,??DataTable43_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BGE.N    ??CenterLineGetSingleWrongAdd_27
// 7544     {
// 7545       //只有左线成功，而且左线尾还那么远，真心没法继续。直接返回失败。
// 7546       //if(BlackLeftEndLine < CameraHight - 1 - BlackLeftBackLineStart)
// 7547       if(BlackLeftEndLine <= BlackControlLineLow)
        LDR.N    R0,??DataTable43_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+27
        BGE.N    ??CenterLineGetSingleWrongAdd_27
// 7548       {
// 7549         flag2 = 0;
        MOVS     R0,#+0
// 7550         return 0;       
        MOVS     R0,#+0
        B.N      ??CenterLineGetSingleWrongAdd_5
// 7551       }
// 7552       //左线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackLeftEndLine。
// 7553       else
// 7554       {
// 7555       }
// 7556     }
// 7557     //左线尾等于CameraHight - 1，直接取BlackLeftEndLine
// 7558     else
// 7559     {
// 7560     }
// 7561     
// 7562     //丢失另一根线的时候，先根据斜率估算出半宽，若没有上一次双线图像时的赛道半宽大，则直接用上一次双线的赛道半宽。
// 7563     //求5行的斜率。
// 7564     if(BlackLeftEndLine - BlackLeftHeadLine > 5)
??CenterLineGetSingleWrongAdd_27:
        LDR.N    R0,??DataTable43_3
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable43_25
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGetSingleWrongAdd_28
// 7565     {
// 7566       slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
// 7567                     (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
        LDR.N    R0,??DataTable43_26
        LDR.N    R1,??DataTable43_3
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.N    R1,??DataTable43_26
        LDR.N    R2,??DataTable43_3
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.N    R3,??DataTable43_21  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.N    R0,??DataTable43_26
        LDR.N    R1,??DataTable43_3
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.N    R1,??DataTable43_26
        LDR.N    R2,??DataTable43_3
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGetSingleWrongAdd_29
// 7568     }
// 7569     else
// 7570     {
// 7571       slope = 0;
??CenterLineGetSingleWrongAdd_28:
        MOVS     R0,#+0
// 7572     }
// 7573     //赛道半宽
// 7574     temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
??CenterLineGetSingleWrongAdd_29:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,#+0
        LDR.N    R3,??DataTable43_21  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.N    R3,??DataTable43_22  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
// 7575     //取最大值
// 7576     RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
        LDR.N    R1,??DataTable43_23
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       MaxRe
        LDR.N    R1,??DataTable43_23
        STRB     R0,[R1, #+0]
// 7577     
// 7578     //根据赛道宽度估计出中心线的线头。
// 7579     CenterLineLoc[BlackLeftEndLine] = BlackUdisLeftLocation[BlackLeftEndLine].x + RoadHalfWidth;
        LDR.N    R0,??DataTable43_26
        LDR.N    R1,??DataTable43_3
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.N    R1,??DataTable43_23
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1
        LDR.N    R1,??DataTable43_16
        LDR.N    R2,??DataTable43_3
        LDRB     R2,[R2, #+0]
        STRH     R0,[R1, R2, LSL #+1]
// 7580     
// 7581     tempflag1 = 0;
        MOVS     R4,#+0
// 7582     tempway1 = 0;
        MOVS     R5,#+0
// 7583     //根据左线的走势估计出中心线。中心线是个int16型矩阵，有正负。
// 7584     for(row = BlackLeftEndLine - 1; ;row--)
        LDR.N    R0,??DataTable43_3
        LDRB     R0,[R0, #+0]
        SUBS     R8,R0,#+1
        B.N      ??CenterLineGetSingleWrongAdd_30
??CenterLineGetSingleWrongAdd_31:
        SUBS     R8,R8,#+1
// 7585     {
// 7586       //左线有效时。根据左线的趋势补线。
// 7587       if(BlackLeftLoc[row][0] != MaxValUint8)
??CenterLineGetSingleWrongAdd_30:
        LDR.N    R0,??DataTable43_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGetSingleWrongAdd_32
// 7588       {
// 7589         tempflag1 = 0;
        MOVS     R4,#+0
// 7590         CenterLineLoc[row] = CenterLineLoc[row+1] + BlackUdisLeftLocation[row].x - BlackUdisLeftLocation[row+1].x;
        LDR.N    R0,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R0,R0,R8, LSL #+1
        LDRH     R0,[R0, #+2]
        LDR.N    R1,??DataTable43_26
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R1,[R1, R8, LSL #+3]
        ADDS     R0,R1,R0
        LDR.N    R1,??DataTable43_26
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R1,R1,R8, LSL #+3
        LDR      R1,[R1, #+8]
        SUBS     R0,R0,R1
        LDR.N    R1,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGetSingleWrongAdd_33
// 7591       }
// 7592       //左线无效时。根据最后两行的中心线趋势补线。
// 7593       else
// 7594       {
// 7595         //当左线无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
// 7596         if(tempflag1 == 0)
??CenterLineGetSingleWrongAdd_32:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BNE.N    ??CenterLineGetSingleWrongAdd_34
// 7597         {
// 7598           //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
// 7599           tempflag1 = 1;
        MOVS     R4,#+1
// 7600           //最后几行行数够多，可以采用最小二乘法的方式。
// 7601           if(row + CenterForwardLineNum <= CameraHight - 1)
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R0,R8,#+4
        CMP      R0,#+60
        BGE.N    ??CenterLineGetSingleWrongAdd_35
// 7602           {
// 7603             tempway1 = 0;
        MOVS     R5,#+0
// 7604             //进行最小二乘法系数的计算。
// 7605             for(i = 0; i < CenterForwardLineNum; i++)
        MOVS     R0,#+0
        B.N      ??CenterLineGetSingleWrongAdd_36
// 7606             {
// 7607               x[i] = row + i + 1;
??CenterLineGetSingleWrongAdd_37:
        ADDS     R1,R0,R8
        ADDS     R1,R1,#+1
        ADD      R2,SP,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 7608               y[i] = CenterLineLoc[row + i + 1];
        LDR.N    R1,??DataTable43_16
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTAB    R2,R0,R8
        ADDS     R1,R1,R2, LSL #+1
        LDRH     R1,[R1, #+2]
        ADD      R2,SP,#+4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRH     R1,[R2, R0, LSL #+1]
// 7609             }
        ADDS     R0,R0,#+1
??CenterLineGetSingleWrongAdd_36:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+4
        BLT.N    ??CenterLineGetSingleWrongAdd_37
// 7610             a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a1
        MOVS     R6,R0
// 7611             a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
        MOVS     R3,#+4
        MOVS     R2,R6
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a0
        MOVS     R7,R0
        B.N      ??CenterLineGetSingleWrongAdd_34
// 7612           }
// 7613           //最后几行的行数不够多，采用最后两行趋势补线的方式。
// 7614           else
// 7615           {
// 7616             tempway1 = 1;
??CenterLineGetSingleWrongAdd_35:
        MOVS     R5,#+1
// 7617           }
// 7618         }
// 7619         else
// 7620         {
// 7621         }
// 7622         
// 7623         //确认补线方式后，开始补线。
// 7624         if(tempway1 == 0)
??CenterLineGetSingleWrongAdd_34:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??CenterLineGetSingleWrongAdd_38
// 7625         {
// 7626           //最小二乘法的方式。
// 7627           CenterLineLoc[row] = (a0 + a1 * row) / LeastSquareMulti;
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MLA      R0,R8,R6,R7
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        LDR.N    R1,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGetSingleWrongAdd_33
// 7628         }
// 7629         else
// 7630         {
// 7631           //如果是最近2行。
// 7632           if(row == CameraHight -1  || row == CameraHight - 2)
??CenterLineGetSingleWrongAdd_38:
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+59
        BEQ.N    ??CenterLineGetSingleWrongAdd_39
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+58
        BNE.N    ??CenterLineGetSingleWrongAdd_40
// 7633           {
// 7634             CenterLineLoc[row] = BlackUdisLeftLocation[row].x + RoadHalfWidth;
??CenterLineGetSingleWrongAdd_39:
        LDR.N    R0,??DataTable43_26
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R0,[R0, R8, LSL #+3]
        LDR.N    R1,??DataTable43_23
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1
        LDR.N    R1,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGetSingleWrongAdd_33
// 7635           }
// 7636           //不是最近2行。
// 7637           else
// 7638           {
// 7639             //最后两行的方式。
// 7640             CenterLineLoc[row] = CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2];            
??CenterLineGetSingleWrongAdd_40:
        LDR.N    R0,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R0,R0,R8, LSL #+1
        LDRH     R0,[R0, #+2]
        LDR.N    R1,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R1,R1,R8, LSL #+1
        LDRH     R1,[R1, #+2]
        ADDS     R0,R1,R0
        LDR.N    R1,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R1,R1,R8, LSL #+1
        LDRH     R1,[R1, #+4]
        SUBS     R0,R0,R1
        LDR.N    R1,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
// 7641           }
// 7642         }
// 7643       }
// 7644       
// 7645       //一直补到最高行。
// 7646       if(row == 0) break;
??CenterLineGetSingleWrongAdd_33:
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+0
        BNE.W    ??CenterLineGetSingleWrongAdd_31
// 7647     }
// 7648     
// 7649     //对未处理的行的中心线置无效值。
// 7650     //底部置无效值。顶部不用处理。
// 7651     if(CenterEndLine != CameraHight - 1)
        LDR.N    R0,??DataTable43_19
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BEQ.N    ??CenterLineGetSingleWrongAdd_21
// 7652     {
// 7653       for(row = CameraHight - 1; ; row--)
        MOVS     R8,#+59
        B.N      ??CenterLineGetSingleWrongAdd_41
// 7654       {
// 7655         if(row == CenterEndLine) break;       
// 7656         CenterLineLoc[row] = MaxValInt16;
??CenterLineGetSingleWrongAdd_42:
        MOVW     R0,#+32767
        LDR.N    R1,??DataTable43_16
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        SUBS     R8,R8,#+1
??CenterLineGetSingleWrongAdd_41:
        LDR.N    R0,??DataTable43_19
        LDRB     R0,[R0, #+0]
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,R0
        BNE.N    ??CenterLineGetSingleWrongAdd_42
// 7657       }
// 7658     }
// 7659     else
// 7660     {
// 7661     }
// 7662   }
// 7663   
// 7664   return 1;
??CenterLineGetSingleWrongAdd_21:
        MOVS     R0,#+1
??CenterLineGetSingleWrongAdd_5:
        ADD      SP,SP,#+16
        POP      {R4-R8,PC}       ;; return
// 7665 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43:
        DC32     BlackRightHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_1:
        DC32     BlackGetPreDir

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_2:
        DC32     BlackLeftDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_3:
        DC32     BlackLeftEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_4:
        DC32     BrickSpeDealFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_5:
        DC32     BrickSpeDealDir

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_6:
        DC32     BlackRightDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_7:
        DC32     CurveSlopeFlagL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_8:
        DC32     CurveSlopeFlagR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_9:
        DC32     BlackLeftRollCheckFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_10:
        DC32     BlackLeftLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_11:
        DC32     BlackRightRollCheckFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_12:
        DC32     BlackRightEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_13:
        DC32     AngleConfirmLockFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_14:
        DC32     AngleSpeDealFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_15:
        DC32     BrickConfirmLockFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_16:
        DC32     CenterLineLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_17:
        DC32     RoadHalfWidthWrongDir

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_18:
        DC32     CenterHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_19:
        DC32     CenterEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_20:
        DC32     BlackUdisRightLocation

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_21:
        DC32     0x3ff00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_22:
        DC32     0x40690000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_23:
        DC32     RoadHalfWidth

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_24:
        DC32     BlackRightLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_25:
        DC32     BlackLeftHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable43_26:
        DC32     BlackUdisLeftLocation
// 7666 
// 7667 
// 7668 
// 7669 //非特殊赛道的中心线提取程序
// 7670 //中心线提取，进来前左右黑线均连续。
// 7671 //采用原始的左右黑线，不使用矫正后的左右黑线。

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
// 7672 uint8 CenterLineGetNormal(void)
// 7673 {
CenterLineGetNormal:
        PUSH     {R4-R9,LR}
        SUB      SP,SP,#+20
// 7674     int black_row, i, j;
// 7675             uint8 temp;
// 7676             uint8 flag1, //左线头标志（远处）
// 7677                 flag2, //左线尾标志（近处）
// 7678                 flag3, //右线头标志
// 7679                 flag4;  //右线尾标志
// 7680             uint8 tempflag1=1;
        MOVS     R8,#+1
// 7681             uint8 tempway1=1;
        MOVS     R9,#+1
// 7682             uint8 x[CenterForwardLineNum];   //中心线向前补线计算斜率时，x坐标，表示第几行。。
// 7683             int16 y[CenterForwardLineNum];   //中心线向前补线计算斜率时，y坐标，表示中心线位置。
// 7684             int32 a1 = 0, a0 = 0;    //中心线向前补线时，最小二乘法的斜率和纵截距。
        MOVS     R4,#+0
        MOVS     R5,#+0
// 7685             uint8 index;
// 7686             uint8 a[BlackBackLineNum];   //取多少个点在一开始有定义。
// 7687             uint8 b[BlackBackLineNum];
// 7688 
// 7689 
// 7690             float slope;
// 7691 
// 7692 
// 7693             //左线提取成功，右线提取失败。
// 7694             if (BlackLeftDone == 1 && BlackRightDone == 0)
        LDR.W    R0,??CenterLineGetNormal_0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??CenterLineGetNormal_1
        LDR.W    R0,??CenterLineGetNormal_0+0x4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.W    ??CenterLineGetNormal_1
// 7695             {
// 7696                 //若右线的线头线尾无效，则直接返回失败。
// 7697                 if (BlackLeftHeadLine == MaxValUint8 || BlackLeftEndLine == MaxValUint8)
        LDR.W    R0,??CenterLineGetNormal_0+0x8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGetNormal_2
        LDR.W    R0,??CenterLineGetNormal_0+0xC
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CenterLineGetNormal_3
// 7698                 {
// 7699                     return 0;
??CenterLineGetNormal_2:
        MOVS     R0,#+0
        B.N      ??CenterLineGetNormal_4
// 7700                 }
// 7701                 else
// 7702                 {
// 7703                 }
// 7704 
// 7705                 flag1 = 1;
??CenterLineGetNormal_3:
        MOVS     R0,#+1
// 7706                 flag2 = 1;
        MOVS     R1,#+1
// 7707 
// 7708                 //中心线的线尾取左线的线尾即可。
// 7709                 CenterHeadLine = BlackLeftHeadLine;   //线头取左线的线头，注意这不是实际的线头。
        LDR.W    R0,??CenterLineGetNormal_0+0x8
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGetNormal_0+0x10
        STRB     R0,[R1, #+0]
// 7710                                                        //CenterHeadLine = 0;                    //线头因为要固定补到第0行，所以直接置0.
// 7711                 CenterEndLine = BlackLeftEndLine;
        LDR.W    R0,??CenterLineGetNormal_0+0xC
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGetNormal_0+0x14
        STRB     R0,[R1, #+0]
// 7712 
// 7713                 //首先看线头是否大于BlackControlLineLow行
// 7714                 if (BlackLeftHeadLine >= 55)
        LDR.W    R0,??CenterLineGetNormal_0+0x8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+55
        BLT.N    ??CenterLineGetNormal_5
// 7715                 {
// 7716                     flag1 = 0;
        MOVS     R0,#+0
// 7717                 }
// 7718                 else
// 7719                 {
// 7720                 }
// 7721 
// 7722                 //右线尾小于CameraHight - 1行。
// 7723                 if (BlackLeftEndLine < CameraHight - 1)
??CenterLineGetNormal_5:
        LDR.W    R0,??CenterLineGetNormal_0+0xC
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BGE.N    ??CenterLineGetNormal_6
// 7724                 {
// 7725                     //只有右线成功，而且右线尾还那么远，真心没法继续。直接返回失败。
// 7726                     //if(BlackRightEndLine < CameraHight - 1 - BlackRightBackLineStart)
// 7727                     if (BlackLeftEndLine <= 5)
        LDR.W    R0,??CenterLineGetNormal_0+0xC
        LDRB     R0,[R0, #+0]
        CMP      R0,#+6
        BGE.N    ??CenterLineGetNormal_6
// 7728                     {
// 7729                         flag2 = 0;
        MOVS     R1,#+0
// 7730                         return 0;
        MOVS     R0,#+0
        B.N      ??CenterLineGetNormal_4
// 7731                     }
// 7732                     //右线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackRightEndLine。
// 7733                     else
// 7734                     {
// 7735                     }
// 7736                 }
// 7737                 //右线尾等于CameraHight - 1，直接取BlackRightEndLine
// 7738                 else
// 7739                 {
// 7740                 }
// 7741 
// 7742                 //丢失另一根线的时候，先根据斜率估算出半宽，若没有上一次双线图像时的赛道半宽大，则直接用上一次双线的赛道半宽。
// 7743                 //求5行的斜率。
// 7744                 for (black_row = BlackLeftHeadLine; ; black_row++)
??CenterLineGetNormal_6:
        LDR.W    R0,??CenterLineGetNormal_0+0x8
        LDRB     R6,[R0, #+0]
        B.N      ??CenterLineGetNormal_7
??CenterLineGetNormal_8:
        ADDS     R6,R6,#+1
// 7745                 {
// 7746                     if (BlackLeftEndLine - BlackLeftHeadLine > 5)
??CenterLineGetNormal_7:
        LDR.W    R0,??CenterLineGetNormal_0+0xC
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGetNormal_0+0x8
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.W    ??CenterLineGetNormal_9
// 7747                     {
// 7748                         if (BlackLeftLoc[black_row][ 0] != MaxValUint8)
        LDR.W    R0,??CenterLineGetNormal_0+0x18
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGetNormal_10
// 7749                         {
// 7750                             slope = 1.0 * (BlackUdisLeftLocation[black_row + 4].x - BlackUdisLeftLocation[black_row].x) /
// 7751                                   (BlackUdisLeftLocation[black_row + 4].y - BlackUdisLeftLocation[black_row].y);
        LDR.W    R0,??CenterLineGetNormal_0+0x1C
        ADDS     R0,R0,R6, LSL #+3
        LDR      R0,[R0, #+32]
        LDR.W    R1,??CenterLineGetNormal_0+0x1C
        LDR      R1,[R1, R6, LSL #+3]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOV      R8,R0
        MOV      R9,R1
        LDR.W    R0,??CenterLineGetNormal_0+0x1C
        ADDS     R0,R0,R6, LSL #+3
        LDR      R0,[R0, #+36]
        LDR.W    R1,??CenterLineGetNormal_0+0x1C
        ADDS     R1,R1,R6, LSL #+3
        LDR      R1,[R1, #+4]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOV      R0,R8
        MOV      R1,R9
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
// 7752                             /* else
// 7753                              {
// 7754                                slope = 0;
// 7755                              }*/
// 7756                             //赛道半宽
// 7757                             temp = CenterLineHalfWidth[black_row];// (int)(1.0 * Math.Sqrt(slope * slope + 1) * CenterLineHalfWidth[black_row] / 2);
        LDR.W    R0,??CenterLineGetNormal_0+0x24
        LDRB     R7,[R6, R0]
// 7758                             //取最大值
// 7759 
// 7760                             RoadHalfWidth = temp;// MaxRe(temp, RoadHalfWidth);
        LDR.W    R0,??CenterLineGetNormal_0+0x28
        STRB     R7,[R0, #+0]
// 7761 
// 7762                             tempflag1 = 0;
        MOVS     R8,#+0
// 7763                             tempway1 = 0;
        MOVS     R9,#+0
// 7764                             buXianCount = 0;
        MOVS     R0,#+0
        LDR.W    R1,??CenterLineGetNormal_0+0x2C
        STRH     R0,[R1, #+0]
// 7765                             //根据赛道宽度估计出中心线的线头。
// 7766                             CenterLineLoc[black_row] = BlackLeftLoc[black_row][ 0] + RoadHalfWidth;
        LDR.W    R0,??CenterLineGetNormal_0+0x18
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGetNormal_0+0x28
        LDRB     R1,[R1, #+0]
        ADDS     R0,R1,R0
        LDR.W    R1,??CenterLineGetNormal_0+0x30
        STRH     R0,[R1, R6, LSL #+1]
        B.N      ??CenterLineGetNormal_11
// 7767                         }
// 7768                         //根据右线的走势估计出中心线。中心线是个int16型矩阵，有正负。
// 7769 
// 7770                         // CenterLineLoc[black_row] = CenterLineLoc[black_row + 1] + BlackRightLoc[black_row, 0] - BlackRightLoc[black_row + 1, 0];
// 7771                         //右线无效时。根据最后两行的中心线趋势补线。
// 7772                         else
// 7773                         {
// 7774                             //当右线无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
// 7775                             if (tempflag1 == 0)
??CenterLineGetNormal_10:
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+0
        BNE.N    ??CenterLineGetNormal_12
// 7776                             {
// 7777                                 //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
// 7778                                 tempflag1 = 1;
        MOVS     R8,#+1
// 7779                                 //最后几行行数够多，可以采用最小二乘法的方式。
// 7780                                 //最后一行或两行尽量不用，因为有可能是拐点。但也不能太往后取，斜率就不对了。
// 7781                                 if (black_row + CenterForwardLineNum + 2 <= CameraHight - 1)
        ADDS     R0,R6,#+6
        CMP      R0,#+60
        BGE.N    ??CenterLineGetNormal_13
// 7782                                 {
// 7783                                     tempway1 = 0;
        MOVS     R9,#+0
// 7784                                     //进行最小二乘法系数的计算。
// 7785                                     for (i = 0; i < CenterForwardLineNum; i++)
        MOVS     R0,#+0
        B.N      ??CenterLineGetNormal_14
// 7786                                     {
// 7787                                         x[i] = black_row - i - 3;
??CenterLineGetNormal_15:
        SUBS     R1,R6,R0
        SUBS     R1,R1,#+3
        ADD      R2,SP,#+0
        STRB     R1,[R0, R2]
// 7788                                         y[i] = CenterLineLoc[black_row - i - 3];
        LDR.W    R1,??CenterLineGetNormal_0+0x30
        SUBS     R2,R6,R0
        ADDS     R1,R1,R2, LSL #+1
        LDRH     R1,[R1, #-6]
        ADD      R2,SP,#+4
        STRH     R1,[R2, R0, LSL #+1]
// 7789                                     }
        ADDS     R0,R0,#+1
??CenterLineGetNormal_14:
        CMP      R0,#+4
        BLT.N    ??CenterLineGetNormal_15
// 7790                                     a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a1
        MOVS     R4,R0
// 7791                                     a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。            
        MOVS     R3,#+4
        MOVS     R2,R4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a0
        MOVS     R5,R0
        B.N      ??CenterLineGetNormal_12
// 7792                                 }
// 7793                                 else if (black_row + CenterForwardLineNum + 1 <= CameraHight - 1)
??CenterLineGetNormal_13:
        ADDS     R0,R6,#+5
        CMP      R0,#+60
        BGE.N    ??CenterLineGetNormal_16
// 7794                                 {
// 7795                                     tempway1 = 0;
        MOVS     R9,#+0
// 7796                                     //进行最小二乘法系数的计算。
// 7797                                     for (i = 0; i < CenterForwardLineNum; i++)
        MOVS     R0,#+0
        B.N      ??CenterLineGetNormal_17
// 7798                                     {
// 7799                                         x[i] = black_row - i - 2;
??CenterLineGetNormal_18:
        SUBS     R1,R6,R0
        SUBS     R1,R1,#+2
        ADD      R2,SP,#+0
        STRB     R1,[R0, R2]
// 7800                                         y[i] = CenterLineLoc[black_row - i - 2];
        LDR.W    R1,??CenterLineGetNormal_0+0x30
        SUBS     R2,R6,R0
        ADDS     R1,R1,R2, LSL #+1
        LDRH     R1,[R1, #-4]
        ADD      R2,SP,#+4
        STRH     R1,[R2, R0, LSL #+1]
// 7801                                     }
        ADDS     R0,R0,#+1
??CenterLineGetNormal_17:
        CMP      R0,#+4
        BLT.N    ??CenterLineGetNormal_18
// 7802                                     a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a1
        MOVS     R4,R0
// 7803                                     a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。                        
        MOVS     R3,#+4
        MOVS     R2,R4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a0
        MOVS     R5,R0
        B.N      ??CenterLineGetNormal_12
// 7804                                 }
// 7805                                 else if (black_row + CenterForwardLineNum <= CameraHight - 1)
??CenterLineGetNormal_16:
        ADDS     R0,R6,#+4
        CMP      R0,#+60
        BGE.N    ??CenterLineGetNormal_19
// 7806                                 {
// 7807                                     tempway1 = 0;
        MOVS     R9,#+0
// 7808                                     //进行最小二乘法系数的计算。
// 7809                                     for (i = 0; i < CenterForwardLineNum; i++)
        MOVS     R0,#+0
        B.N      ??CenterLineGetNormal_20
// 7810                                     {
// 7811                                         x[i] = black_row - i - 1;
??CenterLineGetNormal_21:
        SUBS     R1,R6,R0
        SUBS     R1,R1,#+1
        ADD      R2,SP,#+0
        STRB     R1,[R0, R2]
// 7812                                         y[i] = CenterLineLoc[black_row - i - 1];
        LDR.W    R1,??CenterLineGetNormal_0+0x30
        SUBS     R2,R6,R0
        ADDS     R1,R1,R2, LSL #+1
        LDRH     R1,[R1, #-2]
        ADD      R2,SP,#+4
        STRH     R1,[R2, R0, LSL #+1]
// 7813                                     }
        ADDS     R0,R0,#+1
??CenterLineGetNormal_20:
        CMP      R0,#+4
        BLT.N    ??CenterLineGetNormal_21
// 7814                                     a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a1
        MOVS     R4,R0
// 7815                                     a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
        MOVS     R3,#+4
        MOVS     R2,R4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a0
        MOVS     R5,R0
        B.N      ??CenterLineGetNormal_12
// 7816                                 }
// 7817                                 //最后几行的行数不够多，采用最后两行趋势补线的方式。
// 7818                                 else
// 7819                                 {
// 7820                                     tempway1 = 1;
??CenterLineGetNormal_19:
        MOVS     R9,#+1
// 7821                                 }
// 7822                             }
// 7823                             else
// 7824                             {
// 7825                             }
// 7826 
// 7827                             //确认补线方式后，开始补线。
// 7828                             if (tempway1 == 0)
??CenterLineGetNormal_12:
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+0
        BNE.N    ??CenterLineGetNormal_11
// 7829                             {
// 7830                                 //最小二乘法的方式。
// 7831                                 CenterLineLoc[black_row] = (a0 + a1 * black_row) / LeastSquareMulti;
        MLA      R0,R6,R4,R5
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        LDR.W    R1,??CenterLineGetNormal_0+0x30
        STRH     R0,[R1, R6, LSL #+1]
        B.N      ??CenterLineGetNormal_11
// 7832                             }
// 7833                             else
// 7834                             {
// 7835                                 /*//最近2行。
// 7836                                 if(black_row == CameraHight - 1 || black_row == CameraHight - 2)
// 7837                                 {
// 7838                                   CenterLineLoc[black_row] = BlackRightLoc[black_row,0] - RoadHalfWidth;
// 7839                                 }
// 7840                                 //不是最近2行。
// 7841                                 else
// 7842                                 {
// 7843                                   //最后两行的方式。
// 7844                                   CenterLineLoc[black_row] = CenterLineLoc[black_row+1] + CenterLineLoc[black_row+1] - CenterLineLoc[black_row+2];
// 7845                                 }
// 7846                                 */
// 7847                             }
// 7848                         }
// 7849                     }
// 7850                     else
// 7851                     {
// 7852                         tempflag1 = 1;
??CenterLineGetNormal_9:
        MOVS     R8,#+1
// 7853                         tempway1 = 1;
        MOVS     R9,#+1
// 7854                         temp = CenterLineHalfWidth[black_row];// (int)(1.0 * CenterLineHalfWidth[black_row] / 2);
        LDR.W    R0,??CenterLineGetNormal_0+0x24
        LDRB     R7,[R6, R0]
// 7855                         RoadHalfWidth = temp;// MaxRe(temp, RoadHalfWidth);
        LDR.W    R0,??CenterLineGetNormal_0+0x28
        STRB     R7,[R0, #+0]
// 7856                         CenterLineLoc[black_row] = BlackLeftLoc[black_row][ 0] + RoadHalfWidth;
        LDR.W    R0,??CenterLineGetNormal_0+0x18
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGetNormal_0+0x28
        LDRB     R1,[R1, #+0]
        ADDS     R0,R1,R0
        LDR.W    R1,??CenterLineGetNormal_0+0x30
        STRH     R0,[R1, R6, LSL #+1]
// 7857 
// 7858                     }
// 7859                     if (CenterLineLoc[black_row] >= MaxValUint8)
??CenterLineGetNormal_11:
        LDR.W    R0,??CenterLineGetNormal_0+0x30
        LDRSH    R0,[R0, R6, LSL #+1]
        CMP      R0,#+255
        BLT.N    ??CenterLineGetNormal_22
// 7860                         CenterLineLoc[black_row] = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??CenterLineGetNormal_0+0x30
        STRH     R0,[R1, R6, LSL #+1]
        B.N      ??CenterLineGetNormal_23
// 7861                     else if (CenterLineLoc[black_row] <= 0)
??CenterLineGetNormal_22:
        LDR.W    R0,??CenterLineGetNormal_0+0x30
        LDRSH    R0,[R0, R6, LSL #+1]
        CMP      R0,#+1
        BGE.N    ??CenterLineGetNormal_23
// 7862                         CenterLineLoc[black_row] = 0;
        MOVS     R0,#+0
        LDR.W    R1,??CenterLineGetNormal_0+0x30
        STRH     R0,[R1, R6, LSL #+1]
// 7863                     else
// 7864                     {
// 7865                     }
// 7866                     if (black_row >= 59) break;
??CenterLineGetNormal_23:
        CMP      R6,#+59
        BLT.W    ??CenterLineGetNormal_8
// 7867                 }
// 7868 
// 7869 
// 7870 
// 7871             }
// 7872             //右线提取成功，左线提取失败。
// 7873             else if (BlackLeftDone == 0 && BlackRightDone == 1)
// 7874             {
// 7875                 //若右线的线头线尾无效，则直接返回失败。
// 7876                 if (BlackRightHeadLine == MaxValUint8 || BlackRightEndLine == MaxValUint8)
// 7877                 {
// 7878                     return 0;
// 7879                 }
// 7880                 else
// 7881                 {
// 7882                 }
// 7883 
// 7884                 flag1 = 1;
// 7885                 flag2 = 1;
// 7886 
// 7887                 //中心线的线尾取左线的线尾即可。
// 7888                 CenterHeadLine = BlackRightHeadLine;   //线头取左线的线头，注意这不是实际的线头。
// 7889                                                        //CenterHeadLine = 0;                    //线头因为要固定补到第0行，所以直接置0.
// 7890                 CenterEndLine = BlackRightEndLine;
// 7891 
// 7892                 //首先看线头是否大于BlackControlLineLow行
// 7893                 if (BlackRightHeadLine >= 55)
// 7894                 {
// 7895                     flag1 = 0;
// 7896                 }
// 7897                 else
// 7898                 {
// 7899                 }
// 7900 
// 7901                 //右线尾小于CameraHight - 1行。
// 7902                 if (BlackRightEndLine < CameraHight - 1)
// 7903                 {
// 7904                     //只有右线成功，而且右线尾还那么远，真心没法继续。直接返回失败。
// 7905                     //if(BlackRightEndLine < CameraHight - 1 - BlackRightBackLineStart)
// 7906                     if (BlackRightEndLine <= 5)
// 7907                     {
// 7908                         flag2 = 0;
// 7909                         return 0;
// 7910                     }
// 7911                     //右线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackRightEndLine。
// 7912                     else
// 7913                     {
// 7914                     }
// 7915                 }
// 7916                 //右线尾等于CameraHight - 1，直接取BlackRightEndLine
// 7917                 else
// 7918                 {
// 7919                 }
// 7920 
// 7921                 //丢失另一根线的时候，先根据斜率估算出半宽，若没有上一次双线图像时的赛道半宽大，则直接用上一次双线的赛道半宽。
// 7922                 //求5行的斜率。
// 7923                 for (black_row = BlackRightHeadLine; ; black_row++)
// 7924                 {
// 7925                     if (BlackRightEndLine - BlackRightHeadLine > 5)
// 7926                     {
// 7927                         if (BlackRightLoc[black_row][ 0] != MaxValUint8)
// 7928                         {
// 7929                             slope = 1.0 * (BlackUdisRightLocation[black_row + 4].x - BlackUdisRightLocation[black_row].x) /
// 7930                                   (BlackUdisRightLocation[black_row + 4].y - BlackUdisRightLocation[black_row].y);
// 7931                             /* else
// 7932                              {
// 7933                                slope = 0;
// 7934                              }*/
// 7935                             //赛道半宽
// 7936                             temp = CenterLineHalfWidth[black_row];// (int)(1.0 * Math.Sqrt(slope * slope + 1) * CenterLineHalfWidth[black_row] / 2);
// 7937                             //取最大值
// 7938 
// 7939                             RoadHalfWidth = temp;// MaxRe(temp, RoadHalfWidth);
// 7940 
// 7941                             tempflag1 = 0;
// 7942                             tempway1 = 0;
// 7943                             buXianCount = 0;
// 7944                             //根据赛道宽度估计出中心线的线头。
// 7945                             CenterLineLoc[black_row] = BlackRightLoc[black_row][ 0] - RoadHalfWidth;
// 7946                         }
// 7947                         //根据右线的走势估计出中心线。中心线是个int16型矩阵，有正负。
// 7948 
// 7949                         // CenterLineLoc[black_row] = CenterLineLoc[black_row + 1] + BlackRightLoc[black_row, 0] - BlackRightLoc[black_row + 1, 0];
// 7950                         //右线无效时。根据最后两行的中心线趋势补线。
// 7951                         else
// 7952                         {
// 7953                             //当右线无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
// 7954                             if (tempflag1 == 0)
// 7955                             {
// 7956                                 //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
// 7957                                 tempflag1 = 1;
// 7958                                 //最后几行行数够多，可以采用最小二乘法的方式。
// 7959                                 //最后一行或两行尽量不用，因为有可能是拐点。但也不能太往后取，斜率就不对了。
// 7960                                 if (black_row + CenterForwardLineNum + 2 <= CameraHight - 1)
// 7961                                 {
// 7962                                     tempway1 = 0;
// 7963                                     //进行最小二乘法系数的计算。
// 7964                                     for (i = 0; i < CenterForwardLineNum; i++)
// 7965                                     {
// 7966                                         x[i] = black_row - i - 3;
// 7967                                         y[i] = CenterLineLoc[black_row - i - 3];
// 7968                                     }
// 7969                                     a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
// 7970                                     a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。            
// 7971                                 }
// 7972                                 else if (black_row + CenterForwardLineNum + 1 <= CameraHight - 1)
// 7973                                 {
// 7974                                     tempway1 = 0;
// 7975                                     //进行最小二乘法系数的计算。
// 7976                                     for (i = 0; i < CenterForwardLineNum; i++)
// 7977                                     {
// 7978                                         x[i] = black_row - i - 2;
// 7979                                         y[i] = CenterLineLoc[black_row - i - 2];
// 7980                                     }
// 7981                                     a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
// 7982                                     a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。                        
// 7983                                 }
// 7984                                 else if (black_row + CenterForwardLineNum <= CameraHight - 1)
// 7985                                 {
// 7986                                     tempway1 = 0;
// 7987                                     //进行最小二乘法系数的计算。
// 7988                                     for (i = 0; i < CenterForwardLineNum; i++)
// 7989                                     {
// 7990                                         x[i] = black_row - i - 1;
// 7991                                         y[i] = CenterLineLoc[black_row - i - 1];
// 7992                                     }
// 7993                                     a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
// 7994                                     a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
// 7995                                 }
// 7996                                 //最后几行的行数不够多，采用最后两行趋势补线的方式。
// 7997                                 else
// 7998                                 {
// 7999                                     tempway1 = 1;
// 8000                                 }
// 8001                             }
// 8002                             else
// 8003                             {
// 8004                             }
// 8005 
// 8006                             //确认补线方式后，开始补线。
// 8007                             if (tempway1 == 0)
// 8008                             {
// 8009                                 //最小二乘法的方式。
// 8010                                 CenterLineLoc[black_row] = (a0 + a1 * black_row) / LeastSquareMulti;
// 8011                             }
// 8012                             else
// 8013                             {
// 8014                                 /*//最近2行。
// 8015                                 if(black_row == CameraHight - 1 || black_row == CameraHight - 2)
// 8016                                 {
// 8017                                   CenterLineLoc[black_row] = BlackRightLoc[black_row,0] - RoadHalfWidth;
// 8018                                 }
// 8019                                 //不是最近2行。
// 8020                                 else
// 8021                                 {
// 8022                                   //最后两行的方式。
// 8023                                   CenterLineLoc[black_row] = CenterLineLoc[black_row+1] + CenterLineLoc[black_row+1] - CenterLineLoc[black_row+2];
// 8024                                 }
// 8025                                 */
// 8026                             }
// 8027                         }
// 8028                     }
// 8029                     else
// 8030                     {
// 8031                         tempflag1 = 1;
// 8032                         tempway1 = 1;
// 8033                         temp = CenterLineHalfWidth[black_row];// (int)(1.0 * CenterLineHalfWidth[black_row] / 2);
// 8034                         RoadHalfWidth = temp;// MaxRe(temp, RoadHalfWidth);
// 8035                         CenterLineLoc[black_row] = BlackRightLoc[black_row][ 0] - RoadHalfWidth;
// 8036 
// 8037                     }
// 8038                     if (CenterLineLoc[black_row] >= MaxValUint8)
// 8039                         CenterLineLoc[black_row] = MaxValUint8;
// 8040                     else if (CenterLineLoc[black_row] <= 0)
// 8041                         CenterLineLoc[black_row] = 0;
// 8042                     else
// 8043                     {
// 8044                     }
// 8045                     if (black_row >= 59) break;
// 8046                 }
// 8047 
// 8048 
// 8049             }
// 8050 
// 8051 
// 8052 
// 8053             //对未处理的行的中心线置无效值。
// 8054             //底部置无效值。顶部不用处理。
// 8055             /* if(CenterEndLine != CameraHight - 1)
// 8056              {
// 8057                for(black_row = CameraHight - 1; ; black_row--)
// 8058                {
// 8059                  if(black_row == CenterEndLine) break;       
// 8060                  CenterLineLoc[black_row] = MaxValInt16;
// 8061                }
// 8062              }
// 8063              else
// 8064              {
// 8065              }*/
// 8066 
// 8067        
// 8068 
// 8069   //左右线均提取成功。
// 8070  else if(BlackLeftDone == 1 && BlackRightDone == 1)
// 8071   {
// 8072     CenterHeadLine = MinRe(BlackLeftHeadLine, BlackRightHeadLine);    //线头取两者较小者。     
// 8073     //CenterHeadLine = 0;    //因为固定要补到第0行，所以固定取0.
// 8074     //线尾取两者较大者。
// 8075     CenterEndLine = MinRe(BlackLeftEndLine, BlackRightEndLine);             
// 8076     
// 8077     //不是单线的情况。
// 8078     if(SingleBlackAllFlag == 0)
// 8079     {
// 8080     
// 8081       //左右线均提取成功，首选根据两线得中心线，实在不行再根据赛道宽度估计。
// 8082       //不根据趋势来预测，因为畸变矫正基本上已经把左右线差搞成定值了，所以不用那么麻烦。    
// 8083       
// 8084       //先检查左线，左线不满足条件再检测右线。右线不满足再返回失败。
// 8085       flag1 = 1;
// 8086       flag2 = 1;
// 8087       flag3 = 1;
// 8088       flag4 = 1;
// 8089       //取左右两线的第39到第59行的差，取最大值。
// 8090       //首先看线头是否大于39行，大于39行就直接返回失败。
// 8091       if(BlackLeftHeadLine >= 55)
// 8092       {
// 8093         flag1 = 0;
// 8094       }
// 8095       else
// 8096       {
// 8097       }
// 8098       //左线尾小于CameraHight - 1行。
// 8099       if(BlackLeftEndLine < CameraHight - 1)
// 8100       {
// 8101         //只有左线成功，而且左线尾还那么远，真心没法继续。看右线是不是一样的情况。
// 8102         //if(BlackLeftEndLine < CameraHight - 1 - BlackLeftBackLineStart)
// 8103         if(BlackLeftEndLine <= CameraHight - BlackStep1Size - 1)
// 8104         {
// 8105           flag2 = 0;
// 8106         }
// 8107         //左线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackLeftEndLine。
// 8108         else
// 8109         {
// 8110         }
// 8111       }
// 8112       //左线尾等于CameraHight - 1，直接取BlackLeftEndLine
// 8113       else
// 8114       {
// 8115       }
// 8116   
// 8117       //处理右线，右线不满足条件，则直接返回失败。
// 8118       //首先看线头是否大于39行，大于39行就直接返回失败。
// 8119       if(BlackRightHeadLine >= 55)
// 8120       {
// 8121         flag3 = 0;
// 8122       }
// 8123       else
// 8124       {
// 8125       }    
// 8126       //右线尾小于CameraHight - 1行。
// 8127       if(BlackRightEndLine < CameraHight - 1)
// 8128       {
// 8129         //只有右线成功，而且右线尾还那么远，真心没法继续。直接返回失败。
// 8130         //if(BlackRightEndLine < CameraHight - 1 - BlackRightBackLineStart)
// 8131         if(BlackRightEndLine <= CameraHight - BlackStep1Size - 1)
// 8132         {
// 8133           flag4 = 0;
// 8134           //两次都线尾很远，直接返回失败。
// 8135           if(flag2 == 0) 
// 8136           {
// 8137             return 0;
// 8138           }
// 8139           else
// 8140           {
// 8141           }
// 8142         }
// 8143         //右线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackRightEndLine。
// 8144         else
// 8145         {
// 8146         }
// 8147       }
// 8148       //右线尾等于CameraHight - 1，直接取BlackRightEndLine
// 8149       else
// 8150       {
// 8151       }
// 8152       
// 8153       //只有右线满足要求，则直接取右线的列差值绝对值。
// 8154       if(
// 8155         (flag3 == 1 && flag4 == 1)
// 8156       &&((flag1 == 0 && flag2 == 0) || (flag1 == 1 && flag2 == 0) || (flag1 == 0 && flag2 == 1))
// 8157         )
// 8158       {
// 8159         //斜率的方式估算出赛道半宽。
// 8160         //求5行的斜率。
// 8161         if(BlackRightEndLine - BlackRightHeadLine > 5)
// 8162         {
// 8163           slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
// 8164                     (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
// 8165         }
// 8166         else
// 8167         {
// 8168           slope = 0;
// 8169         }
// 8170         //赛道半宽
// 8171         temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
// 8172         RoadHalfWidthCompen = RoadHalfWidth / temp;
// 8173         if(RoadHalfWidthSwitch == 1)
// 8174         {
// 8175           RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
// 8176         }
// 8177         else
// 8178         {
// 8179         }
// 8180       }
// 8181       //只有左线满足要求，则直接取左线的列差值绝对值。
// 8182       else if(
// 8183              (flag1 == 1 && flag2 == 1)
// 8184            &&((flag3 == 0 && flag4 == 0) || (flag3 == 1 && flag4 == 0) || (flag3 == 0 && flag4 == 1))
// 8185              )
// 8186       {
// 8187         //斜率的方式估算出赛道半宽。
// 8188         //求5行的斜率。
// 8189         if(BlackLeftEndLine - BlackLeftHeadLine > 5)
// 8190         {
// 8191           slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x- BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
// 8192                     (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
// 8193         }
// 8194         else
// 8195         {
// 8196           slope = 0;
// 8197         }
// 8198         //赛道半宽
// 8199         temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
// 8200         RoadHalfWidthCompen = RoadHalfWidth / temp;
// 8201         if(RoadHalfWidthSwitch == 1)
// 8202         {
// 8203           RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
// 8204         }
// 8205         else
// 8206         {
// 8207         }
// 8208       }
// 8209       //左右线均满足条件。则取列差值绝对值较大的。
// 8210       else if(flag1 == 1 && flag2 == 1 && flag3 == 1 && flag4 == 1)
// 8211       {
// 8212         //斜率的方式估算出赛道半宽。
// 8213         //求5行的斜率。
// 8214         if(BlackLeftEndLine - BlackLeftHeadLine > 5)
// 8215         {
// 8216           slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
// 8217                     (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
// 8218         }
// 8219         else
// 8220         {
// 8221           slope = 0;
// 8222         }
// 8223         //赛道半宽
// 8224         temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
// 8225         
// 8226         //求5行的斜率。
// 8227         if(BlackRightEndLine - BlackRightHeadLine > 5)
// 8228         {
// 8229           slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
// 8230                     (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
// 8231         }
// 8232         else
// 8233         {
// 8234           slope = 0;
// 8235         }
// 8236         //赛道半宽
// 8237         temp = MaxRe((uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2), temp);
// 8238         RoadHalfWidthCompen = RoadHalfWidth / temp;
// 8239         if(RoadHalfWidthSwitch == 1)
// 8240         {
// 8241           RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
// 8242         }
// 8243         else
// 8244         {
// 8245         }
// 8246       }
// 8247       //左右线均不满足要求。
// 8248       else
// 8249       {
// 8250         //左右线都在第BlackControlLineLow行的远方。直接返回失败。
// 8251         if(flag2 == 0 && flag4 == 0)
// 8252         {
// 8253           return 0;
// 8254         }
// 8255         else
// 8256         {
// 8257           //左线在第BlackControlLineLow行的近方，右线在第BlackControlLineLow行的远方，则用左线来求。
// 8258           if(flag1 == 1 && flag3 == 0)
// 8259           {
// 8260             //斜率的方式估算出赛道半宽。
// 8261             //求5行的斜率。
// 8262             if(BlackLeftEndLine - BlackLeftHeadLine > 5)
// 8263             {
// 8264               slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
// 8265                     (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
// 8266             }
// 8267             else
// 8268             {
// 8269               slope = 0;
// 8270             }
// 8271             //赛道半宽
// 8272             temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
// 8273             RoadHalfWidthCompen = RoadHalfWidth / temp;
// 8274             if(RoadHalfWidthSwitch == 1)
// 8275             {
// 8276               RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
// 8277             }
// 8278             else
// 8279             {
// 8280             }
// 8281           }
// 8282           //右线在第BlackControlLineLow行的近方，左线在第BlackControlLineLow行的远方，则用右线来求。
// 8283           else if(flag1 == 0 && flag3 == 1)
// 8284           {
// 8285             //斜率的方式估算出赛道半宽。
// 8286             //求5行的斜率。
// 8287             if(BlackRightEndLine - BlackRightHeadLine > 5)
// 8288             {
// 8289               slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
// 8290                     (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
// 8291             }
// 8292             else
// 8293             {
// 8294               slope = 0;
// 8295             }
// 8296             //赛道半宽
// 8297             temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
// 8298             RoadHalfWidthCompen = RoadHalfWidth / temp;
// 8299             if(RoadHalfWidthSwitch == 1)
// 8300             {
// 8301               RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
// 8302             }
// 8303             else
// 8304             {
// 8305             }
// 8306           }
// 8307           //左右线都在第行的近方，则取较大值。
// 8308           else if(flag1 == 0 && flag3 == 0)
// 8309           {
// 8310             //斜率的方式估算出赛道半宽。
// 8311             //求5行的斜率。
// 8312             if(BlackLeftEndLine - BlackLeftHeadLine > 5)
// 8313             {
// 8314               slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
// 8315                     (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
// 8316             }
// 8317             else
// 8318             {
// 8319               slope = 0;
// 8320             }
// 8321             //赛道半宽
// 8322             temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
// 8323             
// 8324             //求5行的斜率。
// 8325             if(BlackRightEndLine - BlackRightHeadLine > 5)
// 8326             {
// 8327               slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
// 8328                     (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
// 8329             }
// 8330             else
// 8331             {
// 8332               slope = 0;
// 8333             }
// 8334             //赛道半宽
// 8335             temp = MaxRe((uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2), temp);
// 8336             RoadHalfWidthCompen = RoadHalfWidth / temp;
// 8337             if(RoadHalfWidthSwitch == 1)
// 8338             {
// 8339               RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
// 8340             }
// 8341             else
// 8342             {
// 8343             }
// 8344           }
// 8345           //理论上不可能走到这里。
// 8346           else
// 8347           {
// 8348             return 0;
// 8349           }
// 8350         }
// 8351       }
// 8352       
// 8353       int temproad;  //本幅图的最后一个双线有效路宽。给本幅图的单线部分用。
// 8354       temproad = RoadHalfWidth;
// 8355       
// 8356       tempflag1 = 0;
// 8357       tempway1 = 0;
// 8358     buXianCount = 0;
// 8359 
// 8360                     //赛道宽度已经求得，现在开始从高到低求中心线。
// 8361                         for (black_row = CenterHeadLine; black_row <= CameraHight - 1; black_row++)
// 8362                         {
// 8363                             //当前行左右黑线均有效。检测有无效不能用Udis数组，只能用原始的黑线储存数组。
// 8364                             if (BlackLeftLoc[black_row][ 0] != MaxValUint8 && BlackRightLoc[black_row][ 0] != MaxValUint8)
// 8365                             {
// 8366                                 tempflag1 = 0;
// 8367                                 //取左右黑线的平均值。
// 8368                                 CenterLineLoc[black_row] = (BlackLeftLoc[black_row][ 0] + BlackRightLoc[black_row][ 0]) / 2;
// 8369                                 //取最后一行两行有效的行的赛道半宽，作为最新的赛道半宽。
// 8370                                 /*  
// 8371 
// 8372                                   //本幅图的最后一个双线有效路宽。给本幅图的单线部分用。
// 8373                                   temproad = RoadHalfWidthRecord[black_row];*/
// 8374                                 //赛道半宽记录.存第CameraHight - 1行的赛道半宽，给下一幅图用。
// 8375                                 //怕出意外，限个幅。
// 8376                                 /* if(black_row == CameraHight - 1) 
// 8377                                  {  
// 8378                                    if(RoadHalfWidthRecord[black_row] > RoadHalfWidthLimitMax)
// 8379                                    {
// 8380                                      RoadHalfWidth = RoadHalfWidthLimitMax;
// 8381                                    }
// 8382                                    else if(RoadHalfWidthRecord[black_row] < RoadHalfWidthLimitMin)
// 8383                                    {
// 8384                                      RoadHalfWidth = RoadHalfWidthLimitMin;
// 8385                                    }
// 8386                                    else
// 8387                                    {
// 8388                                      RoadHalfWidth = RoadHalfWidthRecord[black_row];
// 8389                                    }            
// 8390                                  }
// 8391                                  else
// 8392                                  {
// 8393                                  } */
// 8394                             }
// 8395                             //左行或右行无效。则用上半段的中心线向后补线。
// 8396                             else if (BlackLeftLoc[black_row][ 0] == MaxValUint8 || BlackRightLoc[black_row][ 0] == MaxValUint8)
// 8397                             {
// 8398 
// 8399                                 if (BlackLeftCrossDone == 2 || BlackRightCrossDone == 2)
// 8400                                 {
// 8401                                     buXianCount--;
// 8402                                 }
// 8403                                 else if (BlackRightHeadLine >= 25 && BlackLeftHeadLine >= 25) { buXianCount = 0; }
// 8404                                 else if (BlackLeftHeadLine <= 20 && BlackRightHeadLine >= 50) { buXianCount = 0; }
// 8405                                 else if ((CURVEL < 0 && CURVER > 0) || (CURVEL > 0 && CURVER < 0)) { buXianCount = 0; }
// 8406                                 else if (BlackLeftHeadLine <= 5) { buXianCount = 0; }
// 8407                                 else if (BlackLeftHeadLine <= 20 && BlackRightHeadLine >= 45) { buXianCount = 0; }
// 8408                                 else if (((AbsInt(CURVEL) >= 20) && (AbsInt(CURVEL) <= 50)) || ((AbsInt(CURVER) >= 20) && (AbsInt(CURVER) <= 50)))
// 8409                                 {
// 8410                                     buXianCount = 0;
// 8411                                 }
// 8412                                 else if (((AbsInt(CURVEL) > 50) && (AbsInt(CURVEL) <= 2000)) || ((AbsInt(CURVER) > 50) && (AbsInt(CURVER) <= 2000)))
// 8413                                 {
// 8414                                     buXianCount = 0;
// 8415                                 }
// 8416                                 else if ((AbsInt(CURVEL) > 2000) || (AbsInt(CURVER) > 2000))
// 8417                                 {
// 8418                                     buXianCount = 0;
// 8419                                 }
// 8420 
// 8421 
// 8422                                 tempflag1 = 0;
// 8423                                 index = 0;
// 8424                                 for (i = black_row - 1;i>=0 ; i--)
// 8425                                 {
// 8426                                     if (CenterLineLoc[i] != MaxValUint8)
// 8427                                     {
// 8428                                         b[index] = CenterLineLoc[i];
// 8429                                         a[index] = i;
// 8430                                         index++;
// 8431                                     }
// 8432                                     if (index == BlackBackLineNum)
// 8433                                     {
// 8434 
// 8435                                         break;
// 8436                                     }
// 8437 
// 8438                                 }
// 8439 
// 8440                                 //最小二乘法
// 8441                                 //y = a0 + a1 * x
// 8442                                 a1 = LeastSquarea1(a, b, BlackBackLineNum);
// 8443 
// 8444                                 a0 = LeastSquarea0(a, b, a1, BlackBackLineNum);
// 8445 
// 8446 
// 8447                                 //补线也有个度，向左向右都不能补出范围。
// 8448                                 temp = (a0 + a1 * black_row) / LeastSquareMulti;
// 8449                                 if (temp >= CameraRealWidth - 1)
// 8450                                 {
// 8451                                     //BlackLeftLoc[black_row,0] = CameraRealWidth - 1;
// 8452                                     //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。
// 8453 
// 8454                                     temp = CameraRealWidth - 1;
// 8455                                 }
// 8456                                 else if (temp <= 0)
// 8457                                 {
// 8458                                     //BlackLeftLoc[black_row,0] = 0;
// 8459                                     //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。
// 8460                                     temp = 0;
// 8461                                 }
// 8462                                 CenterLineLoc[black_row] = (int)(temp);
// 8463                                 //  CenterLineLoc[black_row] = BlackLeftLoc[black_row,0] + temproad + buXianCount;
// 8464                             }
// 8465                             //左行无效，右行有效。则用右行减去一个赛道半宽。
// 8466                             /*else if(BlackLeftLoc[black_row,0] == MaxValUint8 && BlackRightLoc[black_row,0] != MaxValUint8)
// 8467                             {
// 8468                                 if (BlackLeftCrossDone == 2 || BlackRightCrossDone == 2)
// 8469                                 {
// 8470                                     buXianCount--;
// 8471                                 }
// 8472                                 else if (BlackRightHeadLine >= 25 && BlackLeftHeadLine >= 25) { buXianCount = 0; }
// 8473                                 else if (BlackRightHeadLine <= 20 && BlackLeftHeadLine >= 50) { buXianCount = 0; }
// 8474                                 else if ((CURVEL < 0 && CURVER > 0) || (CURVEL > 0 && CURVER < 0)) { buXianCount = 0; }
// 8475                                 else if (BlackRightHeadLine <= 5) { buXianCount = 0; }
// 8476                                 else if (BlackRightHeadLine <= 20 && BlackLeftHeadLine >= 45) { buXianCount = 0; }
// 8477                                 else if (((AbsInt(CURVEL) >= 20) && (AbsInt(CURVEL) <= 50)) || ((AbsInt(CURVER) >= 20) && (AbsInt(CURVER) <= 50)))
// 8478                                 {
// 8479                                     buXianCount=0;
// 8480                                 }
// 8481                                 else if (((AbsInt(CURVEL) > 50) && (AbsInt(CURVEL) <= 2000)) || ((AbsInt(CURVER) > 50) && (AbsInt(CURVER) <= 2000)))
// 8482                                 {
// 8483                                     buXianCount =0;
// 8484                                 }
// 8485                                 else if ((AbsInt(CURVEL) > 2000) ||(AbsInt(CURVER) > 2000))
// 8486                                 {
// 8487                                     buXianCount =0;
// 8488                                 }
// 8489 
// 8490 
// 8491                                 tempflag1 = 0;
// 8492                               CenterLineLoc[black_row] = BlackRightLoc[black_row,0] - temproad - buXianCount;
// 8493                             }
// 8494                             //左右行均无效。则用最后的中心线均势往前走。
// 8495                             else if(BlackLeftLoc[black_row,0] == MaxValUint8 && BlackRightLoc[black_row,0] == MaxValUint8)
// 8496                             {
// 8497                               //当左右线均无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
// 8498                               if(tempflag1 == 0)
// 8499                               {
// 8500                                 //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
// 8501                                 //除非又出现左或右黑线有效的情况，则再次刷新斜率。
// 8502                                 tempflag1 = 1;
// 8503                                 //最后几行行数够多，可以采用最小二乘法的方式。
// 8504                                 //最后一行或两行尽量不用，因为有可能是拐点。但也不能太往后取，斜率就不对了。
// 8505                                 if(black_row + CenterForwardLineNum + 2 <= CameraHight - 1)
// 8506                                 {
// 8507                                   tempway1 = 0;
// 8508                                   //进行最小二乘法系数的计算。
// 8509                                   for(i = 0; i < CenterForwardLineNum; i++)
// 8510                                   {
// 8511                                     x[i] = black_row + i + 3;
// 8512                                     y[i] = CenterLineLoc[black_row + i + 3];
// 8513                                   }
// 8514                                   a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
// 8515                                   a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。            
// 8516                                 }
// 8517                                 else if(black_row + CenterForwardLineNum + 1 <= CameraHight - 1)
// 8518                                 {
// 8519                                   tempway1 = 0;
// 8520                                   //进行最小二乘法系数的计算。
// 8521                                   for(i = 0; i < CenterForwardLineNum; i++)
// 8522                                   {
// 8523                                     x[i] = black_row + i + 2;
// 8524                                     y[i] = CenterLineLoc[black_row + i + 2];
// 8525                                   }
// 8526                                   a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
// 8527                                   a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。                        
// 8528                                 }
// 8529                                 else if(black_row + CenterForwardLineNum <= CameraHight - 1)
// 8530                                 {
// 8531                                   tempway1 = 0;
// 8532                                   //进行最小二乘法系数的计算。
// 8533                                   for(i = 0; i < CenterForwardLineNum; i++)
// 8534                                   {
// 8535                                     x[i] = black_row + i + 1;
// 8536                                     y[i] = CenterLineLoc[black_row + i + 1];
// 8537                                   }
// 8538                                   a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
// 8539                                   a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
// 8540                                 }
// 8541                                 //最后几行的行数不够多，采用最后两行趋势补线的方式。
// 8542                                 else
// 8543                                 {
// 8544                                   tempway1 = 1;
// 8545                                 }
// 8546                               }
// 8547                               else
// 8548                               {
// 8549                               }
// 8550 
// 8551                               //确认补线方式后，开始补线。
// 8552                               if(tempway1 == 0)
// 8553                               {
// 8554                                 //最小二乘法的方式。
// 8555                                 CenterLineLoc[black_row] = (a0 + a1 * black_row) / LeastSquareMulti;
// 8556                               }
// 8557                               else
// 8558                               {
// 8559                                 //最后两行的方式。
// 8560                                 CenterLineLoc[black_row] = CenterLineLoc[black_row+1] + CenterLineLoc[black_row+1] - CenterLineLoc[black_row+2];
// 8561                               }
// 8562 
// 8563                             }*/
// 8564                             //理论上不会走到这里。
// 8565                             else
// 8566                             {
// 8567                             }
// 8568 
// 8569                         }
// 8570                     
// 8571       //对未处理的行的中心线置无效值。对顶部的不作处理。
// 8572       //底部置无效值。
// 8573       /* if(CenterEndLine != CameraHight - 1)
// 8574        {
// 8575          for(black_row = CameraHight - 1; ; black_row--)
// 8576          {
// 8577            if(black_row == CenterEndLine) break;       
// 8578            CenterLineLoc[black_row] = MaxValInt16;
// 8579          }
// 8580        }
// 8581        else
// 8582        {
// 8583        }      */
// 8584     }
// 8585     //单线的情况，也就是SingleBlackAllFlag==1的情况。
// 8586     else
// 8587     {
// 8588       tempflag1 = 0;
// 8589       tempway1 = 0;
// 8590       
// 8591       //赛道宽度已经求得，现在开始从低到高求中心线。
// 8592       for(black_row = CenterEndLine; ; black_row--)
// 8593       {
// 8594         //当前行左右黑线均有效。检测有无效不能用Udis数组，只能用原始的黑线储存数组。
// 8595         if(BlackLeftLoc[black_row][0] != MaxValUint8 && BlackRightLoc[black_row][0] != MaxValUint8)
// 8596         {
// 8597           tempflag1 = 0;
// 8598           //取左右黑线的平均值。
// 8599           CenterLineLoc[black_row] = (BlackLeftLoc[black_row][0] + BlackRightLoc[black_row][0]) / 2;
// 8600           //取最后一行两行有效的行的赛道半宽，作为最新的赛道半宽。
// 8601           if(BlackLeftLoc[black_row,0] > BlackRightLoc[black_row,0])
// 8602           {
// 8603             RoadHalfWidthSingle = (BlackLeftLoc[black_row,0] - BlackRightLoc[black_row,0]) / 2;
// 8604           }
// 8605           else
// 8606           {
// 8607             RoadHalfWidthSingle = (BlackRightLoc[black_row,0] - BlackLeftLoc[black_row,0]) / 2;
// 8608           }        
// 8609         }
// 8610         //左行有效，右行无效。则用左行加上一个赛道半宽。
// 8611         else if(BlackLeftLoc[black_row][0] != MaxValUint8 && BlackRightLoc[black_row][0] == MaxValUint8)
// 8612         {
// 8613           tempflag1 = 0;
// 8614           CenterLineLoc[black_row] = BlackLeftLoc[black_row][0] - RoadHalfWidthSingle;    //因为是单线，所以是减号。
// 8615         }
// 8616         //左行无效，右行有效。则用右行减去一个赛道半宽。
// 8617         else if(BlackLeftLoc[black_row][0] == MaxValUint8 && BlackRightLoc[black_row][0] != MaxValUint8)
// 8618         {
// 8619           tempflag1 = 0;
// 8620           CenterLineLoc[black_row] = BlackRightLoc[black_row][0] + RoadHalfWidthSingle;   //因为是单线，所以是加号。
// 8621         }
// 8622         //左右行均无效。则用最后的中心线均势往前走。
// 8623         else if(BlackLeftLoc[black_row][0] == MaxValUint8 && BlackRightLoc[black_row][0] == MaxValUint8)
// 8624         {
// 8625           //当左右线均无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
// 8626           if(tempflag1 == 0)
// 8627           {
// 8628             //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
// 8629             //除非又出现左或右黑线有效的情况，则再次刷新斜率。
// 8630             tempflag1 = 1;
// 8631             //最后几行行数够多，可以采用最小二乘法的方式。
// 8632             //最后一行或两行尽量不用，因为有可能是拐点。但也不能太往后取，斜率就不对了。
// 8633             if(black_row + CenterForwardLineNum + 2 <= CameraHight - 1)
// 8634             {
// 8635               tempway1 = 0;
// 8636               //进行最小二乘法系数的计算。
// 8637               for(i = 0; i < CenterForwardLineNum; i++)
// 8638               {
// 8639                 x[i] = black_row + i + 3;
// 8640                 y[i] = CenterLineLoc[black_row + i + 3];
// 8641               }
// 8642               a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
// 8643               a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。            
// 8644             }
// 8645             else if(black_row + CenterForwardLineNum + 1 <= CameraHight - 1)
// 8646             {
// 8647               tempway1 = 0;
// 8648               //进行最小二乘法系数的计算。
// 8649               for(i = 0; i < CenterForwardLineNum; i++)
// 8650               {
// 8651                 x[i] = black_row + i + 2;
// 8652                 y[i] = CenterLineLoc[black_row + i + 2];
// 8653               }
// 8654               a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
// 8655               a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。                        
// 8656             }
// 8657             else if(black_row + CenterForwardLineNum <= CameraHight - 1)
// 8658             {
// 8659               tempway1 = 0;
// 8660               //进行最小二乘法系数的计算。
// 8661               for(i = 0; i < CenterForwardLineNum; i++)
// 8662               {
// 8663                 x[i] = black_row + i + 1;
// 8664                 y[i] = CenterLineLoc[black_row + i + 1];
// 8665               }
// 8666               a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
// 8667               a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
// 8668             }
// 8669             //最后几行的行数不够多，采用最后两行趋势补线的方式。
// 8670             else
// 8671             {
// 8672               tempway1 = 1;
// 8673             }
// 8674           }
// 8675           else
// 8676           {
// 8677           }
// 8678           
// 8679           //确认补线方式后，开始补线。
// 8680           if(tempway1 == 0)
// 8681           {
// 8682             //最小二乘法的方式。
// 8683             CenterLineLoc[black_row] = (a0 + a1 * black_row) / LeastSquareMulti;
// 8684           }
// 8685           else
// 8686           {
// 8687             //最后两行的方式。
// 8688             CenterLineLoc[black_row] = CenterLineLoc[black_row+1] + CenterLineLoc[black_row+1] - CenterLineLoc[black_row+2];
// 8689           }
// 8690           
// 8691         }
// 8692         //理论上不会走到这里。
// 8693         else
// 8694         {
// 8695         }
// 8696         
// 8697         if(black_row == 0) break;
// 8698       }
// 8699          
// 8700       //对未处理的行的中心线置无效值。对顶部的不作处理。
// 8701       //底部置无效值。
// 8702       if(CenterEndLine != CameraHight - 1)
// 8703       {
// 8704         for(black_row = CameraHight - 1; ; black_row--)
// 8705         {
// 8706           if(black_row == CenterEndLine) break;       
// 8707           CenterLineLoc[black_row] = MaxValInt16;
// 8708         }
// 8709       }
// 8710       else
// 8711       {
// 8712       }
// 8713     }
// 8714   }
// 8715   //理论上不会走到这里。
// 8716   else
// 8717   {
// 8718     //左右黑线均提取失败，返回0.
// 8719     return 0;
// 8720   }
// 8721        /*     if (BlackLeftLoc[CenterEndLine, 0] > BlackRightLoc[CenterEndLine, 0])
// 8722             {
// 8723                 RoadHalfWidth = (BlackLeftLoc[CenterEndLine, 0] - BlackRightLoc[CenterEndLine, 0]) / 2;
// 8724             }
// 8725             else
// 8726             {
// 8727                 RoadHalfWidth = (BlackRightLoc[CenterEndLine, 0] - BlackLeftLoc[CenterEndLine, 0]) / 2;
// 8728             }
// 8729             if (RoadHalfWidth > RoadHalfWidthLimitMax)
// 8730             {
// 8731                 RoadHalfWidth = RoadHalfWidthLimitMax;
// 8732             }
// 8733             else if (RoadHalfWidth < RoadHalfWidthLimitMin)
// 8734             {
// 8735                 RoadHalfWidth = RoadHalfWidthLimitMin;
// 8736             }
// 8737             else
// 8738             {
// 8739             }*/
// 8740             return 1;
??CenterLineGetNormal_24:
        MOVS     R0,#+1
??CenterLineGetNormal_4:
        ADD      SP,SP,#+20
        POP      {R4-R9,PC}       ;; return
??CenterLineGetNormal_1:
        LDR.W    R0,??CenterLineGetNormal_0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.W    ??CenterLineGetNormal_25
        LDR.W    R0,??CenterLineGetNormal_0+0x4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??CenterLineGetNormal_25
        LDR.W    R0,??CenterLineGetNormal_26
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGetNormal_27
        LDR.W    R0,??CenterLineGetNormal_26+0x4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CenterLineGetNormal_28
??CenterLineGetNormal_27:
        MOVS     R0,#+0
        B.N      ??CenterLineGetNormal_4
??CenterLineGetNormal_28:
        MOVS     R0,#+1
        MOVS     R1,#+1
        LDR.W    R0,??CenterLineGetNormal_26
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGetNormal_0+0x10
        STRB     R0,[R1, #+0]
        LDR.W    R0,??CenterLineGetNormal_26+0x4
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGetNormal_0+0x14
        STRB     R0,[R1, #+0]
        LDR.W    R0,??CenterLineGetNormal_26
        LDRB     R0,[R0, #+0]
        CMP      R0,#+55
        BLT.N    ??CenterLineGetNormal_29
        MOVS     R0,#+0
??CenterLineGetNormal_29:
        LDR.W    R0,??CenterLineGetNormal_26+0x4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BGE.N    ??CenterLineGetNormal_30
        LDR.W    R0,??CenterLineGetNormal_26+0x4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+6
        BGE.N    ??CenterLineGetNormal_30
        MOVS     R1,#+0
        MOVS     R0,#+0
        B.N      ??CenterLineGetNormal_4
??CenterLineGetNormal_30:
        LDR.W    R0,??CenterLineGetNormal_26
        LDRB     R6,[R0, #+0]
        B.N      ??CenterLineGetNormal_31
??CenterLineGetNormal_32:
        ADDS     R6,R6,#+1
??CenterLineGetNormal_31:
        LDR.W    R0,??CenterLineGetNormal_26+0x4
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGetNormal_26
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.W    ??CenterLineGetNormal_33
        LDR.W    R0,??CenterLineGetNormal_34
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGetNormal_35
        LDR.W    R0,??CenterLineGetNormal_34+0x4
        ADDS     R0,R0,R6, LSL #+3
        LDR      R0,[R0, #+32]
        LDR.W    R1,??CenterLineGetNormal_34+0x4
        LDR      R1,[R1, R6, LSL #+3]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOV      R8,R0
        MOV      R9,R1
        LDR.W    R0,??CenterLineGetNormal_34+0x4
        ADDS     R0,R0,R6, LSL #+3
        LDR      R0,[R0, #+36]
        LDR.W    R1,??CenterLineGetNormal_34+0x4
        ADDS     R1,R1,R6, LSL #+3
        LDR      R1,[R1, #+4]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOV      R0,R8
        MOV      R1,R9
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        LDR.W    R0,??CenterLineGetNormal_0+0x24
        LDRB     R7,[R6, R0]
        LDR.W    R0,??CenterLineGetNormal_0+0x28
        STRB     R7,[R0, #+0]
        MOVS     R8,#+0
        MOVS     R9,#+0
        MOVS     R0,#+0
        LDR.W    R1,??CenterLineGetNormal_0+0x2C
        STRH     R0,[R1, #+0]
        LDR.W    R0,??CenterLineGetNormal_34
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGetNormal_0+0x28
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        LDR.W    R1,??CenterLineGetNormal_0+0x30
        STRH     R0,[R1, R6, LSL #+1]
        B.N      ??CenterLineGetNormal_36
??CenterLineGetNormal_35:
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+0
        BNE.N    ??CenterLineGetNormal_37
        MOVS     R8,#+1
        ADDS     R0,R6,#+6
        CMP      R0,#+60
        BGE.N    ??CenterLineGetNormal_38
        MOVS     R9,#+0
        MOVS     R0,#+0
        B.N      ??CenterLineGetNormal_39
??CenterLineGetNormal_40:
        SUBS     R1,R6,R0
        SUBS     R1,R1,#+3
        ADD      R2,SP,#+0
        STRB     R1,[R0, R2]
        LDR.W    R1,??CenterLineGetNormal_0+0x30
        SUBS     R2,R6,R0
        ADDS     R1,R1,R2, LSL #+1
        LDRH     R1,[R1, #-6]
        ADD      R2,SP,#+4
        STRH     R1,[R2, R0, LSL #+1]
        ADDS     R0,R0,#+1
??CenterLineGetNormal_39:
        CMP      R0,#+4
        BLT.N    ??CenterLineGetNormal_40
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a1
        MOVS     R4,R0
        MOVS     R3,#+4
        MOVS     R2,R4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a0
        MOVS     R5,R0
        B.N      ??CenterLineGetNormal_37
??CenterLineGetNormal_38:
        ADDS     R0,R6,#+5
        CMP      R0,#+60
        BGE.N    ??CenterLineGetNormal_41
        MOVS     R9,#+0
        MOVS     R0,#+0
        B.N      ??CenterLineGetNormal_42
??CenterLineGetNormal_43:
        SUBS     R1,R6,R0
        SUBS     R1,R1,#+2
        ADD      R2,SP,#+0
        STRB     R1,[R0, R2]
        LDR.W    R1,??CenterLineGetNormal_0+0x30
        SUBS     R2,R6,R0
        ADDS     R1,R1,R2, LSL #+1
        LDRH     R1,[R1, #-4]
        ADD      R2,SP,#+4
        STRH     R1,[R2, R0, LSL #+1]
        ADDS     R0,R0,#+1
??CenterLineGetNormal_42:
        CMP      R0,#+4
        BLT.N    ??CenterLineGetNormal_43
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a1
        MOVS     R4,R0
        MOVS     R3,#+4
        MOVS     R2,R4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a0
        MOVS     R5,R0
        B.N      ??CenterLineGetNormal_37
??CenterLineGetNormal_41:
        ADDS     R0,R6,#+4
        CMP      R0,#+60
        BGE.N    ??CenterLineGetNormal_44
        MOVS     R9,#+0
        MOVS     R0,#+0
        B.N      ??CenterLineGetNormal_45
??CenterLineGetNormal_46:
        SUBS     R1,R6,R0
        SUBS     R1,R1,#+1
        ADD      R2,SP,#+0
        STRB     R1,[R0, R2]
        LDR.W    R1,??CenterLineGetNormal_0+0x30
        SUBS     R2,R6,R0
        ADDS     R1,R1,R2, LSL #+1
        LDRH     R1,[R1, #-2]
        ADD      R2,SP,#+4
        STRH     R1,[R2, R0, LSL #+1]
        ADDS     R0,R0,#+1
??CenterLineGetNormal_45:
        CMP      R0,#+4
        BLT.N    ??CenterLineGetNormal_46
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a1
        MOVS     R4,R0
        MOVS     R3,#+4
        MOVS     R2,R4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a0
        MOVS     R5,R0
        B.N      ??CenterLineGetNormal_37
??CenterLineGetNormal_44:
        MOVS     R9,#+1
??CenterLineGetNormal_37:
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+0
        BNE.N    ??CenterLineGetNormal_36
        MLA      R0,R6,R4,R5
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        LDR.W    R1,??CenterLineGetNormal_0+0x30
        STRH     R0,[R1, R6, LSL #+1]
        B.N      ??CenterLineGetNormal_36
??CenterLineGetNormal_33:
        MOVS     R8,#+1
        MOVS     R9,#+1
        LDR.W    R0,??CenterLineGetNormal_0+0x24
        LDRB     R7,[R6, R0]
        LDR.W    R0,??CenterLineGetNormal_0+0x28
        STRB     R7,[R0, #+0]
        LDR.W    R0,??CenterLineGetNormal_34
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGetNormal_0+0x28
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        LDR.W    R1,??CenterLineGetNormal_0+0x30
        STRH     R0,[R1, R6, LSL #+1]
??CenterLineGetNormal_36:
        LDR.W    R0,??CenterLineGetNormal_0+0x30
        LDRSH    R0,[R0, R6, LSL #+1]
        CMP      R0,#+255
        BLT.N    ??CenterLineGetNormal_47
        MOVS     R0,#+255
        LDR.W    R1,??CenterLineGetNormal_0+0x30
        STRH     R0,[R1, R6, LSL #+1]
        B.N      ??CenterLineGetNormal_48
??CenterLineGetNormal_47:
        LDR.W    R0,??CenterLineGetNormal_0+0x30
        LDRSH    R0,[R0, R6, LSL #+1]
        CMP      R0,#+1
        BGE.N    ??CenterLineGetNormal_48
        MOVS     R0,#+0
        LDR.W    R1,??CenterLineGetNormal_0+0x30
        STRH     R0,[R1, R6, LSL #+1]
??CenterLineGetNormal_48:
        CMP      R6,#+59
        BLT.W    ??CenterLineGetNormal_32
        B.N      ??CenterLineGetNormal_24
??CenterLineGetNormal_25:
        LDR.W    R0,??CenterLineGetNormal_0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??CenterLineGetNormal_49
        LDR.W    R0,??CenterLineGetNormal_0+0x4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??CenterLineGetNormal_49
        LDR.W    R0,??CenterLineGetNormal_26
        LDRB     R1,[R0, #+0]
        LDR.W    R0,??CenterLineGetNormal_0+0x8
        LDRB     R0,[R0, #+0]
        BL       MinRe
        LDR.W    R1,??CenterLineGetNormal_0+0x10
        STRB     R0,[R1, #+0]
        LDR.W    R0,??CenterLineGetNormal_26+0x4
        LDRB     R1,[R0, #+0]
        LDR.W    R0,??CenterLineGetNormal_0+0xC
        LDRB     R0,[R0, #+0]
        BL       MinRe
        LDR.W    R1,??CenterLineGetNormal_0+0x14
        STRB     R0,[R1, #+0]
        LDR.W    R0,??DataTable44
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.W    ??CenterLineGetNormal_50
        MOVS     R0,#+1
        MOVS     R1,#+1
        MOVS     R3,#+1
        MOVS     R2,#+1
        LDR.W    R4,??CenterLineGetNormal_0+0x8
        LDRB     R4,[R4, #+0]
        CMP      R4,#+55
        BLT.N    ??CenterLineGetNormal_51
        MOVS     R0,#+0
??CenterLineGetNormal_51:
        LDR.W    R4,??CenterLineGetNormal_0+0xC
        LDRB     R4,[R4, #+0]
        CMP      R4,#+59
        BGE.N    ??CenterLineGetNormal_52
        LDR.W    R4,??CenterLineGetNormal_0+0xC
        LDRB     R4,[R4, #+0]
        CMP      R4,#+12
        BGE.N    ??CenterLineGetNormal_52
        MOVS     R1,#+0
??CenterLineGetNormal_52:
        LDR.W    R4,??CenterLineGetNormal_26
        LDRB     R4,[R4, #+0]
        CMP      R4,#+55
        BLT.N    ??CenterLineGetNormal_53
        MOVS     R3,#+0
??CenterLineGetNormal_53:
        LDR.W    R4,??CenterLineGetNormal_26+0x4
        LDRB     R4,[R4, #+0]
        CMP      R4,#+59
        BGE.N    ??CenterLineGetNormal_54
        LDR.W    R4,??CenterLineGetNormal_26+0x4
        LDRB     R4,[R4, #+0]
        CMP      R4,#+12
        BGE.N    ??CenterLineGetNormal_54
        MOVS     R2,#+0
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??CenterLineGetNormal_54
        MOVS     R0,#+0
        B.N      ??CenterLineGetNormal_4
??CenterLineGetNormal_54:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+1
        BNE.W    ??CenterLineGetNormal_55
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.W    ??CenterLineGetNormal_55
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??CenterLineGetNormal_56
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BEQ.N    ??CenterLineGetNormal_57
??CenterLineGetNormal_56:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??CenterLineGetNormal_58
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BEQ.N    ??CenterLineGetNormal_57
??CenterLineGetNormal_58:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.W    ??CenterLineGetNormal_55
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.W    ??CenterLineGetNormal_55
??CenterLineGetNormal_57:
        LDR.W    R0,??CenterLineGetNormal_26+0x4
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGetNormal_26
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGetNormal_59
        LDR.W    R0,??CenterLineGetNormal_34+0x4
        LDR.W    R1,??CenterLineGetNormal_26+0x4
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??CenterLineGetNormal_34+0x4
        LDR.W    R2,??CenterLineGetNormal_26+0x4
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.W    R0,??CenterLineGetNormal_34+0x4
        LDR.W    R1,??CenterLineGetNormal_26+0x4
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.W    R1,??CenterLineGetNormal_34+0x4
        LDR.W    R2,??CenterLineGetNormal_26+0x4
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGetNormal_60
??CenterLineGetNormal_59:
        MOVS     R0,#+0
??CenterLineGetNormal_60:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable45  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        MOVS     R7,R0
        LDR.W    R0,??CenterLineGetNormal_0+0x28
        LDRB     R0,[R0, #+0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        SDIV     R0,R0,R7
        BL       __aeabi_i2f
        LDR.W    R1,??DataTable45_1
        STR      R0,[R1, #+0]
        LDR.W    R0,??DataTable45_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??CenterLineGetNormal_61
        LDR.W    R0,??CenterLineGetNormal_0+0x28
        LDRB     R1,[R0, #+0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R0,R7
        BL       MaxRe
        LDR.W    R1,??CenterLineGetNormal_0+0x28
        STRB     R0,[R1, #+0]
??CenterLineGetNormal_61:
        LDR.W    R0,??CenterLineGetNormal_0+0x28
        LDRB     R0,[R0, #+0]
        MOVS     R8,#+0
        MOVS     R9,#+0
        MOVS     R0,#+0
        LDR.W    R1,??CenterLineGetNormal_0+0x2C
        STRH     R0,[R1, #+0]
        LDR.W    R0,??CenterLineGetNormal_0+0x10
        LDRB     R6,[R0, #+0]
        B.N      ??CenterLineGetNormal_62
??CenterLineGetNormal_55:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.W    ??CenterLineGetNormal_63
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.W    ??CenterLineGetNormal_63
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BNE.N    ??CenterLineGetNormal_64
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BEQ.N    ??CenterLineGetNormal_65
??CenterLineGetNormal_64:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+1
        BNE.N    ??CenterLineGetNormal_66
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BEQ.N    ??CenterLineGetNormal_65
??CenterLineGetNormal_66:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BNE.N    ??CenterLineGetNormal_63
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.N    ??CenterLineGetNormal_63
??CenterLineGetNormal_65:
        LDR.W    R0,??CenterLineGetNormal_0+0xC
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGetNormal_0+0x8
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGetNormal_67
        LDR.W    R0,??CenterLineGetNormal_0+0x1C
        LDR.W    R1,??CenterLineGetNormal_0+0xC
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??CenterLineGetNormal_0+0x1C
        LDR.W    R2,??CenterLineGetNormal_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.W    R0,??CenterLineGetNormal_0+0x1C
        LDR.W    R1,??CenterLineGetNormal_0+0xC
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.W    R1,??CenterLineGetNormal_0+0x1C
        LDR.W    R2,??CenterLineGetNormal_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGetNormal_68
??CenterLineGetNormal_67:
        MOVS     R0,#+0
??CenterLineGetNormal_68:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable45  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        MOVS     R7,R0
        LDR.W    R0,??CenterLineGetNormal_0+0x28
        LDRB     R0,[R0, #+0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        SDIV     R0,R0,R7
        BL       __aeabi_i2f
        LDR.W    R1,??DataTable45_1
        STR      R0,[R1, #+0]
        LDR.W    R0,??DataTable45_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??CenterLineGetNormal_61
        LDR.W    R0,??CenterLineGetNormal_0+0x28
        LDRB     R1,[R0, #+0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R0,R7
        BL       MaxRe
        LDR.W    R1,??CenterLineGetNormal_0+0x28
        STRB     R0,[R1, #+0]
        B.N      ??CenterLineGetNormal_61
??CenterLineGetNormal_63:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.W    ??CenterLineGetNormal_69
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.W    ??CenterLineGetNormal_69
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+1
        BNE.W    ??CenterLineGetNormal_69
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.W    ??CenterLineGetNormal_69
        LDR.W    R0,??CenterLineGetNormal_0+0xC
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGetNormal_0+0x8
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGetNormal_70
        LDR.W    R0,??CenterLineGetNormal_0+0x1C
        LDR.W    R1,??CenterLineGetNormal_0+0xC
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??CenterLineGetNormal_0+0x1C
        LDR.W    R2,??CenterLineGetNormal_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.W    R0,??CenterLineGetNormal_0+0x1C
        LDR.W    R1,??CenterLineGetNormal_0+0xC
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.W    R1,??CenterLineGetNormal_0+0x1C
        LDR.W    R2,??CenterLineGetNormal_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGetNormal_71
??CenterLineGetNormal_70:
        MOVS     R0,#+0
??CenterLineGetNormal_71:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable45  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        MOVS     R7,R0
        LDR.W    R0,??CenterLineGetNormal_26+0x4
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGetNormal_26
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGetNormal_72
        LDR.W    R0,??CenterLineGetNormal_34+0x4
        LDR.W    R1,??CenterLineGetNormal_26+0x4
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??CenterLineGetNormal_34+0x4
        LDR.W    R2,??CenterLineGetNormal_26+0x4
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.W    R0,??CenterLineGetNormal_34+0x4
        LDR.W    R1,??CenterLineGetNormal_26+0x4
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.W    R1,??CenterLineGetNormal_34+0x4
        LDR.W    R2,??CenterLineGetNormal_26+0x4
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGetNormal_73
??CenterLineGetNormal_72:
        MOVS     R0,#+0
??CenterLineGetNormal_73:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,R0
        MOVS     R3,R1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R1,R7
        MOVS     R4,R1
        MOVS     R0,#+0
        LDR.W    R1,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable45  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R1,R4
        BL       MaxRe
        MOVS     R7,R0
        LDR.W    R0,??CenterLineGetNormal_0+0x28
        LDRB     R0,[R0, #+0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        SDIV     R0,R0,R7
        BL       __aeabi_i2f
        LDR.W    R1,??DataTable45_1
        STR      R0,[R1, #+0]
        LDR.W    R0,??DataTable45_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??CenterLineGetNormal_61
        LDR.W    R0,??CenterLineGetNormal_0+0x28
        LDRB     R1,[R0, #+0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R0,R7
        BL       MaxRe
        LDR.W    R1,??CenterLineGetNormal_0+0x28
        STRB     R0,[R1, #+0]
        B.N      ??CenterLineGetNormal_61
??CenterLineGetNormal_69:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??CenterLineGetNormal_74
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BNE.N    ??CenterLineGetNormal_74
        MOVS     R0,#+0
        B.N      ??CenterLineGetNormal_4
??CenterLineGetNormal_74:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??CenterLineGetNormal_75
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BNE.N    ??CenterLineGetNormal_75
        LDR.W    R0,??CenterLineGetNormal_0+0xC
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??CenterLineGetNormal_0+0x8
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGetNormal_76
        LDR.N    R0,??CenterLineGetNormal_0+0x1C
        LDR.N    R1,??CenterLineGetNormal_0+0xC
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.N    R1,??CenterLineGetNormal_0+0x1C
        LDR.N    R2,??CenterLineGetNormal_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.N    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.N    R0,??CenterLineGetNormal_0+0x1C
        LDR.N    R1,??CenterLineGetNormal_0+0xC
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.N    R1,??CenterLineGetNormal_0+0x1C
        LDR.N    R2,??CenterLineGetNormal_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGetNormal_77
??CenterLineGetNormal_76:
        MOVS     R0,#+0
??CenterLineGetNormal_77:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,#+0
        LDR.N    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable45  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        MOVS     R7,R0
        LDR.N    R0,??CenterLineGetNormal_0+0x28
        LDRB     R0,[R0, #+0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        SDIV     R0,R0,R7
        BL       __aeabi_i2f
        LDR.W    R1,??DataTable45_1
        STR      R0,[R1, #+0]
        LDR.W    R0,??DataTable45_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??CenterLineGetNormal_61
        LDR.N    R0,??CenterLineGetNormal_0+0x28
        LDRB     R1,[R0, #+0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R0,R7
        BL       MaxRe
        LDR.N    R1,??CenterLineGetNormal_0+0x28
        STRB     R0,[R1, #+0]
        B.N      ??CenterLineGetNormal_61
??CenterLineGetNormal_75:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??CenterLineGetNormal_78
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+1
        BNE.N    ??CenterLineGetNormal_78
        LDR.W    R0,??CenterLineGetNormal_26+0x4
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGetNormal_26
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGetNormal_79
        LDR.W    R0,??CenterLineGetNormal_34+0x4
        LDR.W    R1,??CenterLineGetNormal_26+0x4
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??CenterLineGetNormal_34+0x4
        LDR.W    R2,??CenterLineGetNormal_26+0x4
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.N    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.W    R0,??CenterLineGetNormal_34+0x4
        LDR.W    R1,??CenterLineGetNormal_26+0x4
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.W    R1,??CenterLineGetNormal_34+0x4
        LDR.W    R2,??CenterLineGetNormal_26+0x4
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGetNormal_80
??CenterLineGetNormal_79:
        MOVS     R0,#+0
??CenterLineGetNormal_80:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,#+0
        LDR.N    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable45  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        MOVS     R7,R0
        LDR.N    R0,??CenterLineGetNormal_0+0x28
        LDRB     R0,[R0, #+0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        SDIV     R0,R0,R7
        BL       __aeabi_i2f
        LDR.W    R1,??DataTable45_1
        STR      R0,[R1, #+0]
        LDR.W    R0,??DataTable45_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??CenterLineGetNormal_61
        LDR.N    R0,??CenterLineGetNormal_0+0x28
        LDRB     R1,[R0, #+0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R0,R7
        BL       MaxRe
        LDR.N    R1,??CenterLineGetNormal_0+0x28
        STRB     R0,[R1, #+0]
        B.N      ??CenterLineGetNormal_61
??CenterLineGetNormal_78:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.W    ??CenterLineGetNormal_81
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BNE.W    ??CenterLineGetNormal_81
        LDR.N    R0,??CenterLineGetNormal_0+0xC
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??CenterLineGetNormal_0+0x8
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGetNormal_82
        LDR.N    R0,??CenterLineGetNormal_0+0x1C
        LDR.N    R1,??CenterLineGetNormal_0+0xC
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.N    R1,??CenterLineGetNormal_0+0x1C
        LDR.N    R2,??CenterLineGetNormal_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.N    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.N    R0,??CenterLineGetNormal_0+0x1C
        LDR.N    R1,??CenterLineGetNormal_0+0xC
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.N    R1,??CenterLineGetNormal_0+0x1C
        LDR.N    R2,??CenterLineGetNormal_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGetNormal_83
??CenterLineGetNormal_82:
        MOVS     R0,#+0
??CenterLineGetNormal_83:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,#+0
        LDR.N    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable45  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        MOVS     R7,R0
        LDR.N    R0,??CenterLineGetNormal_26+0x4
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??CenterLineGetNormal_26
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGetNormal_84
        LDR.W    R0,??CenterLineGetNormal_34+0x4
        LDR.N    R1,??CenterLineGetNormal_26+0x4
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??CenterLineGetNormal_34+0x4
        LDR.N    R2,??CenterLineGetNormal_26+0x4
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.N    R3,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.W    R0,??CenterLineGetNormal_34+0x4
        LDR.N    R1,??CenterLineGetNormal_26+0x4
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.W    R1,??CenterLineGetNormal_34+0x4
        LDR.N    R2,??CenterLineGetNormal_26+0x4
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGetNormal_85
??CenterLineGetNormal_84:
        MOVS     R0,#+0
??CenterLineGetNormal_85:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,R0
        MOVS     R3,R1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R1,R7
        MOVS     R4,R1
        MOVS     R0,#+0
        LDR.N    R1,??CenterLineGetNormal_0+0x20  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable45  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R1,R4
        BL       MaxRe
        MOVS     R7,R0
        LDR.N    R0,??CenterLineGetNormal_0+0x28
        LDRB     R0,[R0, #+0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        SDIV     R0,R0,R7
        BL       __aeabi_i2f
        LDR.W    R1,??DataTable45_1
        STR      R0,[R1, #+0]
        LDR.W    R0,??DataTable45_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??CenterLineGetNormal_61
        LDR.N    R0,??CenterLineGetNormal_0+0x28
        LDRB     R1,[R0, #+0]
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R0,R7
        BL       MaxRe
        LDR.N    R1,??CenterLineGetNormal_0+0x28
        STRB     R0,[R1, #+0]
        B.N      ??CenterLineGetNormal_61
        DATA
??CenterLineGetNormal_0:
        DC32     BlackLeftDone
        DC32     BlackRightDone
        DC32     BlackLeftHeadLine
        DC32     BlackLeftEndLine
        DC32     CenterHeadLine
        DC32     CenterEndLine
        DC32     BlackLeftLoc
        DC32     BlackUdisLeftLocation
        DC32     0x3ff00000
        DC32     CenterLineHalfWidth
        DC32     RoadHalfWidth
        DC32     buXianCount
        DC32     CenterLineLoc
        THUMB
??CenterLineGetNormal_81:
        MOVS     R0,#+0
        B.W      ??CenterLineGetNormal_4
??CenterLineGetNormal_86:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BNE.N    ??CenterLineGetNormal_87
        MOVS     R7,#+0
??CenterLineGetNormal_87:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        LDR.W    R0,??DataTable48
        STRH     R7,[R0, R6, LSL #+1]
??CenterLineGetNormal_88:
        ADDS     R6,R6,#+1
??CenterLineGetNormal_62:
        CMP      R6,#+60
        BGE.W    ??CenterLineGetNormal_24
        LDR.W    R0,??DataTable48_1
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGetNormal_89
        LDR.N    R0,??CenterLineGetNormal_34
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGetNormal_89
        MOVS     R8,#+0
        LDR.W    R0,??DataTable48_1
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??CenterLineGetNormal_34
        MOVS     R2,#+3
        MLA      R1,R2,R6,R1
        LDRB     R1,[R1, #+0]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable48
        STRH     R0,[R1, R6, LSL #+1]
        B.N      ??CenterLineGetNormal_88
??CenterLineGetNormal_89:
        LDR.W    R0,??DataTable48_1
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGetNormal_90
        LDR.N    R0,??CenterLineGetNormal_34
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CenterLineGetNormal_88
??CenterLineGetNormal_90:
        LDR.W    R0,??DataTable48_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BEQ.N    ??CenterLineGetNormal_91
        LDR.W    R0,??DataTable48_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BNE.N    ??CenterLineGetNormal_92
??CenterLineGetNormal_91:
        LDR.W    R0,??DataTable48_4
        LDRH     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        LDR.W    R1,??DataTable48_4
        STRH     R0,[R1, #+0]
        B.N      ??CenterLineGetNormal_93
??CenterLineGetNormal_92:
        LDR.N    R0,??CenterLineGetNormal_26
        LDRB     R0,[R0, #+0]
        CMP      R0,#+25
        BLT.N    ??CenterLineGetNormal_94
        LDR.W    R0,??DataTable48_5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+25
        BLT.N    ??CenterLineGetNormal_94
        MOVS     R0,#+0
        LDR.W    R1,??DataTable48_4
        STRH     R0,[R1, #+0]
        B.N      ??CenterLineGetNormal_93
??CenterLineGetNormal_94:
        LDR.W    R0,??DataTable48_5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+21
        BGE.N    ??CenterLineGetNormal_95
        LDR.N    R0,??CenterLineGetNormal_26
        LDRB     R0,[R0, #+0]
        CMP      R0,#+50
        BLT.N    ??CenterLineGetNormal_95
        MOVS     R0,#+0
        LDR.W    R1,??DataTable48_4
        STRH     R0,[R1, #+0]
        B.N      ??CenterLineGetNormal_93
??CenterLineGetNormal_95:
        LDR.W    R0,??DataTable48_6
        LDRSH    R0,[R0, #+0]
        CMP      R0,#+0
        BPL.N    ??CenterLineGetNormal_96
        LDR.W    R0,??DataTable48_7
        LDRSH    R0,[R0, #+0]
        CMP      R0,#+1
        BGE.N    ??CenterLineGetNormal_97
??CenterLineGetNormal_96:
        LDR.W    R0,??DataTable48_6
        LDRSH    R0,[R0, #+0]
        CMP      R0,#+1
        BLT.N    ??CenterLineGetNormal_98
        LDR.W    R0,??DataTable48_7
        LDRSH    R0,[R0, #+0]
        CMP      R0,#+0
        BPL.N    ??CenterLineGetNormal_98
??CenterLineGetNormal_97:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable48_4
        STRH     R0,[R1, #+0]
        B.N      ??CenterLineGetNormal_93
??CenterLineGetNormal_98:
        LDR.W    R0,??DataTable48_5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+6
        BGE.N    ??CenterLineGetNormal_99
        MOVS     R0,#+0
        LDR.W    R1,??DataTable48_4
        STRH     R0,[R1, #+0]
        B.N      ??CenterLineGetNormal_93
??CenterLineGetNormal_99:
        LDR.W    R0,??DataTable48_5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+21
        BGE.N    ??CenterLineGetNormal_100
        LDR.N    R0,??CenterLineGetNormal_26
        LDRB     R0,[R0, #+0]
        CMP      R0,#+45
        BLT.N    ??CenterLineGetNormal_100
        MOVS     R0,#+0
        LDR.W    R1,??DataTable48_4
        STRH     R0,[R1, #+0]
        B.N      ??CenterLineGetNormal_93
??CenterLineGetNormal_100:
        LDR.W    R0,??DataTable48_6
        LDRSH    R0,[R0, #+0]
        BL       AbsInt
        CMP      R0,#+20
        BLT.N    ??CenterLineGetNormal_101
        LDR.W    R0,??DataTable48_6
        LDRSH    R0,[R0, #+0]
        BL       AbsInt
        CMP      R0,#+51
        BLT.N    ??CenterLineGetNormal_102
??CenterLineGetNormal_101:
        LDR.W    R0,??DataTable48_7
        LDRSH    R0,[R0, #+0]
        BL       AbsInt
        CMP      R0,#+20
        BLT.N    ??CenterLineGetNormal_103
        LDR.W    R0,??DataTable48_7
        LDRSH    R0,[R0, #+0]
        BL       AbsInt
        CMP      R0,#+51
        BGE.N    ??CenterLineGetNormal_103
??CenterLineGetNormal_102:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable48_4
        STRH     R0,[R1, #+0]
        B.N      ??CenterLineGetNormal_93
??CenterLineGetNormal_103:
        LDR.W    R0,??DataTable48_6
        LDRSH    R0,[R0, #+0]
        BL       AbsInt
        CMP      R0,#+51
        BLT.N    ??CenterLineGetNormal_104
        LDR.W    R0,??DataTable48_6
        LDRSH    R0,[R0, #+0]
        BL       AbsInt
        CMP      R0,#+2000
        BLE.N    ??CenterLineGetNormal_105
??CenterLineGetNormal_104:
        LDR.W    R0,??DataTable48_7
        LDRSH    R0,[R0, #+0]
        BL       AbsInt
        CMP      R0,#+51
        BLT.N    ??CenterLineGetNormal_106
        LDR.W    R0,??DataTable48_7
        LDRSH    R0,[R0, #+0]
        BL       AbsInt
        CMP      R0,#+2000
        BGT.N    ??CenterLineGetNormal_106
??CenterLineGetNormal_105:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable48_4
        STRH     R0,[R1, #+0]
        B.N      ??CenterLineGetNormal_93
??CenterLineGetNormal_106:
        LDR.W    R0,??DataTable48_6
        LDRSH    R0,[R0, #+0]
        BL       AbsInt
        CMP      R0,#+2000
        BGT.N    ??CenterLineGetNormal_107
        LDR.W    R0,??DataTable48_7
        LDRSH    R0,[R0, #+0]
        BL       AbsInt
        CMP      R0,#+2000
        BLE.N    ??CenterLineGetNormal_93
??CenterLineGetNormal_107:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable48_4
        STRH     R0,[R1, #+0]
??CenterLineGetNormal_93:
        MOVS     R8,#+0
        MOVS     R1,#+0
        SUBS     R0,R6,#+1
        B.N      ??CenterLineGetNormal_108
        DATA
??CenterLineGetNormal_26:
        DC32     BlackRightHeadLine
        DC32     BlackRightEndLine
        THUMB
??CenterLineGetNormal_109:
        SUBS     R0,R0,#+1
??CenterLineGetNormal_108:
        CMP      R0,#+0
        BMI.N    ??CenterLineGetNormal_110
        LDR.W    R2,??DataTable48
        LDRSH    R2,[R2, R0, LSL #+1]
        CMP      R2,#+255
        BEQ.N    ??CenterLineGetNormal_111
        LDR.W    R2,??DataTable48
        LDRH     R2,[R2, R0, LSL #+1]
        ADD      R3,SP,#+12
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R2,[R1, R3]
        ADD      R2,SP,#+16
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R0,[R1, R2]
        ADDS     R1,R1,#+1
??CenterLineGetNormal_111:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??CenterLineGetNormal_109
??CenterLineGetNormal_110:
        MOVS     R2,#+4
        ADD      R1,SP,#+12
        ADD      R0,SP,#+16
        BL       LeastSquarea1
        MOVS     R4,R0
        MOVS     R3,#+4
        MOVS     R2,R4
        ADD      R1,SP,#+12
        ADD      R0,SP,#+16
        BL       LeastSquarea0
        MOVS     R5,R0
        MLA      R0,R6,R4,R5
        MOV      R1,#+1000
        SDIV     R7,R0,R1
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+249
        BLT.W    ??CenterLineGetNormal_86
        MOVS     R7,#+249
        B.N      ??CenterLineGetNormal_87
??CenterLineGetNormal_50:
        MOVS     R8,#+0
        MOVS     R9,#+0
        LDR.W    R0,??DataTable48_8
        LDRB     R6,[R0, #+0]
        B.N      ??CenterLineGetNormal_112
??CenterLineGetNormal_113:
        SUBS     R6,R6,#+1
??CenterLineGetNormal_112:
        LDR.W    R0,??DataTable48_1
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGetNormal_114
        LDR.N    R0,??CenterLineGetNormal_34
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGetNormal_114
        MOVS     R8,#+0
        LDR.W    R0,??DataTable48_1
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??CenterLineGetNormal_34
        MOVS     R2,#+3
        MLA      R1,R2,R6,R1
        LDRB     R1,[R1, #+0]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable48
        STRH     R0,[R1, R6, LSL #+1]
        LDR.N    R0,??CenterLineGetNormal_34
        LDR.W    R1,??DataTable48_1
        CMP      R0,R1
        BCC.N    ??CenterLineGetNormal_115
        LDR.N    R0,??CenterLineGetNormal_34
        LDR.W    R1,??DataTable48_1
        SUBS     R0,R0,R1
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable48_9
        STRB     R0,[R1, #+0]
        B.N      ??CenterLineGetNormal_116
??CenterLineGetNormal_115:
        LDR.W    R0,??DataTable48_1
        LDR.N    R1,??CenterLineGetNormal_34
        SUBS     R0,R0,R1
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable48_9
        STRB     R0,[R1, #+0]
        B.N      ??CenterLineGetNormal_116
        DATA
??CenterLineGetNormal_34:
        DC32     BlackRightLoc
        DC32     BlackUdisRightLocation
        THUMB
??CenterLineGetNormal_114:
        LDR.W    R0,??DataTable48_1
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGetNormal_117
        LDR.W    R0,??DataTable48_10
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CenterLineGetNormal_117
        MOVS     R8,#+0
        LDR.W    R0,??DataTable48_1
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable48_9
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable48
        STRH     R0,[R1, R6, LSL #+1]
        B.N      ??CenterLineGetNormal_116
??CenterLineGetNormal_117:
        LDR.W    R0,??DataTable48_1
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CenterLineGetNormal_118
        LDR.W    R0,??DataTable48_10
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGetNormal_118
        MOVS     R8,#+0
        LDR.W    R0,??DataTable48_10
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable48_9
        LDRB     R1,[R1, #+0]
        ADDS     R0,R1,R0
        LDR.W    R1,??DataTable48
        STRH     R0,[R1, R6, LSL #+1]
        B.N      ??CenterLineGetNormal_116
??CenterLineGetNormal_118:
        LDR.W    R0,??DataTable48_1
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.W    ??CenterLineGetNormal_116
        LDR.W    R0,??DataTable48_10
        MOVS     R1,#+3
        MLA      R0,R1,R6,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.W    ??CenterLineGetNormal_116
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+0
        BNE.N    ??CenterLineGetNormal_119
        MOVS     R8,#+1
        ADDS     R0,R6,#+6
        CMP      R0,#+60
        BGE.N    ??CenterLineGetNormal_120
        MOVS     R9,#+0
        MOVS     R0,#+0
        B.N      ??CenterLineGetNormal_121
??CenterLineGetNormal_122:
        ADDS     R1,R0,R6
        ADDS     R1,R1,#+3
        ADD      R2,SP,#+0
        STRB     R1,[R0, R2]
        LDR.W    R1,??DataTable48
        ADDS     R2,R0,R6
        ADDS     R1,R1,R2, LSL #+1
        LDRH     R1,[R1, #+6]
        ADD      R2,SP,#+4
        STRH     R1,[R2, R0, LSL #+1]
        ADDS     R0,R0,#+1
??CenterLineGetNormal_121:
        CMP      R0,#+4
        BLT.N    ??CenterLineGetNormal_122
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a1
        MOVS     R4,R0
        MOVS     R3,#+4
        MOVS     R2,R4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a0
        MOVS     R5,R0
        B.N      ??CenterLineGetNormal_119
??CenterLineGetNormal_120:
        ADDS     R0,R6,#+5
        CMP      R0,#+60
        BGE.N    ??CenterLineGetNormal_123
        MOVS     R9,#+0
        MOVS     R0,#+0
        B.N      ??CenterLineGetNormal_124
??CenterLineGetNormal_125:
        ADDS     R1,R0,R6
        ADDS     R1,R1,#+2
        ADD      R2,SP,#+0
        STRB     R1,[R0, R2]
        LDR.W    R1,??DataTable48
        ADDS     R2,R0,R6
        ADDS     R1,R1,R2, LSL #+1
        LDRH     R1,[R1, #+4]
        ADD      R2,SP,#+4
        STRH     R1,[R2, R0, LSL #+1]
        ADDS     R0,R0,#+1
??CenterLineGetNormal_124:
        CMP      R0,#+4
        BLT.N    ??CenterLineGetNormal_125
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a1
        MOVS     R4,R0
        MOVS     R3,#+4
        MOVS     R2,R4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a0
        MOVS     R5,R0
        B.N      ??CenterLineGetNormal_119
??CenterLineGetNormal_123:
        ADDS     R0,R6,#+4
        CMP      R0,#+60
        BGE.N    ??CenterLineGetNormal_126
        MOVS     R9,#+0
        MOVS     R0,#+0
        B.N      ??CenterLineGetNormal_127
??CenterLineGetNormal_128:
        ADDS     R1,R0,R6
        ADDS     R1,R1,#+1
        ADD      R2,SP,#+0
        STRB     R1,[R0, R2]
        LDR.W    R1,??DataTable48
        ADDS     R2,R0,R6
        ADDS     R1,R1,R2, LSL #+1
        LDRH     R1,[R1, #+2]
        ADD      R2,SP,#+4
        STRH     R1,[R2, R0, LSL #+1]
        ADDS     R0,R0,#+1
??CenterLineGetNormal_127:
        CMP      R0,#+4
        BLT.N    ??CenterLineGetNormal_128
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a1
        MOVS     R4,R0
        MOVS     R3,#+4
        MOVS     R2,R4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a0
        MOVS     R5,R0
        B.N      ??CenterLineGetNormal_119
??CenterLineGetNormal_126:
        MOVS     R9,#+1
??CenterLineGetNormal_119:
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        CMP      R9,#+0
        BNE.N    ??CenterLineGetNormal_129
        MLA      R0,R6,R4,R5
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable48
        STRH     R0,[R1, R6, LSL #+1]
        B.N      ??CenterLineGetNormal_116
??CenterLineGetNormal_129:
        LDR.W    R0,??DataTable48
        ADDS     R0,R0,R6, LSL #+1
        LDRH     R0,[R0, #+2]
        LDR.W    R1,??DataTable48
        ADDS     R1,R1,R6, LSL #+1
        LDRH     R1,[R1, #+2]
        ADDS     R0,R1,R0
        LDR.W    R1,??DataTable48
        ADDS     R1,R1,R6, LSL #+1
        LDRH     R1,[R1, #+4]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable48
        STRH     R0,[R1, R6, LSL #+1]
??CenterLineGetNormal_116:
        CMP      R6,#+0
        BNE.W    ??CenterLineGetNormal_113
        LDR.W    R0,??DataTable48_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BEQ.W    ??CenterLineGetNormal_24
        MOVS     R6,#+59
        B.N      ??CenterLineGetNormal_130
??CenterLineGetNormal_131:
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable48
        STRH     R0,[R1, R6, LSL #+1]
        SUBS     R6,R6,#+1
??CenterLineGetNormal_130:
        LDR.W    R0,??DataTable48_8
        LDRB     R0,[R0, #+0]
        CMP      R6,R0
        BNE.N    ??CenterLineGetNormal_131
        B.W      ??CenterLineGetNormal_24
??CenterLineGetNormal_49:
        MOVS     R0,#+0
        B.W      ??CenterLineGetNormal_4
// 8741 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44:
        DC32     SingleBlackAllFlag
// 8742 
// 8743 
// 8744 
// 8745 //障碍，锁存后，用以确定是否开始特殊控制。返回1开始，0再等等

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 8746 uint8 BrickSpeDealStartJudge(void)
// 8747 {
// 8748   uint8 col, count1, i, index;
// 8749   int32 a0, a1;
// 8750   uint8 x[BrickSlopeRowNum];   //取多少个点在一开始有定义。
// 8751   uint8 y[BrickSlopeRowNum];
// 8752   
// 8753   return 1;   ///////////////不等待，直接特殊控制。
BrickSpeDealStartJudge:
        MOVS     R0,#+1
        BX       LR               ;; return
// 8754   
// 8755   //通过判断障碍是不是向近处越过了某一行，从而判断是否开始特殊控制。
// 8756   
// 8757   //左障碍
// 8758   if(BrickSpeDealDir == 0)
// 8759   {
// 8760     //最小二乘法计算扫描起始行和结束行的黑点所在列。
// 8761     //取BrickSlopeRowNum个点作为最小二乘法的基准点。
// 8762     //以左上角为原点，向下为x轴正方向，向右为y轴正方向
// 8763     index = 0;
// 8764     for(i = CameraHight - 1; ; i--)
// 8765     {
// 8766       if(BlackLeftLoc[i][0] != MaxValUint8)
// 8767       {
// 8768         y[index] = BlackLeftLoc[i][0];
// 8769         x[index] = i;
// 8770         index++;
// 8771       }
// 8772       if(index == BrickSlopeRowNum)
// 8773       {
// 8774         break;
// 8775       }
// 8776       if(i == BrickSpeDealStartJudgeRow) //CameraHight-BrickSpeDealStartJudgeRow必须比BrickSlopeRowNum大
// 8777       {
// 8778         return 0;
// 8779       }
// 8780     }
// 8781     //最小二乘法
// 8782     //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
// 8783     a1 = LeastSquarea1(x, y, BrickSlopeRowNum);
// 8784     a0 = LeastSquarea0(x, y, a1, BrickSlopeRowNum);
// 8785    
// 8786     //对特定一行的处理。
// 8787     //该行黑点计数，左障碍从右往左扫描。
// 8788     count1 = 0;
// 8789     //当前行的扫描左边界。
// 8790     BrickSpeDealStartJudgeCol = (a0 + a1 * BrickSpeDealStartJudgeRow) / LeastSquareMulti;
// 8791     //向右BrickScanColNum列为右边界
// 8792     for(col = BrickSpeDealStartJudgeCol + BrickScanColNum; ; col--)
// 8793     {
// 8794       if(ImgNew[BrickSpeDealStartJudgeRow][col] < LimitLeftB)  //够黑
// 8795       {
// 8796         count1++;
// 8797       }
// 8798       else
// 8799       {
// 8800       }
// 8801       //向左扫描至左边界。
// 8802       if(col <= BrickSpeDealStartJudgeCol || col == 0) break;
// 8803     }
// 8804     
// 8805     //该行黑点个数大于BrickLineBlackCountNum个时，则行计数加1.
// 8806     if(count1 > BrickLineBlackCountNum) 
// 8807     {
// 8808       return 1;
// 8809     }
// 8810     else
// 8811     {
// 8812     }
// 8813   }
// 8814   //右障碍
// 8815   else
// 8816   {
// 8817     //最小二乘法计算扫描起始行和结束行的黑点所在列。
// 8818     //取BrickSlopeRowNum个点作为最小二乘法的基准点。
// 8819     //以左上角为原点，向下为x轴正方向，向右为y轴正方向
// 8820     index = 0;
// 8821     for(i = CameraHight - 1; ; i--)
// 8822     {
// 8823       if(BlackRightLoc[i][0] != MaxValUint8)
// 8824       {
// 8825         y[index] = BlackRightLoc[i][0];
// 8826         x[index] = i;
// 8827         index++;
// 8828       }
// 8829       if(index == BrickSlopeRowNum)
// 8830       {
// 8831         break;
// 8832       }
// 8833       if(i == BrickSpeDealStartJudgeRow) //CameraHight-BrickSpeDealStartJudgeRow必须比BrickSlopeRowNum大
// 8834       {
// 8835         return 0;
// 8836       }
// 8837     }
// 8838     //最小二乘法
// 8839     //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
// 8840     a1 = LeastSquarea1(x, y, BrickSlopeRowNum);
// 8841     a0 = LeastSquarea0(x, y, a1, BrickSlopeRowNum);
// 8842    
// 8843     //对特定一行的处理。
// 8844     //该行黑点计数，右障碍从左往右扫描。
// 8845     count1 = 0;
// 8846     //当前行的扫描左边界。
// 8847     BrickSpeDealStartJudgeCol = (a0 + a1 * BrickSpeDealStartJudgeRow) / LeastSquareMulti;
// 8848     //向左BrickScanColNum列为左边界
// 8849     for(col = BrickSpeDealStartJudgeCol - BrickScanColNum; ; col++)
// 8850     {
// 8851       if(ImgNew[BrickSpeDealStartJudgeRow][col] < LimitRightB)  //够黑
// 8852       {
// 8853         count1++;
// 8854       }
// 8855       else
// 8856       {
// 8857       }
// 8858       //向右扫描至右边界。
// 8859       if(col >= BrickSpeDealStartJudgeCol || col >= CameraRealWidth - 1) break;
// 8860     }
// 8861     
// 8862     //该行黑点个数大于BrickLineBlackCountNum个时，则行计数加1.
// 8863     if(count1 > BrickLineBlackCountNum) 
// 8864     {
// 8865       return 1;
// 8866     }
// 8867     else
// 8868     {
// 8869     }
// 8870   }
// 8871   
// 8872   //常态为再等等。
// 8873   return 0;
// 8874 }
// 8875 
// 8876 
// 8877 
// 8878 //障碍，特殊控制时，用以确定是否退出特殊控制。
// 8879 //改变BrickSpeDealExitJudgeFlag，1~2继续特殊控制，其中1表示初始态，2表示当前已经与障碍平行，0退出特殊控制，把控制权交还给普通控制。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 8880 uint8 BrickSpeDealExitJudge(void)
// 8881 {
// 8882   return 1;   //////////////不改变退出标志位，只通过倒计时来控制特殊控制的次数。
BrickSpeDealExitJudge:
        MOVS     R0,#+1
        BX       LR               ;; return
// 8883   
// 8884   
// 8885   //根据第CameraHight - 1行的赛道半宽来，先必须检测到小于65的样子，然后必须检测到大于75（不是65，有返回系数的意思）的样子。
// 8886   //左右障碍不用区分，没有必要。
// 8887 
// 8888   //当前为初始态，需要判断是不是已经跟障碍物平行了。
// 8889   if(BrickSpeDealExitJudgeFlag == 1)
// 8890   {
// 8891     if(
// 8892        (BlackLeftLoc[CameraHight - 1][0] != MaxValUint8)
// 8893     && (BlackRightLoc[CameraHight - 1][0] != MaxValUint8)
// 8894     && (BlackRightLoc[CameraHight - 1][0] > BlackLeftLoc[CameraHight - 1][0]) //两线有效
// 8895     && (BlackRightLoc[CameraHight - 1][0] - BlackLeftLoc[CameraHight - 1][0] < BrickSpeDealExitState1Val * 2) //赛道半宽小于一定值
// 8896       )
// 8897     {
// 8898       //符合所有条件，过渡到状态2，表示已经与障碍物平行。
// 8899       BrickSpeDealExitJudgeFlag = 2;
// 8900     }
// 8901     else
// 8902     {
// 8903     }
// 8904   }
// 8905   //当前已经与障碍物平行了，需要判断是不是车前端已经越过了障碍物从而退出特殊控制。
// 8906   else if(BrickSpeDealExitJudgeFlag == 2)
// 8907   {
// 8908     if(
// 8909        (BlackLeftLoc[CameraHight - 1][0] != MaxValUint8)
// 8910     && (BlackRightLoc[CameraHight - 1][0] != MaxValUint8)
// 8911     && (BlackRightLoc[CameraHight - 1][0] > BlackLeftLoc[CameraHight - 1][0]) //两线有效
// 8912     && (BlackRightLoc[CameraHight - 1][0] - BlackLeftLoc[CameraHight - 1][0] > BrickSpeDealExitState2Val * 2) //赛道半宽大于一定值
// 8913       )
// 8914     {
// 8915       //符合所有条件，过渡到状态0，表示车前端已经一定程序越过障碍物，退出特殊控制。
// 8916       BrickSpeDealExitJudgeFlag = 0;
// 8917     }
// 8918     else
// 8919     {
// 8920     }
// 8921   }
// 8922   //理论上不会到这里。
// 8923   else
// 8924   {
// 8925   }
// 8926 
// 8927   return 1;
// 8928 }
// 8929 
// 8930 
// 8931 
// 8932 //障碍物对舵机的特殊处理。///////////////////////////不知道是不是鸡肋

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 8933 uint8 BrickSpeDealServor(void)
// 8934 {  
// 8935   //舵机打角限幅。
// 8936   //左障碍，不能往右打太多。
// 8937   if(BrickSpeDealFlag == 1 && BrickSpeDealCenFlag == 0 && BrickSpeDealDir == 0)
BrickSpeDealServor:
        LDR.W    R0,??DataTable48_11
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BrickSpeDealServor_0
        LDR.W    R0,??DataTable48_12
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??BrickSpeDealServor_0
        LDR.W    R0,??DataTable48_13
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??BrickSpeDealServor_0
// 8938   {
// 8939     //强制左转，侧撞总比出线好。
// 8940     ServoPIDInputVal = ServoPIDCen - 100;
        MOVW     R0,#+1630
        LDR.W    R1,??DataTable48_14
        STR      R0,[R1, #+0]
        B.N      ??BrickSpeDealServor_1
// 8941     //ServoPIDInputVal = ServoPIDCen - 0;
// 8942     //StopFlag = 1;
// 8943   }
// 8944   //右障碍，不能往左打太多。
// 8945   else if(BrickSpeDealFlag == 1 && BrickSpeDealCenFlag == 0 && BrickSpeDealDir == 1)
??BrickSpeDealServor_0:
        LDR.W    R0,??DataTable48_11
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BrickSpeDealServor_1
        LDR.W    R0,??DataTable48_12
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??BrickSpeDealServor_1
        LDR.W    R0,??DataTable48_13
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BrickSpeDealServor_1
// 8946   {
// 8947     //强制右转，侧撞总比出线好。
// 8948     ServoPIDInputVal = ServoPIDCen + 100;  
        MOVW     R0,#+1830
        LDR.W    R1,??DataTable48_14
        STR      R0,[R1, #+0]
// 8949     //ServoPIDInputVal = ServoPIDCen + 0;
// 8950     
// 8951     //StopFlag = 1;
// 8952   }
// 8953   //不是障碍，不用限制
// 8954   else
// 8955   {    
// 8956   }
// 8957 
// 8958   return 1;
??BrickSpeDealServor_1:
        MOVS     R0,#+1
        BX       LR               ;; return
// 8959 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable45:
        DC32     0x40690000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable45_1:
        DC32     RoadHalfWidthCompen

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable45_2:
        DC32     RoadHalfWidthSwitch
// 8960 
// 8961 
// 8962 
// 8963 
// 8964 //障碍，对中心线的特殊处理。不直接修改DeviFuse，而是某一条黑线给出一条修正后的中心线。然后交由ImgProSucceedDeal()函数里的DeviFuse更新函数去弄。
// 8965 //会对CenterLineLoc[]数组产生影响。
// 8966 //进来之前，黑线一定是连续的。所以直接从线尾补到线头即可。
// 8967 //如果直接用BlackLoc数组不太理想，可以尝试使用畸变矫正后的数组，会更直。/////////////////////////

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 8968 uint8 BrickSpeDealCen(void)
// 8969 {
// 8970   uint8 row;
// 8971   
// 8972   //左障碍，按右线往左一小段来补线。
// 8973   if(BrickSpeDealDir == 0)
BrickSpeDealCen:
        LDR.W    R0,??DataTable48_13
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??BrickSpeDealCen_0
// 8974   {
// 8975     //图像失败或非障碍边失败时，不允许补线，返回失败。之后会根据上一幅图的DeviFuse来强制给。
// 8976     if(ImgBlackSucceedFlag == 0 || BlackRightDone == 0)
        LDR.W    R0,??DataTable48_15
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??BrickSpeDealCen_1
        LDR.W    R0,??DataTable48_16
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??BrickSpeDealCen_2
// 8977     {
// 8978       return 0;
??BrickSpeDealCen_1:
        MOVS     R0,#+0
        B.N      ??BrickSpeDealCen_3
// 8979     }
// 8980     else
// 8981     {
// 8982     }
// 8983     
// 8984     //线头线尾
// 8985     //CenterHeadLine = BlackRightHeadLine;
// 8986     CenterHeadLine = 0;
??BrickSpeDealCen_2:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable48_17
        STRB     R0,[R1, #+0]
// 8987     CenterEndLine = BlackRightEndLine;
        LDR.W    R0,??DataTable48_18
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable48_8
        STRB     R0,[R1, #+0]
// 8988     
// 8989     //采用未矫正的数组构造中心线数组，来避障
// 8990     if(BrickSpeDealCenChoose == 0)
// 8991     {
// 8992       //逐行补线
// 8993       for(row = BlackRightEndLine; ; row--)
        LDR.W    R0,??DataTable48_18
        LDRB     R0,[R0, #+0]
        B.N      ??BrickSpeDealCen_4
??BrickSpeDealCen_5:
        SUBS     R0,R0,#+1
// 8994       {
// 8995         CenterLineLoc[row] = BlackRightLoc[row][0] - BrickSpeDealBias[BrickSpeDealBackCount] + (BrickConfirmFinalColCom - 50); //BrickConfirmFinalColCom用于OLED修正
??BrickSpeDealCen_4:
        LDR.W    R1,??DataTable48_10
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable48_19
        LDR.W    R3,??DataTable48_20
        LDRB     R3,[R3, #+0]
        LDR      R2,[R2, R3, LSL #+2]
        SUBS     R1,R1,R2
        LDR.W    R2,??DataTable48_21
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2
        SUBS     R1,R1,#+50
        LDR.N    R2,??DataTable48
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRH     R1,[R2, R0, LSL #+1]
// 8996         
// 8997         if(row == BlackRightHeadLine) break;
        LDR.W    R1,??DataTable48_22
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BNE.N    ??BrickSpeDealCen_5
// 8998       }
// 8999     }
// 9000     //采用矫正后的数组构造中心线数组，来避障
// 9001     else
// 9002     {
// 9003       //逐行补线
// 9004       for(row = BlackRightEndLine; ; row--)
// 9005       {
// 9006         CenterLineLoc[row] = BlackUdisRightLocation[row].x - BrickSpeDealBias[BrickSpeDealBackCount] + (BrickConfirmFinalColCom - 50); //BrickConfirmFinalColCom用于OLED修正
// 9007         
// 9008         if(row == BlackRightHeadLine) break;
// 9009       }      
// 9010     }
// 9011     
// 9012     //一直补到最顶行。
// 9013     if(BlackRightHeadLine != 0)
        LDR.W    R0,??DataTable48_22
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??BrickSpeDealCen_6
// 9014     {
// 9015       for(row = BlackRightHeadLine - 1; ; row--)
        LDR.N    R0,??DataTable48_22
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        B.N      ??BrickSpeDealCen_7
??BrickSpeDealCen_8:
        SUBS     R0,R0,#+1
// 9016       {
// 9017         CenterLineLoc[row] = CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2];
??BrickSpeDealCen_7:
        LDR.N    R1,??DataTable48
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R1,R1,R0, LSL #+1
        LDRH     R1,[R1, #+2]
        LDR.N    R2,??DataTable48
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R2,R2,R0, LSL #+1
        LDRH     R2,[R2, #+2]
        ADDS     R1,R2,R1
        LDR.N    R2,??DataTable48
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R2,R2,R0, LSL #+1
        LDRH     R2,[R2, #+4]
        SUBS     R1,R1,R2
        LDR.N    R2,??DataTable48
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRH     R1,[R2, R0, LSL #+1]
// 9018         
// 9019         if(row == 0) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BrickSpeDealCen_8
        B.N      ??BrickSpeDealCen_6
// 9020       }
// 9021     }
// 9022     else
// 9023     {     
// 9024     }
// 9025     
// 9026   }
// 9027   //右障碍，按左线往右一小段来补线。
// 9028   else
// 9029   {
// 9030     //图像失败或非障碍边失败时，不允许补线，返回失败。之后会根据上一幅图的DeviFuse来强制给。
// 9031     if(ImgBlackSucceedFlag == 0 || BlackLeftDone == 0)
??BrickSpeDealCen_0:
        LDR.N    R0,??DataTable48_15
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??BrickSpeDealCen_9
        LDR.N    R0,??DataTable48_23
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??BrickSpeDealCen_10
// 9032     {
// 9033       return 0;
??BrickSpeDealCen_9:
        MOVS     R0,#+0
        B.N      ??BrickSpeDealCen_3
// 9034     }
// 9035     else
// 9036     {
// 9037     }
// 9038     
// 9039     //线头线尾
// 9040     //CenterHeadLine = BlackLeftHeadLine;
// 9041     CenterHeadLine = 0;
??BrickSpeDealCen_10:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable48_17
        STRB     R0,[R1, #+0]
// 9042     CenterEndLine = BlackLeftEndLine;
        LDR.N    R0,??DataTable48_24
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable48_8
        STRB     R0,[R1, #+0]
// 9043     
// 9044     //采用未矫正的数组构造中心线数组，来避障
// 9045     if(BrickSpeDealCenChoose == 0)
// 9046     {
// 9047       //逐行补线
// 9048       for(row = BlackLeftEndLine; ; row--)
        LDR.N    R0,??DataTable48_24
        LDRB     R0,[R0, #+0]
        B.N      ??BrickSpeDealCen_11
??BrickSpeDealCen_12:
        SUBS     R0,R0,#+1
// 9049       {
// 9050         CenterLineLoc[row] = BlackLeftLoc[row][0] + BrickSpeDealBias[BrickSpeDealBackCount] - (BrickConfirmFinalColCom - 50); //BrickConfirmFinalColCom用于OLED修正
??BrickSpeDealCen_11:
        LDR.N    R1,??DataTable48_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        LDR.N    R2,??DataTable48_19
        LDR.N    R3,??DataTable48_20
        LDRB     R3,[R3, #+0]
        LDR      R2,[R2, R3, LSL #+2]
        ADDS     R1,R2,R1
        LDR.N    R2,??DataTable48_21
        LDRB     R2,[R2, #+0]
        SUBS     R1,R1,R2
        ADDS     R1,R1,#+50
        LDR.N    R2,??DataTable48
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRH     R1,[R2, R0, LSL #+1]
// 9051         
// 9052         if(row == BlackLeftHeadLine) break;
        LDR.N    R1,??DataTable48_5
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BNE.N    ??BrickSpeDealCen_12
// 9053       }
// 9054     }
// 9055     //采用矫正后的数组构造中心线数组，来避障
// 9056     else
// 9057     {
// 9058       //逐行补线
// 9059       for(row = BlackLeftEndLine; ; row--)
// 9060       {
// 9061         CenterLineLoc[row] = BlackUdisLeftLocation[row].x + BrickSpeDealBias[BrickSpeDealBackCount] - (BrickConfirmFinalColCom - 50); //BrickConfirmFinalColCom用于OLED修正
// 9062         
// 9063         if(row == BlackLeftHeadLine) break;
// 9064       }      
// 9065     }
// 9066     
// 9067     //一直补到最顶行。
// 9068     if(BlackLeftHeadLine != 0)
        LDR.N    R0,??DataTable48_5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??BrickSpeDealCen_6
// 9069     {
// 9070       for(row = BlackLeftHeadLine - 1; ; row--)
        LDR.N    R0,??DataTable48_5
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        B.N      ??BrickSpeDealCen_13
??BrickSpeDealCen_14:
        SUBS     R0,R0,#+1
// 9071       {
// 9072         CenterLineLoc[row] = CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2];
??BrickSpeDealCen_13:
        LDR.N    R1,??DataTable48
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R1,R1,R0, LSL #+1
        LDRH     R1,[R1, #+2]
        LDR.N    R2,??DataTable48
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R2,R2,R0, LSL #+1
        LDRH     R2,[R2, #+2]
        ADDS     R1,R2,R1
        LDR.N    R2,??DataTable48
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R2,R2,R0, LSL #+1
        LDRH     R2,[R2, #+4]
        SUBS     R1,R1,R2
        LDR.N    R2,??DataTable48
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRH     R1,[R2, R0, LSL #+1]
// 9073         
// 9074         if(row == 0) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??BrickSpeDealCen_14
// 9075       }
// 9076     }
// 9077     else
// 9078     {     
// 9079     }
// 9080     
// 9081   }
// 9082   
// 9083   return 1;
??BrickSpeDealCen_6:
        MOVS     R0,#+1
??BrickSpeDealCen_3:
        BX       LR               ;; return
// 9084 }
// 9085 
// 9086 
// 9087 
// 9088 //避障程序

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 9089 uint8 BrickAvoid(void)
// 9090 {
BrickAvoid:
        PUSH     {R7,LR}
// 9091   uint8 i;
// 9092   
// 9093   ////障碍锁存标志没有被置位的时候才进行障碍计数，若已被置位，则不用进行障碍计数。
// 9094   if(BrickConfirmLockFlag == 0)
        LDR.N    R0,??DataTable48_25
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.W    ??BrickAvoid_0
// 9095   {
// 9096     //A次计数内有B次障碍成功，则判断为障碍。先入先出队列。
// 9097     for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??BrickAvoid_1
??BrickAvoid_2:
        ADDS     R0,R0,#+1
// 9098     {
// 9099       BrickConfirmMat0[i] = BrickConfirmMat0[i + 1];
??BrickAvoid_1:
        LDR.N    R1,??DataTable48_26
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R1,R0,R1
        LDRB     R1,[R1, #+1]
        LDR.N    R2,??DataTable48_26
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 9100       BrickConfirmMat1[i] = BrickConfirmMat1[i + 1];
        LDR.N    R1,??DataTable48_27
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R1,R0,R1
        LDRB     R1,[R1, #+1]
        LDR.N    R2,??DataTable48_27
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 9101       if(i == BrickConfirmMatNum - 2) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+4
        BNE.N    ??BrickAvoid_2
// 9102     }
// 9103     //左障碍成功
// 9104     if(PathType == PathBrickLeft)
        LDR.N    R0,??DataTable48_28
        LDRB     R0,[R0, #+0]
        CMP      R0,#+8
        BNE.N    ??BrickAvoid_3
// 9105     {
// 9106       //左障碍储存数组置1.
// 9107       BrickConfirmMat0[BrickConfirmMatNum - 1] = 1;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable48_26
        STRB     R0,[R1, #+5]
// 9108       //右障碍储存数组置0。
// 9109       BrickConfirmMat1[BrickConfirmMatNum - 1] = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable48_27
        STRB     R0,[R1, #+5]
        B.N      ??BrickAvoid_4
// 9110     }
// 9111     else if(PathType == PathBrickRight)
??BrickAvoid_3:
        LDR.N    R0,??DataTable48_28
        LDRB     R0,[R0, #+0]
        CMP      R0,#+9
        BNE.N    ??BrickAvoid_5
// 9112     {
// 9113       //右障碍储存数组置1.
// 9114       BrickConfirmMat1[BrickConfirmMatNum - 1] = 1;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable48_27
        STRB     R0,[R1, #+5]
// 9115       //左障碍储存数组置0。
// 9116       BrickConfirmMat0[BrickConfirmMatNum - 1] = 0;   
        MOVS     R0,#+0
        LDR.N    R1,??DataTable48_26
        STRB     R0,[R1, #+5]
        B.N      ??BrickAvoid_4
// 9117     }
// 9118     else
// 9119     {
// 9120       //判定为非障碍则新来的值置0.
// 9121       BrickConfirmMat0[BrickConfirmMatNum - 1] = 0;
??BrickAvoid_5:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable48_26
        STRB     R0,[R1, #+5]
// 9122       BrickConfirmMat1[BrickConfirmMatNum - 1] = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable48_27
        STRB     R0,[R1, #+5]
// 9123     }
// 9124     
// 9125     //收集BrickConfirmMat数组里1的个数。
// 9126     BrickConfirmMatCollect0 = 0;
??BrickAvoid_4:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable48_29
        STRB     R0,[R1, #+0]
// 9127     for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??BrickAvoid_6
??BrickAvoid_7:
        ADDS     R0,R0,#+1
// 9128     {
// 9129       if(BrickConfirmMat0[i] == 1) BrickConfirmMatCollect0++;
??BrickAvoid_6:
        LDR.N    R1,??DataTable48_26
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDRB     R1,[R0, R1]
        CMP      R1,#+1
        BNE.N    ??BrickAvoid_8
        LDR.N    R1,??DataTable48_29
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+1
        LDR.N    R2,??DataTable48_29
        STRB     R1,[R2, #+0]
// 9130       
// 9131       if(i == BrickConfirmMatNum - 1) break;
??BrickAvoid_8:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+5
        BNE.N    ??BrickAvoid_7
// 9132     }
// 9133     
// 9134     //收集BrickConfirmMat数组里1的个数。
// 9135     BrickConfirmMatCollect1 = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable48_30
        STRB     R0,[R1, #+0]
// 9136     for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??BrickAvoid_9
??BrickAvoid_10:
        ADDS     R0,R0,#+1
// 9137     {
// 9138       if(BrickConfirmMat1[i] == 1) BrickConfirmMatCollect1++;
??BrickAvoid_9:
        LDR.N    R1,??DataTable48_27
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDRB     R1,[R0, R1]
        CMP      R1,#+1
        BNE.N    ??BrickAvoid_11
        LDR.N    R1,??DataTable48_30
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+1
        LDR.N    R2,??DataTable48_30
        STRB     R1,[R2, #+0]
// 9139       
// 9140       if(i == BrickConfirmMatNum - 1) break;
??BrickAvoid_11:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+5
        BNE.N    ??BrickAvoid_10
// 9141     }
// 9142     
// 9143     //大于若干次，则锁存为左障碍。
// 9144     if(BrickConfirmMatCollect0 >= BrickConfirmMatLimit)
        LDR.N    R0,??DataTable48_29
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable48_31
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCC.N    ??BrickAvoid_12
// 9145     {
// 9146       //锁存标志位置位。
// 9147       BrickConfirmLockFlag = 1;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable48_25
        STRB     R0,[R1, #+0]
// 9148       //数组清空，防止重复锁存。
// 9149       for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??BrickAvoid_13
??BrickAvoid_14:
        ADDS     R0,R0,#+1
// 9150       {
// 9151         BrickConfirmMat0[i] = 0;
??BrickAvoid_13:
        MOVS     R1,#+0
        LDR.N    R2,??DataTable48_26
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 9152         BrickConfirmMat1[i] = 0;
        MOVS     R1,#+0
        LDR.N    R2,??DataTable48_27
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 9153         if(i == BrickConfirmMatNum - 1) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+5
        BNE.N    ??BrickAvoid_14
// 9154       }
// 9155       //确认障碍的方向。
// 9156       BrickSpeDealDir = 0;             //左障碍
        MOVS     R0,#+0
        LDR.N    R1,??DataTable48_13
        STRB     R0,[R1, #+0]
        B.N      ??BrickAvoid_0
// 9157     }
// 9158     else if(BrickConfirmMatCollect1 >= BrickConfirmMatLimit)
??BrickAvoid_12:
        LDR.N    R0,??DataTable48_30
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable48_31
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCC.N    ??BrickAvoid_0
// 9159     {
// 9160       //锁存标志位置位。
// 9161       BrickConfirmLockFlag = 1;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable48_25
        STRB     R0,[R1, #+0]
// 9162       //数组清空，防止重复锁存。
// 9163       for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??BrickAvoid_15
??BrickAvoid_16:
        ADDS     R0,R0,#+1
// 9164       {
// 9165         BrickConfirmMat0[i] = 0;
??BrickAvoid_15:
        MOVS     R1,#+0
        LDR.N    R2,??DataTable48_26
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 9166         BrickConfirmMat1[i] = 0;
        MOVS     R1,#+0
        LDR.N    R2,??DataTable48_27
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 9167         if(i == BrickConfirmMatNum - 1) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+5
        BNE.N    ??BrickAvoid_16
// 9168       }
// 9169       //确认障碍的方向。
// 9170       BrickSpeDealDir = 1;             //右障碍      
        MOVS     R0,#+1
        LDR.N    R1,??DataTable48_13
        STRB     R0,[R1, #+0]
// 9171     }
// 9172     else
// 9173     {
// 9174     }
// 9175   }
// 9176   //障碍锁存已被置位，则不用进行障碍计数。
// 9177   else
// 9178   {
// 9179   }
// 9180   
// 9181   //若障碍锁存标志位置位，则等待矮线的线头够低后开始障碍处理。
// 9182   if(BrickConfirmLockFlag == 1)
??BrickAvoid_0:
        LDR.N    R0,??DataTable48_25
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BrickAvoid_17
// 9183   {
// 9184     light_control(PORTD, 15, Light_ON);
        MOVS     R2,#+0
        MOVS     R1,#+15
        LDR.N    R0,??DataTable48_32  ;; 0x400ff0c0
        BL       light_control
// 9185     //判断可否开始特殊处理。
// 9186     if(BrickSpeDealStartJudge() == 1)
        BL       BrickSpeDealStartJudge
        CMP      R0,#+1
        BNE.N    ??BrickAvoid_17
// 9187     {
// 9188       BrickSpeDealBackCount = BrickSpeDealBackCountNum;
        MOVS     R0,#+20
        LDR.N    R1,??DataTable48_20
        STRB     R0,[R1, #+0]
// 9189     }
// 9190     else
// 9191     {
// 9192       //还没满足条件，再等等。
// 9193     }
// 9194   }
// 9195   else
// 9196   {
// 9197   }
// 9198 
// 9199   //退出障碍特殊处理的判断。BrickSpeDealExitJudgeFlag会更新。
// 9200   BrickSpeDealExitJudge();
??BrickAvoid_17:
        BL       BrickSpeDealExitJudge
// 9201   
// 9202   //有了倒数次数后，就开始每次倒数，直到为0或判断已经出了障碍.
// 9203   if(BrickSpeDealBackCount != 0 && BrickSpeDealExitJudgeFlag != 0)
        LDR.N    R0,??DataTable48_20
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??BrickAvoid_18
        LDR.N    R0,??DataTable48_33
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??BrickAvoid_18
// 9204   {
// 9205     BrickConfirmLockFlag = 0;    //障碍特殊控制开启成功，则锁存标志位清零。
        MOVS     R0,#+0
        LDR.N    R1,??DataTable48_25
        STRB     R0,[R1, #+0]
// 9206     
// 9207     //倒数值减1。
// 9208     BrickSpeDealBackCount--;
        LDR.N    R0,??DataTable48_20
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        LDR.N    R1,??DataTable48_20
        STRB     R0,[R1, #+0]
// 9209     //标志位说明进行了障碍的特殊处理。
// 9210     BrickSpeDealFlag = 1;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable48_11
        STRB     R0,[R1, #+0]
// 9211     
// 9212     //对中心线的特殊处理函数，还剩BrickSpeDealBackCount次。
// 9213     BrickSpeDealCenFlag = BrickSpeDealCen();
        BL       BrickSpeDealCen
        LDR.N    R1,??DataTable48_12
        STRB     R0,[R1, #+0]
// 9214     //若处理已经出错了，则立即停止特殊控制，后面会将舵机强制打回来。
// 9215     if(BrickSpeDealCenFlag == 0)
        LDR.N    R0,??DataTable48_12
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??BrickAvoid_19
// 9216     {
// 9217       BrickSpeDealBackCount = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable48_20
        STRB     R0,[R1, #+0]
// 9218     }
// 9219     else
// 9220     {
// 9221     }
// 9222     //特殊控制期间，为了防止撞障碍引起的上下坡误判，将坡道禁止赛道类型判断标志复位，并将倒计数置0（不允许置下坡标志，会引起减速），保证复位。
// 9223     //会持续多个周期，所以应该是保险的。
// 9224     GyroResultForbidFlag = 0;
??BrickAvoid_19:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable48_34
        STRB     R0,[R1, #+0]
// 9225     GyroResultForbidBackCount = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable48_35
        STRB     R0,[R1, #+0]
        B.N      ??BrickAvoid_20
// 9226     
// 9227   }
// 9228   else
// 9229   {    
// 9230     //倒数次数清零，防止再次启动障碍特殊处理。
// 9231     BrickSpeDealBackCount = 0;
??BrickAvoid_18:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable48_20
        STRB     R0,[R1, #+0]
// 9232     
// 9233     //标志位说明没有进行障碍的特殊处理。
// 9234     BrickSpeDealFlag = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable48_11
        STRB     R0,[R1, #+0]
// 9235     
// 9236     //判出标志置初始状态1.
// 9237     BrickSpeDealExitJudgeFlag = 1;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable48_33
        STRB     R0,[R1, #+0]
// 9238   }
// 9239   
// 9240   return 1;
??BrickAvoid_20:
        MOVS     R0,#+1
        POP      {R1,PC}          ;; return
// 9241 }
// 9242 
// 9243 
// 9244 //中心线处理函数，包括特殊和非特殊赛道

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 9245 uint8 CenterLineGetRaw(void)
// 9246 {
CenterLineGetRaw:
        PUSH     {R7,LR}
// 9247   uint8 flag;
// 9248   
// 9249   flag = 1;
        MOVS     R0,#+1
// 9250   //直角弯 锁存 或 强制控制期间，就不用进行正常的中心线提取。
// 9251   //ImgProSucceedDeal()里面的DeviFuse更新函数是没有用的，因为AngleStep2Confirm()在ImgProSucceedDeal()的后面执行，会强制更改DeviFuse.
// 9252   if(AngleConfirmLockFlag == 1 || AngleSpeDealFlag == 1)
        LDR.N    R1,??DataTable48_36
        LDRB     R1,[R1, #+0]
        CMP      R1,#+1
        BEQ.N    ??CenterLineGetRaw_0
        LDR.N    R1,??DataTable48_37
        LDRB     R1,[R1, #+0]
        CMP      R1,#+1
        BEQ.N    ??CenterLineGetRaw_0
// 9253   {   
// 9254     //直角弯锁存或特殊控制时，CenterLineLoc[]数组一直是无效值。
// 9255   }
// 9256   //障碍物强制控制期间，不执行正常的中心线提取，而是采用单边线的特殊中心线提取函数。
// 9257   //这里只是给出一条修正后的中心线，用来给ImgProSucceedDeal()里面的DeviFuse更新函数去用。
// 9258   //但是障碍物锁存期间，仍然靠正常提取中心线。
// 9259   else if(BrickSpeDealFlag == 1)
        LDR.N    R1,??DataTable48_11
        LDRB     R1,[R1, #+0]
        CMP      R1,#+1
        BEQ.N    ??CenterLineGetRaw_0
// 9260   {
// 9261     //在BrickAvoid()中已经执行了中心线提取函数。
// 9262   }
// 9263   //不是特殊赛道，进行正常的中心线提取。有可能返回失败。
// 9264   else
// 9265   {
// 9266     flag = CenterLineGetNormal();
        BL       CenterLineGetNormal
// 9267   }
// 9268   
// 9269   return flag;
??CenterLineGetRaw_0:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        POP      {R1,PC}          ;; return
// 9270 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48:
        DC32     CenterLineLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_1:
        DC32     BlackLeftLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_2:
        DC32     BlackLeftCrossDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_3:
        DC32     BlackRightCrossDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_4:
        DC32     buXianCount

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_5:
        DC32     BlackLeftHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_6:
        DC32     CURVEL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_7:
        DC32     CURVER

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_8:
        DC32     CenterEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_9:
        DC32     RoadHalfWidthSingle

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_10:
        DC32     BlackRightLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_11:
        DC32     BrickSpeDealFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_12:
        DC32     BrickSpeDealCenFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_13:
        DC32     BrickSpeDealDir

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_14:
        DC32     ServoPIDInputVal

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_15:
        DC32     ImgBlackSucceedFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_16:
        DC32     BlackRightDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_17:
        DC32     CenterHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_18:
        DC32     BlackRightEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_19:
        DC32     BrickSpeDealBias

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_20:
        DC32     BrickSpeDealBackCount

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_21:
        DC32     BrickConfirmFinalColCom

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_22:
        DC32     BlackRightHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_23:
        DC32     BlackLeftDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_24:
        DC32     BlackLeftEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_25:
        DC32     BrickConfirmLockFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_26:
        DC32     BrickConfirmMat0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_27:
        DC32     BrickConfirmMat1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_28:
        DC32     PathType

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_29:
        DC32     BrickConfirmMatCollect0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_30:
        DC32     BrickConfirmMatCollect1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_31:
        DC32     BrickConfirmMatLimit

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_32:
        DC32     0x400ff0c0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_33:
        DC32     BrickSpeDealExitJudgeFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_34:
        DC32     GyroResultForbidFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_35:
        DC32     GyroResultForbidBackCount

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_36:
        DC32     AngleConfirmLockFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable48_37:
        DC32     AngleSpeDealFlag
// 9271 
// 9272 
// 9273 
// 9274 
// 9275 //中心线提取，进来前左右黑线均连续。

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
// 9276 uint8 CenterLineGet(void)
// 9277 {
CenterLineGet:
        PUSH     {R1-R9,LR}
// 9278   uint8 row, i;
// 9279   uint8 temp;
// 9280   uint8 flag1, flag2, flag3, flag4;  
// 9281   uint8 tempflag1;
// 9282   uint8 tempway1;
// 9283   uint8 x[CenterForwardLineNum];   //中心线向前补线计算斜率时，x坐标，表示第几行。。
// 9284   int16 y[CenterForwardLineNum];   //中心线向前补线计算斜率时，y坐标，表示中心线位置。
// 9285   int32 a1, a0;    //中心线向前补线时，最小二乘法的斜率和纵截距。
// 9286   
// 9287   float slope;
// 9288   
// 9289   
// 9290   //左线提取成功，右线提取失败。
// 9291   if(BlackLeftDone == 1 && BlackRightDone == 0)
        LDR.W    R0,??CenterLineGet_0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??CenterLineGet_1
        LDR.W    R0,??CenterLineGet_0+0x4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.W    ??CenterLineGet_1
// 9292   {
// 9293     //若左线的线头线尾无效，则直接返回失败。
// 9294     if(BlackLeftHeadLine == MaxValUint8 || BlackLeftEndLine == MaxValUint8)
        LDR.W    R0,??CenterLineGet_0+0x8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGet_2
        LDR.W    R0,??CenterLineGet_0+0xC
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CenterLineGet_3
// 9295     {
// 9296       return 0;
??CenterLineGet_2:
        MOVS     R0,#+0
        B.N      ??CenterLineGet_4
// 9297     }
// 9298     else
// 9299     {
// 9300     }
// 9301     
// 9302     flag1 = 1;
??CenterLineGet_3:
        MOVS     R1,#+1
// 9303     flag2 = 1;
        MOVS     R2,#+1
// 9304     
// 9305     //中心线的线尾取左线的线尾即可。
// 9306     CenterHeadLine = BlackLeftHeadLine;     //线头取左线的线头，注意这不是实际的线头。
        LDR.W    R0,??CenterLineGet_0+0x8
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGet_0+0x10
        STRB     R0,[R1, #+0]
// 9307     //CenterHeadLine = 0;   //线头因为要固定补到第0行，所以直接置0.
// 9308     CenterEndLine = BlackLeftEndLine;
        LDR.W    R0,??CenterLineGet_0+0xC
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGet_0+0x14
        STRB     R0,[R1, #+0]
// 9309     
// 9310     //首先看线头是否大于BlackControlLineLow行
// 9311     if(BlackLeftHeadLine >= BlackControlLineLow)
        LDR.W    R0,??CenterLineGet_0+0x8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+26
        BLT.N    ??CenterLineGet_5
// 9312     {
// 9313       flag1 = 0;
        MOVS     R1,#+0
// 9314     }
// 9315     else
// 9316     {
// 9317     }
// 9318     
// 9319     //左线尾小于CameraHight - 1行。
// 9320     if(BlackLeftEndLine < CameraHight - 1)
??CenterLineGet_5:
        LDR.W    R0,??CenterLineGet_0+0xC
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BGE.N    ??CenterLineGet_6
// 9321     {
// 9322       //只有左线成功，而且左线尾还那么远，真心没法继续。直接返回失败。
// 9323       //if(BlackLeftEndLine < CameraHight - 1 - BlackLeftBackLineStart)
// 9324       if(BlackLeftEndLine <= BlackControlLineLow)
        LDR.W    R0,??CenterLineGet_0+0xC
        LDRB     R0,[R0, #+0]
        CMP      R0,#+27
        BGE.N    ??CenterLineGet_6
// 9325       {
// 9326         flag2 = 0;
        MOVS     R2,#+0
// 9327         return 0;       
        MOVS     R0,#+0
        B.N      ??CenterLineGet_4
// 9328       }
// 9329       //左线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackLeftEndLine。
// 9330       else
// 9331       {
// 9332       }
// 9333     }
// 9334     //左线尾等于CameraHight - 1，直接取BlackLeftEndLine
// 9335     else
// 9336     {
// 9337     }
// 9338     
// 9339     //丢失另一根线的时候，先根据斜率估算出半宽，若没有上一次双线图像时的赛道半宽大，则直接用上一次双线的赛道半宽。
// 9340     //求5行的斜率。
// 9341     if(BlackLeftEndLine - BlackLeftHeadLine > 5)
??CenterLineGet_6:
        LDR.W    R0,??CenterLineGet_0+0xC
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGet_0+0x8
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGet_7
// 9342     {
// 9343       slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
// 9344                     (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
        LDR.W    R0,??CenterLineGet_0+0x18
        LDR.W    R1,??CenterLineGet_0+0xC
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??CenterLineGet_0+0x18
        LDR.W    R2,??CenterLineGet_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.W    R0,??CenterLineGet_0+0x18
        LDR.W    R1,??CenterLineGet_0+0xC
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.W    R1,??CenterLineGet_0+0x18
        LDR.W    R2,??CenterLineGet_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGet_9
// 9345     }
// 9346     else
// 9347     {
// 9348       slope = 0;
??CenterLineGet_7:
        MOVS     R0,#+0
// 9349     }
// 9350     //赛道半宽
// 9351     temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
??CenterLineGet_9:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8+0x4  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        MOVS     R4,R0
// 9352     //取最大值
// 9353     RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
        LDR.W    R0,??CenterLineGet_8+0x8
        LDRB     R1,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R0,R4
        BL       MaxRe
        LDR.W    R1,??CenterLineGet_8+0x8
        STRB     R0,[R1, #+0]
// 9354     
// 9355     //根据赛道宽度估计出中心线的线头。
// 9356     CenterLineLoc[BlackLeftEndLine] = BlackUdisLeftLocation[BlackLeftEndLine].x + RoadHalfWidth;
        LDR.W    R0,??CenterLineGet_0+0x18
        LDR.W    R1,??CenterLineGet_0+0xC
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??CenterLineGet_8+0x8
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1
        LDR.W    R1,??CenterLineGet_10
        LDR.W    R2,??CenterLineGet_0+0xC
        LDRB     R2,[R2, #+0]
        STRH     R0,[R1, R2, LSL #+1]
// 9357     
// 9358     tempflag1 = 0;
        MOVS     R4,#+0
// 9359     tempway1 = 0;
        MOVS     R5,#+0
// 9360     //根据左线的走势估计出中心线。中心线是个int16型矩阵，有正负。
// 9361     for(row = BlackLeftEndLine - 1; ;row--)
        LDR.W    R0,??CenterLineGet_0+0xC
        LDRB     R0,[R0, #+0]
        SUBS     R8,R0,#+1
        B.N      ??CenterLineGet_11
??CenterLineGet_12:
        SUBS     R8,R8,#+1
// 9362     {
// 9363       //左线有效时。根据左线的趋势补线。
// 9364       if(BlackLeftLoc[row][0] != MaxValUint8)
??CenterLineGet_11:
        LDR.W    R0,??CenterLineGet_10+0x4
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGet_13
// 9365       {
// 9366         tempflag1 = 0;
        MOVS     R4,#+0
// 9367         CenterLineLoc[row] = CenterLineLoc[row+1] + BlackUdisLeftLocation[row].x - BlackUdisLeftLocation[row+1].x;
        LDR.W    R0,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R0,R0,R8, LSL #+1
        LDRH     R0,[R0, #+2]
        LDR.W    R1,??CenterLineGet_0+0x18
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R1,[R1, R8, LSL #+3]
        ADDS     R0,R1,R0
        LDR.W    R1,??CenterLineGet_0+0x18
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R1,R1,R8, LSL #+3
        LDR      R1,[R1, #+8]
        SUBS     R0,R0,R1
        LDR.W    R1,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGet_14
// 9368       }
// 9369       //左线无效时。根据最后两行的中心线趋势补线。
// 9370       else
// 9371       {
// 9372         //当左线无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
// 9373         if(tempflag1 == 0)
??CenterLineGet_13:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BNE.N    ??CenterLineGet_15
// 9374         {
// 9375           //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
// 9376           tempflag1 = 1;
        MOVS     R4,#+1
// 9377           //最后几行行数够多，可以采用最小二乘法的方式。
// 9378           if(row + CenterForwardLineNum <= CameraHight - 1)
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R0,R8,#+4
        CMP      R0,#+60
        BGE.N    ??CenterLineGet_16
// 9379           {
// 9380             tempway1 = 0;
        MOVS     R5,#+0
// 9381             //进行最小二乘法系数的计算。
// 9382             for(i = 0; i < CenterForwardLineNum; i++)
        MOVS     R0,#+0
        B.N      ??CenterLineGet_17
// 9383             {
// 9384               x[i] = row + i + 1;
??CenterLineGet_18:
        ADDS     R1,R0,R8
        ADDS     R1,R1,#+1
        ADD      R2,SP,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 9385               y[i] = CenterLineLoc[row + i + 1];
        LDR.W    R1,??CenterLineGet_10
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTAB    R2,R0,R8
        ADDS     R1,R1,R2, LSL #+1
        LDRH     R1,[R1, #+2]
        ADD      R2,SP,#+4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRH     R1,[R2, R0, LSL #+1]
// 9386             }
        ADDS     R0,R0,#+1
??CenterLineGet_17:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+4
        BLT.N    ??CenterLineGet_18
// 9387             a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a1
        MOVS     R6,R0
// 9388             a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
        MOVS     R3,#+4
        MOVS     R2,R6
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a0
        MOVS     R7,R0
        B.N      ??CenterLineGet_15
// 9389           }
// 9390           //最后几行的行数不够多，采用最后两行趋势补线的方式。
// 9391           else
// 9392           {
// 9393             tempway1 = 1;
??CenterLineGet_16:
        MOVS     R5,#+1
// 9394           }
// 9395         }
// 9396         else
// 9397         {
// 9398         }
// 9399         
// 9400         //确认补线方式后，开始补线。
// 9401         if(tempway1 == 0)
??CenterLineGet_15:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??CenterLineGet_19
// 9402         {
// 9403           //最小二乘法的方式。
// 9404           CenterLineLoc[row] = (a0 + a1 * row) / LeastSquareMulti;
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MLA      R0,R8,R6,R7
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        LDR.W    R1,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGet_14
// 9405         }
// 9406         else
// 9407         {
// 9408           //如果是最近2行。
// 9409           if(row == CameraHight -1  || row == CameraHight - 2)
??CenterLineGet_19:
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+59
        BEQ.N    ??CenterLineGet_20
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+58
        BNE.N    ??CenterLineGet_21
// 9410           {
// 9411             CenterLineLoc[row] = BlackUdisLeftLocation[row].x + RoadHalfWidth;
??CenterLineGet_20:
        LDR.W    R0,??CenterLineGet_0+0x18
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R0,[R0, R8, LSL #+3]
        LDR.W    R1,??CenterLineGet_8+0x8
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1
        LDR.W    R1,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGet_14
// 9412           }
// 9413           //不是最近2行。
// 9414           else
// 9415           {
// 9416             //最后两行的方式。
// 9417             CenterLineLoc[row] = CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2];            
??CenterLineGet_21:
        LDR.W    R0,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R0,R0,R8, LSL #+1
        LDRH     R0,[R0, #+2]
        LDR.W    R1,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R1,R1,R8, LSL #+1
        LDRH     R1,[R1, #+2]
        ADDS     R0,R1,R0
        LDR.W    R1,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R1,R1,R8, LSL #+1
        LDRH     R1,[R1, #+4]
        SUBS     R0,R0,R1
        LDR.W    R1,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
// 9418           }
// 9419         }
// 9420       }
// 9421       
// 9422       //一直补到最高行。
// 9423       if(row == 0) break;
??CenterLineGet_14:
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+0
        BNE.W    ??CenterLineGet_12
// 9424     }
// 9425     
// 9426     //对未处理的行的中心线置无效值。
// 9427     //底部置无效值。顶部不用处理。
// 9428     if(CenterEndLine != CameraHight - 1)
        LDR.W    R0,??CenterLineGet_0+0x14
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BEQ.N    ??CenterLineGet_22
// 9429     {
// 9430       for(row = CameraHight - 1; ; row--)
        MOVS     R8,#+59
        B.N      ??CenterLineGet_23
// 9431       {
// 9432         if(row == CenterEndLine) break;       
// 9433         CenterLineLoc[row] = MaxValInt16;
??CenterLineGet_24:
        MOVW     R0,#+32767
        LDR.W    R1,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        SUBS     R8,R8,#+1
??CenterLineGet_23:
        LDR.W    R0,??CenterLineGet_0+0x14
        LDRB     R0,[R0, #+0]
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,R0
        BNE.N    ??CenterLineGet_24
// 9434       }
// 9435     }
// 9436     else
// 9437     {
// 9438     }
// 9439 
// 9440     
// 9441   }
// 9442   //右线提取成功，左线提取失败。
// 9443   else if(BlackLeftDone == 0 && BlackRightDone == 1)
// 9444   {
// 9445     //若右线的线头线尾无效，则直接返回失败。
// 9446     if(BlackRightHeadLine == MaxValUint8 || BlackRightEndLine == MaxValUint8)
// 9447     {
// 9448       return 0;
// 9449     }
// 9450     else
// 9451     {
// 9452     }
// 9453        
// 9454     flag1 = 1;
// 9455     flag2 = 1;
// 9456     
// 9457     //中心线的线尾取左线的线尾即可。
// 9458     CenterHeadLine = BlackRightHeadLine;   //线头取左线的线头，注意这不是实际的线头。
// 9459     //CenterHeadLine = 0;                    //线头因为要固定补到第0行，所以直接置0.
// 9460     CenterEndLine = BlackRightEndLine;
// 9461     
// 9462     //首先看线头是否大于BlackControlLineLow行
// 9463     if(BlackRightHeadLine >= BlackControlLineLow)
// 9464     {
// 9465       flag1 = 0;     
// 9466     }
// 9467     else
// 9468     {
// 9469     }
// 9470     
// 9471     //右线尾小于CameraHight - 1行。
// 9472     if(BlackRightEndLine < CameraHight - 1)
// 9473     {
// 9474       //只有右线成功，而且右线尾还那么远，真心没法继续。直接返回失败。
// 9475       //if(BlackRightEndLine < CameraHight - 1 - BlackRightBackLineStart)
// 9476       if(BlackRightEndLine <= BlackControlLineLow)  
// 9477       {
// 9478         flag2 = 0;
// 9479         return 0;
// 9480       }
// 9481       //右线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackRightEndLine。
// 9482       else
// 9483       {
// 9484       }
// 9485     }
// 9486     //右线尾等于CameraHight - 1，直接取BlackRightEndLine
// 9487     else
// 9488     {
// 9489     }
// 9490     
// 9491     //丢失另一根线的时候，先根据斜率估算出半宽，若没有上一次双线图像时的赛道半宽大，则直接用上一次双线的赛道半宽。
// 9492     //求5行的斜率。
// 9493     if(BlackRightEndLine - BlackRightHeadLine > 5)
// 9494     {
// 9495       slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
// 9496                     (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
// 9497     }
// 9498     else
// 9499     {
// 9500       slope = 0;
// 9501     }
// 9502     //赛道半宽
// 9503     temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
// 9504     //取最大值
// 9505     RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
// 9506     
// 9507     tempflag1 = 0;
// 9508     tempway1 = 0;
// 9509     //根据赛道宽度估计出中心线的线头。
// 9510     CenterLineLoc[BlackRightEndLine] = BlackUdisRightLocation[BlackRightEndLine].x - RoadHalfWidth;
// 9511     //根据右线的走势估计出中心线。中心线是个int16型矩阵，有正负。
// 9512     for(row = BlackRightEndLine - 1; ;row--)
// 9513     {
// 9514       //右线有效时。根据右线的趋势补线。
// 9515       if(BlackRightLoc[row][0] != MaxValUint8)
// 9516       {
// 9517         tempflag1 = 0;
// 9518         CenterLineLoc[row] = CenterLineLoc[row+1] + BlackUdisRightLocation[row].x - BlackUdisRightLocation[row+1].x;
// 9519       }
// 9520       //右线无效时。根据最后两行的中心线趋势补线。
// 9521       else
// 9522       {
// 9523           //当右线无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
// 9524           if(tempflag1 == 0)
// 9525           {
// 9526             //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
// 9527             tempflag1 = 1;
// 9528             //最后几行行数够多，可以采用最小二乘法的方式。
// 9529             if(row + CenterForwardLineNum <= CameraHight - 1)
// 9530             {
// 9531               tempway1 = 0;
// 9532               //进行最小二乘法系数的计算。
// 9533               for(i = 0; i < CenterForwardLineNum; i++)
// 9534               {
// 9535                 x[i] = row + i + 1;
// 9536                 y[i] = CenterLineLoc[row + i + 1];
// 9537               }
// 9538               a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
// 9539               a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
// 9540             }
// 9541             //最后几行的行数不够多，采用最后两行趋势补线的方式。
// 9542             else
// 9543             {
// 9544               tempway1 = 1;
// 9545             }
// 9546           }
// 9547           else
// 9548           {
// 9549           }
// 9550         
// 9551           //确认补线方式后，开始补线。
// 9552           if(tempway1 == 0)
// 9553           {
// 9554             //最小二乘法的方式。
// 9555             CenterLineLoc[row] = (a0 + a1 * row) / LeastSquareMulti;
// 9556           }
// 9557           else
// 9558           {
// 9559             //最近2行。
// 9560             if(row == CameraHight - 1 || row == CameraHight - 2)
// 9561             {
// 9562               CenterLineLoc[row] = BlackUdisRightLocation[row].x - RoadHalfWidth;
// 9563             }
// 9564             //不是最近2行。
// 9565             else
// 9566             {
// 9567               //最后两行的方式。
// 9568               CenterLineLoc[row] = CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2];
// 9569             }
// 9570           }
// 9571         }
// 9572       
// 9573         if(row == 0) break;
// 9574       }
// 9575     
// 9576       
// 9577     
// 9578     //对未处理的行的中心线置无效值。
// 9579     //底部置无效值。顶部不用处理。
// 9580     if(CenterEndLine != CameraHight - 1)
// 9581     {
// 9582       for(row = CameraHight - 1; ; row--)
// 9583       {
// 9584         if(row == CenterEndLine) break;       
// 9585         CenterLineLoc[row] = MaxValInt16;
// 9586       }
// 9587     }
// 9588     else
// 9589     {
// 9590     }
// 9591    
// 9592   }
// 9593   //左右线均提取成功。
// 9594   else if(BlackLeftDone == 1 && BlackRightDone == 1)
// 9595   {
// 9596     CenterHeadLine = MinRe(BlackLeftHeadLine, BlackRightHeadLine);    //线头取两者较小者。     
// 9597     //CenterHeadLine = 0;    //因为固定要补到第0行，所以固定取0.
// 9598     //线尾取两者较大者。
// 9599     CenterEndLine = MaxRe(BlackLeftEndLine, BlackRightEndLine);             
// 9600     
// 9601     //不是单线的情况。
// 9602     if(SingleBlackAllFlag == 0)
// 9603     {
// 9604     
// 9605       //左右线均提取成功，首选根据两线得中心线，实在不行再根据赛道宽度估计。
// 9606       //不根据趋势来预测，因为畸变矫正基本上已经把左右线差搞成定值了，所以不用那么麻烦。    
// 9607       
// 9608       //先检查左线，左线不满足条件再检测右线。右线不满足再返回失败。
// 9609       flag1 = 1;
// 9610       flag2 = 1;
// 9611       flag3 = 1;
// 9612       flag4 = 1;
// 9613       //取左右两线的第39到第59行的差，取最大值。
// 9614       //首先看线头是否大于39行，大于39行就直接返回失败。
// 9615       if(BlackLeftHeadLine >= BlackControlLineLow)
// 9616       {
// 9617         flag1 = 0;
// 9618       }
// 9619       else
// 9620       {
// 9621       }
// 9622       //左线尾小于CameraHight - 1行。
// 9623       if(BlackLeftEndLine < CameraHight - 1)
// 9624       {
// 9625         //只有左线成功，而且左线尾还那么远，真心没法继续。看右线是不是一样的情况。
// 9626         //if(BlackLeftEndLine < CameraHight - 1 - BlackLeftBackLineStart)
// 9627         if(BlackLeftEndLine <= BlackControlLineLow)
// 9628         {
// 9629           flag2 = 0;
// 9630         }
// 9631         //左线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackLeftEndLine。
// 9632         else
// 9633         {
// 9634         }
// 9635       }
// 9636       //左线尾等于CameraHight - 1，直接取BlackLeftEndLine
// 9637       else
// 9638       {
// 9639       }
// 9640   
// 9641       //处理右线，右线不满足条件，则直接返回失败。
// 9642       //首先看线头是否大于39行，大于39行就直接返回失败。
// 9643       if(BlackRightHeadLine >= BlackControlLineLow)
// 9644       {
// 9645         flag3 = 0;
// 9646       }
// 9647       else
// 9648       {
// 9649       }    
// 9650       //右线尾小于CameraHight - 1行。
// 9651       if(BlackRightEndLine < CameraHight - 1)
// 9652       {
// 9653         //只有右线成功，而且右线尾还那么远，真心没法继续。直接返回失败。
// 9654         //if(BlackRightEndLine < CameraHight - 1 - BlackRightBackLineStart)
// 9655         if(BlackRightEndLine <= BlackControlLineLow)
// 9656         {
// 9657           flag4 = 0;
// 9658           //两次都线尾很远，直接返回失败。
// 9659           if(flag2 == 0) 
// 9660           {
// 9661             return 0;
// 9662           }
// 9663           else
// 9664           {
// 9665           }
// 9666         }
// 9667         //右线尾在一定范围内。可以允许把第59行往前移几行。直接取BlackRightEndLine。
// 9668         else
// 9669         {
// 9670         }
// 9671       }
// 9672       //右线尾等于CameraHight - 1，直接取BlackRightEndLine
// 9673       else
// 9674       {
// 9675       }
// 9676       
// 9677       //只有右线满足要求，则直接取右线的列差值绝对值。
// 9678       if(
// 9679         (flag3 == 1 && flag4 == 1)
// 9680       &&((flag1 == 0 && flag2 == 0) || (flag1 == 1 && flag2 == 0) || (flag1 == 0 && flag2 == 1))
// 9681         )
// 9682       {
// 9683         //斜率的方式估算出赛道半宽。
// 9684         //求5行的斜率。
// 9685         if(BlackRightEndLine - BlackRightHeadLine > 5)
// 9686         {
// 9687           slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
// 9688                         (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
// 9689         }
// 9690         else
// 9691         {
// 9692           slope = 0;
// 9693         }
// 9694         //赛道半宽
// 9695         temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
// 9696         RoadHalfWidthCompen = RoadHalfWidth / temp;
// 9697         RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
// 9698       }
// 9699       //只有左线满足要求，则直接取左线的列差值绝对值。
// 9700       else if(
// 9701              (flag1 == 1 && flag2 == 1)
// 9702            &&((flag3 == 0 && flag4 == 0) || (flag3 == 1 && flag4 == 0) || (flag3 == 0 && flag4 == 1))
// 9703              )
// 9704       {
// 9705         //斜率的方式估算出赛道半宽。
// 9706         //求5行的斜率。
// 9707         if(BlackLeftEndLine - BlackLeftHeadLine > 5)
// 9708         {
// 9709           slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
// 9710                         (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
// 9711         }
// 9712         else
// 9713         {
// 9714           slope = 0;
// 9715         }
// 9716         //赛道半宽
// 9717         temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
// 9718         RoadHalfWidthCompen = RoadHalfWidth / temp;
// 9719         RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
// 9720       }
// 9721       //左右线均满足条件。则取列差值绝对值较大的。
// 9722       else if(flag1 == 1 && flag2 == 1 && flag3 == 1 && flag4 == 1)
// 9723       {
// 9724         //斜率的方式估算出赛道半宽。
// 9725         //求5行的斜率。
// 9726         if(BlackLeftEndLine - BlackLeftHeadLine > 5)
// 9727         {
// 9728           slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
// 9729                         (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
// 9730         }
// 9731         else
// 9732         {
// 9733           slope = 0;
// 9734         }
// 9735         //赛道半宽
// 9736         temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
// 9737         
// 9738         //求5行的斜率。
// 9739         if(BlackRightEndLine - BlackRightHeadLine > 5)
// 9740         {
// 9741           slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
// 9742                         (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
// 9743         }
// 9744         else
// 9745         {
// 9746           slope = 0;
// 9747         }
// 9748         //赛道半宽
// 9749         temp = MaxRe((uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2), temp);
// 9750         RoadHalfWidthCompen = RoadHalfWidth / temp;
// 9751         RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
// 9752       }
// 9753       //左右线均不满足要求。
// 9754       else
// 9755       {
// 9756         //左右线都在第BlackControlLineLow行的远方。直接返回失败。
// 9757         if(flag2 == 0 && flag4 == 0)
// 9758         {
// 9759           return 0;
// 9760         }
// 9761         else
// 9762         {
// 9763           //左线在第BlackControlLineLow行的近方，右线在第BlackControlLineLow行的远方，则用左线来求。
// 9764           if(flag1 == 1 && flag3 == 0)
// 9765           {
// 9766             //斜率的方式估算出赛道半宽。
// 9767             //求5行的斜率。
// 9768             if(BlackLeftEndLine - BlackLeftHeadLine > 5)
// 9769             {
// 9770               slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
// 9771                             (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
// 9772             }
// 9773             else
// 9774             {
// 9775               slope = 0;
// 9776             }
// 9777             //赛道半宽
// 9778             temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
// 9779             RoadHalfWidthCompen = RoadHalfWidth / temp;
// 9780             RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
// 9781           }
// 9782           //右线在第BlackControlLineLow行的近方，左线在第BlackControlLineLow行的远方，则用右线来求。
// 9783           else if(flag1 == 0 && flag3 == 1)
// 9784           {
// 9785             //斜率的方式估算出赛道半宽。
// 9786             //求5行的斜率。
// 9787             if(BlackRightEndLine - BlackRightHeadLine > 5)
// 9788             {
// 9789               slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
// 9790                             (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
// 9791             }
// 9792             else
// 9793             {
// 9794               slope = 0;
// 9795             }
// 9796             //赛道半宽
// 9797             temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
// 9798             RoadHalfWidthCompen = RoadHalfWidth / temp;
// 9799             RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
// 9800           }
// 9801           //左右线都在第行的近方，则取较大值。
// 9802           else if(flag1 == 0 && flag3 == 0)
// 9803           {
// 9804             //斜率的方式估算出赛道半宽。
// 9805             //求5行的斜率。
// 9806             if(BlackLeftEndLine - BlackLeftHeadLine > 5)
// 9807             {
// 9808               slope = 1.0 * (BlackUdisLeftLocation[BlackLeftEndLine].x - BlackUdisLeftLocation[BlackLeftEndLine-4].x) / 
// 9809                             (BlackUdisLeftLocation[BlackLeftEndLine].y - BlackUdisLeftLocation[BlackLeftEndLine-4].y);
// 9810             }
// 9811             else
// 9812             {
// 9813               slope = 0;
// 9814             }
// 9815             //赛道半宽
// 9816             temp = (uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2);
// 9817             
// 9818             //求5行的斜率。
// 9819             if(BlackRightEndLine - BlackRightHeadLine > 5)
// 9820             {
// 9821               slope = 1.0 * (BlackUdisRightLocation[BlackRightEndLine].x - BlackUdisRightLocation[BlackRightEndLine-4].x) / 
// 9822                             (BlackUdisRightLocation[BlackRightEndLine].y - BlackUdisRightLocation[BlackRightEndLine-4].y);
// 9823             }
// 9824             else
// 9825             {
// 9826               slope = 0;
// 9827             }
// 9828             //赛道半宽
// 9829             temp = MaxRe((uint8)(1.0 * sqrt(slope * slope + 1) * RoadWidth / 2), temp);
// 9830             RoadHalfWidthCompen = RoadHalfWidth / temp;
// 9831             RoadHalfWidth = MaxRe(temp, RoadHalfWidth);
// 9832           }
// 9833           //理论上不可能走到这里。
// 9834           else
// 9835           {
// 9836             return 0;
// 9837           }
// 9838         }
// 9839       }
// 9840       
// 9841       uint8 temproad;  //本幅图的最后一个双线有效路宽。给本幅图的单线部分用。
// 9842       temproad = RoadHalfWidth;
// 9843       
// 9844       tempflag1 = 0;
// 9845       tempway1 = 0;      
// 9846       //赛道宽度已经求得，现在开始从低到高求中心线。
// 9847       for(row = CenterEndLine; ; row--)
// 9848       {
// 9849         //当前行左右黑线均有效。检测有无效不能用Udis数组，只能用原始的黑线储存数组。
// 9850         if(BlackLeftLoc[row][0] != MaxValUint8 && BlackRightLoc[row][0] != MaxValUint8)
// 9851         {
// 9852           tempflag1 = 0;
// 9853           //取左右黑线的平均值。
// 9854           CenterLineLoc[row] = (BlackUdisLeftLocation[row].x + BlackUdisRightLocation[row].x) / 2;
// 9855           //取最后一行两行有效的行的赛道半宽，作为最新的赛道半宽。
// 9856           if(BlackUdisLeftLocation[row].x > BlackUdisRightLocation[row].x)
// 9857           {
// 9858             RoadHalfWidthRecord[row] = (BlackUdisLeftLocation[row].x - BlackUdisRightLocation[row].x) / 2;           
// 9859           }
// 9860           else
// 9861           {
// 9862             RoadHalfWidthRecord[row] = (BlackUdisRightLocation[row].x - BlackUdisLeftLocation[row].x) / 2;
// 9863           }
// 9864           
// 9865           //本幅图的最后一个双线有效路宽。给本幅图的单线部分用。
// 9866           temproad = RoadHalfWidthRecord[row];
// 9867           //赛道半宽记录.存第CameraHight - 1行的赛道半宽，给下一幅图用。
// 9868           //怕出意外，限个幅。
// 9869           if(row == CameraHight - 1) 
// 9870           {  
// 9871             if(RoadHalfWidthRecord[row] > RoadHalfWidthLimitMax)
// 9872             {
// 9873               RoadHalfWidth = RoadHalfWidthLimitMax;
// 9874             }
// 9875             else if(RoadHalfWidthRecord[row] < RoadHalfWidthLimitMin)
// 9876             {
// 9877               RoadHalfWidth = RoadHalfWidthLimitMin;
// 9878             }
// 9879             else
// 9880             {
// 9881               RoadHalfWidth = RoadHalfWidthRecord[row];
// 9882             }            
// 9883           }
// 9884           else
// 9885           {
// 9886           }
// 9887         }
// 9888         //左行有效，右行无效。则用左行加上一个赛道半宽。
// 9889         else if(BlackLeftLoc[row][0] != MaxValUint8 && BlackRightLoc[row][0] == MaxValUint8)
// 9890         {
// 9891           tempflag1 = 0;
// 9892           CenterLineLoc[row] = BlackUdisLeftLocation[row].x + temproad;
// 9893         }
// 9894         //左行无效，右行有效。则用右行减去一个赛道半宽。
// 9895         else if(BlackLeftLoc[row][0] == MaxValUint8 && BlackRightLoc[row][0] != MaxValUint8)
// 9896         {
// 9897           tempflag1 = 0;
// 9898           CenterLineLoc[row] = BlackUdisRightLocation[row].x - temproad;
// 9899         }
// 9900         //左右行均无效。则用最后的中心线均势往前走。
// 9901         else if(BlackLeftLoc[row][0] == MaxValUint8 && BlackRightLoc[row][0] == MaxValUint8)
// 9902         {
// 9903           //当左右线均无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
// 9904           if(tempflag1 == 0)
// 9905           {
// 9906             //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
// 9907             //除非又出现左或右黑线有效的情况，则再次刷新斜率。
// 9908             tempflag1 = 1;
// 9909             //最后几行行数够多，可以采用最小二乘法的方式。
// 9910             if(row + CenterForwardLineNum <= CameraHight - 1)
// 9911             {
// 9912               tempway1 = 0;
// 9913               //进行最小二乘法系数的计算。
// 9914               for(i = 0; i < CenterForwardLineNum; i++)
// 9915               {
// 9916                 x[i] = row + i + 1;
// 9917                 y[i] = CenterLineLoc[row + i + 1];
// 9918               }
// 9919               a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
// 9920               a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
// 9921             }
// 9922             //最后几行的行数不够多，采用最后两行趋势补线的方式。
// 9923             else
// 9924             {
// 9925               tempway1 = 1;
// 9926             }
// 9927           }
// 9928           else
// 9929           {
// 9930           }
// 9931           
// 9932           //确认补线方式后，开始补线。
// 9933           if(tempway1 == 0)
// 9934           {
// 9935             //最小二乘法的方式。
// 9936             CenterLineLoc[row] = (a0 + a1 * row) / LeastSquareMulti;
// 9937           }
// 9938           else
// 9939           {
// 9940             //最后两行的方式。
// 9941             CenterLineLoc[row] = CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2];
// 9942           }
// 9943           
// 9944         }
// 9945         //理论上不会走到这里。
// 9946         else
// 9947         {
// 9948         }
// 9949         
// 9950         if(row == 0) break;
// 9951       }
// 9952          
// 9953       //对未处理的行的中心线置无效值。对顶部的不作处理。
// 9954       //底部置无效值。
// 9955       if(CenterEndLine != CameraHight - 1)
// 9956       {
// 9957         for(row = CameraHight - 1; ; row--)
// 9958         {
// 9959           if(row == CenterEndLine) break;       
// 9960           CenterLineLoc[row] = MaxValInt16;
// 9961         }
// 9962       }
// 9963       else
// 9964       {
// 9965       }
// 9966       
// 9967       //单线错误暂时不检查
// 9968       /*
// 9969       uint8 temphead;
// 9970       
// 9971       //检查单线错误，先判断是不是一线初始行够高，一线初始行够低，若不是，直接跳过节省时间。
// 9972       if(BlackLeftStep1ScanRow <= CameraHight - 3 && BlackRightStep1ScanRow >= CameraHight - 3)
// 9973       {
// 9974         //双线都采集到的时候，最终需要检查一下赛道半宽是不是正确。
// 9975         //第一种情况，有效双行很短，而且范围内存在赛道半宽很小的点。
// 9976         for(i = 0; ; i++)
// 9977         {
// 9978           if(RoadHalfWidthRecord[i] != MaxValUint8)
// 9979           {
// 9980             temphead = i;
// 9981             break;
// 9982           }
// 9983           
// 9984           //理论上不可能走到这里
// 9985           if(i == CameraHight - 1) return 1;  //无法检测单线错误，返回1.
// 9986         }
// 9987         
// 9988         //长度是不是够小。
// 9989         if(BlackLeftStep1ScanRow > temphead && BlackLeftStep1ScanRow - temphead < RoadHalfWidthSingleGapLine)
// 9990         {
// 9991           for(i = BlackLeftStep1ScanRow; ; i--)
// 9992           {
// 9993             if(RoadHalfWidthRecord[i] < RoadHalfWidthSingleLimit)
// 9994             {
// 9995               //存在半宽很小的行，直接置单线错误标志位。 
// 9996               RoadHalfWidthWrongDir = 0;          //单线错误时左线悬空。
// 9997               RoadHalfWidthWrongFlag = 1;
// 9998               break;
// 9999             }            
// 10000             //不存在半宽很小的行，跳出，进行第二种情况的检测。
// 10001             if(i == temphead)
// 10002             {
// 10003               break;
// 10004             }
// 10005           }
// 10006           
// 10007         }
// 10008         
// 10009         //第一种情况没有检测出来的话，就检测第二种情况。
// 10010         if(RoadHalfWidthWrongFlag == 2)
// 10011         {
// 10012           for(i = CameraHight - 1; ; i--)
// 10013           {
// 10014             //只要有效的双行里有任何一个赛道半宽大于阈值，就判断为不是单线错误。
// 10015             if(RoadHalfWidthRecord[i] != MaxValUint8 && RoadHalfWidthRecord[i] > RoadHalfWidthSingleLimit)
// 10016             {
// 10017               RoadHalfWidthWrongFlag = 0;
// 10018               break;
// 10019             }
// 10020             else
// 10021             {
// 10022             }
// 10023             
// 10024             //直到最后一行仍然不满足条件，则判断为单线错误。
// 10025             if(i == 0)
// 10026             {
// 10027               RoadHalfWidthWrongDir = 0;          //单线错误时左线悬空。
// 10028               RoadHalfWidthWrongFlag = 1;
// 10029               break;
// 10030             }
// 10031             else
// 10032             {          
// 10033             }
// 10034           }
// 10035         }
// 10036         else
// 10037         {
// 10038         }        
// 10039       }
// 10040       else if(BlackRightStep1ScanRow <= CameraHight - 3 && BlackLeftStep1ScanRow >= CameraHight - 3)
// 10041       {
// 10042         //双线都采集到的时候，最终需要检查一下赛道半宽是不是正确。
// 10043         //第一种情况，有效双行很短，而且范围内存在赛道半宽很小的点。
// 10044         for(i = 0; ; i++)
// 10045         {
// 10046           if(RoadHalfWidthRecord[i] != MaxValUint8)
// 10047           {
// 10048             temphead = i;
// 10049             break;
// 10050           }
// 10051           
// 10052           //理论上不可能走到这里
// 10053           if(i == CameraHight - 1) return 1;  //无法检测单线错误，返回1.
// 10054         }
// 10055         
// 10056         //长度是不是够小。
// 10057         if(BlackRightStep1ScanRow > temphead && BlackRightStep1ScanRow - temphead < RoadHalfWidthSingleGapLine)
// 10058         {
// 10059           for(i = BlackRightStep1ScanRow; ; i--)
// 10060           {
// 10061             if(RoadHalfWidthRecord[i] < RoadHalfWidthSingleLimit)
// 10062             {
// 10063               //存在半宽很小的行，直接置单线错误标志位。 
// 10064               RoadHalfWidthWrongDir = 1;          //单线错误时右线悬空。
// 10065               RoadHalfWidthWrongFlag = 1;
// 10066               break;
// 10067             }            
// 10068             //不存在半宽很小的行，跳出，进行第二种情况的检测。
// 10069             if(i == temphead)
// 10070             {
// 10071               break;
// 10072             }
// 10073           }
// 10074           
// 10075         }
// 10076         
// 10077         //第一种情况没有检测出来的话，就检测第二种情况。
// 10078         if(RoadHalfWidthWrongFlag == 2)
// 10079         {
// 10080           for(i = CameraHight - 1; ; i--)
// 10081           {
// 10082             //只要有效的双行里有任何一个赛道半宽大于阈值，就判断为不是单线错误。
// 10083             if(RoadHalfWidthRecord[i] != MaxValUint8 && RoadHalfWidthRecord[i] > RoadHalfWidthSingleLimit)
// 10084             {
// 10085               RoadHalfWidthWrongFlag = 0;
// 10086               break;
// 10087             }
// 10088             else
// 10089             {
// 10090             }
// 10091             
// 10092             //直到最后一行仍然不满足条件，则判断为单线错误。
// 10093             if(i == 0)
// 10094             {
// 10095               RoadHalfWidthWrongDir = 1;          //单线错误时右线悬空。
// 10096               RoadHalfWidthWrongFlag = 1;
// 10097               break;
// 10098             }
// 10099             else
// 10100             {          
// 10101             }
// 10102           }
// 10103         }
// 10104         else
// 10105         {
// 10106         }
// 10107         
// 10108       }
// 10109       //初始行不满足条件，则不需要检测单线错误。
// 10110       else
// 10111       {      
// 10112       }
// 10113       
// 10114       //单线错误的处理，暂时简单处理为中心线错误，也就是图像错误。为了让扫描起点保持原状。
// 10115       if(RoadHalfWidthWrongFlag == 1)
// 10116       {        
// 10117         RoadHalfWidth = RoadHalfWidthLast;  //这次的赛道半宽无效，还原为上幅图像最终的赛道半宽。
// 10118         //一边的线是错误的。
// 10119         if(RoadHalfWidthWrongDir == 0)
// 10120         {
// 10121           BlackLeftDone = 0;
// 10122         }
// 10123         else
// 10124         {
// 10125           BlackRightDone = 0;
// 10126         }
// 10127         CenterLineGetSingleWrongAdd();      //针对单线错误的中心线重新处理。
// 10128       }
// 10129       else
// 10130       {        
// 10131       }
// 10132       */
// 10133       
// 10134     }
// 10135     //单线的情况，也就是SingleBlackAllFlag==1的情况。
// 10136     else
// 10137     {
// 10138       tempflag1 = 0;
// 10139       tempway1 = 0;
// 10140       
// 10141       //赛道宽度已经求得，现在开始从低到高求中心线。
// 10142       for(row = CenterEndLine; ; row--)
// 10143       {
// 10144         //当前行左右黑线均有效。检测有无效不能用Udis数组，只能用原始的黑线储存数组。
// 10145         if(BlackLeftLoc[row][0] != MaxValUint8 && BlackRightLoc[row][0] != MaxValUint8)
// 10146         {
// 10147           tempflag1 = 0;
// 10148           //取左右黑线的平均值。
// 10149           CenterLineLoc[row] = (BlackUdisLeftLocation[row].x + BlackUdisRightLocation[row].x) / 2;
// 10150           //取最后一行两行有效的行的赛道半宽，作为最新的赛道半宽。
// 10151           if(BlackUdisLeftLocation[row].x > BlackUdisRightLocation[row].x)
// 10152           {
// 10153             RoadHalfWidthSingle = (BlackUdisLeftLocation[row].x - BlackUdisRightLocation[row].x) / 2;
// 10154           }
// 10155           else
// 10156           {
// 10157             RoadHalfWidthSingle = (BlackUdisRightLocation[row].x - BlackUdisLeftLocation[row].x) / 2;
// 10158           }        
// 10159         }
// 10160         //左行有效，右行无效。则用左行加上一个赛道半宽。
// 10161         else if(BlackLeftLoc[row][0] != MaxValUint8 && BlackRightLoc[row][0] == MaxValUint8)
// 10162         {
// 10163           tempflag1 = 0;
// 10164           CenterLineLoc[row] = BlackUdisLeftLocation[row].x - RoadHalfWidthSingle;    //因为是单线，所以是减号。
// 10165         }
// 10166         //左行无效，右行有效。则用右行减去一个赛道半宽。
// 10167         else if(BlackLeftLoc[row][0] == MaxValUint8 && BlackRightLoc[row][0] != MaxValUint8)
// 10168         {
// 10169           tempflag1 = 0;
// 10170           CenterLineLoc[row] = BlackUdisRightLocation[row].x + RoadHalfWidthSingle;   //因为是单线，所以是加号。
// 10171         }
// 10172         //左右行均无效。则用最后的中心线均势往前走。
// 10173         else if(BlackLeftLoc[row][0] == MaxValUint8 && BlackRightLoc[row][0] == MaxValUint8)
// 10174         {
// 10175           //当左右线均无效时，可以采用最后两行趋势补线，也可以根据最后CenterForwardLineNum行最小二乘法趋势补线。
// 10176           if(tempflag1 == 0)
// 10177           {
// 10178             //每幅图只进来一次，用来确定补线方式，以后就不用再进来了。
// 10179             //除非又出现左或右黑线有效的情况，则再次刷新斜率。
// 10180             tempflag1 = 1;
// 10181             //最后几行行数够多，可以采用最小二乘法的方式。
// 10182             if(row + CenterForwardLineNum <= CameraHight - 1)
// 10183             {
// 10184               tempway1 = 0;
// 10185               //进行最小二乘法系数的计算。
// 10186               for(i = 0; i < CenterForwardLineNum; i++)
// 10187               {
// 10188                 x[i] = row + i + 1;
// 10189                 y[i] = CenterLineLoc[row + i + 1];
// 10190               }
// 10191               a1 = LeastSquareInt16a1(x, y, CenterForwardLineNum);         //斜率计算。
// 10192               a0 = LeastSquareInt16a0(x, y, a1, CenterForwardLineNum);     //纵截距计算。
// 10193             }
// 10194             //最后几行的行数不够多，采用最后两行趋势补线的方式。
// 10195             else
// 10196             {
// 10197               tempway1 = 1;
// 10198             }
// 10199           }
// 10200           else
// 10201           {
// 10202           }
// 10203           
// 10204           //确认补线方式后，开始补线。
// 10205           if(tempway1 == 0)
// 10206           {
// 10207             //最小二乘法的方式。
// 10208             CenterLineLoc[row] = (a0 + a1 * row) / LeastSquareMulti;
// 10209           }
// 10210           else
// 10211           {
// 10212             //最后两行的方式。
// 10213             CenterLineLoc[row] = CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2];
// 10214           }
// 10215           
// 10216         }
// 10217         //理论上不会走到这里。
// 10218         else
// 10219         {
// 10220         }
// 10221         
// 10222         if(row == 0) break;
// 10223       }
// 10224          
// 10225       //对未处理的行的中心线置无效值。对顶部的不作处理。
// 10226       //底部置无效值。
// 10227       if(CenterEndLine != CameraHight - 1)
// 10228       {
// 10229         for(row = CameraHight - 1; ; row--)
// 10230         {
// 10231           if(row == CenterEndLine) break;       
// 10232           CenterLineLoc[row] = MaxValInt16;
// 10233         }
// 10234       }
// 10235       else
// 10236       {
// 10237       }
// 10238     }
// 10239   }
// 10240   //理论上不会走到这里。
// 10241   else
// 10242   {
// 10243     //左右黑线均提取失败，返回0.
// 10244     return 0;
// 10245   }
// 10246   
// 10247   return 1;
??CenterLineGet_22:
        MOVS     R0,#+1
??CenterLineGet_4:
        POP      {R1-R9,PC}       ;; return
??CenterLineGet_1:
        LDR.W    R0,??CenterLineGet_0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.W    ??CenterLineGet_25
        LDR.W    R0,??CenterLineGet_0+0x4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??CenterLineGet_25
        LDR.W    R0,??CenterLineGet_10+0x8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGet_26
        LDR.W    R0,??CenterLineGet_10+0xC
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CenterLineGet_27
??CenterLineGet_26:
        MOVS     R0,#+0
        B.N      ??CenterLineGet_4
??CenterLineGet_27:
        MOVS     R1,#+1
        MOVS     R2,#+1
        LDR.W    R0,??CenterLineGet_10+0x8
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGet_0+0x10
        STRB     R0,[R1, #+0]
        LDR.W    R0,??CenterLineGet_10+0xC
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGet_0+0x14
        STRB     R0,[R1, #+0]
        LDR.W    R0,??CenterLineGet_10+0x8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+26
        BLT.N    ??CenterLineGet_28
        MOVS     R1,#+0
??CenterLineGet_28:
        LDR.W    R0,??CenterLineGet_10+0xC
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BGE.N    ??CenterLineGet_29
        LDR.W    R0,??CenterLineGet_10+0xC
        LDRB     R0,[R0, #+0]
        CMP      R0,#+27
        BGE.N    ??CenterLineGet_29
        MOVS     R2,#+0
        MOVS     R0,#+0
        B.N      ??CenterLineGet_4
??CenterLineGet_29:
        LDR.W    R0,??CenterLineGet_10+0xC
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGet_10+0x8
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGet_30
        LDR.W    R0,??CenterLineGet_10+0x10
        LDR.W    R1,??CenterLineGet_10+0xC
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??CenterLineGet_10+0x10
        LDR.W    R2,??CenterLineGet_10+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.W    R0,??CenterLineGet_10+0x10
        LDR.W    R1,??CenterLineGet_10+0xC
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.W    R1,??CenterLineGet_10+0x10
        LDR.W    R2,??CenterLineGet_10+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGet_31
??CenterLineGet_30:
        MOVS     R0,#+0
??CenterLineGet_31:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8+0x4  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        MOVS     R4,R0
        LDR.W    R0,??CenterLineGet_8+0x8
        LDRB     R1,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R0,R4
        BL       MaxRe
        LDR.W    R1,??CenterLineGet_8+0x8
        STRB     R0,[R1, #+0]
        MOVS     R4,#+0
        MOVS     R5,#+0
        LDR.W    R0,??CenterLineGet_10+0x10
        LDR.W    R1,??CenterLineGet_10+0xC
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??CenterLineGet_8+0x8
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        LDR.W    R1,??CenterLineGet_10
        LDR.W    R2,??CenterLineGet_10+0xC
        LDRB     R2,[R2, #+0]
        STRH     R0,[R1, R2, LSL #+1]
        LDR.W    R0,??CenterLineGet_10+0xC
        LDRB     R0,[R0, #+0]
        SUBS     R8,R0,#+1
        B.N      ??CenterLineGet_32
??CenterLineGet_33:
        SUBS     R8,R8,#+1
??CenterLineGet_32:
        LDR.W    R0,??CenterLineGet_34
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGet_35
        MOVS     R4,#+0
        LDR.W    R0,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R0,R0,R8, LSL #+1
        LDRH     R0,[R0, #+2]
        LDR.W    R1,??CenterLineGet_10+0x10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R1,[R1, R8, LSL #+3]
        ADDS     R0,R1,R0
        LDR.W    R1,??CenterLineGet_10+0x10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R1,R1,R8, LSL #+3
        LDR      R1,[R1, #+8]
        SUBS     R0,R0,R1
        LDR.W    R1,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGet_36
??CenterLineGet_35:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BNE.N    ??CenterLineGet_37
        MOVS     R4,#+1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R0,R8,#+4
        CMP      R0,#+60
        BGE.N    ??CenterLineGet_38
        MOVS     R5,#+0
        MOVS     R0,#+0
        B.N      ??CenterLineGet_39
??CenterLineGet_40:
        ADDS     R1,R0,R8
        ADDS     R1,R1,#+1
        ADD      R2,SP,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
        LDR.W    R1,??CenterLineGet_10
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTAB    R2,R0,R8
        ADDS     R1,R1,R2, LSL #+1
        LDRH     R1,[R1, #+2]
        ADD      R2,SP,#+4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRH     R1,[R2, R0, LSL #+1]
        ADDS     R0,R0,#+1
??CenterLineGet_39:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+4
        BLT.N    ??CenterLineGet_40
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a1
        MOVS     R6,R0
        MOVS     R3,#+4
        MOVS     R2,R6
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a0
        MOVS     R7,R0
        B.N      ??CenterLineGet_37
??CenterLineGet_38:
        MOVS     R5,#+1
??CenterLineGet_37:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??CenterLineGet_41
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MLA      R0,R8,R6,R7
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        LDR.W    R1,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGet_36
??CenterLineGet_41:
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+59
        BEQ.N    ??CenterLineGet_42
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+58
        BNE.N    ??CenterLineGet_43
??CenterLineGet_42:
        LDR.W    R0,??CenterLineGet_10+0x10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R0,[R0, R8, LSL #+3]
        LDR.W    R1,??CenterLineGet_8+0x8
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        LDR.W    R1,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGet_36
??CenterLineGet_43:
        LDR.W    R0,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R0,R0,R8, LSL #+1
        LDRH     R0,[R0, #+2]
        LDR.W    R1,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R1,R1,R8, LSL #+1
        LDRH     R1,[R1, #+2]
        ADDS     R0,R1,R0
        LDR.W    R1,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R1,R1,R8, LSL #+1
        LDRH     R1,[R1, #+4]
        SUBS     R0,R0,R1
        LDR.W    R1,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
??CenterLineGet_36:
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+0
        BNE.W    ??CenterLineGet_33
        LDR.W    R0,??CenterLineGet_0+0x14
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BEQ.W    ??CenterLineGet_22
        MOVS     R8,#+59
        B.N      ??CenterLineGet_44
??CenterLineGet_45:
        MOVW     R0,#+32767
        LDR.W    R1,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        SUBS     R8,R8,#+1
??CenterLineGet_44:
        LDR.W    R0,??CenterLineGet_0+0x14
        LDRB     R0,[R0, #+0]
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,R0
        BNE.N    ??CenterLineGet_45
        B.N      ??CenterLineGet_22
??CenterLineGet_25:
        LDR.W    R0,??CenterLineGet_0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??CenterLineGet_46
        LDR.W    R0,??CenterLineGet_0+0x4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??CenterLineGet_46
        LDR.W    R0,??CenterLineGet_10+0x8
        LDRB     R1,[R0, #+0]
        LDR.W    R0,??CenterLineGet_0+0x8
        LDRB     R0,[R0, #+0]
        BL       MinRe
        LDR.W    R1,??CenterLineGet_0+0x10
        STRB     R0,[R1, #+0]
        LDR.W    R0,??CenterLineGet_10+0xC
        LDRB     R1,[R0, #+0]
        LDR.W    R0,??CenterLineGet_0+0xC
        LDRB     R0,[R0, #+0]
        BL       MaxRe
        LDR.W    R1,??CenterLineGet_0+0x14
        STRB     R0,[R1, #+0]
        LDR.W    R0,??DataTable49
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.W    ??CenterLineGet_47
        MOVS     R1,#+1
        MOVS     R2,#+1
        MOVS     R3,#+1
        MOVS     R0,#+1
        LDR.W    R4,??CenterLineGet_0+0x8
        LDRB     R4,[R4, #+0]
        CMP      R4,#+26
        BLT.N    ??CenterLineGet_48
        MOVS     R1,#+0
??CenterLineGet_48:
        LDR.W    R4,??CenterLineGet_0+0xC
        LDRB     R4,[R4, #+0]
        CMP      R4,#+59
        BGE.N    ??CenterLineGet_49
        LDR.W    R4,??CenterLineGet_0+0xC
        LDRB     R4,[R4, #+0]
        CMP      R4,#+27
        BGE.N    ??CenterLineGet_49
        MOVS     R2,#+0
??CenterLineGet_49:
        LDR.W    R4,??CenterLineGet_10+0x8
        LDRB     R4,[R4, #+0]
        CMP      R4,#+26
        BLT.N    ??CenterLineGet_50
        MOVS     R3,#+0
??CenterLineGet_50:
        LDR.W    R4,??CenterLineGet_10+0xC
        LDRB     R4,[R4, #+0]
        CMP      R4,#+59
        BGE.N    ??CenterLineGet_51
        LDR.W    R4,??CenterLineGet_10+0xC
        LDRB     R4,[R4, #+0]
        CMP      R4,#+27
        BGE.N    ??CenterLineGet_51
        MOVS     R0,#+0
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BNE.N    ??CenterLineGet_51
        MOVS     R0,#+0
        B.N      ??CenterLineGet_4
??CenterLineGet_51:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+1
        BNE.W    ??CenterLineGet_52
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.W    ??CenterLineGet_52
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??CenterLineGet_53
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BEQ.N    ??CenterLineGet_54
??CenterLineGet_53:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??CenterLineGet_55
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BEQ.N    ??CenterLineGet_54
??CenterLineGet_55:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.W    ??CenterLineGet_52
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.N    ??CenterLineGet_52
??CenterLineGet_54:
        LDR.W    R0,??CenterLineGet_10+0xC
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGet_10+0x8
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGet_56
        LDR.W    R0,??CenterLineGet_10+0x10
        LDR.W    R1,??CenterLineGet_10+0xC
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??CenterLineGet_10+0x10
        LDR.W    R2,??CenterLineGet_10+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.W    R0,??CenterLineGet_10+0x10
        LDR.W    R1,??CenterLineGet_10+0xC
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.W    R1,??CenterLineGet_10+0x10
        LDR.W    R2,??CenterLineGet_10+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGet_57
??CenterLineGet_56:
        MOVS     R0,#+0
??CenterLineGet_57:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8+0x4  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        MOVS     R4,R0
        LDR.W    R0,??CenterLineGet_8+0x8
        LDRB     R0,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        SDIV     R0,R0,R4
        BL       __aeabi_i2f
        LDR.W    R1,??DataTable50
        STR      R0,[R1, #+0]
        LDR.W    R0,??CenterLineGet_8+0x8
        LDRB     R1,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R0,R4
        BL       MaxRe
        LDR.W    R1,??CenterLineGet_8+0x8
        STRB     R0,[R1, #+0]
??CenterLineGet_58:
        LDR.W    R0,??CenterLineGet_8+0x8
        LDRB     R9,[R0, #+0]
        MOVS     R4,#+0
        MOVS     R5,#+0
        LDR.W    R0,??CenterLineGet_0+0x14
        LDRB     R8,[R0, #+0]
        B.N      ??CenterLineGet_59
??CenterLineGet_52:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.W    ??CenterLineGet_60
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.W    ??CenterLineGet_60
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BNE.N    ??CenterLineGet_61
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BEQ.N    ??CenterLineGet_62
??CenterLineGet_61:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+1
        BNE.N    ??CenterLineGet_63
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BEQ.N    ??CenterLineGet_62
??CenterLineGet_63:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BNE.N    ??CenterLineGet_60
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??CenterLineGet_60
??CenterLineGet_62:
        LDR.W    R0,??CenterLineGet_0+0xC
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGet_0+0x8
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGet_64
        LDR.W    R0,??CenterLineGet_0+0x18
        LDR.W    R1,??CenterLineGet_0+0xC
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??CenterLineGet_0+0x18
        LDR.W    R2,??CenterLineGet_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.W    R0,??CenterLineGet_0+0x18
        LDR.W    R1,??CenterLineGet_0+0xC
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.W    R1,??CenterLineGet_0+0x18
        LDR.W    R2,??CenterLineGet_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGet_65
??CenterLineGet_64:
        MOVS     R0,#+0
??CenterLineGet_65:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8+0x4  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        MOVS     R4,R0
        LDR.W    R0,??CenterLineGet_8+0x8
        LDRB     R0,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        SDIV     R0,R0,R4
        BL       __aeabi_i2f
        LDR.W    R1,??DataTable50
        STR      R0,[R1, #+0]
        LDR.W    R0,??CenterLineGet_8+0x8
        LDRB     R1,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R0,R4
        BL       MaxRe
        LDR.W    R1,??CenterLineGet_8+0x8
        STRB     R0,[R1, #+0]
        B.N      ??CenterLineGet_58
??CenterLineGet_60:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.W    ??CenterLineGet_66
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.W    ??CenterLineGet_66
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+1
        BNE.W    ??CenterLineGet_66
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.W    ??CenterLineGet_66
        LDR.W    R0,??CenterLineGet_0+0xC
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGet_0+0x8
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGet_67
        LDR.W    R0,??CenterLineGet_0+0x18
        LDR.W    R1,??CenterLineGet_0+0xC
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??CenterLineGet_0+0x18
        LDR.W    R2,??CenterLineGet_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.W    R0,??CenterLineGet_0+0x18
        LDR.W    R1,??CenterLineGet_0+0xC
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.W    R1,??CenterLineGet_0+0x18
        LDR.W    R2,??CenterLineGet_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGet_68
??CenterLineGet_67:
        MOVS     R0,#+0
??CenterLineGet_68:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8+0x4  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        MOVS     R4,R0
        LDR.W    R0,??CenterLineGet_10+0xC
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGet_10+0x8
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGet_69
        LDR.W    R0,??CenterLineGet_10+0x10
        LDR.W    R1,??CenterLineGet_10+0xC
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??CenterLineGet_10+0x10
        LDR.W    R2,??CenterLineGet_10+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOV      R8,R0
        MOV      R9,R1
        LDR.W    R0,??CenterLineGet_10+0x10
        LDR.W    R1,??CenterLineGet_10+0xC
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.W    R1,??CenterLineGet_10+0x10
        LDR.W    R2,??CenterLineGet_10+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOV      R0,R8
        MOV      R1,R9
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGet_70
??CenterLineGet_69:
        MOVS     R0,#+0
??CenterLineGet_70:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,R0
        MOVS     R3,R1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,R4
        MOVS     R4,R1
        MOVS     R0,#+0
        LDR.W    R1,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8+0x4  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R1,R4
        BL       MaxRe
        MOVS     R4,R0
        LDR.W    R0,??CenterLineGet_8+0x8
        LDRB     R0,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        SDIV     R0,R0,R4
        BL       __aeabi_i2f
        LDR.W    R1,??DataTable50
        STR      R0,[R1, #+0]
        LDR.W    R0,??CenterLineGet_8+0x8
        LDRB     R1,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R0,R4
        BL       MaxRe
        LDR.W    R1,??CenterLineGet_8+0x8
        STRB     R0,[R1, #+0]
        B.N      ??CenterLineGet_58
??CenterLineGet_66:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BNE.N    ??CenterLineGet_71
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??CenterLineGet_71
        MOVS     R0,#+0
        B.N      ??CenterLineGet_4
??CenterLineGet_71:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??CenterLineGet_72
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BNE.N    ??CenterLineGet_72
        LDR.N    R0,??CenterLineGet_0+0xC
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??CenterLineGet_0+0x8
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGet_73
        LDR.N    R0,??CenterLineGet_0+0x18
        LDR.N    R1,??CenterLineGet_0+0xC
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.N    R1,??CenterLineGet_0+0x18
        LDR.N    R2,??CenterLineGet_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.N    R0,??CenterLineGet_0+0x18
        LDR.N    R1,??CenterLineGet_0+0xC
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.N    R1,??CenterLineGet_0+0x18
        LDR.N    R2,??CenterLineGet_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGet_74
??CenterLineGet_73:
        MOVS     R0,#+0
??CenterLineGet_74:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??CenterLineGet_8+0x4  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        MOVS     R4,R0
        LDR.N    R0,??CenterLineGet_8+0x8
        LDRB     R0,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        SDIV     R0,R0,R4
        BL       __aeabi_i2f
        LDR.W    R1,??DataTable50
        STR      R0,[R1, #+0]
        LDR.N    R0,??CenterLineGet_8+0x8
        LDRB     R1,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R0,R4
        BL       MaxRe
        LDR.N    R1,??CenterLineGet_8+0x8
        STRB     R0,[R1, #+0]
        B.N      ??CenterLineGet_58
??CenterLineGet_72:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??CenterLineGet_75
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+1
        BNE.N    ??CenterLineGet_75
        LDR.W    R0,??CenterLineGet_10+0xC
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??CenterLineGet_10+0x8
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGet_76
        LDR.W    R0,??CenterLineGet_10+0x10
        LDR.W    R1,??CenterLineGet_10+0xC
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.W    R1,??CenterLineGet_10+0x10
        LDR.W    R2,??CenterLineGet_10+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.N    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.W    R0,??CenterLineGet_10+0x10
        LDR.W    R1,??CenterLineGet_10+0xC
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.W    R1,??CenterLineGet_10+0x10
        LDR.N    R2,??CenterLineGet_10+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGet_77
??CenterLineGet_76:
        MOVS     R0,#+0
??CenterLineGet_77:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,#+0
        LDR.N    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.N    R3,??CenterLineGet_8+0x4  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        MOVS     R4,R0
        LDR.N    R0,??CenterLineGet_8+0x8
        LDRB     R0,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        SDIV     R0,R0,R4
        BL       __aeabi_i2f
        LDR.W    R1,??DataTable50
        STR      R0,[R1, #+0]
        LDR.N    R0,??CenterLineGet_8+0x8
        LDRB     R1,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R0,R4
        BL       MaxRe
        LDR.N    R1,??CenterLineGet_8+0x8
        STRB     R0,[R1, #+0]
        B.N      ??CenterLineGet_58
??CenterLineGet_75:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.W    ??CenterLineGet_78
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BNE.W    ??CenterLineGet_78
        LDR.N    R0,??CenterLineGet_0+0xC
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??CenterLineGet_0+0x8
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGet_79
        LDR.N    R0,??CenterLineGet_0+0x18
        LDR.N    R1,??CenterLineGet_0+0xC
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.N    R1,??CenterLineGet_0+0x18
        LDR.N    R2,??CenterLineGet_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.N    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R4,R0
        MOVS     R5,R1
        LDR.N    R0,??CenterLineGet_0+0x18
        LDR.N    R1,??CenterLineGet_0+0xC
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.N    R1,??CenterLineGet_0+0x18
        LDR.N    R2,??CenterLineGet_0+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOVS     R0,R4
        MOVS     R1,R5
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGet_80
??CenterLineGet_79:
        MOVS     R0,#+0
??CenterLineGet_80:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,#+0
        LDR.N    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.N    R3,??CenterLineGet_8+0x4  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        MOVS     R4,R0
        LDR.N    R0,??CenterLineGet_10+0xC
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??CenterLineGet_10+0x8
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+6
        BLT.N    ??CenterLineGet_81
        LDR.N    R0,??CenterLineGet_10+0x10
        LDR.N    R1,??CenterLineGet_10+0xC
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        LDR.N    R1,??CenterLineGet_10+0x10
        LDR.N    R2,??CenterLineGet_10+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-32]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,#+0
        LDR.N    R3,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOV      R8,R0
        MOV      R9,R1
        LDR.N    R0,??CenterLineGet_10+0x10
        LDR.N    R1,??CenterLineGet_10+0xC
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #+4]
        LDR.N    R1,??CenterLineGet_10+0x10
        LDR.N    R2,??CenterLineGet_10+0xC
        LDRB     R2,[R2, #+0]
        ADDS     R1,R1,R2, LSL #+3
        LDR      R1,[R1, #-28]
        SUBS     R0,R0,R1
        BL       __aeabi_i2d
        MOVS     R2,R0
        MOVS     R3,R1
        MOV      R0,R8
        MOV      R1,R9
        BL       __aeabi_ddiv
        BL       __aeabi_d2f
        B.N      ??CenterLineGet_82
        DATA
??CenterLineGet_0:
        DC32     BlackLeftDone
        DC32     BlackRightDone
        DC32     BlackLeftHeadLine
        DC32     BlackLeftEndLine
        DC32     CenterHeadLine
        DC32     CenterEndLine
        DC32     BlackUdisLeftLocation
        THUMB
??CenterLineGet_81:
        MOVS     R0,#+0
??CenterLineGet_82:
        MOVS     R1,R0
        BL       __aeabi_fmul
        MOVS     R1,#+1065353216
        BL       __aeabi_fadd
        BL       __aeabi_f2d
        BL       sqrt
        MOVS     R2,R0
        MOVS     R3,R1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,R4
        MOVS     R4,R1
        MOVS     R0,#+0
        LDR.N    R1,??CenterLineGet_8  ;; 0x3ff00000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.N    R3,??CenterLineGet_8+0x4  ;; 0x40690000
        BL       __aeabi_dmul
        MOVS     R2,#+0
        MOVS     R3,#+1073741824
        BL       __aeabi_ddiv
        BL       __aeabi_d2iz
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R1,R4
        BL       MaxRe
        MOVS     R4,R0
        LDR.N    R0,??CenterLineGet_8+0x8
        LDRB     R0,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        SDIV     R0,R0,R4
        BL       __aeabi_i2f
        LDR.W    R1,??DataTable50
        STR      R0,[R1, #+0]
        LDR.N    R0,??CenterLineGet_8+0x8
        LDRB     R1,[R0, #+0]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R0,R4
        BL       MaxRe
        LDR.N    R1,??CenterLineGet_8+0x8
        STRB     R0,[R1, #+0]
        B.N      ??CenterLineGet_58
??CenterLineGet_78:
        MOVS     R0,#+0
        B.W      ??CenterLineGet_4
??CenterLineGet_83:
        SUBS     R8,R8,#+1
??CenterLineGet_59:
        LDR.N    R0,??CenterLineGet_10+0x4
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.W    ??CenterLineGet_84
        LDR.W    R0,??CenterLineGet_34
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.W    ??CenterLineGet_84
        MOVS     R4,#+0
        LDR.W    R0,??DataTable53
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R0,[R0, R8, LSL #+3]
        LDR.N    R1,??CenterLineGet_10+0x10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R1,[R1, R8, LSL #+3]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        LDR.N    R1,??CenterLineGet_10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        LDR.N    R0,??CenterLineGet_10+0x10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R0,[R0, R8, LSL #+3]
        LDR.W    R1,??DataTable53
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R1,[R1, R8, LSL #+3]
        CMP      R0,R1
        BGE.N    ??CenterLineGet_85
        LDR.W    R0,??DataTable53
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R0,[R0, R8, LSL #+3]
        LDR.N    R1,??CenterLineGet_10+0x10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R1,[R1, R8, LSL #+3]
        SUBS     R0,R0,R1
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable53_1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRB     R0,[R8, R1]
        B.N      ??CenterLineGet_86
        DATA
??CenterLineGet_8:
        DC32     0x3ff00000
        DC32     0x40690000
        DC32     RoadHalfWidth
        THUMB
??CenterLineGet_85:
        LDR.N    R0,??CenterLineGet_10+0x10
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R0,[R0, R8, LSL #+3]
        LDR.W    R1,??DataTable53
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R1,[R1, R8, LSL #+3]
        SUBS     R0,R0,R1
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable53_1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRB     R0,[R8, R1]
??CenterLineGet_86:
        LDR.W    R0,??DataTable53_1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDRB     R9,[R8, R0]
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+59
        BNE.W    ??CenterLineGet_87
        LDR.W    R0,??DataTable53_1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDRB     R0,[R8, R0]
        CMP      R0,#+101
        BLT.N    ??CenterLineGet_88
        MOVS     R0,#+100
        LDR.W    R1,??DataTable54
        STRB     R0,[R1, #+0]
        B.N      ??CenterLineGet_87
??CenterLineGet_88:
        LDR.W    R0,??DataTable53_1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDRB     R0,[R8, R0]
        CMP      R0,#+70
        BGE.N    ??CenterLineGet_89
        MOVS     R0,#+70
        LDR.W    R1,??DataTable54
        STRB     R0,[R1, #+0]
        B.N      ??CenterLineGet_87
??CenterLineGet_89:
        LDR.W    R0,??DataTable53_1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDRB     R0,[R8, R0]
        LDR.W    R1,??DataTable54
        STRB     R0,[R1, #+0]
        B.N      ??CenterLineGet_87
        Nop      
        DATA
??CenterLineGet_10:
        DC32     CenterLineLoc
        DC32     BlackLeftLoc
        DC32     BlackRightHeadLine
        DC32     BlackRightEndLine
        DC32     BlackUdisRightLocation
        THUMB
??CenterLineGet_84:
        LDR.W    R0,??DataTable54_1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGet_90
        LDR.N    R0,??CenterLineGet_34
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CenterLineGet_90
        MOVS     R4,#+0
        LDR.W    R0,??DataTable53
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R0,[R0, R8, LSL #+3]
        UXTAB    R0,R0,R9
        LDR.W    R1,??DataTable54_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGet_87
??CenterLineGet_90:
        LDR.W    R0,??DataTable54_1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CenterLineGet_91
        LDR.N    R0,??CenterLineGet_34
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGet_91
        MOVS     R4,#+0
        LDR.W    R0,??DataTable54_3
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R0,[R0, R8, LSL #+3]
        UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
        SUBS     R0,R0,R9
        LDR.W    R1,??DataTable54_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGet_87
??CenterLineGet_91:
        LDR.W    R0,??DataTable54_1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CenterLineGet_87
        LDR.N    R0,??CenterLineGet_34
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CenterLineGet_87
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BNE.N    ??CenterLineGet_92
        MOVS     R4,#+1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R0,R8,#+4
        CMP      R0,#+60
        BGE.N    ??CenterLineGet_93
        MOVS     R5,#+0
        MOVS     R0,#+0
        B.N      ??CenterLineGet_94
??CenterLineGet_95:
        ADDS     R1,R0,R8
        ADDS     R1,R1,#+1
        ADD      R2,SP,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
        LDR.W    R1,??DataTable54_2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTAB    R2,R0,R8
        ADDS     R1,R1,R2, LSL #+1
        LDRH     R1,[R1, #+2]
        ADD      R2,SP,#+4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRH     R1,[R2, R0, LSL #+1]
        ADDS     R0,R0,#+1
??CenterLineGet_94:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+4
        BLT.N    ??CenterLineGet_95
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a1
        MOVS     R6,R0
        MOVS     R3,#+4
        MOVS     R2,R6
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a0
        MOVS     R7,R0
        B.N      ??CenterLineGet_92
??CenterLineGet_93:
        MOVS     R5,#+1
??CenterLineGet_92:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??CenterLineGet_96
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MLA      R0,R8,R6,R7
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable54_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGet_87
??CenterLineGet_96:
        LDR.W    R0,??DataTable54_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R0,R0,R8, LSL #+1
        LDRH     R0,[R0, #+2]
        LDR.W    R1,??DataTable54_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R1,R1,R8, LSL #+1
        LDRH     R1,[R1, #+2]
        ADDS     R0,R1,R0
        LDR.W    R1,??DataTable54_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R1,R1,R8, LSL #+1
        LDRH     R1,[R1, #+4]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable54_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
??CenterLineGet_87:
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+0
        BNE.W    ??CenterLineGet_83
        LDR.W    R0,??DataTable56
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BEQ.W    ??CenterLineGet_22
        MOVS     R8,#+59
        B.N      ??CenterLineGet_97
??CenterLineGet_98:
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable54_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        SUBS     R8,R8,#+1
??CenterLineGet_97:
        LDR.W    R0,??DataTable56
        LDRB     R0,[R0, #+0]
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,R0
        BNE.N    ??CenterLineGet_98
        B.W      ??CenterLineGet_22
??CenterLineGet_47:
        MOVS     R4,#+0
        MOVS     R5,#+0
        LDR.W    R0,??DataTable56
        LDRB     R8,[R0, #+0]
        B.N      ??CenterLineGet_99
??CenterLineGet_100:
        SUBS     R8,R8,#+1
??CenterLineGet_99:
        LDR.W    R0,??DataTable54_1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGet_101
        LDR.N    R0,??CenterLineGet_34
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGet_101
        MOVS     R4,#+0
        LDR.W    R0,??DataTable53
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R0,[R0, R8, LSL #+3]
        LDR.W    R1,??DataTable54_3
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R1,[R1, R8, LSL #+3]
        ADDS     R0,R1,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable54_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        LDR.W    R0,??DataTable54_3
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R0,[R0, R8, LSL #+3]
        LDR.W    R1,??DataTable53
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R1,[R1, R8, LSL #+3]
        CMP      R0,R1
        BGE.N    ??CenterLineGet_102
        LDR.W    R0,??DataTable53
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R0,[R0, R8, LSL #+3]
        LDR.W    R1,??DataTable54_3
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R1,[R1, R8, LSL #+3]
        SUBS     R0,R0,R1
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable56_1
        STRB     R0,[R1, #+0]
        B.N      ??CenterLineGet_103
??CenterLineGet_102:
        LDR.W    R0,??DataTable54_3
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R0,[R0, R8, LSL #+3]
        LDR.W    R1,??DataTable53
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R1,[R1, R8, LSL #+3]
        SUBS     R0,R0,R1
        MOVS     R1,#+2
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable56_1
        STRB     R0,[R1, #+0]
        B.N      ??CenterLineGet_103
        Nop      
        DATA
??CenterLineGet_34:
        DC32     BlackRightLoc
        THUMB
??CenterLineGet_101:
        LDR.W    R0,??DataTable54_1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGet_104
        LDR.W    R0,??DataTable56_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CenterLineGet_104
        MOVS     R4,#+0
        LDR.W    R0,??DataTable53
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R0,[R0, R8, LSL #+3]
        LDR.W    R1,??DataTable56_1
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable54_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGet_103
??CenterLineGet_104:
        LDR.W    R0,??DataTable54_1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CenterLineGet_105
        LDR.W    R0,??DataTable56_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CenterLineGet_105
        MOVS     R4,#+0
        LDR.W    R0,??DataTable54_3
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDR      R0,[R0, R8, LSL #+3]
        LDR.W    R1,??DataTable56_1
        LDRB     R1,[R1, #+0]
        ADDS     R0,R0,R1
        LDR.W    R1,??DataTable54_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGet_103
??CenterLineGet_105:
        LDR.W    R0,??DataTable54_1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CenterLineGet_103
        LDR.W    R0,??DataTable56_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R8,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CenterLineGet_103
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BNE.N    ??CenterLineGet_106
        MOVS     R4,#+1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R0,R8,#+4
        CMP      R0,#+60
        BGE.N    ??CenterLineGet_107
        MOVS     R5,#+0
        MOVS     R0,#+0
        B.N      ??CenterLineGet_108
??CenterLineGet_109:
        ADDS     R1,R0,R8
        ADDS     R1,R1,#+1
        ADD      R2,SP,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
        LDR.W    R1,??DataTable54_2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTAB    R2,R0,R8
        ADDS     R1,R1,R2, LSL #+1
        LDRH     R1,[R1, #+2]
        ADD      R2,SP,#+4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRH     R1,[R2, R0, LSL #+1]
        ADDS     R0,R0,#+1
??CenterLineGet_108:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+4
        BLT.N    ??CenterLineGet_109
        MOVS     R2,#+4
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a1
        MOVS     R6,R0
        MOVS     R3,#+4
        MOVS     R2,R6
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
        BL       LeastSquareInt16a0
        MOVS     R7,R0
        B.N      ??CenterLineGet_106
??CenterLineGet_107:
        MOVS     R5,#+1
??CenterLineGet_106:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??CenterLineGet_110
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MLA      R0,R8,R6,R7
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable54_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        B.N      ??CenterLineGet_103
??CenterLineGet_110:
        LDR.W    R0,??DataTable54_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R0,R0,R8, LSL #+1
        LDRH     R0,[R0, #+2]
        LDR.W    R1,??DataTable54_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R1,R1,R8, LSL #+1
        LDRH     R1,[R1, #+2]
        ADDS     R0,R1,R0
        LDR.W    R1,??DataTable54_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        ADDS     R1,R1,R8, LSL #+1
        LDRH     R1,[R1, #+4]
        SUBS     R0,R0,R1
        LDR.W    R1,??DataTable54_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
??CenterLineGet_103:
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,#+0
        BNE.W    ??CenterLineGet_100
        LDR.W    R0,??DataTable56
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BEQ.W    ??CenterLineGet_22
        MOVS     R8,#+59
        B.N      ??CenterLineGet_111
??CenterLineGet_112:
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable54_2
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        STRH     R0,[R1, R8, LSL #+1]
        SUBS     R8,R8,#+1
??CenterLineGet_111:
        LDR.W    R0,??DataTable56
        LDRB     R0,[R0, #+0]
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        CMP      R8,R0
        BNE.N    ??CenterLineGet_112
        B.W      ??CenterLineGet_22
??CenterLineGet_46:
        MOVS     R0,#+0
        B.W      ??CenterLineGet_4
// 10248 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable49:
        DC32     SingleBlackAllFlag
// 10249 
// 10250 
// 10251 
// 10252 
// 10253 
// 10254 //中心线求取时，根据两列偏差绝对值来求取赛道半宽度的函数。
// 10255 //val为第39行与第59的列偏差的绝对值。
// 10256 //返回估计出来的赛道半宽度。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 10257 uint8 CenterLineHalfWidthGet(uint8 val)
// 10258 {
// 10259   uint8 temphalfwidth;
// 10260   
// 10261   if(val <= 25)
CenterLineHalfWidthGet:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+26
        BGE.N    ??CenterLineHalfWidthGet_0
// 10262   {
// 10263     temphalfwidth = 100;
        MOVS     R0,#+100
        B.N      ??CenterLineHalfWidthGet_1
// 10264   }
// 10265   else
// 10266   {
// 10267     if(val <= 30)
??CenterLineHalfWidthGet_0:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+31
        BGE.N    ??CenterLineHalfWidthGet_2
// 10268     {
// 10269       //temphalfwidth = 95;
// 10270       temphalfwidth = 110;
        MOVS     R0,#+110
        B.N      ??CenterLineHalfWidthGet_1
// 10271     }
// 10272     else
// 10273     {
// 10274       if(val <= 35)
??CenterLineHalfWidthGet_2:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+36
        BGE.N    ??CenterLineHalfWidthGet_3
// 10275       {
// 10276         //temphalfwidth = 105;
// 10277         temphalfwidth = 120;
        MOVS     R0,#+120
        B.N      ??CenterLineHalfWidthGet_1
// 10278       }
// 10279       else
// 10280       {
// 10281           //temphalfwidth = 110;
// 10282           temphalfwidth = 130;
??CenterLineHalfWidthGet_3:
        MOVS     R0,#+130
// 10283       }
// 10284     }
// 10285   }
// 10286   
// 10287   return temphalfwidth;
??CenterLineHalfWidthGet_1:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BX       LR               ;; return
// 10288 }
// 10289 
// 10290 
// 10291 
// 10292 
// 10293 //图像重新赋值，摄像头反转版本。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 10294 void ImgReversePut(void)
// 10295 {
ImgReversePut:
        PUSH     {R4-R7}
// 10296 
// 10297     uint16 i, j, k, temp1, temp2;   
// 10298     
// 10299     temp1 = CameraRealLeftCol;
        LDR.W    R0,??DataTable56_3
        LDRB     R0,[R0, #+0]
// 10300     temp2 = CameraRealLeftCol + CameraRealWidth;
        LDR.W    R1,??DataTable56_3
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+250
// 10301     //temp1 = CameraWidth/2 - CameraRealWidth/2 - 1;
// 10302     //temp2 = CameraWidth/2 + CameraRealWidth/2 - 1;
// 10303     
// 10304     if (ImgPresent == ImgNO1)    //如果当前是第1幅图像正在接收数据（即第2幅图像接收完成）
        LDR.W    R2,??DataTable56_4
        LDRB     R2,[R2, #+0]
        CMP      R2,#+1
        BNE.N    ??ImgReversePut_0
// 10305     {
// 10306       for(i = 0; i < CameraHight; i++)
        MOVS     R2,#+0
        B.N      ??ImgReversePut_1
// 10307       {
// 10308         k = 0;
// 10309         for(j = temp1; j < temp2; j++)
// 10310         {
// 10311           ImgNew[CameraHight-1-i][CameraRealWidth-1-k] = ImgStore2[i][j];
??ImgReversePut_2:
        LDR.W    R5,??DataTable56_5
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        RSBS     R6,R2,#+0
        MOVS     R7,#+250
        MLA      R5,R7,R6,R5
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        SUBS     R5,R5,R4
        MOVW     R6,#+14999
        LDR.W    R7,??DataTable56_6
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        MOV      R12,#+320
        MLA      R7,R12,R2,R7
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        LDRB     R7,[R3, R7]
        STRB     R7,[R6, R5]
// 10312           k++;
        ADDS     R4,R4,#+1
// 10313         }
        ADDS     R3,R3,#+1
??ImgReversePut_3:
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        CMP      R3,R1
        BCC.N    ??ImgReversePut_2
        ADDS     R2,R2,#+1
??ImgReversePut_1:
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        CMP      R2,#+60
        BGE.N    ??ImgReversePut_4
        MOVS     R4,#+0
        MOVS     R3,R0
        B.N      ??ImgReversePut_3
// 10314       }
// 10315     }
// 10316     else if (ImgPresent == ImgNO2)  //如果当前是第2幅图像正在接收数据（即第1幅图像接收完成）
??ImgReversePut_0:
        LDR.W    R2,??DataTable56_4
        LDRB     R2,[R2, #+0]
        CMP      R2,#+2
        BNE.N    ??ImgReversePut_4
// 10317     {
// 10318       for(i = 0; i < CameraHight; i++)
        MOVS     R2,#+0
        B.N      ??ImgReversePut_5
// 10319       {
// 10320         k = 0;
// 10321         for(j = temp1; j < temp2; j++)
// 10322         {
// 10323           ImgNew[CameraHight-1-i][CameraRealWidth-1-k] = ImgStore1[i][j];
??ImgReversePut_6:
        LDR.W    R5,??DataTable56_5
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        RSBS     R6,R2,#+0
        MOVS     R7,#+250
        MLA      R5,R7,R6,R5
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        SUBS     R5,R5,R4
        MOVW     R6,#+14999
        LDR.W    R7,??DataTable57
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        MOV      R12,#+320
        MLA      R7,R12,R2,R7
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        LDRB     R7,[R3, R7]
        STRB     R7,[R6, R5]
// 10324           k++;
        ADDS     R4,R4,#+1
// 10325         }
        ADDS     R3,R3,#+1
??ImgReversePut_7:
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        CMP      R3,R1
        BCC.N    ??ImgReversePut_6
        ADDS     R2,R2,#+1
??ImgReversePut_5:
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        CMP      R2,#+60
        BGE.N    ??ImgReversePut_4
        MOVS     R4,#+0
        MOVS     R3,R0
        B.N      ??ImgReversePut_7
// 10326       }
// 10327     }
// 10328     else 
// 10329     {
// 10330         //uart_sendN(UART0, (uint8 *)"\nError In FieldIsr()!", 21);   //错误警告
// 10331     }
// 10332   
// 10333 }
??ImgReversePut_4:
        POP      {R4-R7}
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable50:
        DC32     RoadHalfWidthCompen
// 10334 
// 10335 
// 10336 
// 10337 //图像重新赋值,行不变（行中DMA中变化，选取需要的行），列无法在DMA中变化，就在这里变化。
// 10338 ///////////////////////////////////////////但这里需要用示波器测量一下时间，看是不是耗费了太多时间。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 10339 void ImgPut(void)
// 10340 {
ImgPut:
        PUSH     {R4-R7}
// 10341     uint16 i, j, k, temp1, temp2;   
// 10342     
// 10343     temp1 = CameraRealLeftCol;
        LDR.W    R0,??DataTable56_3
        LDRB     R0,[R0, #+0]
// 10344     temp2 = CameraRealLeftCol + CameraRealWidth;
        LDR.W    R1,??DataTable56_3
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+250
// 10345     //temp1 = CameraWidth/2 - CameraRealWidth/2 - 1;
// 10346     //temp2 = CameraWidth/2 + CameraRealWidth/2 - 1;
// 10347     
// 10348     if (ImgPresent == ImgNO1)    //如果当前是第1幅图像正在接收数据（即第2幅图像接收完成）
        LDR.W    R2,??DataTable56_4
        LDRB     R2,[R2, #+0]
        CMP      R2,#+1
        BNE.N    ??ImgPut_0
// 10349     {
// 10350       for(i = 0; i < CameraHight; i++)
        MOVS     R2,#+0
        B.N      ??ImgPut_1
// 10351       {
// 10352         k = 0;
// 10353         for(j = temp1; j < temp2; j++)
// 10354         {
// 10355           ImgNew[i][k] = ImgStore2[i][j];
??ImgPut_2:
        LDR.W    R5,??DataTable56_5
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        MOVS     R6,#+250
        MLA      R5,R6,R2,R5
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        LDR.W    R6,??DataTable56_6
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        MOV      R7,#+320
        MLA      R6,R7,R2,R6
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        LDRB     R6,[R3, R6]
        STRB     R6,[R4, R5]
// 10356           k++;
        ADDS     R4,R4,#+1
// 10357         }
        ADDS     R3,R3,#+1
??ImgPut_3:
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        CMP      R3,R1
        BCC.N    ??ImgPut_2
        ADDS     R2,R2,#+1
??ImgPut_1:
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        CMP      R2,#+60
        BGE.N    ??ImgPut_4
        MOVS     R4,#+0
        MOVS     R3,R0
        B.N      ??ImgPut_3
// 10358       }
// 10359     }
// 10360     else if (ImgPresent == ImgNO2)  //如果当前是第2幅图像正在接收数据（即第1幅图像接收完成）
??ImgPut_0:
        LDR.W    R2,??DataTable56_4
        LDRB     R2,[R2, #+0]
        CMP      R2,#+2
        BNE.N    ??ImgPut_4
// 10361     {
// 10362       for(i = 0; i < CameraHight; i++)
        MOVS     R2,#+0
        B.N      ??ImgPut_5
// 10363       {
// 10364         k = 0;
// 10365         for(j = temp1; j < temp2; j++)
// 10366         {
// 10367           ImgNew[i][k] = ImgStore1[i][j];
??ImgPut_6:
        LDR.W    R5,??DataTable56_5
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        MOVS     R6,#+250
        MLA      R5,R6,R2,R5
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        LDR.W    R6,??DataTable57
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        MOV      R7,#+320
        MLA      R6,R7,R2,R6
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        LDRB     R6,[R3, R6]
        STRB     R6,[R4, R5]
// 10368           k++;
        ADDS     R4,R4,#+1
// 10369         }
        ADDS     R3,R3,#+1
??ImgPut_7:
        UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        CMP      R3,R1
        BCC.N    ??ImgPut_6
        ADDS     R2,R2,#+1
??ImgPut_5:
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        CMP      R2,#+60
        BGE.N    ??ImgPut_4
        MOVS     R4,#+0
        MOVS     R3,R0
        B.N      ??ImgPut_7
// 10370       }
// 10371     }
// 10372     else 
// 10373     {
// 10374         //uart_sendN(UART0, (uint8 *)"\nError In FieldIsr()!", 21);   //错误警告
// 10375     }
// 10376 
// 10377 }
??ImgPut_4:
        POP      {R4-R7}
        BX       LR               ;; return
// 10378 
// 10379 
// 10380 
// 10381 
// 10382 
// 10383 //中心线离散度求取函数。自身的离散程度，和中心线的。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 10384 void ErrorGet(void)
// 10385 {
ErrorGet:
        PUSH     {R3-R7,LR}
// 10386   uint8 row;
// 10387   uint8 avg = 0;
        MOVS     R7,#+0
// 10388   float temp;
// 10389   uint8 index;
// 10390   //求取平均值
// 10391   temp = 0;
        MOVS     R4,#+0
// 10392   index = 0;
        MOVS     R5,#+0
// 10393   for(row = CameraHight - 1; ; row--)
        MOVS     R6,#+59
        B.N      ??ErrorGet_0
??ErrorGet_1:
        SUBS     R6,R6,#+1
// 10394   {
// 10395     if(CenterLineLoc[row] != MaxValUint8)
??ErrorGet_0:
        LDR.W    R0,??DataTable54_2
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRSH    R0,[R0, R6, LSL #+1]
        CMP      R0,#+255
        BEQ.N    ??ErrorGet_2
// 10396     {
// 10397       temp += CenterLineLoc[row];
        LDR.W    R0,??DataTable54_2
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRSH    R0,[R0, R6, LSL #+1]
        BL       __aeabi_i2f
        MOVS     R1,R4
        BL       __aeabi_fadd
        MOVS     R4,R0
// 10398       index++;
        ADDS     R5,R5,#+1
// 10399     }
// 10400     if(row == 0) break;
??ErrorGet_2:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BNE.N    ??ErrorGet_1
// 10401   }
// 10402   avg = (uint8)(temp / index);
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R0,R5
        BL       __aeabi_ui2f
        MOVS     R1,R0
        MOVS     R0,R4
        BL       __aeabi_fdiv
        BL       __aeabi_f2iz
        MOVS     R7,R0
// 10403   /*
// 10404   //1. 先取线头
// 10405   for(row = CameraHight - 1; ; row--)
// 10406   {
// 10407     if(CenterLineLoc[row] != MaxValUint8)
// 10408     {
// 10409       avg = CenterLineLoc[row];
// 10410       break;
// 10411     }
// 10412     if(row == 0) break;
// 10413   }
// 10414   //2. 叠加求平均
// 10415   for(row--; ; row--)
// 10416   {
// 10417     if(CenterLineLoc[row] != MaxValUint8)
// 10418     {
// 10419       avg = (avg + CenterLineLoc[row]) / 2;
// 10420     }
// 10421     if(row == 0) break;    
// 10422   }
// 10423   */
// 10424   
// 10425 
// 10426   temp = 0;
        MOVS     R4,#+0
// 10427   index = 0;
        MOVS     R5,#+0
// 10428   for(row = CameraHight - 1; ; row--)
        MOVS     R6,#+59
        B.N      ??ErrorGet_3
??ErrorGet_4:
        SUBS     R6,R6,#+1
// 10429   {
// 10430     if(CenterLineLoc[row] != MaxValUint8)
??ErrorGet_3:
        LDR.W    R0,??DataTable54_2
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRSH    R0,[R0, R6, LSL #+1]
        CMP      R0,#+255
        BEQ.N    ??ErrorGet_5
// 10431     {
// 10432       temp += AbsRe(CenterLineLoc[row], avg);
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R1,R7
        LDR.W    R0,??DataTable54_2
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRSH    R0,[R0, R6, LSL #+1]
        BL       AbsRe
        BL       __aeabi_i2f
        MOVS     R1,R4
        BL       __aeabi_fadd
        MOVS     R4,R0
// 10433       index++;
        ADDS     R5,R5,#+1
// 10434     }
// 10435     if(row == 0) break;
??ErrorGet_5:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BNE.N    ??ErrorGet_4
// 10436   }
// 10437   ErrorGetSelf = (uint8)(temp / index);
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R0,R5
        BL       __aeabi_ui2f
        MOVS     R1,R0
        MOVS     R0,R4
        BL       __aeabi_fdiv
        BL       __aeabi_f2iz
        LDR.W    R1,??DataTable57_1
        STRB     R0,[R1, #+0]
// 10438   ErrorGetCen = AbsRe(avg, PhyCenterCol);
        MOVS     R1,#+125
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R0,R7
        BL       AbsRe
        LDR.W    R1,??DataTable57_2
        STRB     R0,[R1, #+0]
// 10439   
// 10440 }
        POP      {R0,R4-R7,PC}    ;; return
// 10441 
// 10442 
// 10443 
// 10444 //开根号运算
// 10445 //本来传进来传出去都是uint16型的，但是我调用的时候只会用到uint8型的，且不会超出255.

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 10446 uint16 MathSqrt(uint16 x1)
// 10447 {
// 10448   uint8 ans = 0, p = 0x80;
MathSqrt:
        MOVS     R1,#+0
        MOVS     R2,#+128
// 10449   uint16 x = x1;
        B.N      ??MathSqrt_0
// 10450   
// 10451   while(p!=0)
// 10452   {
// 10453     ans += p;
??MathSqrt_1:
        ADDS     R1,R2,R1
// 10454     if(ans * ans > x) ans -=p;
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MUL      R3,R1,R1
        CMP      R0,R3
        BGE.N    ??MathSqrt_2
        SUBS     R1,R1,R2
// 10455     p = (uint8)(p / 2);
??MathSqrt_2:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        MOVS     R3,#+2
        SDIV     R2,R2,R3
// 10456   }
??MathSqrt_0:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BNE.N    ??MathSqrt_1
// 10457   return ans;  
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R0,R1
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        BX       LR               ;; return
// 10458 }
// 10459 
// 10460 //曲线的曲率求取，曲线向右拐（三点为顺时针方向分布），曲率为负，曲线向左拐（三点为逆时钟方向分布），曲率为正
// 10461 //K = 4*SABC/AB/BC/AC

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 10462 int16 CurveGet(int16 AX, uint8 AY, int16 BX, uint8 BY, int16 CX, uint8 CY)
// 10463 {
CurveGet:
        PUSH     {R3-R11,LR}
        MOVS     R5,R0
        MOVS     R6,R1
        MOVS     R7,R2
        MOV      R8,R3
        LDRSH    R9,[SP, #+40]
        LDR      R4,[SP, #+44]
// 10464   int16 SABC_temp; //三角形的面积，有正负。
// 10465   int16 tempab, tempbc, tempac;
// 10466   int16 AB, BC, AC; //三角形的边长，均为正。
// 10467   int16 result;
// 10468   //int16 K;        //曲率结果，有正负。
// 10469   
// 10470   SABC_temp = ((BX - AX) * (CY - AY) - (CX - AX) * (BY - AY));
        SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
        SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
        SUBS     R0,R7,R5
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        SUBS     R1,R4,R6
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        SUBS     R2,R8,R6
        SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
        SXTH     R9,R9            ;; SignExt  R9,R9,#+16,#+16
        SUBS     R3,R5,R9
        MULS     R2,R3,R2
        MLA      R10,R1,R0,R2
// 10471   
// 10472   tempab = (BX - AX) * (BX - AX) + (BY - AY) * (BY - AY);
        SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
        SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
        SUBS     R0,R7,R5
        SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
        SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
        SUBS     R1,R7,R5
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        SUBS     R2,R8,R6
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        SUBS     R3,R8,R6
        MULS     R2,R3,R2
        MLA      R0,R1,R0,R2
// 10473   if(tempab > 100) 
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        CMP      R0,#+101
        BLT.N    ??CurveGet_0
// 10474   {
// 10475     AB = MathSqrt(tempab / 100) * 10; //失掉两位的精度，因为求根运算范围的限制。
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        MOVS     R1,#+100
        SDIV     R0,R0,R1
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        BL       MathSqrt
        MOVS     R1,#+10
        SMULBB   R11,R0,R1
        B.N      ??CurveGet_1
// 10476   }
// 10477   else
// 10478   {
// 10479     AB = MathSqrt(tempab);
??CurveGet_0:
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        BL       MathSqrt
        MOV      R11,R0
// 10480   }
// 10481   
// 10482   tempbc = (BX - CX) * (BX - CX) + (BY - CY) * (BY - CY);
??CurveGet_1:
        SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
        SXTH     R9,R9            ;; SignExt  R9,R9,#+16,#+16
        SUBS     R0,R7,R9
        SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
        SXTH     R9,R9            ;; SignExt  R9,R9,#+16,#+16
        SUBS     R1,R7,R9
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        SUBS     R2,R8,R4
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        SUBS     R3,R8,R4
        MULS     R2,R3,R2
        MLA      R0,R1,R0,R2
// 10483   if(tempbc > 100) 
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        CMP      R0,#+101
        BLT.N    ??CurveGet_2
// 10484   {
// 10485     BC = MathSqrt(tempbc / 100) * 10; //失掉两位的精度，因为求根运算范围的限制。
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        MOVS     R1,#+100
        SDIV     R0,R0,R1
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        BL       MathSqrt
        MOVS     R1,#+10
        SMULBB   R7,R0,R1
        B.N      ??CurveGet_3
// 10486   }
// 10487   else
// 10488   {
// 10489     BC = MathSqrt(tempbc);
??CurveGet_2:
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        BL       MathSqrt
        MOVS     R7,R0
// 10490   }
// 10491   
// 10492   tempac = (CX - AX) * (CX - AX) + (CY - AY) * (CY - AY);
??CurveGet_3:
        SXTH     R9,R9            ;; SignExt  R9,R9,#+16,#+16
        SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
        SUBS     R0,R9,R5
        SXTH     R9,R9            ;; SignExt  R9,R9,#+16,#+16
        SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
        SUBS     R1,R9,R5
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        SUBS     R2,R4,R6
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        SUBS     R3,R4,R6
        MULS     R2,R3,R2
        MLA      R0,R1,R0,R2
// 10493   if(tempac > 100) 
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        CMP      R0,#+101
        BLT.N    ??CurveGet_4
// 10494   {
// 10495     AC = MathSqrt(tempac / 100) * 10; //失掉两位的精度，因为求根运算范围的限制。
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        MOVS     R1,#+100
        SDIV     R0,R0,R1
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        BL       MathSqrt
        MOVS     R1,#+10
        SMULBB   R0,R0,R1
        B.N      ??CurveGet_5
// 10496   }
// 10497   else
// 10498   {
// 10499     AC = MathSqrt(tempac);
??CurveGet_4:
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        BL       MathSqrt
// 10500   }
// 10501   
// 10502   result = CurveGetCompen * SABC_temp / AB / BC / AC;
??CurveGet_5:
        MOV      R1,#+2000
        SMULBB   R1,R10,R1
        SXTH     R11,R11          ;; SignExt  R11,R11,#+16,#+16
        SDIV     R1,R1,R11
        SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
        SDIV     R1,R1,R7
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        SDIV     R0,R1,R0
// 10503   if(result >= MaxValUint8) 
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        CMP      R0,#+255
        BLT.N    ??CurveGet_6
// 10504   {
// 10505     result = MaxValUint8 - 1;           //不能大过MaxValUint8
        MOVS     R0,#+254
        B.N      ??CurveGet_7
// 10506   }
// 10507   else if(result + MaxValUint8 < 0)
??CurveGet_6:
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        ADDS     R1,R0,#+255
        CMP      R1,#+0
        BPL.N    ??CurveGet_7
// 10508   {
// 10509     result = 1 - MaxValUint8;           //不能小过-MaxValUint8
        MVNS     R0,#+253
// 10510   }
// 10511   else
// 10512   {
// 10513   }
// 10514   
// 10515   return result;
??CurveGet_7:
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        POP      {R1,R4-R11,PC}   ;; return
// 10516 }
// 10517 
// 10518 
// 10519 
// 10520 //SABC的面积求取，顺时针则返回负值，逆时针则返回正值。
// 10521 //以左下角为原点，向右为x轴正方向(0~249)，向上为y轴正方向(0~49)。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 10522 int16 SABCGet(uint8 x1, uint8 y1, uint8 x2, uint8 y2, uint8 x3, uint8 y3)
// 10523 {
SABCGet:
        PUSH     {R4}
// 10524   int16 SABC_temp;
// 10525   
// 10526   SABC_temp = ((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)) / 2;
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        SUBS     R4,R2,R0
        LDR      R2,[SP, #+8]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        SUBS     R2,R2,R1
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        SUBS     R3,R3,R1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDR      R1,[SP, #+4]
        SUBS     R0,R0,R1
        MUL      R0,R0,R3
        MLA      R0,R2,R4,R0
        MOVS     R1,#+2
        SDIV     R0,R0,R1
// 10527   
// 10528   return SABC_temp;
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        POP      {R4}
        BX       LR               ;; return
// 10529 }
// 10530 
// 10531 
// 10532 
// 10533 
// 10534 //中心线的曲率和斜率求取

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 10535 uint8 CurveSlopeGetCenter(void)
// 10536 {
CurveSlopeGetCenter:
        PUSH     {R4,LR}
        SUB      SP,SP,#+24
// 10537   uint8 row;
// 10538   uint8 temp;
// 10539   uint8 tempslopex[3];
// 10540   int16 tempslopey[3];
// 10541   
// 10542   //1. 
// 10543   //曲率符号预先清零。
// 10544   CurveLineChosenC1 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_3
        STRB     R0,[R1, #+0]
// 10545   CurveLineChosenC2 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_4
        STRB     R0,[R1, #+0]
// 10546   CurveLineChosenC3 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_5
        STRB     R0,[R1, #+0]
// 10547   
// 10548   if(CenterHeadLine == MaxValUint8 || CenterEndLine == MaxValUint8)
        LDR.W    R0,??DataTable57_6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CurveSlopeGetCenter_0
        LDR.W    R0,??DataTable56
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CurveSlopeGetCenter_1
// 10549   {
// 10550     CURVEC = MaxValUint8;  //return 0之前要将中心线曲率置无效值。
??CurveSlopeGetCenter_0:
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_7
        STRH     R0,[R1, #+0]
// 10551     SlopeC = MaxValInt16;  //return 0之前要将中心线斜率置无效值。
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable57_8
        STR      R0,[R1, #+0]
// 10552     return 0;
        MOVS     R0,#+0
        B.N      ??CurveSlopeGetCenter_2
// 10553   }
// 10554   
// 10555   //曲率基于的行1 CurveLineChosen1，即中心线的线头。
// 10556   if(CenterHeadLine >= CameraHight - 2)
??CurveSlopeGetCenter_1:
        LDR.W    R0,??DataTable57_6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+58
        BLT.N    ??CurveSlopeGetCenter_3
// 10557   {
// 10558     CurveLineChosenC1 = MaxValUint8;  
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_3
        STRB     R0,[R1, #+0]
// 10559     CURVEC = MaxValUint8;  //return 0之前要将中心线曲率置无效值。
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_7
        STRH     R0,[R1, #+0]
// 10560     SlopeC = MaxValInt16;  //return 0之前要将中心线斜率置无效值。
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable57_8
        STR      R0,[R1, #+0]
// 10561     return 0;    
        MOVS     R0,#+0
        B.N      ??CurveSlopeGetCenter_2
// 10562   }
// 10563   else
// 10564   {
// 10565     CurveLineChosenC1 = CenterHeadLine;    
??CurveSlopeGetCenter_3:
        LDR.W    R0,??DataTable57_6
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable57_3
        STRB     R0,[R1, #+0]
// 10566   }
// 10567   
// 10568   
// 10569   //把第1个有效值到CameraHight-1的距离分成2段。
// 10570   temp = (CenterEndLine - 1 - CenterHeadLine) / 2;
        LDR.W    R0,??DataTable56
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        LDR.W    R1,??DataTable57_6
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        MOVS     R1,#+2
        SDIV     R1,R0,R1
// 10571   //2 * 2 + 1 = 5, 即如果有效行只有3行以内的话，就放弃求取曲率和斜率。（因为会很不精确）
// 10572   if(temp <= 2) 
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+3
        BGE.N    ??CurveSlopeGetCenter_4
// 10573   {
// 10574     CurveLineChosenC1 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_3
        STRB     R0,[R1, #+0]
// 10575     CURVEC = MaxValUint8;  //return 0之前要将中心线曲率置无效值。
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_7
        STRH     R0,[R1, #+0]
// 10576     SlopeC = MaxValInt16;  //return 0之前要将中心线斜率置无效值。
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable57_8
        STR      R0,[R1, #+0]
// 10577     return 0;
        MOVS     R0,#+0
        B.N      ??CurveSlopeGetCenter_2
// 10578   }
// 10579   
// 10580   //曲率基于的行2 CurveLineChosen2
// 10581   for(row = CurveLineChosenC1 + temp - 1; ; row++)
??CurveSlopeGetCenter_4:
        LDR.W    R0,??DataTable57_3
        LDRB     R0,[R0, #+0]
        ADDS     R0,R1,R0
        SUBS     R0,R0,#+1
// 10582   {
// 10583     if(row > CenterEndLine - 1) 
        LDR.W    R2,??DataTable56
        LDRB     R2,[R2, #+0]
        SUBS     R2,R2,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R2,R0
        BGE.N    ??CurveSlopeGetCenter_5
// 10584     {
// 10585       CurveLineChosenC1 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_3
        STRB     R0,[R1, #+0]
// 10586       CurveLineChosenC2 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_4
        STRB     R0,[R1, #+0]
// 10587       CURVEC = MaxValUint8;  //return 0之前要将中心线曲率置无效值。
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_7
        STRH     R0,[R1, #+0]
// 10588       SlopeC = MaxValInt16;  //return 0之前要将中心线斜率置无效值。
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable57_8
        STR      R0,[R1, #+0]
// 10589       return 0;
        MOVS     R0,#+0
        B.N      ??CurveSlopeGetCenter_2
// 10590     }
// 10591     //不用判断该行是不是无效值。因为中心线连续。
// 10592     CurveLineChosenC2 = row;
??CurveSlopeGetCenter_5:
        LDR.W    R2,??DataTable57_4
        STRB     R0,[R2, #+0]
// 10593     break;
// 10594     
// 10595   }
// 10596   
// 10597   //曲率基于的行3 CurveLineChosen3
// 10598   for(row = CurveLineChosenC2 + temp - 1; ; row++)
        LDR.W    R0,??DataTable57_4
        LDRB     R0,[R0, #+0]
        ADDS     R0,R1,R0
        SUBS     R0,R0,#+1
// 10599   {
// 10600     if(row > CenterEndLine) 
        LDR.W    R1,??DataTable56
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??CurveSlopeGetCenter_6
// 10601     {
// 10602       CurveLineChosenC1 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_3
        STRB     R0,[R1, #+0]
// 10603       CurveLineChosenC2 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_4
        STRB     R0,[R1, #+0]
// 10604       CurveLineChosenC3 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_5
        STRB     R0,[R1, #+0]
// 10605       CURVEC = MaxValUint8;  //return 0之前要将中心线曲率置无效值。
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_7
        STRH     R0,[R1, #+0]
// 10606       SlopeC = MaxValInt16;  //return 0之前要将中心线斜率置无效值。      
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable57_8
        STR      R0,[R1, #+0]
// 10607       return 0;
        MOVS     R0,#+0
        B.N      ??CurveSlopeGetCenter_2
// 10608     }
// 10609     //不用判断该行是不是无效值。因为中心线连续。
// 10610     CurveLineChosenC3 = row;
??CurveSlopeGetCenter_6:
        LDR.W    R1,??DataTable57_5
        STRB     R0,[R1, #+0]
// 10611     break;
// 10612   }
// 10613   //SABCC中心线曲率三角形面积的求取
// 10614   //SABCC = SABCGet(CenterLineLoc[CurveLineChosenC1], CameraHight - 1 - CurveLineChosenC1,
// 10615   //                CenterLineLoc[CurveLineChosenC2], CameraHight - 1 - CurveLineChosenC2,
// 10616   //                CenterLineLoc[CurveLineChosenC3], CameraHight - 1 - CurveLineChosenC3
// 10617   //                );
// 10618   //曲率求取，最大值不会超过MaxValUint8;
// 10619   CURVEC = CurveGet(CenterLineLoc[CurveLineChosenC1], CameraHight - 1 - CurveLineChosenC1,
// 10620                    CenterLineLoc[CurveLineChosenC2], CameraHight - 1 - CurveLineChosenC2,
// 10621                    CenterLineLoc[CurveLineChosenC3], CameraHight - 1 - CurveLineChosenC3
// 10622                    );
        LDR.W    R0,??DataTable57_5
        LDRB     R0,[R0, #+0]
        RSBS     R0,R0,#+59
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STR      R0,[SP, #+4]
        LDR.N    R0,??DataTable54_2
        LDR.W    R1,??DataTable57_5
        LDRB     R1,[R1, #+0]
        LDRSH    R0,[R0, R1, LSL #+1]
        STR      R0,[SP, #+0]
        LDR.W    R0,??DataTable57_4
        LDRB     R0,[R0, #+0]
        RSBS     R3,R0,#+59
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDR.N    R0,??DataTable54_2
        LDR.W    R1,??DataTable57_4
        LDRB     R1,[R1, #+0]
        LDRSH    R2,[R0, R1, LSL #+1]
        LDR.W    R0,??DataTable57_3
        LDRB     R0,[R0, #+0]
        RSBS     R1,R0,#+59
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR.N    R0,??DataTable54_2
        LDR.W    R4,??DataTable57_3
        LDRB     R4,[R4, #+0]
        LDRSH    R0,[R0, R4, LSL #+1]
        BL       CurveGet
        LDR.W    R1,??DataTable57_7
        STRH     R0,[R1, #+0]
// 10623   //中心线斜率求取，左上角为原点，向下X，向右Y。应该不会超过MaxValUint8
// 10624   tempslopex[0] = CurveLineChosenC1;
        LDR.W    R0,??DataTable57_3
        LDRB     R0,[R0, #+0]
        STRB     R0,[SP, #+8]
// 10625   tempslopex[1] = CurveLineChosenC2;
        LDR.W    R0,??DataTable57_4
        LDRB     R0,[R0, #+0]
        STRB     R0,[SP, #+9]
// 10626   tempslopex[2] = CurveLineChosenC3;
        LDR.W    R0,??DataTable57_5
        LDRB     R0,[R0, #+0]
        STRB     R0,[SP, #+10]
// 10627   tempslopey[0] = CenterLineLoc[CurveLineChosenC1];
        LDR.N    R0,??DataTable54_2
        LDR.W    R1,??DataTable57_3
        LDRB     R1,[R1, #+0]
        LDRH     R0,[R0, R1, LSL #+1]
        STRH     R0,[SP, #+12]
// 10628   tempslopey[1] = CenterLineLoc[CurveLineChosenC2];
        LDR.N    R0,??DataTable54_2
        LDR.W    R1,??DataTable57_4
        LDRB     R1,[R1, #+0]
        LDRH     R0,[R0, R1, LSL #+1]
        STRH     R0,[SP, #+14]
// 10629   tempslopey[2] = CenterLineLoc[CurveLineChosenC3];
        LDR.N    R0,??DataTable54_2
        LDR.W    R1,??DataTable57_5
        LDRB     R1,[R1, #+0]
        LDRH     R0,[R0, R1, LSL #+1]
        STRH     R0,[SP, #+16]
// 10630   SlopeC = LeastSquareInt16a1(tempslopex, tempslopey, 3);  //已经乘以了LeastSquareMulti倍。
        MOVS     R2,#+3
        ADD      R1,SP,#+12
        ADD      R0,SP,#+8
        BL       LeastSquareInt16a1
        LDR.W    R1,??DataTable57_8
        STR      R0,[R1, #+0]
// 10631   
// 10632   return 1;
        MOVS     R0,#+1
??CurveSlopeGetCenter_2:
        ADD      SP,SP,#+24
        POP      {R4,PC}          ;; return
// 10633   
// 10634 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable53:
        DC32     BlackUdisLeftLocation

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable53_1:
        DC32     RoadHalfWidthRecord
// 10635 
// 10636 //左黑线的曲率和斜率求取

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 10637 uint8 CurveSlopeGetLeft(void)
// 10638 {
CurveSlopeGetLeft:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+20
// 10639   uint8 row;
// 10640   uint8 temp;
// 10641   uint8 tempslopex[3];
// 10642   int16 tempslopey[3];
// 10643   
// 10644   //左右黑线有可能只有一边提取成功，若不成功，就不用费时间了。
// 10645   if(BlackLeftDone == 1)
        LDR.W    R0,??DataTable57_9
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??CurveSlopeGetLeft_0
// 10646   {
// 10647     //2. 左黑线曲率符号求取
// 10648     //曲率符号预先清零。
// 10649     CurveLineChosenL1 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_10
        STRB     R0,[R1, #+0]
// 10650     CurveLineChosenL2 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_11
        STRB     R0,[R1, #+0]
// 10651     CurveLineChosenL3 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_12
        STRB     R0,[R1, #+0]
// 10652     
// 10653     //曲率基于的行1 CurveLineChosen1，即左线线头BlackLeftHeadLine.
// 10654     if(BlackLeftHeadLine == MaxValUint8 || BlackLeftEndLine == MaxValUint8)
        LDR.W    R0,??DataTable57_13
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CurveSlopeGetLeft_1
        LDR.W    R0,??DataTable57_14
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CurveSlopeGetLeft_2
// 10655     {
// 10656       CURVEL = MaxValInt16;       //return 0之前，要把左黑线的曲率置无效值。
??CurveSlopeGetLeft_1:
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable57_15
        STRH     R0,[R1, #+0]
// 10657       SlopeL = MaxValInt16;       //return 0之前，要把左黑线的斜率置无效值。
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable57_16
        STR      R0,[R1, #+0]
// 10658       return 0;      
        MOVS     R0,#+0
        B.N      ??CurveSlopeGetLeft_3
// 10659     }
// 10660     
// 10661     if(BlackLeftHeadLine >= CameraHight - 2)
??CurveSlopeGetLeft_2:
        LDR.W    R0,??DataTable57_13
        LDRB     R0,[R0, #+0]
        CMP      R0,#+58
        BLT.N    ??CurveSlopeGetLeft_4
// 10662     {
// 10663       CURVEL = MaxValInt16;       //return 0之前，要把左黑线的曲率置无效值。
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable57_15
        STRH     R0,[R1, #+0]
// 10664       SlopeL = MaxValInt16;       //return 0之前，要把左黑线的斜率置无效值。
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable57_16
        STR      R0,[R1, #+0]
// 10665       return 0;      
        MOVS     R0,#+0
        B.N      ??CurveSlopeGetLeft_3
// 10666     }
// 10667     else
// 10668     {
// 10669       CurveLineChosenL1 = BlackLeftHeadLine;
??CurveSlopeGetLeft_4:
        LDR.W    R0,??DataTable57_13
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable57_10
        STRB     R0,[R1, #+0]
// 10670     }
// 10671 
// 10672     //把第1个有效值到CameraHight-1的距离分成2段。
// 10673     temp = (BlackLeftEndLine - 1 - BlackLeftHeadLine) / 2;
        LDR.W    R0,??DataTable57_14
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        LDR.W    R1,??DataTable57_13
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        MOVS     R1,#+2
        SDIV     R1,R0,R1
// 10674     //2 * 2 + 1 = 5, 即如果有效行只有3行以内的话，就放弃求取曲率和斜率。（因为会很不精确）
// 10675     if(temp <= 2) 
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+3
        BGE.N    ??CurveSlopeGetLeft_5
// 10676     {
// 10677       CurveLineChosenL1 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_10
        STRB     R0,[R1, #+0]
// 10678       CURVEL = MaxValInt16;       //return 0之前，要把左黑线的曲率置无效值。
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable57_15
        STRH     R0,[R1, #+0]
// 10679       SlopeL = MaxValInt16;       //return 0之前，要把左黑线的斜率置无效值。      
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable57_16
        STR      R0,[R1, #+0]
// 10680       return 0;
        MOVS     R0,#+0
        B.N      ??CurveSlopeGetLeft_3
// 10681     }
// 10682     
// 10683     //曲率基于的行2 CurveLineChosen2
// 10684     for(row = CurveLineChosenL1 + temp - 1; ; row++)
??CurveSlopeGetLeft_5:
        LDR.W    R0,??DataTable57_10
        LDRB     R0,[R0, #+0]
        ADDS     R0,R1,R0
        SUBS     R0,R0,#+1
// 10685     {
// 10686       if (row > BlackLeftEndLine - 1) 
        LDR.W    R2,??DataTable57_14
        LDRB     R2,[R2, #+0]
        SUBS     R2,R2,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R2,R0
        BGE.N    ??CurveSlopeGetLeft_6
// 10687       {
// 10688         CurveLineChosenL1 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_10
        STRB     R0,[R1, #+0]
// 10689         CurveLineChosenL2 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_11
        STRB     R0,[R1, #+0]
// 10690         CURVEL = MaxValInt16;       //return 0之前，要把左黑线的曲率置无效值。
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable57_15
        STRH     R0,[R1, #+0]
// 10691         SlopeL = MaxValInt16;       //return 0之前，要把左黑线的斜率置无效值。     
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable57_16
        STR      R0,[R1, #+0]
// 10692         return 0;
        MOVS     R0,#+0
        B.N      ??CurveSlopeGetLeft_3
// 10693       }
// 10694       //不用判断是不是无效值。因为左黑线连续。
// 10695       CurveLineChosenL2 = row;
??CurveSlopeGetLeft_6:
        LDR.W    R2,??DataTable57_11
        STRB     R0,[R2, #+0]
// 10696       break;
// 10697     }
// 10698     
// 10699     //曲率基于的行3 CurveLineChosen3
// 10700     for(row = CurveLineChosenL2 + temp - 1; ; row++)
        LDR.W    R0,??DataTable57_11
        LDRB     R0,[R0, #+0]
        ADDS     R0,R1,R0
        SUBS     R0,R0,#+1
// 10701     {
// 10702       if (row > BlackLeftEndLine) 
        LDR.W    R1,??DataTable57_14
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??CurveSlopeGetLeft_7
// 10703       {
// 10704         CurveLineChosenL1 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_10
        STRB     R0,[R1, #+0]
// 10705         CurveLineChosenL2 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_11
        STRB     R0,[R1, #+0]
// 10706         CurveLineChosenL3 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_12
        STRB     R0,[R1, #+0]
// 10707         CURVEL = MaxValInt16;       //return 0之前，要把左黑线的曲率置无效值。
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable57_15
        STRH     R0,[R1, #+0]
// 10708         SlopeL = MaxValInt16;       //return 0之前，要把左黑线的斜率置无效值。        
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable57_16
        STR      R0,[R1, #+0]
// 10709         return 0;
        MOVS     R0,#+0
        B.N      ??CurveSlopeGetLeft_3
// 10710       }
// 10711       //不用判断是不是无效值。因为左黑线连续。
// 10712       CurveLineChosenL3 = row;
??CurveSlopeGetLeft_7:
        LDR.W    R1,??DataTable57_12
        STRB     R0,[R1, #+0]
// 10713       break;
// 10714     }
// 10715     //SABCL左黑线曲率三角形面积的求取
// 10716     //SABCL = SABCGet(BlackLeftLoc[CurveLineChosenL1,0], CameraHight - 1 - CurveLineChosenL1,
// 10717     //               BlackLeftLoc[CurveLineChosenL2,0], CameraHight - 1 - CurveLineChosenL2,
// 10718     //               BlackLeftLoc[CurveLineChosenL3,0], CameraHight - 1 - CurveLineChosenL3
// 10719     //               );
// 10720     
// 10721 //    CURVEL = CurveGet(BlackUdisLeftLocation[CurveLineChosenL1].x, CameraHight - 1 - CurveLineChosenL1,
// 10722 //                      BlackUdisLeftLocation[CurveLineChosenL2].x, CameraHight - 1 - CurveLineChosenL2,
// 10723 //                      BlackUdisLeftLocation[CurveLineChosenL3].x, CameraHight - 1 - CurveLineChosenL3
// 10724 //                      );
// 10725     
// 10726     CURVEL = CurveGet(BlackLeftLoc[CurveLineChosenL1][0], CameraHight - 1 - CurveLineChosenL1,
// 10727                       BlackLeftLoc[CurveLineChosenL2][0], CameraHight - 1 - CurveLineChosenL2,
// 10728                       BlackLeftLoc[CurveLineChosenL3][0], CameraHight - 1 - CurveLineChosenL3
// 10729                       );
        LDR.W    R0,??DataTable57_12
        LDRB     R0,[R0, #+0]
        RSBS     R0,R0,#+59
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STR      R0,[SP, #+4]
        LDR.N    R0,??DataTable54_1
        LDR.W    R1,??DataTable57_12
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        STR      R0,[SP, #+0]
        LDR.W    R0,??DataTable57_11
        LDRB     R0,[R0, #+0]
        RSBS     R3,R0,#+59
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDR.N    R0,??DataTable54_1
        LDR.W    R1,??DataTable57_11
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R2,[R0, #+0]
        SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
        LDR.W    R0,??DataTable57_10
        LDRB     R0,[R0, #+0]
        RSBS     R1,R0,#+59
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR.N    R0,??DataTable54_1
        LDR.W    R4,??DataTable57_10
        LDRB     R4,[R4, #+0]
        MOVS     R5,#+3
        MLA      R0,R5,R4,R0
        LDRB     R0,[R0, #+0]
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        BL       CurveGet
        LDR.W    R1,??DataTable57_15
        STRH     R0,[R1, #+0]
// 10730     //左黑线斜率求取，左上角为原点，向下X，向右Y。
// 10731     tempslopex[0] = CurveLineChosenL1;
        LDR.W    R0,??DataTable57_10
        LDRB     R0,[R0, #+0]
        STRB     R0,[SP, #+8]
// 10732     tempslopex[1] = CurveLineChosenL2;
        LDR.W    R0,??DataTable57_11
        LDRB     R0,[R0, #+0]
        STRB     R0,[SP, #+9]
// 10733     tempslopex[2] = CurveLineChosenL3;
        LDR.W    R0,??DataTable57_12
        LDRB     R0,[R0, #+0]
        STRB     R0,[SP, #+10]
// 10734     tempslopey[0] = BlackUdisLeftLocation[CurveLineChosenL1].x;
        LDR.W    R0,??DataTable57_17
        LDR.W    R1,??DataTable57_10
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        STRH     R0,[SP, #+12]
// 10735     tempslopey[1] = BlackUdisLeftLocation[CurveLineChosenL2].x;
        LDR.W    R0,??DataTable57_17
        LDR.W    R1,??DataTable57_11
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        STRH     R0,[SP, #+14]
// 10736     tempslopey[2] = BlackUdisLeftLocation[CurveLineChosenL3].x;
        LDR.W    R0,??DataTable57_17
        LDR.W    R1,??DataTable57_12
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        STRH     R0,[SP, #+16]
// 10737     SlopeL = LeastSquareInt16a1(tempslopex, tempslopey, 3);   //已经乘以了LeastSquareMulti倍。
        MOVS     R2,#+3
        ADD      R1,SP,#+12
        ADD      R0,SP,#+8
        BL       LeastSquareInt16a1
        LDR.W    R1,??DataTable57_16
        STR      R0,[R1, #+0]
// 10738     
// 10739     return 1;
        MOVS     R0,#+1
        B.N      ??CurveSlopeGetLeft_3
// 10740   }
// 10741   //左黑线提取失败，直接返回失败。
// 10742   else
// 10743   {
// 10744     CURVEL = MaxValInt16;       //return 0之前，要把左黑线的曲率置无效值。
??CurveSlopeGetLeft_0:
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable57_15
        STRH     R0,[R1, #+0]
// 10745     SlopeL = MaxValInt16;       //return 0之前，要把左黑线的斜率置无效值。
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable57_16
        STR      R0,[R1, #+0]
// 10746     return 0;
        MOVS     R0,#+0
??CurveSlopeGetLeft_3:
        ADD      SP,SP,#+20
        POP      {R4,R5,PC}       ;; return
// 10747   }
// 10748 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable54:
        DC32     RoadHalfWidth

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable54_1:
        DC32     BlackLeftLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable54_2:
        DC32     CenterLineLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable54_3:
        DC32     BlackUdisRightLocation
// 10749 
// 10750 
// 10751 
// 10752 //右黑线的曲率和斜率求取

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 10753 uint8 CurveSlopeGetRight(void)
// 10754 {
CurveSlopeGetRight:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+20
// 10755   uint8 row;
// 10756   uint8 temp;
// 10757   uint8 tempslopex[3];
// 10758   int16 tempslopey[3];
// 10759 
// 10760   //左右黑线有可能只有一边提取成功，若不成功，就不用费时间了。
// 10761   if(BlackRightDone == 1)
        LDR.W    R0,??DataTable57_18
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??CurveSlopeGetRight_0
// 10762   {
// 10763     //3. 右黑线曲率符号求取
// 10764     //曲率符号预先清零。
// 10765     CurveLineChosenR1 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_19
        STRB     R0,[R1, #+0]
// 10766     CurveLineChosenR2 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_20
        STRB     R0,[R1, #+0]
// 10767     CurveLineChosenR3 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_21
        STRB     R0,[R1, #+0]
// 10768     
// 10769     //曲率基于的行1 CurveLineChosen1，从上到下取第一个有效值。
// 10770     if(BlackRightHeadLine == MaxValUint8 || BlackRightEndLine == MaxValUint8)
        LDR.W    R0,??DataTable57_22
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??CurveSlopeGetRight_1
        LDR.W    R0,??DataTable57_23
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??CurveSlopeGetRight_2
// 10771     {
// 10772       CURVER = MaxValInt16;      //return 0前先把右黑线的曲率置无效值。   
??CurveSlopeGetRight_1:
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable58
        STRH     R0,[R1, #+0]
// 10773       SlopeR = MaxValInt16;      //return 0前先把右黑线的斜率置无效值。        
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable58_1
        STR      R0,[R1, #+0]
// 10774       return 0;      
        MOVS     R0,#+0
        B.N      ??CurveSlopeGetRight_3
// 10775     }
// 10776     if(BlackRightHeadLine  >= CameraHight - 2)
??CurveSlopeGetRight_2:
        LDR.W    R0,??DataTable57_22
        LDRB     R0,[R0, #+0]
        CMP      R0,#+58
        BLT.N    ??CurveSlopeGetRight_4
// 10777     {
// 10778       CURVER = MaxValInt16;      //return 0前先把右黑线的曲率置无效值。   
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable58
        STRH     R0,[R1, #+0]
// 10779       SlopeR = MaxValInt16;      //return 0前先把右黑线的斜率置无效值。        
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable58_1
        STR      R0,[R1, #+0]
// 10780       return 0;      
        MOVS     R0,#+0
        B.N      ??CurveSlopeGetRight_3
// 10781     }
// 10782     else
// 10783     {
// 10784       CurveLineChosenR1 = BlackRightHeadLine;
??CurveSlopeGetRight_4:
        LDR.W    R0,??DataTable57_22
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable57_19
        STRB     R0,[R1, #+0]
// 10785     }
// 10786 
// 10787     //把第1个有效值到CameraHight-1的距离分成2段。
// 10788     temp = (BlackRightEndLine - 1 - BlackRightHeadLine) / 2;
        LDR.W    R0,??DataTable57_23
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        LDR.W    R1,??DataTable57_22
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        MOVS     R1,#+2
        SDIV     R1,R0,R1
// 10789     //2 * 2 + 1 = 5, 即如果有效行只有3行以内的话，就放弃求取曲率和斜率。（因为会很不精确）
// 10790     if(temp <= 2)
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+3
        BGE.N    ??CurveSlopeGetRight_5
// 10791     {
// 10792       CurveLineChosenR1 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_19
        STRB     R0,[R1, #+0]
// 10793       CURVER = MaxValInt16;      //return 0前先把右黑线的曲率置无效值。   
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable58
        STRH     R0,[R1, #+0]
// 10794       SlopeR = MaxValInt16;      //return 0前先把右黑线的斜率置无效值。      
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable58_1
        STR      R0,[R1, #+0]
// 10795       return 0;
        MOVS     R0,#+0
        B.N      ??CurveSlopeGetRight_3
// 10796     }
// 10797     
// 10798     //曲率基于的行2 CurveLineChosen2
// 10799     for(row = CurveLineChosenR1 + temp - 1; ; row++)
??CurveSlopeGetRight_5:
        LDR.W    R0,??DataTable57_19
        LDRB     R0,[R0, #+0]
        ADDS     R0,R1,R0
        SUBS     R0,R0,#+1
// 10800     {
// 10801       if (row > BlackRightEndLine - 1) 
        LDR.W    R2,??DataTable57_23
        LDRB     R2,[R2, #+0]
        SUBS     R2,R2,#+1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R2,R0
        BGE.N    ??CurveSlopeGetRight_6
// 10802       {
// 10803         CurveLineChosenR1 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_19
        STRB     R0,[R1, #+0]
// 10804         CurveLineChosenR2 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_20
        STRB     R0,[R1, #+0]
// 10805         CURVER = MaxValInt16;      //return 0前先把右黑线的曲率置无效值。   
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable58
        STRH     R0,[R1, #+0]
// 10806         SlopeR = MaxValInt16;      //return 0前先把右黑线的斜率置无效值。      
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable58_1
        STR      R0,[R1, #+0]
// 10807         return 0;
        MOVS     R0,#+0
        B.N      ??CurveSlopeGetRight_3
// 10808       }
// 10809       //不用判断该行是不是无效值，因为右线连续。
// 10810       CurveLineChosenR2 = row;
??CurveSlopeGetRight_6:
        LDR.W    R2,??DataTable57_20
        STRB     R0,[R2, #+0]
// 10811       break;
// 10812     }
// 10813     
// 10814     //曲率基于的行3 CurveLineChosen3
// 10815     for(row = CurveLineChosenR2 + temp - 1; ; row++)
        LDR.W    R0,??DataTable57_20
        LDRB     R0,[R0, #+0]
        ADDS     R0,R1,R0
        SUBS     R0,R0,#+1
// 10816     {
// 10817       if (row > BlackRightEndLine) 
        LDR.W    R1,??DataTable57_23
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??CurveSlopeGetRight_7
// 10818       {
// 10819         CurveLineChosenR1 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_19
        STRB     R0,[R1, #+0]
// 10820         CurveLineChosenR2 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_20
        STRB     R0,[R1, #+0]
// 10821         CurveLineChosenR3 = MaxValUint8;
        MOVS     R0,#+255
        LDR.W    R1,??DataTable57_21
        STRB     R0,[R1, #+0]
// 10822         CURVER = MaxValInt16;      //return 0前先把右黑线的曲率置无效值。   
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable58
        STRH     R0,[R1, #+0]
// 10823         SlopeR = MaxValInt16;      //return 0前先把右黑线的斜率置无效值。        
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable58_1
        STR      R0,[R1, #+0]
// 10824         return 0;
        MOVS     R0,#+0
        B.N      ??CurveSlopeGetRight_3
// 10825       }
// 10826       //不用判断该行是不是无效值，因为右线连续。
// 10827       CurveLineChosenR3 = row;
??CurveSlopeGetRight_7:
        LDR.W    R1,??DataTable57_21
        STRB     R0,[R1, #+0]
// 10828       break;
// 10829     }   
// 10830     //SABCR右黑线曲率三角形面积的求取
// 10831     //SABCR = SABCGet(BlackRightLoc[CurveLineChosenR1,0], CameraHight - 1 - CurveLineChosenR1, 
// 10832     //                BlackRightLoc[CurveLineChosenR2,0], CameraHight - 1 - CurveLineChosenR2, 
// 10833     //                BlackRightLoc[CurveLineChosenR3,0], CameraHight - 1 - CurveLineChosenR3
// 10834     //                );
// 10835     
// 10836 //    CURVER = CurveGet(BlackUdisRightLocation[CurveLineChosenR1].x, CameraHight - 1 - CurveLineChosenR1,
// 10837 //                      BlackUdisRightLocation[CurveLineChosenR2].x, CameraHight - 1 - CurveLineChosenR2,
// 10838 //                      BlackUdisRightLocation[CurveLineChosenR3].x, CameraHight - 1 - CurveLineChosenR3
// 10839 //                      );
// 10840     
// 10841     CURVER = CurveGet(BlackRightLoc[CurveLineChosenR1][0], CameraHight - 1 - CurveLineChosenR1,
// 10842                       BlackRightLoc[CurveLineChosenR2][0], CameraHight - 1 - CurveLineChosenR2,
// 10843                       BlackRightLoc[CurveLineChosenR3][0], CameraHight - 1 - CurveLineChosenR3
// 10844                       );
        LDR.W    R0,??DataTable57_21
        LDRB     R0,[R0, #+0]
        RSBS     R0,R0,#+59
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STR      R0,[SP, #+4]
        LDR.N    R0,??DataTable56_2
        LDR.W    R1,??DataTable57_21
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        STR      R0,[SP, #+0]
        LDR.W    R0,??DataTable57_20
        LDRB     R0,[R0, #+0]
        RSBS     R3,R0,#+59
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDR.N    R0,??DataTable56_2
        LDR.W    R1,??DataTable57_20
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R2,[R0, #+0]
        SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
        LDR.W    R0,??DataTable57_19
        LDRB     R0,[R0, #+0]
        RSBS     R1,R0,#+59
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR.N    R0,??DataTable56_2
        LDR.W    R4,??DataTable57_19
        LDRB     R4,[R4, #+0]
        MOVS     R5,#+3
        MLA      R0,R5,R4,R0
        LDRB     R0,[R0, #+0]
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        BL       CurveGet
        LDR.W    R1,??DataTable58
        STRH     R0,[R1, #+0]
// 10845     
// 10846     //右黑线斜率求取，左上角为原点，向下X，向右Y。
// 10847     tempslopex[0] = CurveLineChosenR1;
        LDR.W    R0,??DataTable57_19
        LDRB     R0,[R0, #+0]
        STRB     R0,[SP, #+8]
// 10848     tempslopex[1] = CurveLineChosenR2;
        LDR.W    R0,??DataTable57_20
        LDRB     R0,[R0, #+0]
        STRB     R0,[SP, #+9]
// 10849     tempslopex[2] = CurveLineChosenR3;
        LDR.N    R0,??DataTable57_21
        LDRB     R0,[R0, #+0]
        STRB     R0,[SP, #+10]
// 10850     tempslopey[0] = BlackUdisRightLocation[CurveLineChosenR1].x;
        LDR.W    R0,??DataTable58_2
        LDR.N    R1,??DataTable57_19
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        STRH     R0,[SP, #+12]
// 10851     tempslopey[1] = BlackUdisRightLocation[CurveLineChosenR2].x;
        LDR.W    R0,??DataTable58_2
        LDR.N    R1,??DataTable57_20
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        STRH     R0,[SP, #+14]
// 10852     tempslopey[2] = BlackUdisRightLocation[CurveLineChosenR3].x;
        LDR.W    R0,??DataTable58_2
        LDR.N    R1,??DataTable57_21
        LDRB     R1,[R1, #+0]
        LDR      R0,[R0, R1, LSL #+3]
        STRH     R0,[SP, #+16]
// 10853     SlopeR = LeastSquareInt16a1(tempslopex, tempslopey, 3);         //已经乘以了LeastSquareMulti倍。
        MOVS     R2,#+3
        ADD      R1,SP,#+12
        ADD      R0,SP,#+8
        BL       LeastSquareInt16a1
        LDR.W    R1,??DataTable58_1
        STR      R0,[R1, #+0]
// 10854     
// 10855     return 1;
        MOVS     R0,#+1
        B.N      ??CurveSlopeGetRight_3
// 10856   }
// 10857   //右黑线提取失败，直接返回失败。
// 10858   else
// 10859   {
// 10860     CURVER = MaxValInt16;      //return 0前先把右黑线的曲率置无效值。   
??CurveSlopeGetRight_0:
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable58
        STRH     R0,[R1, #+0]
// 10861     SlopeR = MaxValInt16;      //return 0前先把右黑线的斜率置无效值。
        MOVW     R0,#+32767
        LDR.W    R1,??DataTable58_1
        STR      R0,[R1, #+0]
// 10862     return 0;
        MOVS     R0,#+0
??CurveSlopeGetRight_3:
        ADD      SP,SP,#+20
        POP      {R4,R5,PC}       ;; return
// 10863   }
// 10864   
// 10865 }
// 10866 
// 10867 
// 10868 
// 10869 
// 10870 
// 10871 //曲率符号求取
// 10872 //影响：CurveSL, CurveSC, CurveSR, 0无效，1正，2负
// 10873 //      SABCL, SABCC, SABCR

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 10874 uint8 CurveSlopeGet(void)
// 10875 {
CurveSlopeGet:
        PUSH     {R7,LR}
// 10876   //左、右黑线的斜曲率求取在BlackGet函数中已经进行过了，相应标志位也已经更新。
// 10877   //曲率、斜率求取的标志位，1成功，0失败。默认置为成功。
// 10878   CurveSlopeFlagC = 1;  
        MOVS     R0,#+1
        LDR.W    R1,??DataTable58_3
        STRB     R0,[R1, #+0]
// 10879   
// 10880   //中心线的曲率、斜率的求取。
// 10881   if(CurveSlopeGetCenter() == 0)
        BL       CurveSlopeGetCenter
        CMP      R0,#+0
        BNE.N    ??CurveSlopeGet_0
// 10882   {
// 10883     CurveSlopeFlagC = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable58_3
        STRB     R0,[R1, #+0]
// 10884     //uart_sendN(UART0, (uint8 *)"\nCurveSlopeGetCenter() Failed!", 30);
// 10885   }  
// 10886   
// 10887   //只有当3条线的曲率、斜率求取均失败的时候，才返回0，意在提醒后面的赛道类型不用判断了。
// 10888   if(CurveSlopeFlagL == 0 && CurveSlopeFlagC == 0 && CurveSlopeFlagR == 0)
??CurveSlopeGet_0:
        LDR.W    R0,??DataTable58_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??CurveSlopeGet_1
        LDR.W    R0,??DataTable58_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??CurveSlopeGet_1
        LDR.W    R0,??DataTable58_5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??CurveSlopeGet_1
// 10889   {
// 10890     return 0;
        MOVS     R0,#+0
        B.N      ??CurveSlopeGet_2
// 10891   }
// 10892   else
// 10893   {
// 10894     return 1;
??CurveSlopeGet_1:
        MOVS     R0,#+1
??CurveSlopeGet_2:
        POP      {R1,PC}          ;; return
// 10895   }
// 10896   
// 10897 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56:
        DC32     CenterEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56_1:
        DC32     RoadHalfWidthSingle

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56_2:
        DC32     BlackRightLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56_3:
        DC32     CameraRealLeftCol

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56_4:
        DC32     ImgPresent

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56_5:
        DC32     ImgNew

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable56_6:
        DC32     ImgStore2
// 10898 
// 10899 
// 10900 //直角线头差判断第6步，非障碍确认。
// 10901 //其实是效仿障碍判断中的非障碍边确认。
// 10902 //输入：dir 0表示非左障碍确认，1表示非右障碍确认
// 10903 //返回：1成功 0失败

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 10904 uint8 AngleStep1JudgeNotBrick(uint8 dir)
// 10905 {
AngleStep1JudgeNotBrick:
        PUSH     {R4-R7,LR}
        SUB      SP,SP,#+20
// 10906   uint8 row;
// 10907   uint8 col;
// 10908   uint8 count3;
// 10909     
// 10910   int32 a0, a1;
// 10911   uint8 i, index, tempend;
// 10912   
// 10913   uint8 x[BrickSlopeRowNum];   //取多少个点在一开始有定义。
// 10914   uint8 y[BrickSlopeRowNum];
// 10915   
// 10916   uint8 tempheadrow;
// 10917   
// 10918   //非左障碍确认
// 10919   if(dir == 0)
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.W    ??AngleStep1JudgeNotBrick_0
// 10920   {
// 10921     //2. 1 非障碍边最小二乘法
// 10922     index = 0;    
        MOVS     R0,#+0
// 10923     for(i = BrickEndRow + 1; ; i++)
        MOVS     R1,#+36
        B.N      ??AngleStep1JudgeNotBrick_1
??AngleStep1JudgeNotBrick_2:
        ADDS     R1,R1,#+1
// 10924     {
// 10925       if(BlackLeftLoc[i][0] != MaxValUint8)
??AngleStep1JudgeNotBrick_1:
        LDR.W    R2,??DataTable58_6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BEQ.N    ??AngleStep1JudgeNotBrick_3
// 10926       {
// 10927         y[index] = BlackLeftLoc[i][0];
        LDR.W    R2,??DataTable58_6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        ADD      R3,SP,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R2,[R0, R3]
// 10928         x[index] = i;
        ADD      R2,SP,#+8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 10929         index++;
        ADDS     R0,R0,#+1
// 10930       }
// 10931       if(index == BrickSlopeRowNum)
??AngleStep1JudgeNotBrick_3:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+8
        BNE.N    ??AngleStep1JudgeNotBrick_4
// 10932       {
// 10933         break;  
// 10934       }
// 10935       if(i == CameraHight - 1)
// 10936       {
// 10937         return 0;
// 10938       }
// 10939     }
// 10940     
// 10941     //最小二乘法
// 10942     //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
// 10943     a1 = LeastSquarea1(x, y, BrickSlopeRowNum);
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea1
        MOVS     R4,R0
// 10944     //左边，斜率应该是-PathJudgeStraightSlopeLimit~0,否则斜率不对，返回失败。
// 10945     if(a1 < 0 && a1 + PathJudgeStraightSlopeLimit > 0)
        CMP      R4,#+0
        BPL.N    ??AngleStep1JudgeNotBrick_5
        ADDW     R0,R4,#+2100
        CMP      R0,#+1
        BGE.N    ??AngleStep1JudgeNotBrick_6
// 10946     {
// 10947     }
// 10948     else
// 10949     {
// 10950       return 0;
??AngleStep1JudgeNotBrick_5:
        MOVS     R0,#+0
        B.N      ??AngleStep1JudgeNotBrick_7
// 10951     }
??AngleStep1JudgeNotBrick_4:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+59
        BNE.N    ??AngleStep1JudgeNotBrick_2
        MOVS     R0,#+0
        B.N      ??AngleStep1JudgeNotBrick_7
// 10952     a0 = LeastSquarea0(x, y, a1, BrickSlopeRowNum);
??AngleStep1JudgeNotBrick_6:
        MOVS     R3,#+8
        MOVS     R2,R4
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea0
        MOVS     R5,R0
// 10953     //直角梯形的两个突出顶点所在列
// 10954     //起始行（近行）黑点所在列。
// 10955     AngleStep1NotBrickEndColL = (a0 + a1 * BrickEndRow) / LeastSquareMulti + BrickColCom;
        MOVS     R0,#+35
        MLA      R0,R0,R4,R5
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        ADDS     R0,R0,#+5
        LDR.W    R1,??DataTable58_7
        STRB     R0,[R1, #+0]
// 10956     //直角梯形的直角边所在列。
// 10957     //不能比该行有效右黑线还大。    
// 10958     if(BlackRightLoc[BrickEndRow][0] != MaxValUint8)
        LDR.W    R0,??DataTable58_8
        LDRB     R0,[R0, #+105]
        CMP      R0,#+255
        BEQ.N    ??AngleStep1JudgeNotBrick_8
// 10959     {
// 10960       AngleStep1NotBrickBorderColL = MinRe(AngleStep1NotBrickEndColL + BrickScanColNum, BlackRightLoc[BrickEndRow][0]); //这里与非障碍边不同，非障碍是BrickScanColNum / 2，这里为了保险，取BrickScanColNum。
        LDR.W    R0,??DataTable58_8
        LDRB     R1,[R0, #+105]
        LDR.W    R0,??DataTable58_7
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+60
        BL       MinRe
        LDR.W    R1,??DataTable58_9
        STRB     R0,[R1, #+0]
// 10961     }
// 10962     else
// 10963     {
// 10964     }
// 10965 
// 10966     //2.2 非障碍边，开始扫描，找到黑点过多的行，则右障碍确认失败。
// 10967     //为了防止检测过头，检测的最远行需要跟左线头挂勾。
// 10968     //不能比BrickEndRow更近。
// 10969     tempheadrow = MinRe(BrickEndRow, BlackLeftHeadLine);
??AngleStep1JudgeNotBrick_8:
        LDR.N    R0,??DataTable57_13
        LDRB     R1,[R0, #+0]
        MOVS     R0,#+35
        BL       MinRe
        MOVS     R6,R0
// 10970     //不能比BrickHeadRow更远。
// 10971     tempheadrow = MaxRe(BrickHeadRow, tempheadrow);    
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MOVS     R1,R6
        MOVS     R0,#+15
        BL       MaxRe
        MOVS     R6,R0
// 10972     for(row = tempheadrow; ; row++)
        B.N      ??AngleStep1JudgeNotBrick_9
??AngleStep1JudgeNotBrick_10:
        ADDS     R6,R6,#+1
// 10973     {
// 10974       //对某一行的处理。
// 10975       //该行黑点计数
// 10976       count3 = 0;
??AngleStep1JudgeNotBrick_9:
        MOVS     R7,#+0
// 10977       //从右往左扫描。
// 10978       tempend = (a0 + a1 * row) / LeastSquareMulti + BrickColCom;   //记得除以增加的倍数
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MLA      R0,R6,R4,R5
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        ADDS     R0,R0,#+5
// 10979       //限幅。
// 10980       tempend = MinRe(tempend, AngleStep1NotBrickBorderColL);
        LDR.W    R1,??DataTable58_9
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       MinRe
// 10981       //黑点扫描。
// 10982       for(col = AngleStep1NotBrickBorderColL; ; col--)
        LDR.W    R1,??DataTable58_9
        LDRB     R1,[R1, #+0]
        B.N      ??AngleStep1JudgeNotBrick_11
??AngleStep1JudgeNotBrick_12:
        SUBS     R1,R1,#+1
// 10983       {
// 10984         if(ImgNew[row][col] < LimitLeftB)  //够黑
??AngleStep1JudgeNotBrick_11:
        LDR.W    R2,??DataTable58_10
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R6,R2
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R2,[R1, R2]
        LDR.W    R3,??DataTable58_11
        LDRB     R3,[R3, #+0]
        CMP      R2,R3
        BCS.N    ??AngleStep1JudgeNotBrick_13
// 10985         {
// 10986           count3++;
        ADDS     R7,R7,#+1
// 10987         }
// 10988         else
// 10989         {
// 10990         }
// 10991         //向左扫描至边界
// 10992         if(col <= tempend || col == 0) break;
??AngleStep1JudgeNotBrick_13:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R0,R1
        BCS.N    ??AngleStep1JudgeNotBrick_14
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??AngleStep1JudgeNotBrick_12
// 10993       }
// 10994       //该行黑点个数大于BrickLineBlackCountNum个时，则行计数加1.
// 10995       if(count3 > BrickLineBlackCountNum) 
??AngleStep1JudgeNotBrick_14:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+21
        BLT.N    ??AngleStep1JudgeNotBrick_15
// 10996       {
// 10997         //存在有行黑点过多，则直接返回失败
// 10998         return 0;
        MOVS     R0,#+0
        B.N      ??AngleStep1JudgeNotBrick_7
// 10999       }
// 11000       else
// 11001       {
// 11002       }
// 11003       
// 11004       if(row == BrickEndRow) break;
??AngleStep1JudgeNotBrick_15:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+35
        BNE.N    ??AngleStep1JudgeNotBrick_10
// 11005     }
// 11006     
// 11007     //3. 最终确认，返回成功。
// 11008     return 1;
        MOVS     R0,#+1
        B.N      ??AngleStep1JudgeNotBrick_7
// 11009        
// 11010   }
// 11011   //非右障碍确认
// 11012   else if(dir == 1)
??AngleStep1JudgeNotBrick_0:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.W    ??AngleStep1JudgeNotBrick_16
// 11013   {
// 11014     //1. 最小二乘法
// 11015     index = 0;    
        MOVS     R0,#+0
// 11016     for(i = BrickEndRow + 1; ; i++)
        MOVS     R1,#+36
        B.N      ??AngleStep1JudgeNotBrick_17
??AngleStep1JudgeNotBrick_18:
        ADDS     R1,R1,#+1
// 11017     {
// 11018       if(BlackRightLoc[i][0] != MaxValUint8)
??AngleStep1JudgeNotBrick_17:
        LDR.W    R2,??DataTable58_8
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BEQ.N    ??AngleStep1JudgeNotBrick_19
// 11019       {
// 11020         y[index] = BlackRightLoc[i][0];
        LDR.W    R2,??DataTable58_8
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        ADD      R3,SP,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R2,[R0, R3]
// 11021         x[index] = i;
        ADD      R2,SP,#+8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 11022         index++;
        ADDS     R0,R0,#+1
// 11023       }
// 11024       if(index == BrickSlopeRowNum)
??AngleStep1JudgeNotBrick_19:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+8
        BNE.N    ??AngleStep1JudgeNotBrick_20
// 11025       {
// 11026         break;  
// 11027       }
// 11028       if(i == CameraHight - 1)
// 11029       {
// 11030         return 0;
// 11031       }
// 11032     }
// 11033     
// 11034     //最小二乘法
// 11035     //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
// 11036     a1 = LeastSquarea1(x, y, BrickSlopeRowNum);
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea1
        MOVS     R4,R0
// 11037     //右边，斜率应该是0~PathJudgeStraightSlopeLimit,否则斜率不对，返回失败。
// 11038     if(a1 > 0 && a1 < PathJudgeStraightSlopeLimit)
        SUBS     R0,R4,#+1
        MOVW     R1,#+2099
        CMP      R0,R1
        BCC.N    ??AngleStep1JudgeNotBrick_21
// 11039     {
// 11040     }
// 11041     else
// 11042     {
// 11043       return 0;
        MOVS     R0,#+0
        B.N      ??AngleStep1JudgeNotBrick_7
// 11044     }
??AngleStep1JudgeNotBrick_20:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+59
        BNE.N    ??AngleStep1JudgeNotBrick_18
        MOVS     R0,#+0
        B.N      ??AngleStep1JudgeNotBrick_7
// 11045     a0 = LeastSquarea0(x, y, a1, BrickSlopeRowNum);
??AngleStep1JudgeNotBrick_21:
        MOVS     R3,#+8
        MOVS     R2,R4
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea0
        MOVS     R5,R0
// 11046     //直角梯形的两个突出顶点所在列
// 11047     //起始行（近行）黑点所在列。
// 11048     AngleStep1NotBrickEndColR = (a0 + a1 * BrickEndRow) / LeastSquareMulti - BrickColCom;   //变量有改，不会重叠。
        MOVS     R0,#+35
        MLA      R0,R0,R4,R5
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+5
        LDR.W    R1,??DataTable58_12
        STRB     R0,[R1, #+0]
// 11049     //直角梯形的直角边所在列。不能比当前行的有效左黑线还要小。
// 11050     if(BlackLeftLoc[BrickEndRow][0] != MaxValUint8)
        LDR.W    R0,??DataTable58_6
        LDRB     R0,[R0, #+105]
        CMP      R0,#+255
        BEQ.N    ??AngleStep1JudgeNotBrick_22
// 11051     {
// 11052       AngleStep1NotBrickBorderColR = MaxRe(AngleStep1NotBrickEndColR - BrickScanColNum, BlackLeftLoc[BrickEndRow][0]);  //这里与非障碍边不同，非障碍是BrickScanColNum / 2，这里为了保险，取BrickScanColNum。
        LDR.W    R0,??DataTable58_6
        LDRB     R1,[R0, #+105]
        LDR.W    R0,??DataTable58_12
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+60
        BL       MaxRe
        LDR.W    R1,??DataTable58_13
        STRB     R0,[R1, #+0]
// 11053     }
// 11054     else
// 11055     {
// 11056     }
// 11057     
// 11058     //2.2 非障碍边，开始扫描，找到黑点过多的行，则左障碍确认失败。进行右障碍扫描。
// 11059     //为了防止检测过头，检测的最远行需要跟右线头挂勾。
// 11060     //不能比BrickEndRow更近。
// 11061     tempheadrow = MinRe(BrickEndRow, BlackRightHeadLine);
??AngleStep1JudgeNotBrick_22:
        LDR.N    R0,??DataTable57_22
        LDRB     R1,[R0, #+0]
        MOVS     R0,#+35
        BL       MinRe
        MOVS     R6,R0
// 11062     //不能比BrickHeadRow更远。
// 11063     tempheadrow = MaxRe(BrickHeadRow, tempheadrow);    
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MOVS     R1,R6
        MOVS     R0,#+15
        BL       MaxRe
        MOVS     R6,R0
// 11064     for(row = tempheadrow; ; row++)
        B.N      ??AngleStep1JudgeNotBrick_23
??AngleStep1JudgeNotBrick_24:
        ADDS     R6,R6,#+1
// 11065     {
// 11066       //对某一行的处理。
// 11067       //该行黑点计数，从左往右扫描。
// 11068       count3 = 0;
??AngleStep1JudgeNotBrick_23:
        MOVS     R7,#+0
// 11069       //当前行的扫描的右边界。
// 11070       tempend = (a0 + a1 * row) / LeastSquareMulti - BrickColCom;   //记得除以增加的倍数
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MLA      R0,R6,R4,R5
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+5
// 11071       //限幅。
// 11072       tempend = MaxRe(tempend, AngleStep1NotBrickBorderColR);
        LDR.W    R1,??DataTable58_13
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       MaxRe
// 11073       //黑点扫描。
// 11074       for(col = AngleStep1NotBrickBorderColR; ; col++)
        LDR.W    R1,??DataTable58_13
        LDRB     R1,[R1, #+0]
        B.N      ??AngleStep1JudgeNotBrick_25
??AngleStep1JudgeNotBrick_26:
        ADDS     R1,R1,#+1
// 11075       {
// 11076         if(ImgNew[row][col] < LimitRightB)  //够黑
??AngleStep1JudgeNotBrick_25:
        LDR.W    R2,??DataTable58_10
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R6,R2
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R2,[R1, R2]
        LDR.W    R3,??DataTable59
        LDRB     R3,[R3, #+0]
        CMP      R2,R3
        BCS.N    ??AngleStep1JudgeNotBrick_27
// 11077         {
// 11078           count3++;
        ADDS     R7,R7,#+1
// 11079         }
// 11080         else
// 11081         {
// 11082         }
// 11083         //向右扫描至边界
// 11084         if(col >= tempend || col == CameraRealWidth - 1) break;
??AngleStep1JudgeNotBrick_27:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BCS.N    ??AngleStep1JudgeNotBrick_28
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+249
        BNE.N    ??AngleStep1JudgeNotBrick_26
// 11085       }
// 11086       //该行黑点个数大于BrickLineBlackCountNum个时，则行计数加1.
// 11087       if(count3 > BrickLineBlackCountNum) 
??AngleStep1JudgeNotBrick_28:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+21
        BLT.N    ??AngleStep1JudgeNotBrick_29
// 11088       {
// 11089         //存在有行黑点过多，则直接返回失败
// 11090         return 0;
        MOVS     R0,#+0
        B.N      ??AngleStep1JudgeNotBrick_7
// 11091       }
// 11092       else
// 11093       {
// 11094       }
// 11095       
// 11096       if(row == BrickEndRow) break;
??AngleStep1JudgeNotBrick_29:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+35
        BNE.N    ??AngleStep1JudgeNotBrick_24
// 11097     }
// 11098     
// 11099     //3. 最终确认
// 11100     //走到这里说明没有非障碍检测成功，返回成功。
// 11101     return 1;
        MOVS     R0,#+1
        B.N      ??AngleStep1JudgeNotBrick_7
// 11102   }
// 11103   else
// 11104   {
// 11105   }
// 11106 
// 11107   
// 11108   //常态为返回失败。
// 11109   return 0;
??AngleStep1JudgeNotBrick_16:
        MOVS     R0,#+0
??AngleStep1JudgeNotBrick_7:
        ADD      SP,SP,#+20
        POP      {R4-R7,PC}       ;; return
// 11110 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57:
        DC32     ImgStore1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_1:
        DC32     ErrorGetSelf

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_2:
        DC32     ErrorGetCen

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_3:
        DC32     CurveLineChosenC1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_4:
        DC32     CurveLineChosenC2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_5:
        DC32     CurveLineChosenC3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_6:
        DC32     CenterHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_7:
        DC32     CURVEC

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_8:
        DC32     SlopeC

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_9:
        DC32     BlackLeftDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_10:
        DC32     CurveLineChosenL1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_11:
        DC32     CurveLineChosenL2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_12:
        DC32     CurveLineChosenL3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_13:
        DC32     BlackLeftHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_14:
        DC32     BlackLeftEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_15:
        DC32     CURVEL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_16:
        DC32     SlopeL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_17:
        DC32     BlackUdisLeftLocation

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_18:
        DC32     BlackRightDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_19:
        DC32     CurveLineChosenR1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_20:
        DC32     CurveLineChosenR2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_21:
        DC32     CurveLineChosenR3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_22:
        DC32     BlackRightHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable57_23:
        DC32     BlackRightEndLine
// 11111 
// 11112 
// 11113 
// 11114 //======================================================================
// 11115 //函数名：AngleStep1Judge
// 11116 //功  能：直角弯初步判断
// 11117 //参  数：
// 11118 //返  回：1成功，0失败
// 11119 //影  响：
// 11120 //说  明：1. 这只是初步判断，需确认多次方可确认为直角弯。
// 11121 //        2. 其实还可以添加第6步，就是矮线的左右边有黑色区域。
// 11122 //             
// 11123 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 11124 uint8 AngleStep1Judge(void)
// 11125 {
AngleStep1Judge:
        PUSH     {R4-R8,LR}
// 11126   uint8 i, j, col;
// 11127   uint8 errorcount;
// 11128   uint8 templ, tempr;
// 11129   uint8 check_row, leftborder, rightborder;
// 11130   uint8 leftbordercal, rightbordercal;
// 11131   //由于现在进来之前不需要判断直道，所以需要先做一遍直道做的事情。
// 11132   //若判断不准，可以尝试把errorcount的阈值减小。
// 11133 
// 11134   //1. 左、右黑线均提取成功
// 11135   if(BlackLeftDone == 1 && BlackRightDone == 1)
        LDR.W    R0,??DataTable59_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??AngleStep1Judge_0
        LDR.W    R0,??DataTable59_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??AngleStep1Judge_1
// 11136   {
// 11137   }
// 11138   else
// 11139   {
// 11140     return 0;
??AngleStep1Judge_0:
        MOVS     R0,#+0
        B.N      ??AngleStep1Judge_2
// 11141   }
// 11142   
// 11143   //进来后进一步需要判断的条件：
// 11144   //2. 线头有高度差
// 11145   //左线头比右线头高很多，则有可能是右直角弯。
// 11146   if (BlackRightHeadLine >= BlackLeftHeadLine + AngleHeadLineNum)
??AngleStep1Judge_1:
        LDR.W    R0,??DataTable59_3
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable59_4
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable59_5
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        CMP      R0,R1
        BLT.W    ??AngleStep1Judge_3
// 11147   {
// 11148       //3. 左线十字状态未进入或失败（反正不能成功），线尾很近
// 11149       //   右线十字状态未进入或失败（反正不能成功），线尾很近
// 11150       //BlackLeftCrossDone 0未进入，1失败，2成功
// 11151       //BlackLeftStep4Flag 0未进入，1失败，2成功
// 11152       if ((BlackLeftCrossDone != 2)
// 11153       //&& (BlackLeftEndLine > CameraHight - 5)
// 11154       && (BlackRightCrossDone != 2)
// 11155       //&& (BlackRightEndLine > CameraHight - 5)
// 11156       && (CURVEL <= 30 && CURVEL >= 0 - 30)      //左曲率应该是个绝对值较小的值
// 11157       && (CURVER <= 30 && CURVER >= 0 - 40)      //右直角弯 //右曲率应该是个绝对值较小的值
// 11158         )
        LDR.W    R0,??DataTable59_6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BEQ.W    ??AngleStep1Judge_4
        LDR.W    R0,??DataTable59_7
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BEQ.W    ??AngleStep1Judge_4
        LDR.W    R0,??DataTable59_8
        LDRSH    R0,[R0, #+0]
        ADDS     R0,R0,#+30
        CMP      R0,#+61
        BCS.W    ??AngleStep1Judge_4
        LDR.W    R0,??DataTable58
        LDRSH    R0,[R0, #+0]
        ADDS     R0,R0,#+40
        CMP      R0,#+71
        BCS.W    ??AngleStep1Judge_4
// 11159       {
// 11160           //3.5 检查右线头处有没有小拐弯，如果有小拐弯，则返回失败。
// 11161           if(BlackRightLoc[BlackRightHeadLine][0] > BlackRightLoc[BlackRightHeadLine+1][0] && BlackRightLoc[BlackRightHeadLine+1][0] > BlackRightLoc[BlackRightHeadLine+2][0])
        LDR.W    R0,??DataTable58_8
        LDR.W    R1,??DataTable59_3
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+3]
        LDR.W    R1,??DataTable58_8
        LDR.W    R2,??DataTable59_3
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+3
        MLA      R1,R3,R2,R1
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCS.N    ??AngleStep1Judge_5
        LDR.W    R0,??DataTable58_8
        LDR.W    R1,??DataTable59_3
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+6]
        LDR.W    R1,??DataTable58_8
        LDR.W    R2,??DataTable59_3
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+3
        MLA      R1,R3,R2,R1
        LDRB     R1,[R1, #+3]
        CMP      R0,R1
        BCS.N    ??AngleStep1Judge_5
// 11162           {
// 11163             return 0;
        MOVS     R0,#+0
        B.N      ??AngleStep1Judge_2
// 11164           }
// 11165           else
// 11166           {
// 11167           }
// 11168           
// 11169           //4. 两线5Slope数组均很小
// 11170           //左线
// 11171           //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
// 11172           //直角弯长线头策略，1表示去掉长线线头。
// 11173           if(AngleLongHeadLineStrategy == 1)
??AngleStep1Judge_5:
        LDR.W    R0,??DataTable60
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??AngleStep1Judge_6
// 11174           {
// 11175             if(BlackLeftEndLine - BlackLeftHeadLine - 4 - AngleHeadLineNum < 0 || BlackLeft5SlopeIndex - 1 - AngleHeadLineNum < 0)
        LDR.W    R0,??DataTable60_1
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable59_4
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+4
        LDR.W    R1,??DataTable59_5
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+0
        BMI.N    ??AngleStep1Judge_7
        LDR.W    R0,??DataTable60_2
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        LDR.W    R1,??DataTable59_5
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+0
        BPL.N    ??AngleStep1Judge_8
// 11176             {
// 11177               return 0;
??AngleStep1Judge_7:
        MOVS     R0,#+0
        B.N      ??AngleStep1Judge_2
// 11178             }
// 11179             else
// 11180             {        
// 11181             }
// 11182             templ = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 4, BlackLeft5SlopeIndex - 1);               
??AngleStep1Judge_8:
        LDR.W    R0,??DataTable60_2
        LDRB     R0,[R0, #+0]
        SUBS     R1,R0,#+1
        LDR.W    R0,??DataTable60_1
        LDRB     R0,[R0, #+0]
        LDR.W    R2,??DataTable59_4
        LDRB     R2,[R2, #+0]
        SUBS     R0,R0,R2
        SUBS     R0,R0,#+4
        BL       MinRe
        B.N      ??AngleStep1Judge_9
// 11183           }
// 11184           //0表示不去掉。
// 11185           else
// 11186           {
// 11187             if(BlackLeftEndLine - BlackLeftHeadLine - 4 < 0 || BlackLeft5SlopeIndex - 1 < 0)
??AngleStep1Judge_6:
        LDR.W    R0,??DataTable60_1
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable59_4
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+4
        CMP      R0,#+0
        BMI.N    ??AngleStep1Judge_10
        LDR.W    R0,??DataTable60_2
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        CMP      R0,#+0
        BPL.N    ??AngleStep1Judge_11
// 11188             {
// 11189               return 0;
??AngleStep1Judge_10:
        MOVS     R0,#+0
        B.N      ??AngleStep1Judge_2
// 11190             }
// 11191             else
// 11192             {        
// 11193             }
// 11194             templ = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 4, BlackLeft5SlopeIndex - 1);            
??AngleStep1Judge_11:
        LDR.W    R0,??DataTable60_2
        LDRB     R0,[R0, #+0]
        SUBS     R1,R0,#+1
        LDR.W    R0,??DataTable60_1
        LDRB     R0,[R0, #+0]
        LDR.W    R2,??DataTable59_4
        LDRB     R2,[R2, #+0]
        SUBS     R0,R0,R2
        SUBS     R0,R0,#+4
        BL       MinRe
// 11195           }
// 11196           //错误计数清零
// 11197           errorcount = 0;
??AngleStep1Judge_9:
        MOVS     R2,#+0
// 11198           //逐个判断小5点斜率是否满足条件
// 11199           for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??AngleStep1Judge_12
??AngleStep1Judge_13:
        ADDS     R1,R1,#+1
// 11200           {
// 11201             if(BlackLeft5Slope[i] > 0 || BlackLeft5Slope[i] < 0 - PathJudgeStraightSlopeLimit) //右上到左下的斜率是负的。 
??AngleStep1Judge_12:
        LDR.W    R3,??DataTable60_3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R3,[R3, R1, LSL #+2]
        ADDW     R3,R3,#+2100
        MOVW     R4,#+2101
        CMP      R3,R4
        BCC.N    ??AngleStep1Judge_14
// 11202             {
// 11203               errorcount++;
        ADDS     R2,R2,#+1
// 11204               if(errorcount > 3) break;   //允许有若干个点斜率超出范围
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+4
        BGE.N    ??AngleStep1Judge_15
// 11205             }
// 11206       
// 11207             if(i == templ) break;
??AngleStep1Judge_14:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BNE.N    ??AngleStep1Judge_13
// 11208           }
// 11209           //不满足条件，返回失败。
// 11210           if(i != templ) return 0;
??AngleStep1Judge_15:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BEQ.N    ??AngleStep1Judge_16
        MOVS     R0,#+0
        B.N      ??AngleStep1Judge_2
// 11211           
// 11212           //右线
// 11213           //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
// 11214           if(BlackRightEndLine - BlackRightHeadLine - 4 < 0 || BlackRight5SlopeIndex - 1 < 0)
??AngleStep1Judge_16:
        LDR.W    R0,??DataTable60_4
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable59_3
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+4
        CMP      R0,#+0
        BMI.N    ??AngleStep1Judge_17
        LDR.W    R0,??DataTable60_5
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        CMP      R0,#+0
        BPL.N    ??AngleStep1Judge_18
// 11215           {
// 11216             return 0;
??AngleStep1Judge_17:
        MOVS     R0,#+0
        B.N      ??AngleStep1Judge_2
// 11217           }
// 11218           else
// 11219           {
// 11220           }
// 11221           tempr = MinRe(BlackRightEndLine - BlackRightHeadLine - 4, BlackRight5SlopeIndex - 1);
??AngleStep1Judge_18:
        LDR.W    R0,??DataTable60_5
        LDRB     R0,[R0, #+0]
        SUBS     R1,R0,#+1
        LDR.W    R0,??DataTable60_4
        LDRB     R0,[R0, #+0]
        LDR.W    R2,??DataTable59_3
        LDRB     R2,[R2, #+0]
        SUBS     R0,R0,R2
        SUBS     R0,R0,#+4
        BL       MinRe
// 11222           //错误计数清零
// 11223           errorcount = 0;
        MOVS     R2,#+0
// 11224           //逐个判断小5点斜率是否满足条件
// 11225           for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??AngleStep1Judge_19
??AngleStep1Judge_20:
        ADDS     R1,R1,#+1
// 11226           {
// 11227             if(BlackRight5Slope[i] < 0 || BlackRight5Slope[i] > PathJudgeStraightSlopeLimit) //左上到右下的斜率是正的。
??AngleStep1Judge_19:
        LDR.W    R3,??DataTable60_6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R3,[R3, R1, LSL #+2]
        SUBS     R3,R3,#+0
        MOVW     R4,#+2101
        CMP      R3,R4
        BCC.N    ??AngleStep1Judge_21
// 11228             {
// 11229               errorcount++;
        ADDS     R2,R2,#+1
// 11230               if(errorcount > 3) break;   //允许有若干个点斜率超出范围
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+4
        BGE.N    ??AngleStep1Judge_22
// 11231             }
// 11232       
// 11233             if(i == tempr) break;
??AngleStep1Judge_21:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BNE.N    ??AngleStep1Judge_20
// 11234           }
// 11235           //不满足条件，返回失败。
// 11236           if(i != tempr) return 0;
??AngleStep1Judge_22:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BEQ.N    ??AngleStep1Judge_23
        MOVS     R0,#+0
        B.N      ??AngleStep1Judge_2
// 11237           
// 11238           //若左右两线都满足要求，会继续往下走。
// 11239 
// 11240           //5. 对右线头往上一些点进行白区域检测。
// 11241           //5.1. 一竖
// 11242           col = BlackRightLoc[BlackRightHeadLine][0];   //这里采用原始的黑点，不能采用矫正后的。
??AngleStep1Judge_23:
        LDR.W    R0,??DataTable58_8
        LDR.W    R1,??DataTable59_3
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
// 11243           for(i = BlackRightHeadLine-3; i > (BlackRightHeadLine-AngleHeadLineNum); i--)
        LDR.W    R1,??DataTable59_3
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+3
        B.N      ??AngleStep1Judge_24
// 11244           {
// 11245             //与右线白点阈值进行比较，必须大于白点阈值。
// 11246             if(ImgNew[i][col] < LimitRightW - AngleWhiteAreaLimitVal)
// 11247             {
// 11248               flag222 = 10;
// 11249               //只要有一个点不满足，即判定不是直角弯。
// 11250               break;
// 11251             }
// 11252             else
// 11253             {
// 11254               flag222 = 0;
??AngleStep1Judge_25:
        MOVS     R2,#+0
        LDR.W    R3,??DataTable60_7
        STR      R2,[R3, #+0]
// 11255             }
        SUBS     R1,R1,#+1
??AngleStep1Judge_24:
        LDR.W    R2,??DataTable59_3
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable59_5
        LDRB     R3,[R3, #+0]
        SUBS     R2,R2,R3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R2,R1
        BGE.N    ??AngleStep1Judge_26
        LDR.W    R2,??DataTable58_10
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R1,R2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDRB     R2,[R0, R2]
        LDR.W    R3,??DataTable60_8
        LDRB     R3,[R3, #+0]
        SUBS     R3,R3,#+20
        CMP      R2,R3
        BGE.N    ??AngleStep1Judge_25
        MOVS     R2,#+10
        LDR.W    R3,??DataTable60_7
        STR      R2,[R3, #+0]
// 11256           }
// 11257           //从下到上一直满足白点，且最上与最下两个点像素差值够小。
// 11258           if(
// 11259             (i <= BlackRightHeadLine-AngleHeadLineNum)
// 11260           &&(AbsInt(ImgNew[BlackRightHeadLine-3][col] - ImgNew[BlackRightHeadLine-AngleHeadLineNum][col]) < 2 * AngleWhiteAreaLimitVal)
// 11261             )
??AngleStep1Judge_26:
        LDR.W    R2,??DataTable59_3
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable59_5
        LDRB     R3,[R3, #+0]
        SUBS     R2,R2,R3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R2,R1
        BLT.W    ??AngleStep1Judge_4
        LDR.W    R1,??DataTable58_10
        LDR.W    R2,??DataTable59_3
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+250
        MLA      R1,R3,R2,R1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R1,R0,R1
        SUBW     R1,R1,#+750
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable58_10
        LDR.W    R3,??DataTable59_3
        LDRB     R3,[R3, #+0]
        LDR.W    R4,??DataTable59_5
        LDRB     R4,[R4, #+0]
        SUBS     R3,R3,R4
        MOVS     R4,#+250
        MLA      R2,R4,R3,R2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDRB     R0,[R0, R2]
        SUBS     R0,R1,R0
        BL       AbsInt
        CMP      R0,#+40
        BGE.W    ??AngleStep1Judge_4
// 11262           {
// 11263             //5.2. 一横
// 11264             check_row = BlackRightHeadLine - AngleHeadLineNum / 2;
        LDR.W    R0,??DataTable59_3
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable59_5
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+2
        SDIV     R1,R1,R2
        SUBS     R4,R0,R1
// 11265             //一横的左边界
// 11266             //不能小于图像左边界
// 11267             leftborder = MaxRe(0, BlackRightLoc[BlackRightHeadLine][0] - 15);
        LDR.W    R0,??DataTable58_8
        LDR.W    R1,??DataTable59_3
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        SUBS     R1,R0,#+15
        MOVS     R0,#+0
        BL       MaxRe
        MOVS     R5,R0
// 11268             leftbordercal = MaxRe(0, BlackRightLoc[BlackRightHeadLine][0] - 15);
        LDR.W    R0,??DataTable58_8
        LDR.W    R1,??DataTable59_3
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        SUBS     R1,R0,#+15
        MOVS     R0,#+0
        BL       MaxRe
        MOVS     R6,R0
// 11269             //不能比该行有效左黑线小。
// 11270             if(BlackLeftLoc[check_row][0] != MaxValUint8)
        LDR.W    R0,??DataTable58_6
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??AngleStep1Judge_27
// 11271             {
// 11272               leftborder = MaxRe(BlackLeftLoc[check_row][0], leftborder);
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        MOVS     R1,R5
        LDR.W    R0,??DataTable58_6
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R0,R2,R4,R0
        LDRB     R0,[R0, #+0]
        BL       MaxRe
        MOVS     R5,R0
// 11273               leftbordercal = MaxRe(BlackLeftLoc[check_row][0], leftbordercal);
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MOVS     R1,R6
        LDR.W    R0,??DataTable58_6
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R0,R2,R4,R0
        LDRB     R0,[R0, #+0]
        BL       MaxRe
        MOVS     R6,R0
// 11274             }
// 11275             else
// 11276             {
// 11277             } 
// 11278             //一横的右边界。
// 11279             rightborder = MinRe(CameraRealWidth - 1, BlackRightLoc[BlackRightHeadLine][0] + 15);
??AngleStep1Judge_27:
        LDR.W    R0,??DataTable58_8
        LDR.W    R1,??DataTable59_3
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        ADDS     R1,R0,#+15
        MOVS     R0,#+249
        BL       MinRe
        MOVS     R7,R0
// 11280             rightbordercal = MinRe(CameraRealWidth - 1, BlackRightLoc[BlackRightHeadLine][0] + 15);
        LDR.W    R0,??DataTable58_8
        LDR.W    R1,??DataTable59_3
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        ADDS     R1,R0,#+15
        MOVS     R0,#+249
        BL       MinRe
        MOV      R8,R0
// 11281             //从左到右进行白点检查
// 11282             for(j = leftborder; j < rightborder; j++)
        B.N      ??AngleStep1Judge_28
??AngleStep1Judge_29:
        ADDS     R5,R5,#+1
??AngleStep1Judge_28:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R5,R7
        BCS.N    ??AngleStep1Judge_30
// 11283             {
// 11284               if(ImgNew[check_row][j] < LimitRightW - AngleWhiteAreaLimitVal) break;              
        LDR.W    R0,??DataTable58_10
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LDRB     R0,[R5, R0]
        LDR.W    R1,??DataTable60_8
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+20
        CMP      R0,R1
        BGE.N    ??AngleStep1Judge_29
// 11285             }
// 11286             //从左到右一直满足白点，且最左最右两点差值够小，进入第6步。
// 11287             if(
// 11288               (j >= rightborder) 
// 11289             &&(AbsInt(ImgNew[check_row][leftbordercal] - ImgNew[check_row][rightbordercal]) < 2 * AngleWhiteAreaLimitVal) //隔的点比较多，允许差值稍微大一些。
// 11290               )
??AngleStep1Judge_30:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R5,R7
        BCC.W    ??AngleStep1Judge_4
        LDR.W    R0,??DataTable58_10
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRB     R0,[R6, R0]
        LDR.W    R1,??DataTable58_10
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDRB     R1,[R8, R1]
        SUBS     R0,R0,R1
        BL       AbsInt
        CMP      R0,#+40
        BGE.W    ??AngleStep1Judge_4
// 11291             {
// 11292               //6. 非右障碍确认成功，则最终确认是右直角。
// 11293               if(AngleStep1JudgeNotBrick(1) == 1)
        MOVS     R0,#+1
        BL       AngleStep1JudgeNotBrick
        CMP      R0,#+1
        BNE.W    ??AngleStep1Judge_4
// 11294               {
// 11295                 PathType = PathTypeAngleR;
        MOVS     R0,#+5
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??AngleStep1Judge_4
// 11296               }
// 11297               else
// 11298               {
// 11299               }
// 11300             }
// 11301             else
// 11302             {
// 11303               
// 11304             }           
// 11305           }
// 11306           else
// 11307           {            
// 11308           }
// 11309       }
// 11310       //否则仍为直道
// 11311       else
// 11312       {
// 11313       }
// 11314 
// 11315   }
// 11316   //右线头比左线头高很多，则有可能是左直角弯。
// 11317   else if (BlackLeftHeadLine >= BlackRightHeadLine + AngleHeadLineNum)
??AngleStep1Judge_3:
        LDR.W    R0,??DataTable59_4
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable59_3
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable59_5
        LDRB     R2,[R2, #+0]
        ADDS     R1,R2,R1
        CMP      R0,R1
        BLT.W    ??AngleStep1Judge_4
// 11318   {
// 11319       //3. 左线十字状态未进入或失败（反正不能成功），线尾很近
// 11320       //   右线十字状态未进入或失败（反正不能成功），线尾很近
// 11321       //BlackLeftCrossDone 0未进入，1失败，2成功
// 11322       //BlackLeftStep4Flag 0未进入，1失败，2成功
// 11323       if ((BlackLeftCrossDone != 2)
// 11324       //&& (BlackLeftEndLine > CameraHight - 5)
// 11325       && (BlackRightCrossDone != 2)
// 11326       //&& (BlackRightEndLine > CameraHight - 5)
// 11327       && (CURVEL <= 40 && CURVEL >= 0 - 30)      //左直角弯//左曲率应该是个绝对值较小的值
// 11328       && (CURVER <= 30 && CURVER >= 0 - 30)      //右曲率应该是个绝对值较小的值
// 11329         )
        LDR.W    R0,??DataTable59_6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BEQ.W    ??AngleStep1Judge_4
        LDR.W    R0,??DataTable59_7
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BEQ.W    ??AngleStep1Judge_4
        LDR.W    R0,??DataTable59_8
        LDRSH    R0,[R0, #+0]
        ADDS     R0,R0,#+30
        CMP      R0,#+71
        BCS.W    ??AngleStep1Judge_4
        LDR.W    R0,??DataTable58
        LDRSH    R0,[R0, #+0]
        ADDS     R0,R0,#+30
        CMP      R0,#+61
        BCS.W    ??AngleStep1Judge_4
// 11330       {
// 11331           //3.5 检查左线头处有没有小拐弯，如果有小拐弯，则返回失败。
// 11332           if(BlackLeftLoc[BlackLeftHeadLine][0] < BlackLeftLoc[BlackLeftHeadLine+1][0] && BlackLeftLoc[BlackLeftHeadLine+1][0] < BlackLeftLoc[BlackLeftHeadLine+2][0])
        LDR.W    R0,??DataTable58_6
        LDR.W    R1,??DataTable59_4
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable58_6
        LDR.W    R2,??DataTable59_4
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+3
        MLA      R1,R3,R2,R1
        LDRB     R1,[R1, #+3]
        CMP      R0,R1
        BCS.N    ??AngleStep1Judge_31
        LDR.N    R0,??DataTable58_6
        LDR.W    R1,??DataTable59_4
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+3]
        LDR.N    R1,??DataTable58_6
        LDR.W    R2,??DataTable59_4
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+3
        MLA      R1,R3,R2,R1
        LDRB     R1,[R1, #+6]
        CMP      R0,R1
        BCS.N    ??AngleStep1Judge_31
// 11333           {
// 11334             return 0;
        MOVS     R0,#+0
        B.N      ??AngleStep1Judge_2
// 11335           }
// 11336           else
// 11337           {
// 11338           }
// 11339 
// 11340           //4. 两线5Slope数组均很小
// 11341           //左线
// 11342           //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
// 11343           if(BlackLeftEndLine - BlackLeftHeadLine - 4 < 0 || BlackLeft5SlopeIndex - 1 < 0)
??AngleStep1Judge_31:
        LDR.W    R0,??DataTable60_1
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable59_4
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+4
        CMP      R0,#+0
        BMI.N    ??AngleStep1Judge_32
        LDR.W    R0,??DataTable60_2
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        CMP      R0,#+0
        BPL.N    ??AngleStep1Judge_33
// 11344           {
// 11345             return 0;
??AngleStep1Judge_32:
        MOVS     R0,#+0
        B.N      ??AngleStep1Judge_2
// 11346           }
// 11347           else
// 11348           {        
// 11349           }
// 11350           templ = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 4, BlackLeft5SlopeIndex - 1);
??AngleStep1Judge_33:
        LDR.W    R0,??DataTable60_2
        LDRB     R0,[R0, #+0]
        SUBS     R1,R0,#+1
        LDR.W    R0,??DataTable60_1
        LDRB     R0,[R0, #+0]
        LDR.W    R2,??DataTable59_4
        LDRB     R2,[R2, #+0]
        SUBS     R0,R0,R2
        SUBS     R0,R0,#+4
        BL       MinRe
// 11351           //错误计数清零
// 11352           errorcount = 0;
        MOVS     R2,#+0
// 11353           //逐个判断小5点斜率是否满足条件
// 11354           for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??AngleStep1Judge_34
??AngleStep1Judge_35:
        ADDS     R1,R1,#+1
// 11355           {
// 11356             if(BlackLeft5Slope[i] > 0 || BlackLeft5Slope[i] < 0 - PathJudgeStraightSlopeLimit) //右上到左下的斜率是负的。 
??AngleStep1Judge_34:
        LDR.W    R3,??DataTable60_3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R3,[R3, R1, LSL #+2]
        ADDW     R3,R3,#+2100
        MOVW     R4,#+2101
        CMP      R3,R4
        BCC.N    ??AngleStep1Judge_36
// 11357             {
// 11358               errorcount++;
        ADDS     R2,R2,#+1
// 11359               if(errorcount > 3) break;   //允许有若干个点斜率超出范围
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+4
        BGE.N    ??AngleStep1Judge_37
// 11360             }
// 11361       
// 11362             if(i == templ) break;
??AngleStep1Judge_36:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BNE.N    ??AngleStep1Judge_35
// 11363           }
// 11364           //不满足条件，返回失败。
// 11365           if(i != templ) return 0;
??AngleStep1Judge_37:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BEQ.N    ??AngleStep1Judge_38
        MOVS     R0,#+0
        B.N      ??AngleStep1Judge_2
// 11366           
// 11367           //右线
// 11368           //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
// 11369           //直角弯线头差策略，1表示去掉长线的线头。
// 11370           if(AngleLongHeadLineStrategy == 1)
??AngleStep1Judge_38:
        LDR.W    R0,??DataTable60
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??AngleStep1Judge_39
// 11371           {
// 11372             if(BlackRightEndLine - BlackRightHeadLine - 4 - AngleHeadLineNum < 0 || BlackRight5SlopeIndex - 1 - AngleHeadLineNum < 0)
        LDR.W    R0,??DataTable60_4
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable59_3
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+4
        LDR.W    R1,??DataTable59_5
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+0
        BMI.N    ??AngleStep1Judge_40
        LDR.W    R0,??DataTable60_5
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        LDR.W    R1,??DataTable59_5
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        CMP      R0,#+0
        BPL.N    ??AngleStep1Judge_41
// 11373             {
// 11374               return 0;
??AngleStep1Judge_40:
        MOVS     R0,#+0
        B.N      ??AngleStep1Judge_2
// 11375             }
// 11376             else
// 11377             {
// 11378             }
// 11379             tempr = MinRe(BlackRightEndLine - BlackRightHeadLine - 4 - AngleHeadLineNum, BlackRight5SlopeIndex - 1 - AngleHeadLineNum);
??AngleStep1Judge_41:
        LDR.W    R0,??DataTable60_5
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        LDR.W    R1,??DataTable59_5
        LDRB     R1,[R1, #+0]
        SUBS     R1,R0,R1
        LDR.W    R0,??DataTable60_4
        LDRB     R0,[R0, #+0]
        LDR.W    R2,??DataTable59_3
        LDRB     R2,[R2, #+0]
        SUBS     R0,R0,R2
        SUBS     R0,R0,#+4
        LDR.W    R2,??DataTable59_5
        LDRB     R2,[R2, #+0]
        SUBS     R0,R0,R2
        BL       MinRe
        B.N      ??AngleStep1Judge_42
// 11380           }
// 11381           //0表示不去掉长线的线头。
// 11382           else
// 11383           {
// 11384             if(BlackRightEndLine - BlackRightHeadLine - 4 < 0 || BlackRight5SlopeIndex - 1 < 0)
??AngleStep1Judge_39:
        LDR.W    R0,??DataTable60_4
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable59_3
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+4
        CMP      R0,#+0
        BMI.N    ??AngleStep1Judge_43
        LDR.W    R0,??DataTable60_5
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        CMP      R0,#+0
        BPL.N    ??AngleStep1Judge_44
// 11385             {
// 11386               return 0;
??AngleStep1Judge_43:
        MOVS     R0,#+0
        B.N      ??AngleStep1Judge_2
// 11387             }
// 11388             else
// 11389             {
// 11390             }
// 11391             tempr = MinRe(BlackRightEndLine - BlackRightHeadLine - 4, BlackRight5SlopeIndex - 1);
??AngleStep1Judge_44:
        LDR.W    R0,??DataTable60_5
        LDRB     R0,[R0, #+0]
        SUBS     R1,R0,#+1
        LDR.W    R0,??DataTable60_4
        LDRB     R0,[R0, #+0]
        LDR.W    R2,??DataTable59_3
        LDRB     R2,[R2, #+0]
        SUBS     R0,R0,R2
        SUBS     R0,R0,#+4
        BL       MinRe
// 11392             
// 11393           }
// 11394           //错误计数清零
// 11395           errorcount = 0;
??AngleStep1Judge_42:
        MOVS     R2,#+0
// 11396           //逐个判断小5点斜率是否满足条件
// 11397           for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??AngleStep1Judge_45
??AngleStep1Judge_46:
        ADDS     R1,R1,#+1
// 11398           {
// 11399             if(BlackRight5Slope[i] < 0 || BlackRight5Slope[i] > PathJudgeStraightSlopeLimit) //左上到右下的斜率是正的。
??AngleStep1Judge_45:
        LDR.W    R3,??DataTable60_6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R3,[R3, R1, LSL #+2]
        SUBS     R3,R3,#+0
        MOVW     R4,#+2101
        CMP      R3,R4
        BCC.N    ??AngleStep1Judge_47
// 11400             {
// 11401               errorcount++;
        ADDS     R2,R2,#+1
// 11402               if(errorcount > 3) break;   //允许有若干个点斜率超出范围
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+4
        BGE.N    ??AngleStep1Judge_48
// 11403             }
// 11404       
// 11405             if(i == tempr) break;
??AngleStep1Judge_47:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BNE.N    ??AngleStep1Judge_46
// 11406           }
// 11407           //不满足条件，返回失败。
// 11408           if(i != tempr) return 0;
??AngleStep1Judge_48:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BEQ.N    ??AngleStep1Judge_49
        MOVS     R0,#+0
        B.N      ??AngleStep1Judge_2
// 11409           
// 11410           //若左右两线都满足要求，会继续往下走。        
// 11411 
// 11412           //5. 对左线头往上一些点进行白区域检测。
// 11413           //5.1. 一竖
// 11414           col = BlackLeftLoc[BlackLeftHeadLine][0];   //这里采用原始的黑点，不能采用矫正后的。
??AngleStep1Judge_49:
        LDR.N    R0,??DataTable58_6
        LDR.W    R1,??DataTable59_4
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
// 11415           for(i = BlackLeftHeadLine-3; i > (BlackLeftHeadLine-AngleHeadLineNum); i--)
        LDR.W    R1,??DataTable59_4
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+3
        B.N      ??AngleStep1Judge_50
// 11416           {
// 11417             //与右线白点阈值进行比较，必须大于白点阈值。
// 11418             if(ImgNew[i][col] < LimitLeftW - AngleWhiteAreaLimitVal)
// 11419             {
// 11420               flag222 = 10;
// 11421               //只要有一个点不满足，即判定不是直角弯。
// 11422               break;
// 11423             }
// 11424             else
// 11425             {
// 11426               flag222 = 0;
??AngleStep1Judge_51:
        MOVS     R2,#+0
        LDR.W    R3,??DataTable60_7
        STR      R2,[R3, #+0]
// 11427             }
        SUBS     R1,R1,#+1
??AngleStep1Judge_50:
        LDR.W    R2,??DataTable59_4
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable59_5
        LDRB     R3,[R3, #+0]
        SUBS     R2,R2,R3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R2,R1
        BGE.N    ??AngleStep1Judge_52
        LDR.N    R2,??DataTable58_10
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+250
        MLA      R2,R3,R1,R2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDRB     R2,[R0, R2]
        LDR.W    R3,??DataTable61_1
        LDRB     R3,[R3, #+0]
        SUBS     R3,R3,#+20
        CMP      R2,R3
        BGE.N    ??AngleStep1Judge_51
        MOVS     R2,#+10
        LDR.W    R3,??DataTable60_7
        STR      R2,[R3, #+0]
// 11428           }
// 11429           //从下到上一直满足白点，且最上与最下两个点像素差值够小。
// 11430           if(
// 11431             (i <= BlackLeftHeadLine-AngleHeadLineNum)
// 11432           &&(AbsInt(ImgNew[BlackLeftHeadLine-3][col] - ImgNew[BlackLeftHeadLine-AngleHeadLineNum][col]) < 2 * AngleWhiteAreaLimitVal) //隔的点比较多，允许差值稍微大一些。
// 11433             )
??AngleStep1Judge_52:
        LDR.W    R2,??DataTable59_4
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable59_5
        LDRB     R3,[R3, #+0]
        SUBS     R2,R2,R3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R2,R1
        BLT.W    ??AngleStep1Judge_4
        LDR.N    R1,??DataTable58_10
        LDR.W    R2,??DataTable59_4
        LDRB     R2,[R2, #+0]
        MOVS     R3,#+250
        MLA      R1,R3,R2,R1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R1,R0,R1
        SUBW     R1,R1,#+750
        LDRB     R1,[R1, #+0]
        LDR.N    R2,??DataTable58_10
        LDR.W    R3,??DataTable59_4
        LDRB     R3,[R3, #+0]
        LDR.W    R4,??DataTable59_5
        LDRB     R4,[R4, #+0]
        SUBS     R3,R3,R4
        MOVS     R4,#+250
        MLA      R2,R4,R3,R2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDRB     R0,[R0, R2]
        SUBS     R0,R1,R0
        BL       AbsInt
        CMP      R0,#+40
        BGE.W    ??AngleStep1Judge_4
// 11434           {
// 11435             //5.2. 一横
// 11436             check_row = BlackLeftHeadLine - AngleHeadLineNum / 2;
        LDR.W    R0,??DataTable59_4
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable59_5
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+2
        SDIV     R1,R1,R2
        SUBS     R4,R0,R1
// 11437             //一横的左边界
// 11438             //不能小于图像左边界
// 11439             leftborder = MaxRe(0, BlackLeftLoc[BlackLeftHeadLine][0] - 15);
        LDR.N    R0,??DataTable58_6
        LDR.W    R1,??DataTable59_4
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        SUBS     R1,R0,#+15
        MOVS     R0,#+0
        BL       MaxRe
        MOVS     R5,R0
// 11440             leftbordercal = MaxRe(0, BlackLeftLoc[BlackLeftHeadLine][0] - 15);
        LDR.N    R0,??DataTable58_6
        LDR.W    R1,??DataTable59_4
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        SUBS     R1,R0,#+15
        MOVS     R0,#+0
        BL       MaxRe
        MOVS     R6,R0
// 11441             //一横的右边界。
// 11442             rightborder = MinRe(CameraRealWidth - 1, BlackLeftLoc[BlackLeftHeadLine][0] + 15);
        LDR.N    R0,??DataTable58_6
        LDR.W    R1,??DataTable59_4
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        ADDS     R1,R0,#+15
        MOVS     R0,#+249
        BL       MinRe
        MOVS     R7,R0
// 11443             rightbordercal = MinRe(CameraRealWidth - 1, BlackLeftLoc[BlackLeftHeadLine][0] + 15);
        LDR.N    R0,??DataTable58_6
        LDR.W    R1,??DataTable59_4
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        ADDS     R1,R0,#+15
        MOVS     R0,#+249
        BL       MinRe
        MOV      R8,R0
// 11444             //不能比该行有效右黑线还大
// 11445             if(BlackRightLoc[check_row][0] != MaxValUint8)
        LDR.N    R0,??DataTable58_8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+3
        MLA      R0,R1,R4,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??AngleStep1Judge_53
// 11446             {
// 11447               rightborder = MinRe(BlackRightLoc[check_row][0], rightborder);
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R1,R7
        LDR.N    R0,??DataTable58_8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R0,R2,R4,R0
        LDRB     R0,[R0, #+0]
        BL       MinRe
        MOVS     R7,R0
// 11448               rightbordercal = MinRe(BlackRightLoc[check_row][0], rightbordercal);
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        MOV      R1,R8
        LDR.N    R0,??DataTable58_8
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R0,R2,R4,R0
        LDRB     R0,[R0, #+0]
        BL       MinRe
        MOV      R8,R0
// 11449             }
// 11450             else
// 11451             {
// 11452             }
// 11453             //从左到右进行白点检查
// 11454             for(j = leftborder; j < rightborder; j++)
??AngleStep1Judge_53:
        B.N      ??AngleStep1Judge_54
??AngleStep1Judge_55:
        ADDS     R5,R5,#+1
??AngleStep1Judge_54:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R5,R7
        BCS.N    ??AngleStep1Judge_56
// 11455             {
// 11456               if(ImgNew[check_row][j] < LimitLeftW - AngleWhiteAreaLimitVal) break;              
        LDR.N    R0,??DataTable58_10
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LDRB     R0,[R5, R0]
        LDR.W    R1,??DataTable61_1
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+20
        CMP      R0,R1
        BGE.N    ??AngleStep1Judge_55
// 11457             }
// 11458             //从左到右一直满足白点，且最左最右两点差值够小，进入第6步。
// 11459             if(
// 11460               (j >= rightborder) 
// 11461             &&(AbsInt(ImgNew[check_row][leftbordercal] - ImgNew[check_row][rightbordercal]) < 2 * AngleWhiteAreaLimitVal)
// 11462               )
??AngleStep1Judge_56:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R5,R7
        BCC.N    ??AngleStep1Judge_4
        LDR.N    R0,??DataTable58_10
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,#+250
        MLA      R0,R1,R4,R0
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        LDRB     R0,[R6, R0]
        LDR.N    R1,??DataTable58_10
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R4,R1
        UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
        LDRB     R1,[R8, R1]
        SUBS     R0,R0,R1
        BL       AbsInt
        CMP      R0,#+40
        BGE.N    ??AngleStep1Judge_4
// 11463             {
// 11464               //6. 非左障碍确认成功，则最终确认是左直角。
// 11465               if(AngleStep1JudgeNotBrick(0) == 1)
        MOVS     R0,#+0
        BL       AngleStep1JudgeNotBrick
        CMP      R0,#+1
        BNE.N    ??AngleStep1Judge_4
// 11466               {
// 11467                 PathType = PathTypeAngleL;
        MOVS     R0,#+4
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
// 11468               }
// 11469               else
// 11470               {
// 11471               }
// 11472             }
// 11473             else
// 11474             {
// 11475             }            
// 11476           }
// 11477           else
// 11478           {
// 11479           }
// 11480       }
// 11481       //否则仍为直道
// 11482       else
// 11483       {
// 11484       }
// 11485   }
// 11486   //否则保持直道不变。
// 11487   else
// 11488   {
// 11489   }
// 11490   return 1;
??AngleStep1Judge_4:
        MOVS     R0,#+1
??AngleStep1Judge_2:
        POP      {R4-R8,PC}       ;; return
// 11491   
// 11492 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable58:
        DC32     CURVER

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable58_1:
        DC32     SlopeR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable58_2:
        DC32     BlackUdisRightLocation

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable58_3:
        DC32     CurveSlopeFlagC

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable58_4:
        DC32     CurveSlopeFlagL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable58_5:
        DC32     CurveSlopeFlagR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable58_6:
        DC32     BlackLeftLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable58_7:
        DC32     AngleStep1NotBrickEndColL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable58_8:
        DC32     BlackRightLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable58_9:
        DC32     AngleStep1NotBrickBorderColL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable58_10:
        DC32     ImgNew

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable58_11:
        DC32     LimitLeftB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable58_12:
        DC32     AngleStep1NotBrickEndColR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable58_13:
        DC32     AngleStep1NotBrickBorderColR
// 11493 
// 11494 
// 11495 
// 11496 
// 11497 //======================================================================
// 11498 //函数名：PathLCRAngle1Judge
// 11499 //功  能：直道、左弯、右弯判断，直角弯第1阶段预判。
// 11500 //参  数：
// 11501 //返  回：1成功，0失败。
// 11502 //影  响：
// 11503 //说  明：1. 只有在斜曲率求取失败时才会返回0，否则只会返回1. 
// 11504 //        2. 在左右黑线都求取成功的时候，会进行直角弯第1阶段预判。
// 11505 //             
// 11506 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 11507 uint8 PathLCRAngle1Judge(void)
// 11508 {
PathLCRAngle1Judge:
        PUSH     {R3-R7,LR}
// 11509   
// 11510   //ErrorGet();
// 11511   int32 AbsSlopeC;
// 11512   uint8 curvetempLL, curvetempLR, curvetempRL, curvetempRR;
// 11513   uint8 slopetempLL, slopetempLR, slopetempRL, slopetempRR;
// 11514   
// 11515   //以下是一套以斜率为主导的赛道类型判断方法
// 11516 
// 11517   //赛道类型PathType: 0未知 1直道 2左内 3左中 4左外 5右内 6右中 7右外
// 11518   PathType = PathTypeUnknown;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
// 11519   //曲率符号获取成功
// 11520   //如果CurveSlopeGet()返回0，则代表3条线的曲率、斜率均求取失败，不用进行下面的判断。
// 11521   if(CurveSlopeGet() == 1)
        BL       CurveSlopeGet
        CMP      R0,#+1
        BNE.W    ??PathLCRAngle1Judge_0
// 11522   {
// 11523     //先将绝对值求出来，后面就不用反复使用了。
// 11524     AbsSlopeC = AbsInt(SlopeC);
        LDR.W    R0,??DataTable61_2
        LDR      R0,[R0, #+0]
        BL       AbsInt
// 11525     //AbsSlopeL = AbsSelfFloat(SlopeL);
// 11526     //AbsSlopeR = AbsSelfFloat(SlopeR);
// 11527     //不用判断中心线成功，到这里了肯定是成功的。
// 11528     //此时中心线的曲率、斜率一定存在，左线或者右线不一定。
// 11529     //下面用来“或”的时候用,对于曲率来说，左负右正。对于斜率来说，左正右负。
// 11530     curvetempRL = (CurveSlopeFlagL == 1 && (CURVEL > CurveStraightLimitL));        //如果该线曲率无效，就为0，如果有效，就有可能为1.用以判断左线曲率是否朝右。
        LDR.W    R1,??DataTable61_3
        LDRB     R1,[R1, #+0]
        CMP      R1,#+1
        BNE.N    ??PathLCRAngle1Judge_1
        LDR.W    R1,??DataTable59_8
        LDRSH    R1,[R1, #+0]
        CMP      R1,#+31
        BLT.N    ??PathLCRAngle1Judge_1
        MOVS     R1,#+1
        B.N      ??PathLCRAngle1Judge_2
??PathLCRAngle1Judge_1:
        MOVS     R1,#+0
// 11531     curvetempRR = (CurveSlopeFlagR == 1 && (CURVER > CurveStraightLimitR));        //如果该线曲率无效，就为0，如果有效，就有可能为1.用以判断右线曲率是否朝右。
??PathLCRAngle1Judge_2:
        LDR.W    R2,??DataTable61_4
        LDRB     R2,[R2, #+0]
        CMP      R2,#+1
        BNE.N    ??PathLCRAngle1Judge_3
        LDR.W    R2,??DataTable61_5
        LDRSH    R2,[R2, #+0]
        CMP      R2,#+31
        BLT.N    ??PathLCRAngle1Judge_3
        MOVS     R2,#+1
        B.N      ??PathLCRAngle1Judge_4
??PathLCRAngle1Judge_3:
        MOVS     R2,#+0
// 11532     curvetempLL = (CurveSlopeFlagL == 1 && (CURVEL + CurveStraightLimitL < 0));    //如果该线曲率无效，就为0，如果有效，就有可能为1.用以判断左线曲率是否朝左。          
??PathLCRAngle1Judge_4:
        LDR.W    R3,??DataTable61_3
        LDRB     R3,[R3, #+0]
        CMP      R3,#+1
        BNE.N    ??PathLCRAngle1Judge_5
        LDR.W    R3,??DataTable59_8
        LDRSH    R3,[R3, #+0]
        ADDS     R3,R3,#+30
        CMP      R3,#+0
        BPL.N    ??PathLCRAngle1Judge_5
        MOVS     R3,#+1
        B.N      ??PathLCRAngle1Judge_6
??PathLCRAngle1Judge_5:
        MOVS     R3,#+0
// 11533     curvetempLR = (CurveSlopeFlagR == 1 && (CURVER + CurveStraightLimitR < 0));    //如果该线曲率无效，就为0，如果有效，就有可能为1.用以判断右线曲率是否朝左。  
??PathLCRAngle1Judge_6:
        LDR.W    R4,??DataTable61_4
        LDRB     R4,[R4, #+0]
        CMP      R4,#+1
        BNE.N    ??PathLCRAngle1Judge_7
        LDR.W    R4,??DataTable61_5
        LDRSH    R4,[R4, #+0]
        ADDS     R4,R4,#+30
        CMP      R4,#+0
        BPL.N    ??PathLCRAngle1Judge_7
        MOVS     R4,#+1
        B.N      ??PathLCRAngle1Judge_8
??PathLCRAngle1Judge_7:
        MOVS     R4,#+0
// 11534     slopetempRL = (CurveSlopeFlagL == 1 && (SlopeL + SlopeLimitL < 0));            //如果该线斜率无效，就为0，如果有效，就有可能为1.用以判断左线斜率是否朝右。
??PathLCRAngle1Judge_8:
        LDR.W    R5,??DataTable61_3
        LDRB     R5,[R5, #+0]
        CMP      R5,#+1
        BNE.N    ??PathLCRAngle1Judge_9
        LDR.W    R5,??DataTable61_6
        LDR      R5,[R5, #+0]
        ADDW     R5,R5,#+1500
        CMP      R5,#+0
        BPL.N    ??PathLCRAngle1Judge_9
        MOVS     R5,#+1
        B.N      ??PathLCRAngle1Judge_10
??PathLCRAngle1Judge_9:
        MOVS     R5,#+0
// 11535     slopetempRR = (CurveSlopeFlagR == 1 && (SlopeR + SlopeLimitR < 0));            //如果该线斜率无效，就为0，如果有效，就有可能为1.用以判断右线斜率是否朝右。
??PathLCRAngle1Judge_10:
        LDR.W    R6,??DataTable61_4
        LDRB     R6,[R6, #+0]
        CMP      R6,#+1
        BNE.N    ??PathLCRAngle1Judge_11
        LDR.W    R6,??DataTable61_7
        LDR      R6,[R6, #+0]
        ADDW     R6,R6,#+1500
        CMP      R6,#+0
        BPL.N    ??PathLCRAngle1Judge_11
        MOVS     R6,#+1
        B.N      ??PathLCRAngle1Judge_12
??PathLCRAngle1Judge_11:
        MOVS     R6,#+0
// 11536     slopetempLL = (CurveSlopeFlagL == 1 && (SlopeL > SlopeLimitL));                //如果该线斜率无效，就为0，如果有效，就有可能为1.用以判断左线斜率是否朝左。
??PathLCRAngle1Judge_12:
        LDR.W    R7,??DataTable61_3
        LDRB     R7,[R7, #+0]
        CMP      R7,#+1
        BNE.N    ??PathLCRAngle1Judge_13
        LDR.W    R7,??DataTable61_6
        LDR      R7,[R7, #+0]
        MOVW     R12,#+1501
        CMP      R7,R12
        BLT.N    ??PathLCRAngle1Judge_13
        MOVS     R7,#+1
        B.N      ??PathLCRAngle1Judge_14
??PathLCRAngle1Judge_13:
        MOVS     R7,#+0
// 11537     slopetempLR = (CurveSlopeFlagR == 1 && (SlopeR > SlopeLimitR));                //如果该线斜率无效，就为0，如果有效，就有可能为1.用以判断右线斜率是否朝左。
??PathLCRAngle1Judge_14:
        LDR.W    R12,??DataTable61_4
        LDRB     R12,[R12, #+0]
        CMP      R12,#+1
        BNE.N    ??PathLCRAngle1Judge_15
        LDR.W    R12,??DataTable61_7
        LDR      R12,[R12, #+0]
        MOVW     LR,#+1501
        CMP      R12,LR
        BLT.N    ??PathLCRAngle1Judge_15
        MOVS     R12,#+1
        B.N      ??PathLCRAngle1Judge_16
??PathLCRAngle1Judge_15:
        MOVS     R12,#+0
// 11538     //下面用来“与”的时候用
// 11539     /*
// 11540     tempRL = ((CurveSlopeFlagL && (CURVEL > CurveStraightLimitL)) //如果该线曲率有效，则该逻辑就有可能是0。
// 11541           ||(!CurveSlopeFlagL)                                   //如果该线曲率无效，则该逻辑就一定是1.
// 11542             );
// 11543     tempRR = ((CurveSlopeFlagR && (CURVER > CurveStraightLimitR)) //如果该线曲率有效，则该逻辑就有可能是0。
// 11544           ||(!CurveSlopeFlagR)                                   //如果该线曲率无效，则该逻辑就一定是1.
// 11545             );
// 11546     tempLL = ((CurveSlopeFlagL && (CURVEL + CurveStraightLimitL < 0)) //如果该线曲率有效，则该逻辑就有可能是0。
// 11547           ||(!CurveSlopeFlagL)                                   //如果该线曲率无效，则该逻辑就一定是1.
// 11548             );
// 11549     tempLR = ((CurveSlopeFlagR && (CURVER + CurveStraightLimitR < 0)) //如果该线曲率有效，则该逻辑就有可能是0。
// 11550           ||(!CurveSlopeFlagR)                                   //如果该线曲率无效，则该逻辑就一定是1.
// 11551             );
// 11552     */
// 11553       //1. 左右黑线均提取成功的情况。
// 11554       if(BlackLeftDone == 1 && BlackRightDone == 1)
??PathLCRAngle1Judge_16:
        LDR.W    LR,??DataTable59_1
        LDRB     LR,[LR, #+0]
        CMP      LR,#+1
        BNE.W    ??PathLCRAngle1Judge_17
        LDR.W    LR,??DataTable59_2
        LDRB     LR,[LR, #+0]
        CMP      LR,#+1
        BNE.N    ??PathLCRAngle1Judge_17
// 11555       {
// 11556       //1.1. 中心线斜率足够正。这一步避免了270度弯曲率小斜率大的判断失误问题。
// 11557       if(AbsSlopeC <= SlopeLimitC)
        MOVW     LR,#+1501
        CMP      R0,LR
        BGE.N    ??PathLCRAngle1Judge_18
// 11558       {
// 11559         //1.1.1. 左、右线曲率里只要有一条比较大，且向右，那么判断为右弯。        
// 11560         if(
// 11561            //(CURVEC > CurveStraightLimitC)
// 11562             (curvetempRL)
// 11563          || (curvetempRR)
// 11564            )
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??PathLCRAngle1Judge_19
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BEQ.N    ??PathLCRAngle1Judge_20
// 11565         {//1.1.1.1. 左右黑线斜率里只要有一条比较大，且向右，那么判断为右弯。
// 11566           if((slopetempRL)
// 11567           || (slopetempRR)
// 11568               )
??PathLCRAngle1Judge_19:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??PathLCRAngle1Judge_21
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BEQ.N    ??PathLCRAngle1Judge_22
// 11569           {
// 11570             PathType = PathTypeRight;
??PathLCRAngle1Judge_21:
        MOVS     R0,#+3
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_23
// 11571           }
// 11572           //1.1.1.2. 左右黑线斜率都不大，就算曲率比较大，也判断为直道。
// 11573           else
// 11574           {
// 11575               PathType = PathTypeStraight;
??PathLCRAngle1Judge_22:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_23
// 11576           }
// 11577           
// 11578         }
// 11579         //1.1.2. 左、右线曲率里只要有一条比较大，且向左，那么判断为左弯。
// 11580         else if(
// 11581                //(CURVEC + CurveStraightLimitC < 0)
// 11582                  (curvetempLL)
// 11583               || (curvetempLR)
// 11584                 )
??PathLCRAngle1Judge_20:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BNE.N    ??PathLCRAngle1Judge_24
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BEQ.N    ??PathLCRAngle1Judge_25
// 11585         {   //1.1.2.1. 左右黑线斜率里只要有一条比较大，且向左，那么判断为左弯。
// 11586             if((slopetempLL)
// 11587             || (slopetempLR)
// 11588               )
??PathLCRAngle1Judge_24:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BNE.N    ??PathLCRAngle1Judge_26
        UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
        CMP      R12,#+0
        BEQ.N    ??PathLCRAngle1Judge_27
// 11589             {
// 11590                 PathType = PathTypeLeft;
??PathLCRAngle1Judge_26:
        MOVS     R0,#+2
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_23
// 11591             }
// 11592             //1.1.2.2. 左右黑线斜率都不大，就算斜率比较大，也判断为直道。
// 11593             else
// 11594             {
// 11595                 PathType = PathTypeStraight;
??PathLCRAngle1Judge_27:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_23
// 11596             }         
// 11597         }
// 11598         //1.1.3. 左、右线曲率都不大，那么就判断为直道。
// 11599         else
// 11600         {
// 11601           PathType = PathTypeStraight;
??PathLCRAngle1Judge_25:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_23
// 11602          
// 11603         }
// 11604       }
// 11605       //1.2. 斜率向左偏，最有可能是左道。对于斜率来说，向左是正，向右是负。
// 11606       else if(SlopeC > SlopeLimitC)
??PathLCRAngle1Judge_18:
        LDR.W    R0,??DataTable61_2
        LDR      R0,[R0, #+0]
        MOVW     LR,#+1501
        CMP      R0,LR
        BLT.N    ??PathLCRAngle1Judge_28
// 11607       { //1.2.1. 三线只要有一个曲率比较大，且向左，就判断为左道。
// 11608         //左右黑线斜率里只要有一条比较大，且向左，那么判断为左弯。
// 11609         if(
// 11610            //(CURVEC + CurveStraightLimitC < 0)
// 11611            (curvetempLL)
// 11612         || (curvetempLR)
// 11613         || (slopetempLL)
// 11614         || (slopetempLR)
// 11615           )
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BNE.N    ??PathLCRAngle1Judge_29
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BNE.N    ??PathLCRAngle1Judge_29
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BNE.N    ??PathLCRAngle1Judge_29
        UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
        CMP      R12,#+0
        BEQ.N    ??PathLCRAngle1Judge_30
// 11616         {
// 11617           PathType = PathTypeLeft;
??PathLCRAngle1Judge_29:
        MOVS     R0,#+2
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_23
// 11618         }
// 11619         //1.2.2. 否则就是直道。
// 11620         else
// 11621         {
// 11622           PathType = PathTypeStraight;
??PathLCRAngle1Judge_30:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_23
// 11623         }
// 11624       }
// 11625       //1.3. 斜率向右偏，最有可能是右道。
// 11626       else if(SlopeC + SlopeLimitC < 0)
??PathLCRAngle1Judge_28:
        LDR.W    R0,??DataTable61_2
        LDR      R0,[R0, #+0]
        ADDW     R0,R0,#+1500
        CMP      R0,#+0
        BPL.N    ??PathLCRAngle1Judge_23
// 11627       {
// 11628         //1.3.1. 三线只要有一个曲率比较大，且向右，就判断为右道。
// 11629         //左右黑线斜率里只要有一条比较大，且向右，那么判断为右弯。
// 11630         if(
// 11631            //(CURVEC > CurveStraightLimitC)
// 11632             (curvetempRL)
// 11633          || (curvetempRR)
// 11634          || (slopetempRL)
// 11635          || (slopetempRR)
// 11636            )
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??PathLCRAngle1Judge_31
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BNE.N    ??PathLCRAngle1Judge_31
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BNE.N    ??PathLCRAngle1Judge_31
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BEQ.N    ??PathLCRAngle1Judge_32
// 11637         {
// 11638           PathType = PathTypeRight;
??PathLCRAngle1Judge_31:
        MOVS     R0,#+3
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_23
// 11639         }
// 11640         //1.3.2. 否则就是直道。
// 11641         else
// 11642         {
// 11643           PathType = PathTypeStraight;
??PathLCRAngle1Judge_32:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
// 11644         }        
// 11645       }
// 11646       //1.4. 理论上不会走到这里。
// 11647       else
// 11648       {
// 11649       }
// 11650       
// 11651       //若判断为直道，则启动直角弯单独检测。
// 11652       if(PathType == PathTypeStraight)
??PathLCRAngle1Judge_23:
        LDR.W    R0,??DataTable61
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??PathLCRAngle1Judge_33
// 11653       {
// 11654         AngleStep1Judge();
        BL       AngleStep1Judge
        B.N      ??PathLCRAngle1Judge_33
// 11655       }
// 11656       else
// 11657       {
// 11658       }   
// 11659       
// 11660     }
// 11661     //2. 左线提取成功，右线提取失败
// 11662     else if(BlackLeftDone == 1 && BlackRightDone == 0)
??PathLCRAngle1Judge_17:
        LDR.W    LR,??DataTable59_1
        LDRB     LR,[LR, #+0]
        CMP      LR,#+1
        BNE.N    ??PathLCRAngle1Judge_34
        LDR.W    LR,??DataTable59_2
        LDRB     LR,[LR, #+0]
        CMP      LR,#+0
        BNE.N    ??PathLCRAngle1Judge_34
// 11663     {
// 11664       
// 11665       //2.1. 中心线斜率足够正。
// 11666       if(AbsSlopeC <= SlopeLimitC)
        MOVW     R2,#+1501
        CMP      R0,R2
        BGE.N    ??PathLCRAngle1Judge_35
// 11667       {
// 11668         //2.1.1. 中左线曲率里只要有一条比较大，且向右，那么判断为右弯。        
// 11669         if((CURVEC > CurveStraightLimitC)
// 11670          || (curvetempRL)
// 11671            )
        LDR.W    R0,??DataTable64
        LDRSH    R0,[R0, #+0]
        CMP      R0,#+31
        BGE.N    ??PathLCRAngle1Judge_36
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BEQ.N    ??PathLCRAngle1Judge_37
// 11672         {   //2.1.1.1. 若左线斜率较大，且向右，那么判断为右弯。
// 11673             if (slopetempRL)
??PathLCRAngle1Judge_36:
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BEQ.N    ??PathLCRAngle1Judge_38
// 11674             {
// 11675                 PathType = PathTypeRight;
        MOVS     R0,#+3
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_33
// 11676             }
// 11677             //2.1.1.2. 若左线斜率不大，就算曲率较大，也判断为直道。
// 11678             else
// 11679             {
// 11680                 PathType = PathTypeStraight;
??PathLCRAngle1Judge_38:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_33
// 11681             }
// 11682           
// 11683         }
// 11684         //2.1.2. 中左线曲率里只要有一条比较大，且向左，那么判断为左弯。
// 11685         else if((CURVEC + CurveStraightLimitC < 0)
// 11686               || (curvetempLL)
// 11687                 )
??PathLCRAngle1Judge_37:
        LDR.W    R0,??DataTable64
        LDRSH    R0,[R0, #+0]
        ADDS     R0,R0,#+30
        CMP      R0,#+0
        BMI.N    ??PathLCRAngle1Judge_39
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BEQ.N    ??PathLCRAngle1Judge_40
// 11688         {   //2.1.2.1. 若左线斜率较大，且向左，那么有判断为左弯。
// 11689             if (slopetempLL)
??PathLCRAngle1Judge_39:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BEQ.N    ??PathLCRAngle1Judge_41
// 11690             {
// 11691                 PathType = PathTypeLeft;
        MOVS     R0,#+2
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_33
// 11692             }
// 11693             //2.1.2.2. 若在线斜率不大，就算曲率较大，也判断为直道。
// 11694             else
// 11695             {
// 11696                 PathType = PathTypeStraight;
??PathLCRAngle1Judge_41:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_33
// 11697             }          
// 11698         }
// 11699         //2.1.3. 曲率都不大，最大值比较小。那么就判断为直道。
// 11700         else
// 11701         {
// 11702           PathType = PathTypeStraight;
??PathLCRAngle1Judge_40:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_33
// 11703         }
// 11704       }
// 11705       //2.2. 斜率向左偏，最有可能是左道。对于斜率来说，向左是正，向右是负。
// 11706       else if(SlopeC > SlopeLimitC)
??PathLCRAngle1Judge_35:
        LDR.W    R0,??DataTable61_2
        LDR      R0,[R0, #+0]
        MOVW     R2,#+1501
        CMP      R0,R2
        BLT.N    ??PathLCRAngle1Judge_42
// 11707       { //2.2.1. 中左线只要有一个曲率比较大，且向左，就判断为左道。
// 11708         //若左线斜率较大，且向左，就判断为左道。
// 11709         if((CURVEC + CurveStraightLimitC < 0)
// 11710         || (curvetempLL)
// 11711         || (slopetempLL)
// 11712           )
        LDR.W    R0,??DataTable64
        LDRSH    R0,[R0, #+0]
        ADDS     R0,R0,#+30
        CMP      R0,#+0
        BMI.N    ??PathLCRAngle1Judge_43
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BNE.N    ??PathLCRAngle1Judge_43
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+0
        BEQ.N    ??PathLCRAngle1Judge_44
// 11713         {
// 11714           PathType = PathTypeLeft;
??PathLCRAngle1Judge_43:
        MOVS     R0,#+2
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_33
// 11715         }
// 11716         //2.2.2. 否则就是直道。
// 11717         else
// 11718         {
// 11719           PathType = PathTypeStraight;
??PathLCRAngle1Judge_44:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_33
// 11720         }
// 11721       }
// 11722       //2.3. 斜率向右偏，最有可能是右道。
// 11723       else if(SlopeC + SlopeLimitC < 0)
??PathLCRAngle1Judge_42:
        LDR.W    R0,??DataTable61_2
        LDR      R0,[R0, #+0]
        ADDW     R0,R0,#+1500
        CMP      R0,#+0
        BPL.W    ??PathLCRAngle1Judge_33
// 11724       {
// 11725         //2.3.1. 中左线只要有一个曲率比较大，且向右，就判断为右道。
// 11726         //若左线斜率较大，且向右，就判断为右道。
// 11727         if((CURVEC > CurveStraightLimitC)
// 11728          || (curvetempRL)
// 11729          || (slopetempRL)
// 11730            )
        LDR.W    R0,??DataTable64
        LDRSH    R0,[R0, #+0]
        CMP      R0,#+31
        BGE.N    ??PathLCRAngle1Judge_45
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??PathLCRAngle1Judge_45
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        CMP      R5,#+0
        BEQ.N    ??PathLCRAngle1Judge_46
// 11731         {
// 11732           PathType = PathTypeRight;
??PathLCRAngle1Judge_45:
        MOVS     R0,#+3
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_33
// 11733         }
// 11734         //2.3.2. 否则就是直道。
// 11735         else
// 11736         {
// 11737           PathType = PathTypeStraight;
??PathLCRAngle1Judge_46:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_33
// 11738         }        
// 11739       }
// 11740       //2.4. 理论上不会走到这里。
// 11741       else
// 11742       {
// 11743       } 
// 11744     }
// 11745     //3. 左线提取失败，右线提取成功
// 11746     else if(BlackLeftDone == 0 && BlackRightDone == 1)
??PathLCRAngle1Judge_34:
        LDR.N    R1,??DataTable59_1
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BNE.N    ??PathLCRAngle1Judge_33
        LDR.N    R1,??DataTable59_2
        LDRB     R1,[R1, #+0]
        CMP      R1,#+1
        BNE.N    ??PathLCRAngle1Judge_33
// 11747     {             
// 11748       //3.1. 中心线斜率足够正。
// 11749       if(AbsSlopeC <= SlopeLimitC)
        MOVW     R1,#+1501
        CMP      R0,R1
        BGE.N    ??PathLCRAngle1Judge_47
// 11750       { 
// 11751         //3.1.1. 中右线曲率里只要有一条比较大，且向右，那就判断为右弯。        
// 11752         if((CURVEC > CurveStraightLimitC)
// 11753          || (curvetempRR)
// 11754            )
        LDR.W    R0,??DataTable64
        LDRSH    R0,[R0, #+0]
        CMP      R0,#+31
        BGE.N    ??PathLCRAngle1Judge_48
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BEQ.N    ??PathLCRAngle1Judge_49
// 11755         {   //3.1.1.1. 如果右线斜率较大，且向右，那就判断为右弯。
// 11756             if (slopetempRR)
??PathLCRAngle1Judge_48:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BEQ.N    ??PathLCRAngle1Judge_50
// 11757             {
// 11758                 PathType = PathTypeRight;
        MOVS     R0,#+3
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_33
// 11759             }
// 11760             //3.1.1.2. 如果右线斜率不大，就算曲率较大，仍判断为直道。
// 11761             else
// 11762             {
// 11763                 PathType = PathTypeStraight;
??PathLCRAngle1Judge_50:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_33
// 11764             }
// 11765           
// 11766         }
// 11767         //3.1.2. 中右线曲率里只要有一条比较大，且向左，那么有可能是左弯。
// 11768         else if((CURVEC + CurveStraightLimitC < 0)
// 11769               || (curvetempLR)
// 11770                 )
??PathLCRAngle1Judge_49:
        LDR.W    R0,??DataTable64
        LDRSH    R0,[R0, #+0]
        ADDS     R0,R0,#+30
        CMP      R0,#+0
        BMI.N    ??PathLCRAngle1Judge_51
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BEQ.N    ??PathLCRAngle1Judge_52
// 11771         {   //3.1.2.1. 如果右线斜率较大，且向左，那就判断为左弯。
// 11772             if (slopetempLR)
??PathLCRAngle1Judge_51:
        UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
        CMP      R12,#+0
        BEQ.N    ??PathLCRAngle1Judge_53
// 11773             {
// 11774                 PathType = PathTypeLeft;
        MOVS     R0,#+2
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_33
// 11775             }
// 11776             //3.1.2.2. 如果右线斜率不大，就算曲率较大，也判断为直道。
// 11777             else
// 11778             {
// 11779                 PathType = PathTypeStraight;
??PathLCRAngle1Judge_53:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_33
// 11780             }          
// 11781         }
// 11782         //3.1.3. 曲率都不大，最大值比较小。那么就判断为直道。
// 11783         else
// 11784         {
// 11785           PathType = PathTypeStraight;
??PathLCRAngle1Judge_52:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_33
// 11786         }
// 11787       }
// 11788       //3.2. 斜率向左偏，最有可能是左道。对于斜率来说，向左是正，向右是负。
// 11789       else if(SlopeC > SlopeLimitC)
??PathLCRAngle1Judge_47:
        LDR.W    R0,??DataTable61_2
        LDR      R0,[R0, #+0]
        MOVW     R1,#+1501
        CMP      R0,R1
        BLT.N    ??PathLCRAngle1Judge_54
// 11790       { //3.2.1. 中右线只要有一个曲率比较大，且向左，就判断为左道。
// 11791         //如果右线斜率较大，且向左，那就判断为左弯。
// 11792         if((CURVEC + CurveStraightLimitC < 0)
// 11793         || (curvetempLR)
// 11794         || (slopetempLR)
// 11795           )
        LDR.W    R0,??DataTable64
        LDRSH    R0,[R0, #+0]
        ADDS     R0,R0,#+30
        CMP      R0,#+0
        BMI.N    ??PathLCRAngle1Judge_55
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BNE.N    ??PathLCRAngle1Judge_55
        UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
        CMP      R12,#+0
        BEQ.N    ??PathLCRAngle1Judge_56
// 11796         {
// 11797           PathType = PathTypeLeft;
??PathLCRAngle1Judge_55:
        MOVS     R0,#+2
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_33
// 11798         }
// 11799         //3.2.2. 否则就是直道。
// 11800         else
// 11801         {
// 11802           PathType = PathTypeStraight;
??PathLCRAngle1Judge_56:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_33
// 11803         }
// 11804       }
// 11805       //3.3. 斜率向右偏，最有可能是右道。
// 11806       else if(SlopeC + SlopeLimitC < 0)
??PathLCRAngle1Judge_54:
        LDR.W    R0,??DataTable61_2
        LDR      R0,[R0, #+0]
        ADDW     R0,R0,#+1500
        CMP      R0,#+0
        BPL.N    ??PathLCRAngle1Judge_33
// 11807       {
// 11808         //3.3.1. 中右线只要有一个曲率比较大，且向右，就判断为右道。
// 11809         //如果右线斜率较大，且向右，那就判断为右弯。
// 11810         if((CURVEC > CurveStraightLimitC)
// 11811          || (curvetempRR)
// 11812          || (slopetempRR)
// 11813            )
        LDR.W    R0,??DataTable64
        LDRSH    R0,[R0, #+0]
        CMP      R0,#+31
        BGE.N    ??PathLCRAngle1Judge_57
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BNE.N    ??PathLCRAngle1Judge_57
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+0
        BEQ.N    ??PathLCRAngle1Judge_58
// 11814         {
// 11815           PathType = PathTypeRight;
??PathLCRAngle1Judge_57:
        MOVS     R0,#+3
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
        B.N      ??PathLCRAngle1Judge_33
// 11816         }
// 11817         //3.3.2. 否则就是直道。
// 11818         else
// 11819         {
// 11820           PathType = PathTypeStraight;
??PathLCRAngle1Judge_58:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
// 11821         }        
// 11822       }
// 11823       //3.4. 理论上不会走到这里。
// 11824       else
// 11825       {
// 11826       }      
// 11827     }
// 11828     //4. 理论上不会出现这种情况。
// 11829     else 
// 11830     {
// 11831     }
// 11832     
// 11833     return 1;
??PathLCRAngle1Judge_33:
        MOVS     R0,#+1
        B.N      ??PathLCRAngle1Judge_59
// 11834     //直道、左弯、右弯、判断完毕，直角弯预判完毕。
// 11835   }
// 11836   //3条线的曲率、斜率均求取失败，直接返回失败。
// 11837   else
// 11838   {
// 11839     PathType = PathTypeUnknown;  
??PathLCRAngle1Judge_0:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable61
        STRB     R0,[R1, #+0]
// 11840     return 0;
        MOVS     R0,#+0
??PathLCRAngle1Judge_59:
        POP      {R1,R4-R7,PC}    ;; return
// 11841   }
// 11842 
// 11843 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable59:
        DC32     LimitRightB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable59_1:
        DC32     BlackLeftDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable59_2:
        DC32     BlackRightDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable59_3:
        DC32     BlackRightHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable59_4:
        DC32     BlackLeftHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable59_5:
        DC32     AngleHeadLineNum

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable59_6:
        DC32     BlackLeftCrossDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable59_7:
        DC32     BlackRightCrossDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable59_8:
        DC32     CURVEL
// 11844 
// 11845 
// 11846 //======================================================================
// 11847 //函数名：PathSmallSJudgeStep2
// 11848 //功  能：赛道类型判断时，小S弯第2个拐角的判断。
// 11849 //参  数：row需要处理的前一行，sel 左线0 右线1，dir Z字形0 反Z字形1.
// 11850 //返  回：1成功，0失败。
// 11851 //影  响：
// 11852 //说  明：1. 第2个拐角判断成功，则返回1。否则返回0.
// 11853 //        2. 进入该函数前，黑线已经连续。
// 11854 //             
// 11855 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 11856 uint8 PathSmallSJudgeStep2(uint8 row, uint8 sel, uint8 dir)
// 11857 {
// 11858   uint8 i;
// 11859   
// 11860   //左线
// 11861   if(sel == 0)
PathSmallSJudgeStep2:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??PathSmallSJudgeStep2_0
// 11862   {
// 11863     //Z字形
// 11864     if(dir == 0)
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BNE.N    ??PathSmallSJudgeStep2_1
// 11865     {
// 11866       for(i = row + 1; i < BlackLeftEndLine - PathSmallSGapLine; i++)
        ADDS     R0,R0,#+1
        B.N      ??PathSmallSJudgeStep2_2
??PathSmallSJudgeStep2_3:
        ADDS     R0,R0,#+1
??PathSmallSJudgeStep2_2:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDR.N    R1,??DataTable60_1
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+3
        CMP      R0,R1
        BGE.N    ??PathSmallSJudgeStep2_4
// 11867       {
// 11868         //Z字形，需要检测从左上到右下的轨迹。
// 11869         if(BlackLeftLoc[i][0] < BlackLeftLoc[i + 1 + PathSmallSGapLine][0])
        LDR.W    R1,??DataTable65
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable65
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+12]
        CMP      R1,R2
        BCS.N    ??PathSmallSJudgeStep2_3
// 11870         {
// 11871           return 1;
        MOVS     R0,#+1
        B.N      ??PathSmallSJudgeStep2_5
// 11872         }
// 11873         else
// 11874         {
// 11875         }
// 11876       }
// 11877     }
// 11878     //反Z字形
// 11879     else
// 11880     {
// 11881       for(i = row + 1; i < BlackLeftEndLine - PathSmallSGapLine; i++)
??PathSmallSJudgeStep2_1:
        ADDS     R0,R0,#+1
        B.N      ??PathSmallSJudgeStep2_6
??PathSmallSJudgeStep2_7:
        ADDS     R0,R0,#+1
??PathSmallSJudgeStep2_6:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDR.N    R1,??DataTable60_1
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+3
        CMP      R0,R1
        BGE.N    ??PathSmallSJudgeStep2_4
// 11882       {
// 11883         //反Z字形，需要检测从右上到左下的轨迹。
// 11884         if(BlackLeftLoc[i][0] >= BlackLeftLoc[i + 1 + PathSmallSGapLine][0])
        LDR.W    R1,??DataTable65
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable65
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+12]
        CMP      R1,R2
        BCC.N    ??PathSmallSJudgeStep2_7
// 11885         {
// 11886           return 1;
        MOVS     R0,#+1
        B.N      ??PathSmallSJudgeStep2_5
// 11887         }
// 11888         else
// 11889         {
// 11890         }
// 11891       }
// 11892     }
// 11893     
// 11894     //一直到有效黑线末尾仍未检测到相应的轨迹，第2个拐角检测失败，返回0。
// 11895     return 0;
??PathSmallSJudgeStep2_4:
        MOVS     R0,#+0
        B.N      ??PathSmallSJudgeStep2_5
// 11896   }
// 11897   //右线
// 11898   else
// 11899   {
// 11900     //Z字形
// 11901     if(dir == 0)
??PathSmallSJudgeStep2_0:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+0
        BNE.N    ??PathSmallSJudgeStep2_8
// 11902     {
// 11903       for(i = row + 1; i < BlackRightEndLine - PathSmallSGapLine; i++)
        ADDS     R0,R0,#+1
        B.N      ??PathSmallSJudgeStep2_9
??PathSmallSJudgeStep2_10:
        ADDS     R0,R0,#+1
??PathSmallSJudgeStep2_9:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDR.N    R1,??DataTable60_4
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+3
        CMP      R0,R1
        BGE.N    ??PathSmallSJudgeStep2_11
// 11904       {
// 11905         //Z字形，需要检测从左上到右下的轨迹。
// 11906         if(BlackRightLoc[i][0] < BlackRightLoc[i + 1 + PathSmallSGapLine][0])
        LDR.W    R1,??DataTable65_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable65_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+12]
        CMP      R1,R2
        BCS.N    ??PathSmallSJudgeStep2_10
// 11907         {
// 11908           return 1;
        MOVS     R0,#+1
        B.N      ??PathSmallSJudgeStep2_5
// 11909         }
// 11910         else
// 11911         {
// 11912         }
// 11913       }
// 11914     }
// 11915     //反Z字形
// 11916     else
// 11917     {
// 11918       for(i = row + 1; i < BlackRightEndLine - PathSmallSGapLine; i++)
??PathSmallSJudgeStep2_8:
        ADDS     R0,R0,#+1
        B.N      ??PathSmallSJudgeStep2_12
??PathSmallSJudgeStep2_13:
        ADDS     R0,R0,#+1
??PathSmallSJudgeStep2_12:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDR.N    R1,??DataTable60_4
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+3
        CMP      R0,R1
        BGE.N    ??PathSmallSJudgeStep2_11
// 11919       {
// 11920         //反Z字形，需要检测从右上到左下的轨迹。
// 11921         if(BlackRightLoc[i][0] >= BlackRightLoc[i + 1 + PathSmallSGapLine][0])
        LDR.W    R1,??DataTable65_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R0,R1
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable65_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+12]
        CMP      R1,R2
        BCC.N    ??PathSmallSJudgeStep2_13
// 11922         {
// 11923           return 1;
        MOVS     R0,#+1
        B.N      ??PathSmallSJudgeStep2_5
// 11924         }
// 11925         else
// 11926         {
// 11927         }
// 11928       }
// 11929     }
// 11930     
// 11931     //一直到有效黑线末尾仍未检测到相应的轨迹，第2个拐角检测失败，返回0。
// 11932     return 0;
??PathSmallSJudgeStep2_11:
        MOVS     R0,#+0
??PathSmallSJudgeStep2_5:
        BX       LR               ;; return
// 11933   }
// 11934 
// 11935 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable60:
        DC32     AngleLongHeadLineStrategy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable60_1:
        DC32     BlackLeftEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable60_2:
        DC32     BlackLeft5SlopeIndex

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable60_3:
        DC32     BlackLeft5Slope

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable60_4:
        DC32     BlackRightEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable60_5:
        DC32     BlackRight5SlopeIndex

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable60_6:
        DC32     BlackRight5Slope

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable60_7:
        DC32     flag222

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable60_8:
        DC32     LimitRightW
// 11936 
// 11937 
// 11938 //======================================================================
// 11939 //函数名：PathSmallSJudgeStep1
// 11940 //功  能：赛道类型判断时，小S弯第1个拐角的判断。
// 11941 //参  数：
// 11942 //返  回：1成功，0失败。
// 11943 //影  响：
// 11944 //说  明：1. 返回1或0只是表示是否为小S弯。
// 11945 //        2. 进入该函数前，黑线已经连续。
// 11946 //             
// 11947 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 11948 uint8 PathSmallSJudgeStep1(void)
// 11949 {
PathSmallSJudgeStep1:
        PUSH     {R4,LR}
// 11950     uint8 i;
// 11951     uint8 signflag1 = 2;    //初始为2，不为0也不为1.
        MOVS     R0,#+2
// 11952     //1. 线头够高。2. 从下往下的差会出现变化。
// 11953 
// 11954     //1. 左右黑线均提取成功。
// 11955     if (BlackLeftDone == 1 && BlackRightDone == 1)
        LDR.W    R1,??DataTable65_2
        LDRB     R1,[R1, #+0]
        CMP      R1,#+1
        BNE.W    ??PathSmallSJudgeStep1_0
        LDR.W    R1,??DataTable65_3
        LDRB     R1,[R1, #+0]
        CMP      R1,#+1
        BNE.W    ??PathSmallSJudgeStep1_0
// 11956     {
// 11957         //1.1. 左线线头够高。
// 11958         if (
// 11959             (BlackLeftHeadLine < PathSmallSHeadLimit) 
// 11960          && (BlackLeftEndLine > BlackLeftHeadLine + PathSmallSGapLine + 1)
// 11961             )
        LDR.W    R0,??DataTable65_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+10
        BGE.N    ??PathSmallSJudgeStep1_1
        LDR.W    R0,??DataTable65_4
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+4
        LDR.W    R1,??DataTable65_5
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BGE.N    ??PathSmallSJudgeStep1_1
// 11962         {
// 11963             //初始为2，不为0也不为1.
// 11964             signflag1 = 2;
        MOVS     R0,#+2
// 11965             
// 11966             //1.2. 两线有正到负 或者 负到正 的变化。 
// 11967             //左线
// 11968             for (i = BlackLeftHeadLine; i < BlackLeftEndLine - PathSmallSGapLine; i++)
        LDR.W    R1,??DataTable65_4
        LDRB     R4,[R1, #+0]
        B.N      ??PathSmallSJudgeStep1_2
// 11969             {
// 11970                 //赛道右向。若检测到跳变，中途会return.
// 11971                 if (BlackLeftLoc[i][0] >= BlackLeftLoc[i + 1 + PathSmallSGapLine][0])
// 11972                 {
// 11973                     //检测到跳变
// 11974                     if (signflag1 == 0)
// 11975                     {
// 11976                         //进行小S弯的第2个拐角的识别。左线，Z字形。
// 11977                         if(PathSmallSJudgeStep2(i, 0, 0) == 1)
// 11978                         {
// 11979                           PathSmallSDoneFlag = 1;   //小S弯判断成功。
// 11980                           PathSmallSDir = 1;    //小S弯先右向。
// 11981                           PathType = PathTypeSmallSR;   //右S
// 11982                           return 1;
// 11983                         }
// 11984                         else
// 11985                         {
// 11986                           //左线第2个拐角没有检测成功，没关系，下面会进行右线的检测。
// 11987                           //return 0;
// 11988                         }
// 11989                     }
// 11990                     else
// 11991                     {
// 11992                     }
// 11993                     signflag1 = 1;
// 11994                 }
// 11995                 //赛道左向。
// 11996                 else
// 11997                 {   
// 11998                     //检测到跳变。
// 11999                     if (signflag1 == 1)
// 12000                     { 
// 12001                         //进行小S弯的第2个拐角的识别。左线，反Z字形。
// 12002                         if(PathSmallSJudgeStep2(i, 0, 1) == 1)
// 12003                         {
// 12004                           PathSmallSDoneFlag = 1;   //小S弯判断成功。
// 12005                           PathSmallSDir = 0;    //小S弯先左向。
// 12006                           PathType = PathTypeSmallSL;  //左S
// 12007                           return 1;
// 12008                         }
// 12009                         else
// 12010                         {
// 12011                           //左线第2个拐角没有检测成功，没关系，下面会进行右线的检测。
// 12012                           //return 0;
// 12013                         }
// 12014                     }
// 12015                     else
// 12016                     {
// 12017                     }
// 12018                     signflag1 = 0;
??PathSmallSJudgeStep1_3:
        MOVS     R0,#+0
??PathSmallSJudgeStep1_4:
        ADDS     R4,R4,#+1
??PathSmallSJudgeStep1_2:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR.W    R1,??DataTable65_5
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+3
        CMP      R4,R1
        BGE.N    ??PathSmallSJudgeStep1_1
        LDR.W    R1,??DataTable65
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable65
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R4,R2
        LDRB     R2,[R2, #+12]
        CMP      R1,R2
        BCC.N    ??PathSmallSJudgeStep1_5
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??PathSmallSJudgeStep1_6
        MOVS     R2,#+0
        MOVS     R1,#+0
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       PathSmallSJudgeStep2
        CMP      R0,#+1
        BNE.N    ??PathSmallSJudgeStep1_6
        MOVS     R0,#+1
        LDR.W    R1,??DataTable65_6
        STRB     R0,[R1, #+0]
        MOVS     R0,#+1
        LDR.W    R1,??DataTable65_7
        STRB     R0,[R1, #+0]
        MOVS     R0,#+7
        LDR.N    R1,??DataTable61
        STRB     R0,[R1, #+0]
        MOVS     R0,#+1
        B.N      ??PathSmallSJudgeStep1_7
??PathSmallSJudgeStep1_6:
        MOVS     R0,#+1
        B.N      ??PathSmallSJudgeStep1_4
??PathSmallSJudgeStep1_5:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??PathSmallSJudgeStep1_3
        MOVS     R2,#+1
        MOVS     R1,#+0
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       PathSmallSJudgeStep2
        CMP      R0,#+1
        BNE.N    ??PathSmallSJudgeStep1_3
        MOVS     R0,#+1
        LDR.W    R1,??DataTable65_6
        STRB     R0,[R1, #+0]
        MOVS     R0,#+0
        LDR.W    R1,??DataTable65_7
        STRB     R0,[R1, #+0]
        MOVS     R0,#+6
        LDR.N    R1,??DataTable61
        STRB     R0,[R1, #+0]
        MOVS     R0,#+1
        B.N      ??PathSmallSJudgeStep1_7
// 12019                 }
// 12020             }
// 12021             
// 12022             //到这里说明左线不成功，但没关系，继续分析右线。
// 12023         }
// 12024         //左线线头不够高，则直接跳过，分析右线。
// 12025         else
// 12026         {
// 12027         }
// 12028         
// 12029         //右线线头要够高。
// 12030         if(
// 12031             (BlackRightHeadLine < PathSmallSHeadLimit)
// 12032          && (BlackRightEndLine > BlackRightHeadLine + PathSmallSGapLine + 1)
// 12033            )
??PathSmallSJudgeStep1_1:
        LDR.W    R0,??DataTable65_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+10
        BGE.N    ??PathSmallSJudgeStep1_8
        LDR.W    R0,??DataTable65_8
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+4
        LDR.W    R1,??DataTable65_9
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BGE.N    ??PathSmallSJudgeStep1_8
// 12034         {
// 12035           //初始为2，不为0也不为1.
// 12036           signflag1 = 2;
        MOVS     R0,#+2
// 12037 
// 12038           //右线。左线若没有return，就继续找跳变。
// 12039           for (i = BlackRightHeadLine; i < BlackRightEndLine - PathSmallSGapLine; i++)
        LDR.W    R1,??DataTable65_8
        LDRB     R4,[R1, #+0]
        B.N      ??PathSmallSJudgeStep1_9
// 12040           {
// 12041               //赛道右向。
// 12042               if (BlackRightLoc[i][0] >= BlackRightLoc[i + 1 + PathSmallSGapLine][0])
// 12043               {
// 12044                   //检测到跳变
// 12045                   if (signflag1 == 0)
// 12046                   {
// 12047                       //进行小S弯的第2个拐角的识别。右线，Z字形。
// 12048                       if(PathSmallSJudgeStep2(i, 1, 0) == 1)
// 12049                       {
// 12050                         PathSmallSDoneFlag = 1;   //小S弯判断成功。
// 12051                         PathSmallSDir = 1;    //小S弯先右向。
// 12052                         PathType = PathTypeSmallSR;   //右S
// 12053                         return 1;
// 12054                       }
// 12055                       else
// 12056                       {
// 12057                         return 0;
// 12058                       }
// 12059                   }
// 12060                   else
// 12061                   {
// 12062                   }
// 12063                   signflag1 = 1;
// 12064               }
// 12065               //赛道左向。
// 12066               else
// 12067               {
// 12068                   //检测到跳变。
// 12069                   if (signflag1 == 1)
// 12070                   {
// 12071                       //进行小S弯的第2个拐角的识别。右线，反Z字形。
// 12072                       if(PathSmallSJudgeStep2(i, 1, 1) == 1)
// 12073                       {
// 12074                         PathSmallSDoneFlag = 1;   //小S弯判断成功。
// 12075                         PathSmallSDir = 0;    //小S弯先左向。
// 12076                         PathType = PathTypeSmallSL;   //左S
// 12077                         return 1;
// 12078                       }
// 12079                       else
// 12080                       {
// 12081                         return 0;
// 12082                       }
// 12083                   }
// 12084                   else
// 12085                   {
// 12086                   }
// 12087                   signflag1 = 0;
??PathSmallSJudgeStep1_10:
        MOVS     R0,#+0
??PathSmallSJudgeStep1_11:
        ADDS     R4,R4,#+1
??PathSmallSJudgeStep1_9:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR.W    R1,??DataTable65_9
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+3
        CMP      R4,R1
        BGE.N    ??PathSmallSJudgeStep1_12
        LDR.W    R1,??DataTable65_1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable65_1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R4,R2
        LDRB     R2,[R2, #+12]
        CMP      R1,R2
        BCC.N    ??PathSmallSJudgeStep1_13
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??PathSmallSJudgeStep1_14
        MOVS     R2,#+0
        MOVS     R1,#+1
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       PathSmallSJudgeStep2
        CMP      R0,#+1
        BNE.N    ??PathSmallSJudgeStep1_15
        MOVS     R0,#+1
        LDR.W    R1,??DataTable65_6
        STRB     R0,[R1, #+0]
        MOVS     R0,#+1
        LDR.W    R1,??DataTable65_7
        STRB     R0,[R1, #+0]
        MOVS     R0,#+7
        LDR.N    R1,??DataTable61
        STRB     R0,[R1, #+0]
        MOVS     R0,#+1
        B.N      ??PathSmallSJudgeStep1_7
??PathSmallSJudgeStep1_15:
        MOVS     R0,#+0
        B.N      ??PathSmallSJudgeStep1_7
??PathSmallSJudgeStep1_14:
        MOVS     R0,#+1
        B.N      ??PathSmallSJudgeStep1_11
??PathSmallSJudgeStep1_13:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??PathSmallSJudgeStep1_10
        MOVS     R2,#+1
        MOVS     R1,#+1
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       PathSmallSJudgeStep2
        CMP      R0,#+1
        BNE.N    ??PathSmallSJudgeStep1_16
        MOVS     R0,#+1
        LDR.W    R1,??DataTable65_6
        STRB     R0,[R1, #+0]
        MOVS     R0,#+0
        LDR.W    R1,??DataTable65_7
        STRB     R0,[R1, #+0]
        MOVS     R0,#+6
        LDR.N    R1,??DataTable61
        STRB     R0,[R1, #+0]
        MOVS     R0,#+1
        B.N      ??PathSmallSJudgeStep1_7
??PathSmallSJudgeStep1_16:
        MOVS     R0,#+0
        B.N      ??PathSmallSJudgeStep1_7
// 12088               }
// 12089           }
// 12090 
// 12091           //若左右线中途都没有return 1，则返回检测失败。
// 12092           return 0;
??PathSmallSJudgeStep1_12:
        MOVS     R0,#+0
        B.N      ??PathSmallSJudgeStep1_7
// 12093         }
// 12094         else
// 12095         {
// 12096           //右线线头过低，不符合小S弯。返回失败。
// 12097           return 0;
??PathSmallSJudgeStep1_8:
        MOVS     R0,#+0
        B.N      ??PathSmallSJudgeStep1_7
// 12098         }
// 12099     }
// 12100     //2. 左线提取成功，右线提取失败。
// 12101     else if (BlackLeftDone == 1 && BlackRightDone == 0)
??PathSmallSJudgeStep1_0:
        LDR.W    R1,??DataTable65_2
        LDRB     R1,[R1, #+0]
        CMP      R1,#+1
        BNE.N    ??PathSmallSJudgeStep1_17
        LDR.W    R1,??DataTable65_3
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BNE.N    ??PathSmallSJudgeStep1_17
// 12102     {
// 12103         //2.1. 左线线头要求够高。
// 12104         if (BlackLeftHeadLine < PathSmallSHeadLimit && BlackLeftEndLine > BlackLeftHeadLine + PathSmallSGapLine + 1)
        LDR.W    R1,??DataTable65_4
        LDRB     R1,[R1, #+0]
        CMP      R1,#+10
        BGE.N    ??PathSmallSJudgeStep1_18
        LDR.W    R1,??DataTable65_4
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+4
        LDR.W    R2,??DataTable65_5
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BGE.N    ??PathSmallSJudgeStep1_18
// 12105         {
// 12106             //2.2. 检测跳变。
// 12107             for (i = BlackLeftHeadLine; i < BlackLeftEndLine - PathSmallSGapLine; i++)
        LDR.W    R1,??DataTable65_4
        LDRB     R4,[R1, #+0]
        B.N      ??PathSmallSJudgeStep1_19
// 12108             {
// 12109 
// 12110                 //赛道右向。若检测到跳变，中途会return.
// 12111                 if (BlackLeftLoc[i][0] >= BlackLeftLoc[i + 1 + PathSmallSGapLine][0])
// 12112                 {
// 12113                     //检测到跳变
// 12114                     if (signflag1 == 0)
// 12115                     {                           
// 12116                         //进行小S弯的第2个拐角的识别。左线，Z字形。
// 12117                         if(PathSmallSJudgeStep2(i, 0, 0) == 1)
// 12118                         {
// 12119                           PathSmallSDoneFlag = 1;   //小S弯判断成功。
// 12120                           PathSmallSDir = 1;    //小S弯先右向。
// 12121                           PathType = PathTypeSmallSR;   //右S
// 12122                           return 1;
// 12123                         }
// 12124                         else
// 12125                         {
// 12126                           return 0;
// 12127                         }
// 12128                     }
// 12129                     else
// 12130                     {
// 12131                     }
// 12132                     signflag1 = 1;
// 12133                 }
// 12134                 //赛道左向。
// 12135                 else
// 12136                 {
// 12137                     //检测到跳变。
// 12138                     if (signflag1 == 1)
// 12139                     {                           
// 12140                         //进行小S弯的第2个拐角的识别。左线，反Z字形。
// 12141                         if(PathSmallSJudgeStep2(i, 0, 1) == 1)
// 12142                         {
// 12143                           PathSmallSDoneFlag = 1;   //小S弯判断成功。
// 12144                           PathSmallSDir = 0;    //小S弯先左向。
// 12145                           PathType = PathTypeSmallSL;  //左S
// 12146                           return 1;
// 12147                         }
// 12148                         else
// 12149                         {
// 12150                           return 0;
// 12151                         }
// 12152                     }
// 12153                     else
// 12154                     {
// 12155                     }
// 12156                     signflag1 = 0;
??PathSmallSJudgeStep1_20:
        MOVS     R0,#+0
??PathSmallSJudgeStep1_21:
        ADDS     R4,R4,#+1
??PathSmallSJudgeStep1_19:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR.W    R1,??DataTable65_5
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+3
        CMP      R4,R1
        BGE.N    ??PathSmallSJudgeStep1_22
        LDR.W    R1,??DataTable65
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable65
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R4,R2
        LDRB     R2,[R2, #+12]
        CMP      R1,R2
        BCC.N    ??PathSmallSJudgeStep1_23
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??PathSmallSJudgeStep1_24
        MOVS     R2,#+0
        MOVS     R1,#+0
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       PathSmallSJudgeStep2
        CMP      R0,#+1
        BNE.N    ??PathSmallSJudgeStep1_25
        MOVS     R0,#+1
        LDR.W    R1,??DataTable65_6
        STRB     R0,[R1, #+0]
        MOVS     R0,#+1
        LDR.W    R1,??DataTable65_7
        STRB     R0,[R1, #+0]
        MOVS     R0,#+7
        LDR.N    R1,??DataTable61
        STRB     R0,[R1, #+0]
        MOVS     R0,#+1
        B.N      ??PathSmallSJudgeStep1_7
??PathSmallSJudgeStep1_25:
        MOVS     R0,#+0
        B.N      ??PathSmallSJudgeStep1_7
??PathSmallSJudgeStep1_24:
        MOVS     R0,#+1
        B.N      ??PathSmallSJudgeStep1_21
??PathSmallSJudgeStep1_23:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??PathSmallSJudgeStep1_20
        MOVS     R2,#+1
        MOVS     R1,#+0
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       PathSmallSJudgeStep2
        CMP      R0,#+1
        BNE.N    ??PathSmallSJudgeStep1_26
        MOVS     R0,#+1
        LDR.W    R1,??DataTable65_6
        STRB     R0,[R1, #+0]
        MOVS     R0,#+0
        LDR.W    R1,??DataTable65_7
        STRB     R0,[R1, #+0]
        MOVS     R0,#+6
        LDR.N    R1,??DataTable61
        STRB     R0,[R1, #+0]
        MOVS     R0,#+1
        B.N      ??PathSmallSJudgeStep1_7
??PathSmallSJudgeStep1_26:
        MOVS     R0,#+0
        B.N      ??PathSmallSJudgeStep1_7
// 12157                 }
// 12158             }
// 12159 
// 12160             //若左线中途没有return，则返回检测失败。
// 12161             return 0;
??PathSmallSJudgeStep1_22:
        MOVS     R0,#+0
        B.N      ??PathSmallSJudgeStep1_7
// 12162         }
// 12163         //线头过低，不符合小S弯。返回失败。
// 12164         else
// 12165         {
// 12166             return 0;
??PathSmallSJudgeStep1_18:
        MOVS     R0,#+0
        B.N      ??PathSmallSJudgeStep1_7
// 12167         }
// 12168     }
// 12169     //3. 右线提取成功，左线提取失败。
// 12170     else if (BlackLeftDone == 0 && BlackRightDone == 1)
??PathSmallSJudgeStep1_17:
        LDR.W    R1,??DataTable65_2
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BNE.N    ??PathSmallSJudgeStep1_27
        LDR.W    R1,??DataTable65_3
        LDRB     R1,[R1, #+0]
        CMP      R1,#+1
        BNE.N    ??PathSmallSJudgeStep1_27
// 12171     {
// 12172         //3.1. 两线线头都要够高。
// 12173         if (BlackRightHeadLine < PathSmallSHeadLimit && BlackRightEndLine > BlackRightHeadLine + PathSmallSGapLine + 1)
        LDR.W    R1,??DataTable65_8
        LDRB     R1,[R1, #+0]
        CMP      R1,#+10
        BGE.N    ??PathSmallSJudgeStep1_28
        LDR.W    R1,??DataTable65_8
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+4
        LDR.W    R2,??DataTable65_9
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BGE.N    ??PathSmallSJudgeStep1_28
// 12174         {
// 12175             //右线。
// 12176             for (i = BlackRightHeadLine; i < BlackRightEndLine - PathSmallSGapLine; i++)
        LDR.W    R1,??DataTable65_8
        LDRB     R4,[R1, #+0]
        B.N      ??PathSmallSJudgeStep1_29
// 12177             {
// 12178                   //赛道右向。
// 12179                   if (BlackRightLoc[i][0] >= BlackRightLoc[i + 1 + PathSmallSGapLine][0])
// 12180                   {
// 12181                       //检测到跳变
// 12182                       if (signflag1 == 0)
// 12183                       {                           
// 12184                           //进行小S弯的第2个拐角的识别。右线，Z字形。
// 12185                           if(PathSmallSJudgeStep2(i, 1, 0) == 1)
// 12186                           {
// 12187                             PathSmallSDoneFlag = 1;   //小S弯判断成功。
// 12188                             PathSmallSDir = 1;    //小S弯先右向。
// 12189                             PathType = PathTypeSmallSR; //右S
// 12190                             return 1;
// 12191                           }
// 12192                           else
// 12193                           {
// 12194                             return 0;
// 12195                           }
// 12196                       }
// 12197                       else
// 12198                       {
// 12199                       }
// 12200                       signflag1 = 1;
// 12201                   }
// 12202                   //赛道左向。
// 12203                   else
// 12204                   {
// 12205                       //检测到跳变。
// 12206                       if (signflag1 == 1)
// 12207                       {                           
// 12208                           //进行小S弯的第2个拐角的识别。右线，反Z字形。
// 12209                           if(PathSmallSJudgeStep2(i, 1, 1) == 1)
// 12210                           {
// 12211                             PathSmallSDoneFlag = 1;   //小S弯判断成功。
// 12212                             PathSmallSDir = 0;    //小S弯先左向。
// 12213                             PathType = PathTypeSmallSL;  //左S
// 12214                             return 1;
// 12215                           }
// 12216                           else
// 12217                           {
// 12218                             return 0;
// 12219                           }
// 12220                       }
// 12221                       else
// 12222                       {
// 12223                       }
// 12224                       signflag1 = 0;
??PathSmallSJudgeStep1_30:
        MOVS     R0,#+0
??PathSmallSJudgeStep1_31:
        ADDS     R4,R4,#+1
??PathSmallSJudgeStep1_29:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR.W    R1,??DataTable65_9
        LDRB     R1,[R1, #+0]
        SUBS     R1,R1,#+3
        CMP      R4,R1
        BGE.N    ??PathSmallSJudgeStep1_32
        LDR.W    R1,??DataTable65_1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R2,#+3
        MLA      R1,R2,R4,R1
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable65_1
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R4,R2
        LDRB     R2,[R2, #+12]
        CMP      R1,R2
        BCC.N    ??PathSmallSJudgeStep1_33
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??PathSmallSJudgeStep1_34
        MOVS     R2,#+0
        MOVS     R1,#+1
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       PathSmallSJudgeStep2
        CMP      R0,#+1
        BNE.N    ??PathSmallSJudgeStep1_35
        MOVS     R0,#+1
        LDR.W    R1,??DataTable65_6
        STRB     R0,[R1, #+0]
        MOVS     R0,#+1
        LDR.W    R1,??DataTable65_7
        STRB     R0,[R1, #+0]
        MOVS     R0,#+7
        LDR.N    R1,??DataTable61
        STRB     R0,[R1, #+0]
        MOVS     R0,#+1
        B.N      ??PathSmallSJudgeStep1_7
??PathSmallSJudgeStep1_35:
        MOVS     R0,#+0
        B.N      ??PathSmallSJudgeStep1_7
??PathSmallSJudgeStep1_34:
        MOVS     R0,#+1
        B.N      ??PathSmallSJudgeStep1_31
??PathSmallSJudgeStep1_33:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??PathSmallSJudgeStep1_30
        MOVS     R2,#+1
        MOVS     R1,#+1
        MOVS     R0,R4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       PathSmallSJudgeStep2
        CMP      R0,#+1
        BNE.N    ??PathSmallSJudgeStep1_36
        MOVS     R0,#+1
        LDR.W    R1,??DataTable65_6
        STRB     R0,[R1, #+0]
        MOVS     R0,#+0
        LDR.W    R1,??DataTable65_7
        STRB     R0,[R1, #+0]
        MOVS     R0,#+6
        LDR.N    R1,??DataTable61
        STRB     R0,[R1, #+0]
        MOVS     R0,#+1
        B.N      ??PathSmallSJudgeStep1_7
??PathSmallSJudgeStep1_36:
        MOVS     R0,#+0
        B.N      ??PathSmallSJudgeStep1_7
// 12225                   }
// 12226             }
// 12227 
// 12228             //若右线中途没有return，则返回检测失败。
// 12229             return 0;
??PathSmallSJudgeStep1_32:
        MOVS     R0,#+0
        B.N      ??PathSmallSJudgeStep1_7
// 12230         }
// 12231         //线头过低，不符合小S弯。返回失败。
// 12232         else
// 12233         {
// 12234             return 0;
??PathSmallSJudgeStep1_28:
        MOVS     R0,#+0
        B.N      ??PathSmallSJudgeStep1_7
// 12235         }
// 12236 
// 12237     }
// 12238     //4. 理论上不会走到这里。
// 12239     else
// 12240     {
// 12241         return 0;
??PathSmallSJudgeStep1_27:
        MOVS     R0,#+0
??PathSmallSJudgeStep1_7:
        POP      {R4,PC}          ;; return
// 12242     }
// 12243 
// 12244 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable61:
        DC32     PathType

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable61_1:
        DC32     LimitLeftW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable61_2:
        DC32     SlopeC

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable61_3:
        DC32     CurveSlopeFlagL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable61_4:
        DC32     CurveSlopeFlagR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable61_5:
        DC32     CURVER

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable61_6:
        DC32     SlopeL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable61_7:
        DC32     SlopeR
// 12245 
// 12246 
// 12247 
// 12248 //赛道类型判断
// 12249 //======================================================================
// 12250 //函数名：PathJudge
// 12251 //功  能：赛道类型判断
// 12252 //参  数：无
// 12253 //返  回：1成功 0失败
// 12254 //影  响：PathType
// 12255 //说  明：1. 根据曲率和斜率来判断。
// 12256 //        2. PathType: 0未知 1直道 2左内 3左中 4左外 5右内 6右中 7右外
// 12257 //             
// 12258 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 12259 uint8 PathJudge(void)
// 12260 {  
PathJudge:
        PUSH     {R7,LR}
// 12261   uint8 flag1, flag2;
// 12262   
// 12263   
// 12264   //直道、左弯、右弯判断，直角弯第1阶段预判。
// 12265   //当斜曲率求取失败时，会返回0.
// 12266   flag1 = PathLCRAngle1Judge();
        BL       PathLCRAngle1Judge
// 12267 
// 12268   //小S弯判断。非小S弯会返回0.
// 12269   //flag2 = PathSmallSJudgeStep1();
// 12270   flag2 = 1;
        MOVS     R1,#+1
// 12271   
// 12272   if(flag1 == 0 && flag2 == 0)
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??PathJudge_0
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+0
        BNE.N    ??PathJudge_0
// 12273   {
// 12274     return 0;
        MOVS     R0,#+0
        B.N      ??PathJudge_1
// 12275   }
// 12276   else
// 12277   {
// 12278     return 1;
??PathJudge_0:
        MOVS     R0,#+1
??PathJudge_1:
        POP      {R1,PC}          ;; return
// 12279   }
// 12280   
// 12281   //以下是一套以曲率为主导的赛道类型判断方法。
// 12282   /*
// 12283   //赛道类型PathType: 0未知 1直道 2左内 3左中 4左外 5右内 6右中 7右外
// 12284   PathType = PathTypeUnknown;
// 12285   //曲率符号获取成功
// 12286   //如果CurveSlopeGet()返回0，则代表3条线的曲率、斜率均求取失败，不用进行下面的判断。
// 12287   if(CurveSlopeGet())
// 12288   {
// 12289     //不用判断中心线成功，到这里了肯定是成功的。
// 12290     //左右黑线均提取成功，的情况。
// 12291     if(BlackLeftDone == 1 && BlackRightDone == 1)
// 12292     { //全部逆时针，且逆得比较多，则为左弯，而且是小车走在左弯道较为中心的左弯。
// 12293       if(
// 12294          (CURVEL + CurveStraightLimitL < 0) 
// 12295        &&(CURVEC + CurveStraightLimitC < 0)
// 12296        &&(CURVER + CurveStraightLimitR < 0)       
// 12297          )
// 12298       {
// 12299         PathType = PathTypeLeftMiddle;
// 12300       }
// 12301       //全部顺时针，且顺得比较多，则为右弯，而且是小车走在右弯道较为中心的右弯。
// 12302       else if(CURVEL > CurveStraightLimitL && CURVEC > CurveStraightLimitC && CURVER > CurveStraightLimitR)
// 12303       {        
// 12304         PathType = PathTypeRightMiddle;
// 12305       }
// 12306       else
// 12307       {
// 12308         if(
// 12309           (AbsSelf(CURVEL) < CurveStraightLimitL)
// 12310         &&(AbsSelf(CURVEC) < CurveStraightLimitC)
// 12311         &&(AbsSelf(CURVER) < CurveStraightLimitR) //三个值的绝对值够小。
// 12312         &&(SlopeL + SlopeLimitL < 0)              //左黑线斜率小于某负值
// 12313         &&(AbsSelfFloat(SlopeC) < SlopeLimitC)         //中心线斜率绝对值够小
// 12314         &&(SlopeR > SlopeLimitR)                  //右黑线斜率大于某正值
// 12315           )
// 12316         { //均小于阈值，为直道。
// 12317           PathType = PathTypeStraight;  
// 12318         }
// 12319         else
// 12320         {
// 12321           PathType = PathTypeUnknown; //未知赛道类型。  
// 12322         }
// 12323       }
// 12324     }
// 12325     
// 12326     //左黑线提取失败，右黑线提取成功，的情况。
// 12327     if(BlackLeftDone == 0 && BlackRightDone == 1)
// 12328     { //左弯道，外道。
// 12329       if((CURVEC + CurveStraightLimitC < 0) 
// 12330        &&(CURVER + CurveStraightLimitR < 0)
// 12331          )
// 12332       {
// 12333         PathType = PathTypeLeftOut;
// 12334       }
// 12335       //右弯道，内道。
// 12336       else if(CURVEC > CurveStraightLimitC && CURVER > CurveStraightLimitR)
// 12337       {
// 12338         PathType = PathTypeRightIn;
// 12339       }
// 12340       else
// 12341       {
// 12342         if(
// 12343           (AbsSelf(CURVEC) < CurveStraightLimitC)
// 12344         &&(AbsSelf(CURVER) < CurveStraightLimitR)
// 12345         &&(AbsSelfFloat(SlopeC) < SlopeLimitC)         //中心线斜率绝对值够小
// 12346         &&(SlopeR > SlopeLimitR)                  //右黑线斜率大于某正值
// 12347           )
// 12348         { //均小于阈值，为直道。
// 12349           PathType = PathTypeStraight;  
// 12350         }
// 12351         else
// 12352         {
// 12353           PathType = PathTypeUnknown; //未知赛道类型。  
// 12354         }
// 12355       }
// 12356     }
// 12357     
// 12358     //右黑线提取失败，左黑线提取成功，的情况。
// 12359     if(BlackLeftDone == 1 && BlackRightDone == 0)
// 12360     { //左弯道，内道。
// 12361       if((CURVEC + CurveStraightLimitC < 0)
// 12362        &&(CURVEL + CurveStraightLimitL < 0)
// 12363          )
// 12364       {
// 12365         PathType = PathTypeLeftIn;
// 12366       }
// 12367       //右弯道，外道。
// 12368       else if(CURVEC > CurveStraightLimitC && CURVEL > CurveStraightLimitL)
// 12369       {
// 12370         PathType = PathTypeRightOut;
// 12371       }
// 12372       else
// 12373       {
// 12374         if(
// 12375           (AbsSelf(CURVEC) < CurveStraightLimitC)
// 12376         &&(AbsSelf(CURVEL) < CurveStraightLimitL)
// 12377         &&(SlopeL + SlopeLimitL < 0)              //左黑线斜率小于某负值
// 12378         &&(AbsSelfFloat(SlopeC) < SlopeLimitC)         //中心线斜率绝对值够小          
// 12379           )
// 12380         { //均小于阈值，为直道。
// 12381           PathType = PathTypeStraight;  
// 12382         }
// 12383         else
// 12384         {
// 12385           PathType = PathTypeUnknown; //未知赛道类型。  
// 12386         }
// 12387       }
// 12388     }
// 12389     
// 12390     return 1;
// 12391   }
// 12392   //3条线的曲率、斜率均求取失败，直接返回失败。
// 12393   else
// 12394   {
// 12395     PathType = PathTypeUnknown;  
// 12396     return 0;
// 12397   }
// 12398   
// 12399   */   //end of 以曲率为主导的赛道类型判断方法。
// 12400   
// 12401 }
// 12402 
// 12403 
// 12404 
// 12405 
// 12406 
// 12407 
// 12408 
// 12409 
// 12410 //图像畸变矫正

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 12411 uint8 BlackUdis(void)
// 12412 {
BlackUdis:
        PUSH     {R4,R5}
// 12413   uint8 row;
// 12414   
// 12415   //矫正
// 12416   //对左黑线的畸变矫正
// 12417   if(BlackLeftDone == 1)
        LDR.W    R0,??DataTable65_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??BlackUdis_0
// 12418   {
// 12419     //从线尾到线头。
// 12420     for(row = BlackLeftEndLine; ; row--)
        LDR.W    R0,??DataTable65_5
        LDRB     R0,[R0, #+0]
        B.N      ??BlackUdis_1
??BlackUdis_2:
        SUBS     R0,R0,#+1
// 12421     {
// 12422       //近处的行
// 12423       if(row > BlackUdisMiddleLine)
??BlackUdis_1:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+39
        BLT.N    ??BlackUdis_3
// 12424       {
// 12425         //列
// 12426         BlackUdisLeftLocation[row].x  = (BlackUdisMatrixLow[0] * BlackLeftLoc[row][0] + BlackUdisMatrixLow[1] * (row + 1) + BlackUdisMatrixLow[2]) 
// 12427                                       / (BlackUdisMatrixLow[6] * BlackLeftLoc[row][0] + BlackUdisMatrixLow[7] * (row + 1) + 1000);
        LDR.W    R1,??DataTable66
        LDR      R1,[R1, #+0]
        LDR.W    R2,??DataTable65
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable66
        LDR      R3,[R3, #+4]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R4,R0,#+1
        MULS     R3,R4,R3
        MLA      R1,R2,R1,R3
        LDR.W    R2,??DataTable66
        LDR      R2,[R2, #+8]
        ADDS     R1,R2,R1
        LDR.W    R2,??DataTable66
        LDR      R2,[R2, #+24]
        LDR.W    R3,??DataTable65
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R0,R3
        LDRB     R3,[R3, #+0]
        LDR.W    R4,??DataTable66
        LDR      R4,[R4, #+28]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R5,R0,#+1
        MULS     R4,R5,R4
        MLA      R2,R3,R2,R4
        ADDS     R2,R2,#+1000
        SDIV     R1,R1,R2
        LDR.W    R2,??DataTable66_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STR      R1,[R2, R0, LSL #+3]
// 12428         //行
// 12429         BlackUdisLeftLocation[row].y  = (BlackUdisMatrixLow[3] * BlackLeftLoc[row][0] + BlackUdisMatrixLow[4] * (row + 1) + BlackUdisMatrixLow[5]) 
// 12430                                       / (BlackUdisMatrixLow[6] * BlackLeftLoc[row][0] + BlackUdisMatrixLow[7] * (row + 1) + 1000);
        LDR.W    R1,??DataTable66
        LDR      R1,[R1, #+12]
        LDR.W    R2,??DataTable65
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable66
        LDR      R3,[R3, #+16]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R4,R0,#+1
        MULS     R3,R4,R3
        MLA      R1,R2,R1,R3
        LDR.W    R2,??DataTable66
        LDR      R2,[R2, #+20]
        ADDS     R1,R2,R1
        LDR.W    R2,??DataTable66
        LDR      R2,[R2, #+24]
        LDR.W    R3,??DataTable65
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R0,R3
        LDRB     R3,[R3, #+0]
        LDR.W    R4,??DataTable66
        LDR      R4,[R4, #+28]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R5,R0,#+1
        MULS     R4,R5,R4
        MLA      R2,R3,R2,R4
        ADDS     R2,R2,#+1000
        SDIV     R1,R1,R2
        LDR.W    R2,??DataTable66_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R2,R2,R0, LSL #+3
        STR      R1,[R2, #+4]
        B.N      ??BlackUdis_4
// 12431       }
// 12432       else
// 12433       {
// 12434         //中间的行
// 12435         if(row > BlackUdisFarLine)
??BlackUdis_3:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+19
        BLT.N    ??BlackUdis_5
// 12436         {
// 12437           //列
// 12438           BlackUdisLeftLocation[row].x  = (BlackUdisMatrixMiddle[0] * BlackLeftLoc[row][0] + BlackUdisMatrixMiddle[1] * (row + 1) + BlackUdisMatrixMiddle[2]) 
// 12439                                         / (BlackUdisMatrixMiddle[6] * BlackLeftLoc[row][0] + BlackUdisMatrixMiddle[7] * (row + 1) + 1000);
        LDR.W    R1,??DataTable66_2
        LDR      R1,[R1, #+0]
        LDR.W    R2,??DataTable65
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable66_2
        LDR      R3,[R3, #+4]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R4,R0,#+1
        MULS     R3,R4,R3
        MLA      R1,R2,R1,R3
        LDR.W    R2,??DataTable66_2
        LDR      R2,[R2, #+8]
        ADDS     R1,R2,R1
        LDR.W    R2,??DataTable66_2
        LDR      R2,[R2, #+24]
        LDR.W    R3,??DataTable65
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R0,R3
        LDRB     R3,[R3, #+0]
        LDR.W    R4,??DataTable66_2
        LDR      R4,[R4, #+28]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R5,R0,#+1
        MULS     R4,R5,R4
        MLA      R2,R3,R2,R4
        ADDS     R2,R2,#+1000
        SDIV     R1,R1,R2
        LDR.W    R2,??DataTable66_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STR      R1,[R2, R0, LSL #+3]
// 12440           //行
// 12441           BlackUdisLeftLocation[row].y  = (BlackUdisMatrixMiddle[3] * BlackLeftLoc[row][0] + BlackUdisMatrixMiddle[4] * (row + 1) + BlackUdisMatrixMiddle[5]) 
// 12442                                         / (BlackUdisMatrixMiddle[6] * BlackLeftLoc[row][0] + BlackUdisMatrixMiddle[7] * (row + 1) + 1000);     
        LDR.W    R1,??DataTable66_2
        LDR      R1,[R1, #+12]
        LDR.W    R2,??DataTable65
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable66_2
        LDR      R3,[R3, #+16]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R4,R0,#+1
        MULS     R3,R4,R3
        MLA      R1,R2,R1,R3
        LDR.W    R2,??DataTable66_2
        LDR      R2,[R2, #+20]
        ADDS     R1,R2,R1
        LDR.W    R2,??DataTable66_2
        LDR      R2,[R2, #+24]
        LDR.W    R3,??DataTable65
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R0,R3
        LDRB     R3,[R3, #+0]
        LDR.W    R4,??DataTable66_2
        LDR      R4,[R4, #+28]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R5,R0,#+1
        MULS     R4,R5,R4
        MLA      R2,R3,R2,R4
        ADDS     R2,R2,#+1000
        SDIV     R1,R1,R2
        LDR.W    R2,??DataTable66_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R2,R2,R0, LSL #+3
        STR      R1,[R2, #+4]
        B.N      ??BlackUdis_4
// 12443         }
// 12444         //远处的行
// 12445         else
// 12446         {
// 12447           //列
// 12448           BlackUdisLeftLocation[row].x  = (BlackUdisMatrixFar[0] * BlackLeftLoc[row][0] + BlackUdisMatrixFar[1] * (row + 1) + BlackUdisMatrixFar[2]) 
// 12449                                         / (BlackUdisMatrixFar[6] * BlackLeftLoc[row][0] + BlackUdisMatrixFar[7] * (row + 1) + 1000);
??BlackUdis_5:
        LDR.W    R1,??DataTable66_3
        LDR      R1,[R1, #+0]
        LDR.W    R2,??DataTable65
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable66_3
        LDR      R3,[R3, #+4]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R4,R0,#+1
        MULS     R3,R4,R3
        MLA      R1,R2,R1,R3
        LDR.W    R2,??DataTable66_3
        LDR      R2,[R2, #+8]
        ADDS     R1,R2,R1
        LDR.W    R2,??DataTable66_3
        LDR      R2,[R2, #+24]
        LDR.W    R3,??DataTable65
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R0,R3
        LDRB     R3,[R3, #+0]
        LDR.W    R4,??DataTable66_3
        LDR      R4,[R4, #+28]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R5,R0,#+1
        MULS     R4,R5,R4
        MLA      R2,R3,R2,R4
        ADDS     R2,R2,#+1000
        SDIV     R1,R1,R2
        LDR.W    R2,??DataTable66_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STR      R1,[R2, R0, LSL #+3]
// 12450           //行
// 12451           BlackUdisLeftLocation[row].y  = (BlackUdisMatrixFar[3] * BlackLeftLoc[row][0] + BlackUdisMatrixFar[4] * (row + 1) + BlackUdisMatrixFar[5]) 
// 12452                                         / (BlackUdisMatrixFar[6] * BlackLeftLoc[row][0] + BlackUdisMatrixFar[7] * (row + 1) + 1000);          
        LDR.W    R1,??DataTable66_3
        LDR      R1,[R1, #+12]
        LDR.W    R2,??DataTable65
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable66_3
        LDR      R3,[R3, #+16]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R4,R0,#+1
        MULS     R3,R4,R3
        MLA      R1,R2,R1,R3
        LDR.W    R2,??DataTable66_3
        LDR      R2,[R2, #+20]
        ADDS     R1,R2,R1
        LDR.W    R2,??DataTable66_3
        LDR      R2,[R2, #+24]
        LDR.W    R3,??DataTable65
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R0,R3
        LDRB     R3,[R3, #+0]
        LDR.W    R4,??DataTable66_3
        LDR      R4,[R4, #+28]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R5,R0,#+1
        MULS     R4,R5,R4
        MLA      R2,R3,R2,R4
        ADDS     R2,R2,#+1000
        SDIV     R1,R1,R2
        LDR.W    R2,??DataTable66_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R2,R2,R0, LSL #+3
        STR      R1,[R2, #+4]
// 12453         }       
// 12454       }
// 12455       
// 12456       if(row == BlackLeftHeadLine) break;
??BlackUdis_4:
        LDR.W    R1,??DataTable65_4
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BNE.W    ??BlackUdis_2
// 12457     }
// 12458   }
// 12459   else
// 12460   {    
// 12461   }
// 12462   
// 12463   //对右黑线的畸变矫正
// 12464   if(BlackRightDone == 1)
??BlackUdis_0:
        LDR.W    R0,??DataTable65_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??BlackUdis_6
// 12465   {
// 12466     //从线尾到线头。
// 12467     for(row = BlackRightEndLine; ; row--)
        LDR.W    R0,??DataTable65_9
        LDRB     R0,[R0, #+0]
        B.N      ??BlackUdis_7
??BlackUdis_8:
        SUBS     R0,R0,#+1
// 12468     {
// 12469       //近处的行
// 12470       if(row > BlackUdisMiddleLine)
??BlackUdis_7:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+39
        BLT.N    ??BlackUdis_9
// 12471       {
// 12472         //列
// 12473         BlackUdisRightLocation[row].x  = (BlackUdisMatrixLow[0] * BlackRightLoc[row][0] + BlackUdisMatrixLow[1] * (row + 1) + BlackUdisMatrixLow[2]) 
// 12474                                        / (BlackUdisMatrixLow[6] * BlackRightLoc[row][0] + BlackUdisMatrixLow[7] * (row + 1) + 1000);
        LDR.W    R1,??DataTable66
        LDR      R1,[R1, #+0]
        LDR.W    R2,??DataTable65_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable66
        LDR      R3,[R3, #+4]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R4,R0,#+1
        MULS     R3,R4,R3
        MLA      R1,R2,R1,R3
        LDR.W    R2,??DataTable66
        LDR      R2,[R2, #+8]
        ADDS     R1,R2,R1
        LDR.W    R2,??DataTable66
        LDR      R2,[R2, #+24]
        LDR.W    R3,??DataTable65_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R0,R3
        LDRB     R3,[R3, #+0]
        LDR.W    R4,??DataTable66
        LDR      R4,[R4, #+28]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R5,R0,#+1
        MULS     R4,R5,R4
        MLA      R2,R3,R2,R4
        ADDS     R2,R2,#+1000
        SDIV     R1,R1,R2
        LDR.W    R2,??DataTable66_4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STR      R1,[R2, R0, LSL #+3]
// 12475         //行
// 12476         BlackUdisRightLocation[row].y  = (BlackUdisMatrixLow[3] * BlackRightLoc[row][0] + BlackUdisMatrixLow[4] * (row + 1) + BlackUdisMatrixLow[5]) 
// 12477                                        / (BlackUdisMatrixLow[6] * BlackRightLoc[row][0] + BlackUdisMatrixLow[7] * (row + 1) + 1000);
        LDR.W    R1,??DataTable66
        LDR      R1,[R1, #+12]
        LDR.W    R2,??DataTable65_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable66
        LDR      R3,[R3, #+16]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R4,R0,#+1
        MULS     R3,R4,R3
        MLA      R1,R2,R1,R3
        LDR.W    R2,??DataTable66
        LDR      R2,[R2, #+20]
        ADDS     R1,R2,R1
        LDR.W    R2,??DataTable66
        LDR      R2,[R2, #+24]
        LDR.W    R3,??DataTable65_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R0,R3
        LDRB     R3,[R3, #+0]
        LDR.W    R4,??DataTable66
        LDR      R4,[R4, #+28]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R5,R0,#+1
        MULS     R4,R5,R4
        MLA      R2,R3,R2,R4
        ADDS     R2,R2,#+1000
        SDIV     R1,R1,R2
        LDR.W    R2,??DataTable66_4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R2,R2,R0, LSL #+3
        STR      R1,[R2, #+4]
        B.N      ??BlackUdis_10
// 12478       }
// 12479       else
// 12480       {
// 12481         //中间的行
// 12482         if(row > BlackUdisFarLine)
??BlackUdis_9:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+19
        BLT.N    ??BlackUdis_11
// 12483         {
// 12484           //列
// 12485           BlackUdisRightLocation[row].x  = (BlackUdisMatrixMiddle[0] * BlackRightLoc[row][0] + BlackUdisMatrixMiddle[1] * (row + 1) + BlackUdisMatrixMiddle[2]) 
// 12486                                          / (BlackUdisMatrixMiddle[6] * BlackRightLoc[row][0] + BlackUdisMatrixMiddle[7] * (row + 1) + 1000);
        LDR.W    R1,??DataTable66_2
        LDR      R1,[R1, #+0]
        LDR.W    R2,??DataTable65_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable66_2
        LDR      R3,[R3, #+4]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R4,R0,#+1
        MULS     R3,R4,R3
        MLA      R1,R2,R1,R3
        LDR.W    R2,??DataTable66_2
        LDR      R2,[R2, #+8]
        ADDS     R1,R2,R1
        LDR.W    R2,??DataTable66_2
        LDR      R2,[R2, #+24]
        LDR.W    R3,??DataTable65_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R0,R3
        LDRB     R3,[R3, #+0]
        LDR.W    R4,??DataTable66_2
        LDR      R4,[R4, #+28]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R5,R0,#+1
        MULS     R4,R5,R4
        MLA      R2,R3,R2,R4
        ADDS     R2,R2,#+1000
        SDIV     R1,R1,R2
        LDR.W    R2,??DataTable66_4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STR      R1,[R2, R0, LSL #+3]
// 12487           //行
// 12488           BlackUdisRightLocation[row].y  = (BlackUdisMatrixMiddle[3] * BlackRightLoc[row][0] + BlackUdisMatrixMiddle[4] * (row + 1) + BlackUdisMatrixMiddle[5]) 
// 12489                                          / (BlackUdisMatrixMiddle[6] * BlackRightLoc[row][0] + BlackUdisMatrixMiddle[7] * (row + 1) + 1000);     
        LDR.W    R1,??DataTable66_2
        LDR      R1,[R1, #+12]
        LDR.W    R2,??DataTable65_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable66_2
        LDR      R3,[R3, #+16]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R4,R0,#+1
        MULS     R3,R4,R3
        MLA      R1,R2,R1,R3
        LDR.W    R2,??DataTable66_2
        LDR      R2,[R2, #+20]
        ADDS     R1,R2,R1
        LDR.W    R2,??DataTable66_2
        LDR      R2,[R2, #+24]
        LDR.N    R3,??DataTable65_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R0,R3
        LDRB     R3,[R3, #+0]
        LDR.W    R4,??DataTable66_2
        LDR      R4,[R4, #+28]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R5,R0,#+1
        MULS     R4,R5,R4
        MLA      R2,R3,R2,R4
        ADDS     R2,R2,#+1000
        SDIV     R1,R1,R2
        LDR.W    R2,??DataTable66_4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R2,R2,R0, LSL #+3
        STR      R1,[R2, #+4]
        B.N      ??BlackUdis_10
// 12490         }
// 12491         //远处的行
// 12492         else
// 12493         {
// 12494           //列
// 12495           BlackUdisRightLocation[row].x  = (BlackUdisMatrixFar[0] * BlackRightLoc[row][0] + BlackUdisMatrixFar[1] * (row + 1) + BlackUdisMatrixFar[2]) 
// 12496                                          / (BlackUdisMatrixFar[6] * BlackRightLoc[row][0] + BlackUdisMatrixFar[7] * (row + 1) + 1000);
??BlackUdis_11:
        LDR.W    R1,??DataTable66_3
        LDR      R1,[R1, #+0]
        LDR.N    R2,??DataTable65_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable66_3
        LDR      R3,[R3, #+4]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R4,R0,#+1
        MULS     R3,R4,R3
        MLA      R1,R2,R1,R3
        LDR.W    R2,??DataTable66_3
        LDR      R2,[R2, #+8]
        ADDS     R1,R2,R1
        LDR.W    R2,??DataTable66_3
        LDR      R2,[R2, #+24]
        LDR.N    R3,??DataTable65_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R0,R3
        LDRB     R3,[R3, #+0]
        LDR.W    R4,??DataTable66_3
        LDR      R4,[R4, #+28]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R5,R0,#+1
        MULS     R4,R5,R4
        MLA      R2,R3,R2,R4
        ADDS     R2,R2,#+1000
        SDIV     R1,R1,R2
        LDR.W    R2,??DataTable66_4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STR      R1,[R2, R0, LSL #+3]
// 12497           //行
// 12498           BlackUdisRightLocation[row].y  = (BlackUdisMatrixFar[3] * BlackRightLoc[row][0] + BlackUdisMatrixFar[4] * (row + 1) + BlackUdisMatrixFar[5]) 
// 12499                                          / (BlackUdisMatrixFar[6] * BlackRightLoc[row][0] + BlackUdisMatrixFar[7] * (row + 1) + 1000);          
        LDR.W    R1,??DataTable66_3
        LDR      R1,[R1, #+12]
        LDR.N    R2,??DataTable65_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        LDRB     R2,[R2, #+0]
        LDR.W    R3,??DataTable66_3
        LDR      R3,[R3, #+16]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R4,R0,#+1
        MULS     R3,R4,R3
        MLA      R1,R2,R1,R3
        LDR.W    R2,??DataTable66_3
        LDR      R2,[R2, #+20]
        ADDS     R1,R2,R1
        LDR.W    R2,??DataTable66_3
        LDR      R2,[R2, #+24]
        LDR.N    R3,??DataTable65_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R4,#+3
        MLA      R3,R4,R0,R3
        LDRB     R3,[R3, #+0]
        LDR.W    R4,??DataTable66_3
        LDR      R4,[R4, #+28]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R5,R0,#+1
        MULS     R4,R5,R4
        MLA      R2,R3,R2,R4
        ADDS     R2,R2,#+1000
        SDIV     R1,R1,R2
        LDR.W    R2,??DataTable66_4
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R2,R2,R0, LSL #+3
        STR      R1,[R2, #+4]
// 12500         }       
// 12501       }
// 12502       
// 12503       if(row == BlackRightHeadLine) break;
??BlackUdis_10:
        LDR.W    R1,??DataTable67
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BNE.W    ??BlackUdis_8
// 12504     }
// 12505   }
// 12506   else
// 12507   {
// 12508   }
// 12509   
// 12510   return 1;
??BlackUdis_6:
        MOVS     R0,#+1
        POP      {R4,R5}
        BX       LR               ;; return
// 12511 }
// 12512 
// 12513 
// 12514 //直角弯时，对中心线的特殊处理函数。
// 12515 //放在ImgProSucceedDeal()函数里有DeviFuse更新函数的后面，强制修改DeviFuse的值，不影响CenterLineLoc[]数组。
// 12516 //直角弯锁存或特殊控制时，CenterLineLoc[]数组一直是无效值。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 12517 uint8 AngleSpeDealCen(uint8 dir)
// 12518 {
// 12519   //左直角弯
// 12520   if(dir == 0)
AngleSpeDealCen:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+0
        BNE.N    ??AngleSpeDealCen_0
// 12521   {
// 12522     //对DeviNow的特殊赋值。影响舵机控制。
// 12523     DeviFuse = AngleSpeDealDeviNow[AngleSpeDealBackCountNum-AngleSpeDealBackCount-1];
        LDR.W    R0,??DataTable67_1
        LDR.W    R1,??DataTable67_2
        LDRB     R1,[R1, #+0]
        RSBS     R1,R1,#+0
        ADDS     R0,R0,R1, LSL #+1
        LDRSH    R0,[R0, #+28]
        LDR.W    R1,??DataTable67_3
        STR      R0,[R1, #+0]
// 12524     //对DeviNowLevel的特殊赋值。影响舵机和电机控制。
// 12525     //DeviNowLevel = AngleSpeDealDeviNowLevel[AngleSpeDealBackCountNum-AngleSpeDealBackCount-1];
// 12526     ////对SlopeC的特殊赋值。影响SlopeCLevel。影响电机控制。
// 12527     SlopeC = AngleSpeDealSlopeC[AngleSpeDealBackCountNum-AngleSpeDealBackCount-1];
        LDR.W    R0,??DataTable67_4
        LDR.W    R1,??DataTable67_2
        LDRB     R1,[R1, #+0]
        RSBS     R1,R1,#+0
        ADDS     R0,R0,R1, LSL #+2
        LDR      R0,[R0, #+56]
        LDR.W    R1,??DataTable67_5
        STR      R0,[R1, #+0]
        B.N      ??AngleSpeDealCen_1
// 12528   }
// 12529   //右直角弯
// 12530   else if(dir == 1)
??AngleSpeDealCen_0:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+1
        BNE.N    ??AngleSpeDealCen_1
// 12531   {
// 12532     //对DeviNow的特殊赋值。影响舵机控制。
// 12533     DeviFuse = 0 - AngleSpeDealDeviNow[AngleSpeDealBackCountNum-AngleSpeDealBackCount-1];
        LDR.W    R0,??DataTable67_1
        LDR.W    R1,??DataTable67_2
        LDRB     R1,[R1, #+0]
        RSBS     R1,R1,#+0
        ADDS     R0,R0,R1, LSL #+1
        LDRSH    R0,[R0, #+28]
        RSBS     R0,R0,#+0
        LDR.W    R1,??DataTable67_3
        STR      R0,[R1, #+0]
// 12534     //对DeviNowLevel的特殊赋值。影响舵机和电机控制。
// 12535     //DeviNowLevel = AngleSpeDealDeviNowLevel[AngleSpeDealBackCountNum-AngleSpeDealBackCount-1];
// 12536     //对SlopeC的特殊赋值。影响SlopeCLevel。影响电机控制。
// 12537     SlopeC = AngleSpeDealSlopeC[AngleSpeDealBackCountNum-AngleSpeDealBackCount-1];    
        LDR.W    R0,??DataTable67_4
        LDR.W    R1,??DataTable67_2
        LDRB     R1,[R1, #+0]
        RSBS     R1,R1,#+0
        ADDS     R0,R0,R1, LSL #+2
        LDR      R0,[R0, #+56]
        LDR.W    R1,??DataTable67_5
        STR      R0,[R1, #+0]
// 12538   }
// 12539   //错误
// 12540   else
// 12541   {    
// 12542   }
// 12543   
// 12544   return 1;
??AngleSpeDealCen_1:
        MOVS     R0,#+1
        BX       LR               ;; return
// 12545 }
// 12546 
// 12547 
// 12548 //出直角弯判断，1已出，0未出

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 12549 uint8 AngleSpeDealExitJudge(void)
// 12550 {
AngleSpeDealExitJudge:
        PUSH     {R7,LR}
// 12551   //至少要进行AngleSpeDealBackCountMin次强制控制。
// 12552   if(AngleSpeDealBackCountNum - AngleSpeDealBackCount < AngleSpeDealBackCountMin)
        LDR.W    R0,??DataTable67_2
        LDRB     R0,[R0, #+0]
        RSBS     R0,R0,#+15
        CMP      R0,#+8
        BGE.N    ??AngleSpeDealExitJudge_0
// 12553   {
// 12554     return 0;
        MOVS     R0,#+0
        B.N      ??AngleSpeDealExitJudge_1
// 12555   }
// 12556   else
// 12557   {
// 12558   }
// 12559   
// 12560   //退出强制控制的条件，左右线均成功，均左右线斜率绝对值小于一定值。
// 12561   if(
// 12562      (BlackLeftDone == 1)
// 12563    &&(BlackRightDone == 1)
// 12564    &&(AbsInt(SlopeL) < AngelSpeDealExitSlope)
// 12565    &&(AbsInt(SlopeR) < AngelSpeDealExitSlope)
// 12566      )
??AngleSpeDealExitJudge_0:
        LDR.N    R0,??DataTable65_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??AngleSpeDealExitJudge_2
        LDR.N    R0,??DataTable65_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??AngleSpeDealExitJudge_2
        LDR.W    R0,??DataTable67_6
        LDR      R0,[R0, #+0]
        BL       AbsInt
        MOVW     R1,#+3000
        CMP      R0,R1
        BGE.N    ??AngleSpeDealExitJudge_2
        LDR.W    R0,??DataTable67_7
        LDR      R0,[R0, #+0]
        BL       AbsInt
        MOVW     R1,#+3000
        CMP      R0,R1
        BGE.N    ??AngleSpeDealExitJudge_2
// 12567   {
// 12568     return 1;
        MOVS     R0,#+1
        B.N      ??AngleSpeDealExitJudge_1
// 12569   }
// 12570   else
// 12571   {
// 12572     return 0;
??AngleSpeDealExitJudge_2:
        MOVS     R0,#+0
??AngleSpeDealExitJudge_1:
        POP      {R1,PC}          ;; return
// 12573   }
// 12574   
// 12575   /*
// 12576   //看到了2条线，可以判断已经出了直角弯。
// 12577   if(BlackLeftDone == 1 && BlackRightDone == 1)
// 12578   {
// 12579     return 1;
// 12580   }
// 12581   else
// 12582   {
// 12583   }
// 12584   
// 12585   //AngleSpeDealDir所在线的斜率超过了AngelSpeDealExitSlope，也可以把控制权交给常规控制了。
// 12586   if(AngleSpeDealDir == 0)
// 12587   {
// 12588     //左直角弯。
// 12589     if(SlopeR >= AngelSpeDealExitSlope)
// 12590     {
// 12591       return 1;
// 12592     }
// 12593     else
// 12594     {
// 12595     }
// 12596   }
// 12597   else if(AngleSpeDealDir == 1)
// 12598   {
// 12599     //右直角弯。
// 12600     if(SlopeL >= AngelSpeDealExitSlope)
// 12601     {
// 12602       return 1;
// 12603     }
// 12604     else
// 12605     {
// 12606     }    
// 12607   }
// 12608   else
// 12609   {
// 12610   }
// 12611 
// 12612   return 0;
// 12613   */
// 12614 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable64:
        DC32     CURVEC
// 12615 
// 12616 //直角弯确认函数。确认多次能才确认是直角弯，并作相应操作。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 12617 uint8 AngleStep2Confirm(void)
// 12618 {          
AngleStep2Confirm:
        PUSH     {R7,LR}
// 12619   uint8 i;
// 12620   
// 12621   //用的是上一次的实时速度等级值，虽然没用这一次的，但也应该差别不大。
// 12622   //QuadSpeedLevel共10个等级，0低速9高速。目前确认次数只分2级。可以继续细分。
// 12623   /*
// 12624   if(QuadSpeedLevel >= 5)
// 12625   {
// 12626     //高速，确认次数相对较少 。
// 12627     realConfirmNum = 5;
// 12628   }
// 12629   else
// 12630   {
// 12631     //低速，确认次数相对较多。
// 12632     realConfirmNum = 10;
// 12633   }
// 12634   */
// 12635   ///////////////////////////////////暂时先不用。等测试值出来了再用。
// 12636 
// 12637   //A次计数内有B次直角成功，则判断为直角弯。先入先出队列。
// 12638   //直角锁存没被置位时，才直角计数，若已被置位，不用直角计数。
// 12639   if(AngleConfirmLockFlag == 0)
        LDR.W    R0,??DataTable67_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??AngleStep2Confirm_0
// 12640   {
// 12641     for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??AngleStep2Confirm_1
??AngleStep2Confirm_2:
        ADDS     R0,R0,#+1
// 12642     {
// 12643       AngleConfirmMat[i] = AngleConfirmMat[i + 1];
??AngleStep2Confirm_1:
        LDR.W    R1,??DataTable67_9
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R1,R0,R1
        LDRB     R1,[R1, #+1]
        LDR.W    R2,??DataTable67_9
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 12644       if(i == AngleConfirmMatNum - 2) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+4
        BNE.N    ??AngleStep2Confirm_2
// 12645     }
// 12646     //成功
// 12647     if(PathType == PathTypeAngleL || PathType == PathTypeAngleR)
        LDR.W    R0,??DataTable67_10
        LDRB     R0,[R0, #+0]
        CMP      R0,#+4
        BEQ.N    ??AngleStep2Confirm_3
        LDR.W    R0,??DataTable67_10
        LDRB     R0,[R0, #+0]
        CMP      R0,#+5
        BNE.N    ??AngleStep2Confirm_4
// 12648     {
// 12649       //判定为直角则新来的值置1。
// 12650       AngleConfirmMat[AngleConfirmMatNum - 1] = 1;
??AngleStep2Confirm_3:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable67_9
        STRB     R0,[R1, #+5]
        B.N      ??AngleStep2Confirm_5
// 12651     }
// 12652     else
// 12653     {
// 12654       //判定为非直角则新来的值置0.
// 12655       AngleConfirmMat[AngleConfirmMatNum - 1] = 0;
??AngleStep2Confirm_4:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable67_9
        STRB     R0,[R1, #+5]
// 12656     }
// 12657     //收集AngleConfirmMat数组里1的个数。
// 12658     AngleConfirmMatCollect = 0;
??AngleStep2Confirm_5:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable67_11
        STRB     R0,[R1, #+0]
// 12659     for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??AngleStep2Confirm_6
??AngleStep2Confirm_7:
        ADDS     R0,R0,#+1
// 12660     {
// 12661       if(AngleConfirmMat[i] == 1) AngleConfirmMatCollect++;
??AngleStep2Confirm_6:
        LDR.W    R1,??DataTable67_9
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDRB     R1,[R0, R1]
        CMP      R1,#+1
        BNE.N    ??AngleStep2Confirm_8
        LDR.W    R1,??DataTable67_11
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+1
        LDR.W    R2,??DataTable67_11
        STRB     R1,[R2, #+0]
// 12662       
// 12663       if(i == AngleConfirmMatNum - 1) break;
??AngleStep2Confirm_8:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+5
        BNE.N    ??AngleStep2Confirm_7
// 12664     }
// 12665   }
// 12666   //直角锁存标志位已被置位，不用直角计数。
// 12667   else
// 12668   {
// 12669   }
// 12670   
// 12671   //大于若干次，则锁存为直角。
// 12672   if(AngleConfirmMatCollect >= AngleConfirmMatLimit)
??AngleStep2Confirm_0:
        LDR.W    R0,??DataTable67_11
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable67_12
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCC.N    ??AngleStep2Confirm_9
// 12673   {
// 12674     //锁存标志位置位。
// 12675     AngleConfirmLockFlag = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable67_8
        STRB     R0,[R1, #+0]
// 12676     //数组清空，防止重复锁存。
// 12677     for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??AngleStep2Confirm_10
??AngleStep2Confirm_11:
        ADDS     R0,R0,#+1
// 12678     {
// 12679       AngleConfirmMat[i] = 0;
??AngleStep2Confirm_10:
        MOVS     R1,#+0
        LDR.W    R2,??DataTable67_9
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 12680       if(i == AngleConfirmMatNum - 1) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+5
        BNE.N    ??AngleStep2Confirm_11
// 12681     }
// 12682     //确认直角弯的方向。
// 12683     if(PathType == PathTypeAngleL)
        LDR.W    R0,??DataTable67_10
        LDRB     R0,[R0, #+0]
        CMP      R0,#+4
        BNE.N    ??AngleStep2Confirm_12
// 12684     {
// 12685       AngleSpeDealDir = 0;             //左直角弯
        MOVS     R0,#+0
        LDR.W    R1,??DataTable67_13
        STRB     R0,[R1, #+0]
        B.N      ??AngleStep2Confirm_9
// 12686     }
// 12687     else if(PathType == PathTypeAngleR)
??AngleStep2Confirm_12:
        LDR.W    R0,??DataTable67_10
        LDRB     R0,[R0, #+0]
        CMP      R0,#+5
        BNE.N    ??AngleStep2Confirm_9
// 12688     {
// 12689       AngleSpeDealDir = 1;             //右直角弯
        MOVS     R0,#+1
        LDR.W    R1,??DataTable67_13
        STRB     R0,[R1, #+0]
// 12690     }
// 12691     else
// 12692     {
// 12693       //AngleSpeDealDir = 2;             //错误
// 12694     }
// 12695   }
// 12696   else
// 12697   {
// 12698   }
// 12699   
// 12700   //若直角弯锁存标志位置位，则等待矮线的线头够低后开始直角弯处理。
// 12701   if(AngleConfirmLockFlag == 1)
??AngleStep2Confirm_9:
        LDR.W    R0,??DataTable67_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??AngleStep2Confirm_13
// 12702   {
// 12703     //直角黑块锁存标志位清零。但因为直角锁存置位，所以直角黑块不会进行检测。
// 12704     AngleZoneConfirmLockFlag = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable67_14
        STRB     R0,[R1, #+0]
// 12705     
// 12706     //左直角弯
// 12707     if(AngleSpeDealDir == 0)
        LDR.W    R0,??DataTable67_13
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??AngleStep2Confirm_14
// 12708     {
// 12709       if(BlackLeftHeadLine >= AngleSpeDealStartHeadLine || BlackLeftHeadLine == MaxValUint8)
        LDR.N    R0,??DataTable65_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+40
        BGE.N    ??AngleStep2Confirm_15
        LDR.N    R0,??DataTable65_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??AngleStep2Confirm_13
// 12710       {
// 12711         //左线头够矮（快到直角弯）或者左线头无效（已经过了直角弯），则开始直角弯特殊处理。
// 12712         AngleSpeDealBackCount = AngleSpeDealBackCountNum;
??AngleStep2Confirm_15:
        MOVS     R0,#+15
        LDR.W    R1,??DataTable67_2
        STRB     R0,[R1, #+0]
        B.N      ??AngleStep2Confirm_13
// 12713       }
// 12714       else
// 12715       {
// 12716         //还没满足条件，再等等。
// 12717       }
// 12718     }
// 12719     //右直角弯
// 12720     else if(AngleSpeDealDir == 1)
??AngleStep2Confirm_14:
        LDR.W    R0,??DataTable67_13
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??AngleStep2Confirm_13
// 12721     {
// 12722       if(BlackRightHeadLine >= AngleSpeDealStartHeadLine || BlackRightHeadLine == MaxValUint8)
        LDR.N    R0,??DataTable65_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+40
        BGE.N    ??AngleStep2Confirm_16
        LDR.N    R0,??DataTable65_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BNE.N    ??AngleStep2Confirm_13
// 12723       {
// 12724         //右线头够矮（快到直角弯）或者右线头无效（已经过了直角弯），则开始直角弯特殊处理。
// 12725         AngleSpeDealBackCount = AngleSpeDealBackCountNum;
??AngleStep2Confirm_16:
        MOVS     R0,#+15
        LDR.W    R1,??DataTable67_2
        STRB     R0,[R1, #+0]
// 12726       }
// 12727       else
// 12728       {
// 12729         //还没满足条件，再等等。
// 12730       }
// 12731     }
// 12732     else
// 12733     {
// 12734     }
// 12735   }
// 12736   else
// 12737   {
// 12738   }
// 12739 
// 12740   //退出直角特殊处理的判断。
// 12741   AngleSpeDealExitJudgeFlag = AngleSpeDealExitJudge();
??AngleStep2Confirm_13:
        BL       AngleSpeDealExitJudge
        LDR.W    R1,??DataTable67_15
        STRB     R0,[R1, #+0]
// 12742   
// 12743   //有了倒数次数后，就开始每次倒数，直到为0或判断已经出了直角。并持续亮灯。
// 12744   if(AngleSpeDealBackCount != 0 && AngleSpeDealExitJudgeFlag == 0)
        LDR.W    R0,??DataTable67_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??AngleStep2Confirm_17
        LDR.W    R0,??DataTable67_15
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??AngleStep2Confirm_17
// 12745   {
// 12746     AngleConfirmLockFlag = 0;    //直角弯判断成功锁存标志位清零。
        MOVS     R0,#+0
        LDR.W    R1,??DataTable67_8
        STRB     R0,[R1, #+0]
// 12747     
// 12748     //倒数值减1。
// 12749     AngleSpeDealBackCount--;
        LDR.W    R0,??DataTable67_2
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        LDR.W    R1,??DataTable67_2
        STRB     R0,[R1, #+0]
// 12750     //对中心线的特殊处理函数，还剩AngleSpeDealBackCount次。
// 12751     AngleSpeDealCen(AngleSpeDealDir);
        LDR.W    R0,??DataTable67_13
        LDRB     R0,[R0, #+0]
        BL       AngleSpeDealCen
// 12752     //标志位说明进行了直角弯的特殊处理。
// 12753     AngleSpeDealFlag = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable67_16
        STRB     R0,[R1, #+0]
// 12754     
// 12755     //直角黑块锁存标志位清零。但因为直角锁存置位，所以直角黑块不会进行检测。
// 12756     AngleZoneConfirmLockFlag = 0;    
        MOVS     R0,#+0
        LDR.W    R1,??DataTable67_14
        STRB     R0,[R1, #+0]
        B.N      ??AngleStep2Confirm_18
// 12757   }
// 12758   else
// 12759   {
// 12760     //倒数次数清零，防止再次启动直角弯特殊处理。
// 12761     AngleSpeDealBackCount = 0;
??AngleStep2Confirm_17:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable67_2
        STRB     R0,[R1, #+0]
// 12762     
// 12763     //标志位说明没有进行直角弯的特殊处理。
// 12764     AngleSpeDealFlag = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable67_16
        STRB     R0,[R1, #+0]
// 12765   }
// 12766   
// 12767   return 1;
??AngleStep2Confirm_18:
        MOVS     R0,#+1
        POP      {R1,PC}          ;; return
// 12768 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable65:
        DC32     BlackLeftLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable65_1:
        DC32     BlackRightLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable65_2:
        DC32     BlackLeftDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable65_3:
        DC32     BlackRightDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable65_4:
        DC32     BlackLeftHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable65_5:
        DC32     BlackLeftEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable65_6:
        DC32     PathSmallSDoneFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable65_7:
        DC32     PathSmallSDir

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable65_8:
        DC32     BlackRightHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable65_9:
        DC32     BlackRightEndLine
// 12769 
// 12770 
// 12771 
// 12772 
// 12773 
// 12774 
// 12775 
// 12776 
// 12777 
// 12778 //赛道类型判断中的直道判断
// 12779 //1是直道，0不是直道

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 12780 uint8 PathJudgeNewStraight(void)
// 12781 {
PathJudgeNewStraight:
        PUSH     {R4,LR}
// 12782   uint8 templ, tempr;
// 12783   uint8 i;
// 12784   uint8 errorcount;
// 12785   
// 12786   
// 12787   //直道判断
// 12788   //1. 直道的判断很严格，必须左右线均成功，且整个小5点斜率数组均很小。
// 12789   if(BlackLeftDone == 1 && BlackRightDone == 1)
        LDR.W    R0,??DataTable67_17
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??PathJudgeNewStraight_0
        LDR.W    R0,??DataTable67_18
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.W    ??PathJudgeNewStraight_0
// 12790   {
// 12791     //2. 直道还必须要求，线头为最低行。考虑到第56-59行会先找单线，不一定能成功，所以非起始扫描线放宽到第55行。
// 12792     if(BlackGetPreDir == 0 || BlackGetPreDir == 2)
        LDR.W    R0,??DataTable67_19
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??PathJudgeNewStraight_1
        LDR.W    R0,??DataTable67_19
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BNE.N    ??PathJudgeNewStraight_2
// 12793     {
// 12794       if(BlackLeftStep1ScanRow == CameraHight - 1 && BlackRightStep1ScanRow >= CameraHight - 5)
??PathJudgeNewStraight_1:
        LDR.W    R0,??DataTable67_20
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BNE.N    ??PathJudgeNewStraight_3
        LDR.W    R0,??DataTable67_21
        LDRB     R0,[R0, #+0]
        CMP      R0,#+55
        BGE.N    ??PathJudgeNewStraight_4
// 12795       {
// 12796       }
// 12797       else
// 12798       {
// 12799         return 0;
??PathJudgeNewStraight_3:
        MOVS     R0,#+0
        B.N      ??PathJudgeNewStraight_5
// 12800       }
// 12801     }
// 12802     else
// 12803     {
// 12804       if (BlackLeftStep1ScanRow >= CameraHight - 5 && BlackRightStep1ScanRow == CameraHight - 1)
??PathJudgeNewStraight_2:
        LDR.W    R0,??DataTable67_20
        LDRB     R0,[R0, #+0]
        CMP      R0,#+55
        BLT.N    ??PathJudgeNewStraight_6
        LDR.W    R0,??DataTable67_21
        LDRB     R0,[R0, #+0]
        CMP      R0,#+59
        BEQ.N    ??PathJudgeNewStraight_4
// 12805       {
// 12806       }
// 12807       else
// 12808       {
// 12809         return 0;
??PathJudgeNewStraight_6:
        MOVS     R0,#+0
        B.N      ??PathJudgeNewStraight_5
// 12810       }
// 12811     }
// 12812     //3. PathJudgeNewStraightChoose为0表示判断直道要用到所有的点，而不是掐头。
// 12813     //此种方法比较严格，会减小直道判断成功率，但不容易将其它赛道误判成直道。
// 12814     if(PathJudgeNewStraightChoose == 0)
// 12815     {
// 12816       errorcount = 0;
// 12817       //左线
// 12818       //搜索小5点斜率数组的末端
// 12819       templ = BlackLeft5SlopeIndex - 1;
// 12820       //if(templ <= 10) return 0;
// 12821       
// 12822       //逐个判断小5点斜率是否满足条件
// 12823       for(i = 0; ; i++)
// 12824       {
// 12825         if(BlackLeft5Slope[i] > 0 || BlackLeft5Slope[i] < 0 - PathJudgeStraightSlopeLimit) //右上到左下的斜率是负的。 
// 12826         {
// 12827           errorcount++;
// 12828           if(errorcount > 3) break;   //允许有若干个点斜率超出范围
// 12829         }
// 12830         
// 12831         //if(i == templ - 10) break;
// 12832         if(i == templ) break;
// 12833       }
// 12834       //if(i != templ - 10) 
// 12835       if(i != templ)
// 12836       {
// 12837         flag000 = 3;
// 12838         flag111 = BlackLeft5Slope[i];
// 12839         return 0;
// 12840       }
// 12841       
// 12842       errorcount = 0;
// 12843       //右线
// 12844       //搜索小5点斜率数组的末端
// 12845       tempr = BlackRight5SlopeIndex - 1;
// 12846       //if(tempr <= 10) return 0;
// 12847       
// 12848       //逐个判断小5点斜率是否满足条件
// 12849       for(i = 0; ; i++)
// 12850       {
// 12851         if(BlackRight5Slope[i] < 0 || BlackRight5Slope[i] > PathJudgeStraightSlopeLimit) //左上到右下的斜率是正的。
// 12852         {
// 12853           errorcount++;
// 12854           if(errorcount > 3) break;   //允许有若干个点斜率超出范围
// 12855         }
// 12856         
// 12857         //if(i == tempr - 10) break;
// 12858         if(i == tempr) break;
// 12859       }
// 12860       //if(i != tempr - 10)
// 12861       if(i != tempr)
// 12862       {
// 12863         flag111 = BlackRight5Slope[i];
// 12864         flag000 = 5;
// 12865         return 0;
// 12866       }
// 12867       
// 12868       //走到这里说明判断直道成功。
// 12869       flag000 = 0;
// 12870       PathType = PathTypeStraight;
// 12871       return 1;
// 12872     
// 12873     }
// 12874     //3. PathJudgeNewStraightChoose为1表示判断直道时掐掉线头开始往近行的10行，再判断。
// 12875     //此种方法能增加直道判断成功率，但容易将其它赛道误判成直道。
// 12876     else if(PathJudgeNewStraightChoose == 1)
// 12877     {
// 12878       errorcount = 0;
// 12879       //左线
// 12880       //搜索小5点斜率数组的末端
// 12881       templ = BlackLeft5SlopeIndex - 1;
// 12882       if(templ <= 10) return 0; //
// 12883       
// 12884       //逐个判断小5点斜率是否满足条件
// 12885       for(i = 0; ; i++)
// 12886       {
// 12887         if(BlackLeft5Slope[i] > 0 || BlackLeft5Slope[i] < 0 - PathJudgeStraightSlopeLimit) //右上到左下的斜率是负的。 
// 12888         {
// 12889           errorcount++;
// 12890           if(errorcount > 3) break;   //允许有若干个点斜率超出范围
// 12891         }
// 12892         
// 12893         if(i == templ - 10) break;
// 12894         //if(i == templ) break;
// 12895       }
// 12896       if(i != templ - 10) 
// 12897       //if(i != templ)
// 12898       {
// 12899         flag000 = 3;
// 12900         flag111 = BlackLeft5Slope[i];
// 12901         return 0;
// 12902       }
// 12903       
// 12904       errorcount = 0;
// 12905       //右线
// 12906       //搜索小5点斜率数组的末端
// 12907       tempr = BlackRight5SlopeIndex - 1;
// 12908       if(tempr <= 10) return 0;  //
// 12909       
// 12910       //逐个判断小5点斜率是否满足条件
// 12911       for(i = 0; ; i++)
// 12912       {
// 12913         if(BlackRight5Slope[i] < 0 || BlackRight5Slope[i] > PathJudgeStraightSlopeLimit) //左上到右下的斜率是正的。
// 12914         {
// 12915           errorcount++;
// 12916           if(errorcount > 3) break;   //允许有若干个点斜率超出范围
// 12917         }
// 12918         
// 12919         if(i == tempr - 10) break;
// 12920         //if(i == tempr) break;
// 12921       }
// 12922       if(i != tempr - 10) 
// 12923       //if(i != tempr)
// 12924       {
// 12925         flag111 = BlackRight5Slope[i];
// 12926         flag000 = 5;
// 12927         return 0;
// 12928       }
// 12929       
// 12930       //走到这里说明判断直道成功。
// 12931       flag000 = 0;
// 12932       PathType = PathTypeStraight;
// 12933       return 1;      
// 12934     }
// 12935     //3. PathJudgeNewStraightChoose为2表示判断直道要用到所有的点，而不是掐头。
// 12936     //此种方法比较严格，会减小直道判断成功率，但不容易将其它赛道误判成直道。
// 12937     //这种方法的厉害之处在于考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
// 12938     else
// 12939     {
// 12940       //不是单线的情况
// 12941       if(SingleBlackAllFlag == 0)
??PathJudgeNewStraight_4:
        LDR.W    R0,??DataTable67_22
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.W    ??PathJudgeNewStraight_7
// 12942       {
// 12943         errorcount = 0;
        MOVS     R4,#+0
// 12944         //左线
// 12945         //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
// 12946         if(BlackLeftEndLine - BlackLeftHeadLine - 4 < 0 || BlackLeft5SlopeIndex - 1 < 0)
        LDR.W    R0,??DataTable67_23
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable67_24
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+4
        CMP      R0,#+0
        BMI.N    ??PathJudgeNewStraight_8
        LDR.W    R0,??DataTable67_25
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        CMP      R0,#+0
        BPL.N    ??PathJudgeNewStraight_9
// 12947         {
// 12948           return 0;
??PathJudgeNewStraight_8:
        MOVS     R0,#+0
        B.N      ??PathJudgeNewStraight_5
// 12949         }
// 12950         else
// 12951         {        
// 12952         }
// 12953         templ = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 4, BlackLeft5SlopeIndex - 1);
??PathJudgeNewStraight_9:
        LDR.W    R0,??DataTable67_25
        LDRB     R0,[R0, #+0]
        SUBS     R1,R0,#+1
        LDR.W    R0,??DataTable67_23
        LDRB     R0,[R0, #+0]
        LDR.W    R2,??DataTable67_24
        LDRB     R2,[R2, #+0]
        SUBS     R0,R0,R2
        SUBS     R0,R0,#+4
        BL       MinRe
// 12954         //if(templ <= 10) return 0;
// 12955         
// 12956         //逐个判断小5点斜率是否满足条件
// 12957         for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??PathJudgeNewStraight_10
??PathJudgeNewStraight_11:
        ADDS     R1,R1,#+1
// 12958         {
// 12959           if(BlackLeft5Slope[i] > 0 || BlackLeft5Slope[i] < 0 - PathJudgeStraightSlopeLimit) //右上到左下的斜率是负的。 
??PathJudgeNewStraight_10:
        LDR.W    R2,??DataTable67_26
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R2,[R2, R1, LSL #+2]
        ADDW     R2,R2,#+2100
        MOVW     R3,#+2101
        CMP      R2,R3
        BCC.N    ??PathJudgeNewStraight_12
// 12960           {
// 12961             errorcount++;
        ADDS     R4,R4,#+1
// 12962             if(errorcount > 3) break;   //允许有若干个点斜率超出范围
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+4
        BGE.N    ??PathJudgeNewStraight_13
// 12963           }
// 12964           
// 12965           //if(i == templ - 10) break;
// 12966           if(i == templ) break;
??PathJudgeNewStraight_12:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BNE.N    ??PathJudgeNewStraight_11
// 12967         }
// 12968         //if(i != templ - 10) 
// 12969         if(i != templ)
??PathJudgeNewStraight_13:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BEQ.N    ??PathJudgeNewStraight_14
// 12970         {
// 12971           flag000 = 3;
        MOVS     R0,#+3
        LDR.W    R2,??DataTable67_27
        STRB     R0,[R2, #+0]
// 12972           flag111 = BlackLeft5Slope[i];
        LDR.W    R0,??DataTable67_26
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R0,[R0, R1, LSL #+2]
        LDR.W    R1,??DataTable67_28
        STR      R0,[R1, #+0]
// 12973           return 0;
        MOVS     R0,#+0
        B.N      ??PathJudgeNewStraight_5
// 12974         }
// 12975         
// 12976         errorcount = 0;
??PathJudgeNewStraight_14:
        MOVS     R4,#+0
// 12977         
// 12978         //右线
// 12979         //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
// 12980         if(BlackRightEndLine - BlackRightHeadLine - 4 < 0 || BlackRight5SlopeIndex - 1 < 0)
        LDR.W    R0,??DataTable67_29
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable67
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+4
        CMP      R0,#+0
        BMI.N    ??PathJudgeNewStraight_15
        LDR.W    R0,??DataTable67_30
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        CMP      R0,#+0
        BPL.N    ??PathJudgeNewStraight_16
// 12981         {
// 12982           return 0;
??PathJudgeNewStraight_15:
        MOVS     R0,#+0
        B.N      ??PathJudgeNewStraight_5
// 12983         }
// 12984         else
// 12985         {
// 12986         }
// 12987         tempr = MinRe(BlackRightEndLine - BlackRightHeadLine - 4, BlackRight5SlopeIndex - 1);
??PathJudgeNewStraight_16:
        LDR.W    R0,??DataTable67_30
        LDRB     R0,[R0, #+0]
        SUBS     R1,R0,#+1
        LDR.W    R0,??DataTable67_29
        LDRB     R0,[R0, #+0]
        LDR.W    R2,??DataTable67
        LDRB     R2,[R2, #+0]
        SUBS     R0,R0,R2
        SUBS     R0,R0,#+4
        BL       MinRe
// 12988         //if(tempr <= 10) return 0;
// 12989         
// 12990         //逐个判断小5点斜率是否满足条件
// 12991         for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??PathJudgeNewStraight_17
??PathJudgeNewStraight_18:
        ADDS     R1,R1,#+1
// 12992         {
// 12993           if(BlackRight5Slope[i] < 0 || BlackRight5Slope[i] > PathJudgeStraightSlopeLimit) //左上到右下的斜率是正的。
??PathJudgeNewStraight_17:
        LDR.W    R2,??DataTable67_31
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R2,[R2, R1, LSL #+2]
        SUBS     R2,R2,#+0
        MOVW     R3,#+2101
        CMP      R2,R3
        BCC.N    ??PathJudgeNewStraight_19
// 12994           {
// 12995             errorcount++;
        ADDS     R4,R4,#+1
// 12996             if(errorcount > 3) break;   //允许有若干个点斜率超出范围
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+4
        BGE.N    ??PathJudgeNewStraight_20
// 12997           }
// 12998           
// 12999           //if(i == tempr - 10) break;
// 13000           if(i == tempr) break;
??PathJudgeNewStraight_19:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BNE.N    ??PathJudgeNewStraight_18
// 13001         }
// 13002         //if(i != tempr - 10)
// 13003         if(i != tempr)
??PathJudgeNewStraight_20:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BEQ.N    ??PathJudgeNewStraight_21
// 13004         {
// 13005           flag111 = BlackRight5Slope[i];
        LDR.W    R0,??DataTable67_31
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R0,[R0, R1, LSL #+2]
        LDR.W    R1,??DataTable67_28
        STR      R0,[R1, #+0]
// 13006           flag000 = 5;
        MOVS     R0,#+5
        LDR.W    R1,??DataTable67_27
        STRB     R0,[R1, #+0]
// 13007           return 0;
        MOVS     R0,#+0
        B.N      ??PathJudgeNewStraight_5
// 13008         }
// 13009         
// 13010         //走到这里说明判断直道成功。
// 13011         flag000 = 0;
??PathJudgeNewStraight_21:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable67_27
        STRB     R0,[R1, #+0]
// 13012         PathType = PathTypeStraight;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable67_10
        STRB     R0,[R1, #+0]
// 13013         return 1;   
        MOVS     R0,#+1
        B.N      ??PathJudgeNewStraight_5
// 13014       }
// 13015       //单线的情况
// 13016       else
// 13017       {
// 13018         errorcount = 0;
??PathJudgeNewStraight_7:
        MOVS     R4,#+0
// 13019         //左线
// 13020         //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
// 13021         if(BlackLeftEndLine - BlackLeftHeadLine - 4 < 0 || BlackLeft5SlopeIndex - 1 < 0)
        LDR.W    R0,??DataTable67_23
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable67_24
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+4
        CMP      R0,#+0
        BMI.N    ??PathJudgeNewStraight_22
        LDR.W    R0,??DataTable67_25
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        CMP      R0,#+0
        BPL.N    ??PathJudgeNewStraight_23
// 13022         {
// 13023           return 0;
??PathJudgeNewStraight_22:
        MOVS     R0,#+0
        B.N      ??PathJudgeNewStraight_5
// 13024         }
// 13025         else
// 13026         {        
// 13027         }
// 13028         templ = MinRe(BlackLeftEndLine - BlackLeftHeadLine - 4, BlackLeft5SlopeIndex - 1);
??PathJudgeNewStraight_23:
        LDR.W    R0,??DataTable67_25
        LDRB     R0,[R0, #+0]
        SUBS     R1,R0,#+1
        LDR.W    R0,??DataTable67_23
        LDRB     R0,[R0, #+0]
        LDR.W    R2,??DataTable67_24
        LDRB     R2,[R2, #+0]
        SUBS     R0,R0,R2
        SUBS     R0,R0,#+4
        BL       MinRe
// 13029         //if(templ <= 10) return 0;
// 13030         
// 13031         //逐个判断小5点斜率是否满足条件
// 13032         for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??PathJudgeNewStraight_24
??PathJudgeNewStraight_25:
        ADDS     R1,R1,#+1
// 13033         {
// 13034           if(BlackLeft5Slope[i] > 1001 || BlackLeft5Slope[i] < 0 - 1000) //右上到左下的斜率是负的。 
??PathJudgeNewStraight_24:
        LDR.W    R2,??DataTable67_26
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R2,[R2, R1, LSL #+2]
        ADDS     R2,R2,#+1000
        MOVW     R3,#+2002
        CMP      R2,R3
        BCC.N    ??PathJudgeNewStraight_26
// 13035           {
// 13036             errorcount++;
        ADDS     R4,R4,#+1
// 13037             if(errorcount > 3) break;   //允许有若干个点斜率超出范围
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+4
        BGE.N    ??PathJudgeNewStraight_27
// 13038           }
// 13039           
// 13040           //if(i == templ - 10) break;
// 13041           if(i == templ) break;
??PathJudgeNewStraight_26:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BNE.N    ??PathJudgeNewStraight_25
// 13042         }
// 13043         //if(i != templ - 10) 
// 13044         if(i != templ)
??PathJudgeNewStraight_27:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BEQ.N    ??PathJudgeNewStraight_28
// 13045         {
// 13046           flag000 = 3;
        MOVS     R0,#+3
        LDR.W    R2,??DataTable67_27
        STRB     R0,[R2, #+0]
// 13047           flag111 = BlackLeft5Slope[i];
        LDR.W    R0,??DataTable67_26
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R0,[R0, R1, LSL #+2]
        LDR.W    R1,??DataTable67_28
        STR      R0,[R1, #+0]
// 13048           return 0;
        MOVS     R0,#+0
        B.N      ??PathJudgeNewStraight_5
// 13049         }
// 13050         
// 13051         errorcount = 0;
??PathJudgeNewStraight_28:
        MOVS     R4,#+0
// 13052         
// 13053         //右线
// 13054         //考虑到了Black5Slope数组的个数与有效黑点不一定相同，大大减少了误判的机率。
// 13055         if(BlackRightEndLine - BlackRightHeadLine - 4 < 0 || BlackRight5SlopeIndex - 1 < 0)
        LDR.W    R0,??DataTable67_29
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable67
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+4
        CMP      R0,#+0
        BMI.N    ??PathJudgeNewStraight_29
        LDR.W    R0,??DataTable67_30
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
        CMP      R0,#+0
        BPL.N    ??PathJudgeNewStraight_30
// 13056         {
// 13057           return 0;
??PathJudgeNewStraight_29:
        MOVS     R0,#+0
        B.N      ??PathJudgeNewStraight_5
// 13058         }
// 13059         else
// 13060         {
// 13061         }
// 13062         tempr = MinRe(BlackRightEndLine - BlackRightHeadLine - 4, BlackRight5SlopeIndex - 1);
??PathJudgeNewStraight_30:
        LDR.W    R0,??DataTable67_30
        LDRB     R0,[R0, #+0]
        SUBS     R1,R0,#+1
        LDR.W    R0,??DataTable67_29
        LDRB     R0,[R0, #+0]
        LDR.W    R2,??DataTable67
        LDRB     R2,[R2, #+0]
        SUBS     R0,R0,R2
        SUBS     R0,R0,#+4
        BL       MinRe
// 13063         //if(tempr <= 10) return 0;
// 13064         
// 13065         //逐个判断小5点斜率是否满足条件
// 13066         for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??PathJudgeNewStraight_31
??PathJudgeNewStraight_32:
        ADDS     R1,R1,#+1
// 13067         {
// 13068           if(BlackRight5Slope[i] < 0 - 1001 || BlackRight5Slope[i] > 1000) //左上到右下的斜率是正的。
??PathJudgeNewStraight_31:
        LDR.W    R2,??DataTable67_31
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R2,[R2, R1, LSL #+2]
        ADDW     R2,R2,#+1001
        MOVW     R3,#+2002
        CMP      R2,R3
        BCC.N    ??PathJudgeNewStraight_33
// 13069           {
// 13070             errorcount++;
        ADDS     R4,R4,#+1
// 13071             if(errorcount > 3) break;   //允许有若干个点斜率超出范围
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+4
        BGE.N    ??PathJudgeNewStraight_34
// 13072           }
// 13073           
// 13074           //if(i == tempr - 10) break;
// 13075           if(i == tempr) break;
??PathJudgeNewStraight_33:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BNE.N    ??PathJudgeNewStraight_32
// 13076         }
// 13077         //if(i != tempr - 10)
// 13078         if(i != tempr)
??PathJudgeNewStraight_34:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R1,R0
        BEQ.N    ??PathJudgeNewStraight_35
// 13079         {
// 13080           flag111 = BlackRight5Slope[i];
        LDR.W    R0,??DataTable67_31
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDR      R0,[R0, R1, LSL #+2]
        LDR.W    R1,??DataTable67_28
        STR      R0,[R1, #+0]
// 13081           flag000 = 5;
        MOVS     R0,#+5
        LDR.W    R1,??DataTable67_27
        STRB     R0,[R1, #+0]
// 13082           return 0;
        MOVS     R0,#+0
        B.N      ??PathJudgeNewStraight_5
// 13083         }
// 13084         
// 13085         //走到这里说明判断直道成功。
// 13086         flag000 = 0;
??PathJudgeNewStraight_35:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable67_27
        STRB     R0,[R1, #+0]
// 13087         PathType = PathTypeStraight;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable67_10
        STRB     R0,[R1, #+0]
// 13088         return 1;           
        MOVS     R0,#+1
        B.N      ??PathJudgeNewStraight_5
// 13089       }
// 13090     }
// 13091   }
// 13092   else
// 13093   {
// 13094     flag000 = 1;
??PathJudgeNewStraight_0:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable67_27
        STRB     R0,[R1, #+0]
// 13095     //两线若有什么任何一线不成功，则不可能是直道，直接返回0.
// 13096     return 0;
        MOVS     R0,#+0
??PathJudgeNewStraight_5:
        POP      {R4,PC}          ;; return
// 13097   }
// 13098   
// 13099 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable66:
        DC32     BlackUdisMatrixLow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable66_1:
        DC32     BlackUdisLeftLocation

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable66_2:
        DC32     BlackUdisMatrixMiddle

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable66_3:
        DC32     BlackUdisMatrixFar

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable66_4:
        DC32     BlackUdisRightLocation
// 13100 
// 13101 //障碍判断
// 13102 //进来的前提是赛道类型为直道

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 13103 uint8 BrickJudge(void)
// 13104 {
BrickJudge:
        PUSH     {R4-R7,LR}
        SUB      SP,SP,#+20
// 13105   uint8 row;
// 13106   uint8 col;
// 13107   uint8 count1, count2, count3;
// 13108     
// 13109   int32 a0, a1;
// 13110   uint8 i, index, tempend;
// 13111   
// 13112   uint8 x[BrickSlopeRowNum];   //取多少个点在一开始有定义。
// 13113   uint8 y[BrickSlopeRowNum];
// 13114   
// 13115   if(BlackLeftDone == 1 && BlackRightDone == 1)
        LDR.W    R0,??DataTable67_17
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??BrickJudge_0
        LDR.W    R0,??DataTable67_18
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??BrickJudge_1
// 13116   {
// 13117   }
// 13118   else
// 13119   {
// 13120     return 0;
??BrickJudge_0:
        MOVS     R0,#+0
        B.N      ??BrickJudge_2
// 13121   }
// 13122   
// 13123   
// 13124   //左障碍查找，先看看满不满足基本条件。
// 13125   if(
// 13126     (BlackRightHeadLine > BrickHeadRow)                                         //右线头太近
// 13127   ||(BlackRightCrossDone != 0 && BlackRightRow1RealLastLine  > BrickHeadRow)    //右线开启了十字再检测，且第1段黑线起始行太近。
// 13128     )
??BrickJudge_1:
        LDR.W    R0,??DataTable67
        LDRB     R0,[R0, #+0]
        CMP      R0,#+16
        BGE.W    ??BrickJudge_3
        LDR.W    R0,??DataTable67_32
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??BrickJudge_4
        LDR.W    R0,??DataTable67_33
        LDRB     R0,[R0, #+0]
        CMP      R0,#+16
        BGE.W    ??BrickJudge_3
// 13129   {
// 13130     //不满足基本条件，更有可能是右障碍，直接跳过左障碍去检测右障碍。
// 13131   }
// 13132   else
// 13133   {
// 13134     //1.1 障碍边，最小二乘法计算扫描起始行和结束行的黑点所在列。
// 13135     //取BrickSlopeRowNum个点作为最小二乘法的基准点。
// 13136     //以左上角为原点，向下为x轴正方向，向右为y轴正方向
// 13137     index = 0;    
??BrickJudge_4:
        MOVS     R0,#+0
// 13138     for(i = BrickEndRow + 1; ; i++)
        MOVS     R1,#+36
        B.N      ??BrickJudge_5
??BrickJudge_6:
        ADDS     R1,R1,#+1
// 13139     {
// 13140       if(BlackLeftLoc[i][0] != MaxValUint8)
??BrickJudge_5:
        LDR.W    R2,??DataTable67_34
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BEQ.N    ??BrickJudge_7
// 13141       {
// 13142         y[index] = BlackLeftLoc[i][0];
        LDR.W    R2,??DataTable67_34
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        ADD      R3,SP,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R2,[R0, R3]
// 13143         x[index] = i;
        ADD      R2,SP,#+8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 13144         index++;
        ADDS     R0,R0,#+1
// 13145       }
// 13146       if(index == BrickSlopeRowNum)
??BrickJudge_7:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+8
        BNE.N    ??BrickJudge_8
// 13147       {
// 13148         break;  
// 13149       }
// 13150       if(i == CameraHight - 1)
// 13151       {
// 13152         return 0;
// 13153       }
// 13154     }
// 13155     
// 13156     //最小二乘法
// 13157     //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
// 13158     a1 = LeastSquarea1(x, y, BrickSlopeRowNum);
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea1
        MOVS     R4,R0
// 13159     //左边，斜率应该是-PathJudgeStraightSlopeLimit~0,否则斜率不对，返回失败。
// 13160     if(a1 < 0 && a1 + PathJudgeStraightSlopeLimit > 0)
        CMP      R4,#+0
        BPL.N    ??BrickJudge_9
        ADDW     R0,R4,#+2100
        CMP      R0,#+1
        BGE.N    ??BrickJudge_10
// 13161     {
// 13162     }
// 13163     else
// 13164     {
// 13165       return 0;
??BrickJudge_9:
        MOVS     R0,#+0
        B.N      ??BrickJudge_2
// 13166     }
??BrickJudge_8:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+59
        BNE.N    ??BrickJudge_6
        MOVS     R0,#+0
        B.N      ??BrickJudge_2
// 13167     a0 = LeastSquarea0(x, y, a1, BrickSlopeRowNum);
??BrickJudge_10:
        MOVS     R3,#+8
        MOVS     R2,R4
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea0
        MOVS     R5,R0
// 13168     //直角梯形的两个突出顶点所在列
// 13169     //起始行（近行）黑点所在列。
// 13170     BrickEndColL = (a0 + a1 * BrickEndRow) / LeastSquareMulti + BrickColCom;
        MOVS     R0,#+35
        MLA      R0,R0,R4,R5
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        ADDS     R0,R0,#+5
        LDR.W    R1,??DataTable68
        STRB     R0,[R1, #+0]
// 13171     //结束行（远行）黑点所在列
// 13172     BrickHeadColL = (a0 + a1 * BrickHeadRow) / LeastSquareMulti + BrickColCom;
        MOVS     R0,#+15
        MLA      R0,R0,R4,R5
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        ADDS     R0,R0,#+5
        LDR.W    R1,??DataTable68_1
        STRB     R0,[R1, #+0]
// 13173     //直角梯形的直角边所在列。左障碍扫描的右边界。稍微限幅一下。
// 13174     //不能超过图像右边界
// 13175     BrickBorderColL = MinRe(CameraRealWidth - 1, BrickEndColL + BrickScanColNum);
        LDR.W    R0,??DataTable68
        LDRB     R0,[R0, #+0]
        ADDS     R1,R0,#+60
        MOVS     R0,#+249
        BL       MinRe
        LDR.W    R1,??DataTable68_2
        STRB     R0,[R1, #+0]
// 13176     //不能超过该行右线黑点。
// 13177     if(BlackRightLoc[BrickEndRow][0] != MaxValUint8)
        LDR.W    R0,??DataTable68_3
        LDRB     R0,[R0, #+105]
        CMP      R0,#+255
        BEQ.N    ??BrickJudge_11
// 13178     {
// 13179       BrickBorderColL = MinRe(BrickBorderColL, BlackRightLoc[BrickEndRow][0]);
        LDR.W    R0,??DataTable68_3
        LDRB     R1,[R0, #+105]
        LDR.W    R0,??DataTable68_2
        LDRB     R0,[R0, #+0]
        BL       MinRe
        LDR.W    R1,??DataTable68_2
        STRB     R0,[R1, #+0]
// 13180     }
// 13181     else
// 13182     {
// 13183     }
// 13184     
// 13185     //1.2 障碍边，开始扫描
// 13186     count2 = 0;
??BrickJudge_11:
        MOVS     R1,#+0
// 13187     for(row = BrickHeadRow; ; row++)
        MOVS     R6,#+15
        B.N      ??BrickJudge_12
??BrickJudge_13:
        ADDS     R6,R6,#+1
// 13188     {
// 13189       //对某一行的处理。
// 13190       //该行黑点计数，从右往左扫描。
// 13191       count1 = 0;
??BrickJudge_12:
        MOVS     R2,#+0
// 13192       //当前行的扫描左边界。
// 13193       tempend = (a0 + a1 * row) / LeastSquareMulti + BrickColCom;   //记得除以增加的倍数
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MLA      R0,R6,R4,R5
        MOV      R3,#+1000
        SDIV     R0,R0,R3
        ADDS     R0,R0,#+5
// 13194       for(col = BrickBorderColL; ; col--)
        LDR.W    R3,??DataTable68_2
        LDRB     R3,[R3, #+0]
        B.N      ??BrickJudge_14
??BrickJudge_15:
        SUBS     R3,R3,#+1
// 13195       {
// 13196         if(ImgNew[row][col] < LimitLeftB)  //够黑
??BrickJudge_14:
        LDR.W    R7,??DataTable68_4
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MOVS     R12,#+250
        MLA      R7,R12,R6,R7
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R7,[R3, R7]
        LDR.W    R12,??DataTable68_5
        LDRB     R12,[R12, #+0]
        CMP      R7,R12
        BCS.N    ??BrickJudge_16
// 13197         {
// 13198           count1++;
        ADDS     R2,R2,#+1
// 13199         }
// 13200         else
// 13201         {
// 13202         }
// 13203         //向左扫描至边界。
// 13204         if(col <= tempend || col == 0) break;
??BrickJudge_16:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R0,R3
        BCS.N    ??BrickJudge_17
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BNE.N    ??BrickJudge_15
// 13205       }
// 13206       //该行黑点个数大于BrickLineBlackCountNum个时，则行计数加1.
// 13207       if(count1 > BrickLineBlackCountNum) 
??BrickJudge_17:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+21
        BLT.N    ??BrickJudge_18
// 13208       {
// 13209         count2++;
        ADDS     R1,R1,#+1
// 13210         BrickLineCountNumRecord = count2;
        LDR.W    R0,??DataTable68_6
        STRB     R1,[R0, #+0]
// 13211         //满足黑点个数的行有BrickLineCountNum个时，则初步判断为左障碍。
// 13212         if(count2 > BrickLineCountNum) 
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BGE.N    ??BrickJudge_19
// 13213         {
// 13214           //不能直接返回成功，还需要对右边进行检测。
// 13215           break;
// 13216         }
// 13217         else
// 13218         {      
// 13219         }
// 13220       }
// 13221       else
// 13222       {
// 13223       }
// 13224       if(row == BrickEndRow) break;
??BrickJudge_18:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+35
        BNE.N    ??BrickJudge_13
// 13225     }
// 13226     
// 13227     //2. 非障碍边确认
// 13228     if(row != BrickEndRow)
??BrickJudge_19:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+35
        BEQ.W    ??BrickJudge_3
// 13229     {
// 13230       //2. 1 非障碍边最小二乘法
// 13231       index = 0;    
        MOVS     R0,#+0
// 13232       for(i = BrickEndRow + 1; ; i++)
        MOVS     R1,#+36
        B.N      ??BrickJudge_20
??BrickJudge_21:
        ADDS     R1,R1,#+1
// 13233       {
// 13234         if(BlackRightLoc[i][0] != MaxValUint8)
??BrickJudge_20:
        LDR.W    R2,??DataTable68_3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BEQ.N    ??BrickJudge_22
// 13235         {
// 13236           y[index] = BlackRightLoc[i][0];
        LDR.W    R2,??DataTable68_3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        ADD      R3,SP,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R2,[R0, R3]
// 13237           x[index] = i;
        ADD      R2,SP,#+8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 13238           index++;
        ADDS     R0,R0,#+1
// 13239         }
// 13240         if(index == BrickSlopeRowNum)
??BrickJudge_22:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+8
        BNE.N    ??BrickJudge_23
// 13241         {
// 13242           break;  
// 13243         }
// 13244         if(i == CameraHight - 1)
// 13245         {
// 13246           return 0;
// 13247         }
// 13248       }
// 13249       
// 13250       //最小二乘法
// 13251       //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
// 13252       a1 = LeastSquarea1(x, y, BrickSlopeRowNum);
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea1
        MOVS     R4,R0
// 13253       //右边，斜率应该是0~PathJudgeStraightSlopeLimit,否则斜率不对，返回失败。
// 13254       if(a1 > 0 && a1 < PathJudgeStraightSlopeLimit)
        SUBS     R0,R4,#+1
        MOVW     R1,#+2099
        CMP      R0,R1
        BCC.N    ??BrickJudge_24
// 13255       {
// 13256       }
// 13257       else
// 13258       {
// 13259         return 0;
        MOVS     R0,#+0
        B.N      ??BrickJudge_2
// 13260       }
??BrickJudge_23:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+59
        BNE.N    ??BrickJudge_21
        MOVS     R0,#+0
        B.N      ??BrickJudge_2
// 13261       a0 = LeastSquarea0(x, y, a1, BrickSlopeRowNum);
??BrickJudge_24:
        MOVS     R3,#+8
        MOVS     R2,R4
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea0
        MOVS     R5,R0
// 13262       //直角梯形的两个突出顶点所在列
// 13263       //起始行（近行）黑点所在列。
// 13264       BrickEndColR = (a0 + a1 * BrickEndRow) / LeastSquareMulti - BrickColCom;
        MOVS     R0,#+35
        MLA      R0,R0,R4,R5
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+5
        LDR.W    R1,??DataTable68_7
        STRB     R0,[R1, #+0]
// 13265       //结束行（远行）黑点所在列
// 13266       BrickHeadColR = (a0 + a1 * BrickHeadRow) / LeastSquareMulti - BrickColCom;
        MOVS     R0,#+15
        MLA      R0,R0,R4,R5
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+5
        LDR.W    R1,??DataTable68_8
        STRB     R0,[R1, #+0]
// 13267       //直角梯形的直角边所在列。左障碍的非障碍边，也就是右边直角梯形的直角边。不能比左直角梯形的直角边还小。
// 13268       BrickBorderColR = MaxRe(BrickEndColR - BrickScanColNum / 2, BrickBorderColL);
        LDR.W    R0,??DataTable68_2
        LDRB     R1,[R0, #+0]
        LDR.W    R0,??DataTable68_7
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+30
        BL       MaxRe
        LDR.W    R1,??DataTable68_9
        STRB     R0,[R1, #+0]
// 13269    
// 13270       //2.2 非障碍边，开始扫描，找到黑点过多的行，则左障碍确认失败。进行右障碍扫描。
// 13271       for(row = BrickHeadRow; ; row++)
        MOVS     R6,#+15
        B.N      ??BrickJudge_25
??BrickJudge_26:
        ADDS     R6,R6,#+1
// 13272       {
// 13273         //对某一行的处理。
// 13274         //该行黑点计数，从左往右扫描。
// 13275         count3 = 0;
??BrickJudge_25:
        MOVS     R7,#+0
// 13276         //当前行的扫描的右边界。
// 13277         tempend = (a0 + a1 * row) / LeastSquareMulti - BrickColCom;   //记得除以增加的倍数
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MLA      R0,R6,R4,R5
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+5
// 13278         //限幅。
// 13279         tempend = MaxRe(tempend, BrickBorderColR);
        LDR.W    R1,??DataTable68_9
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       MaxRe
// 13280         //黑点扫描。
// 13281         for(col = BrickBorderColR; ; col++)
        LDR.W    R1,??DataTable68_9
        LDRB     R3,[R1, #+0]
        B.N      ??BrickJudge_27
??BrickJudge_28:
        ADDS     R3,R3,#+1
// 13282         {
// 13283           if(ImgNew[row][col] < LimitRightB)  //够黑
??BrickJudge_27:
        LDR.W    R1,??DataTable68_4
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R6,R1
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R1,[R3, R1]
        LDR.W    R2,??DataTable68_10
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BCS.N    ??BrickJudge_29
// 13284           {
// 13285             count3++;
        ADDS     R7,R7,#+1
// 13286           }
// 13287           else
// 13288           {
// 13289           }
// 13290           //向右扫描至边界
// 13291           if(col >= tempend || col == CameraRealWidth - 1) break;
??BrickJudge_29:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R3,R0
        BCS.N    ??BrickJudge_30
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+249
        BNE.N    ??BrickJudge_28
// 13292         }
// 13293         //该行黑点个数大于BrickLineBlackCountNum个时，则行计数加1.
// 13294         if(count3 > BrickLineBlackCountNum) 
??BrickJudge_30:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+21
        BGE.N    ??BrickJudge_31
// 13295         {
// 13296           //存在有行黑点过多，则直接跳出。
// 13297           break;
// 13298         }
// 13299         else
// 13300         {
// 13301         }
// 13302         
// 13303         if(row == BrickEndRow) break;
??BrickJudge_32:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+35
        BNE.N    ??BrickJudge_26
// 13304       }
// 13305       
// 13306       //3. 最终确认
// 13307       if(row == BrickEndRow)
??BrickJudge_31:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+35
        BNE.N    ??BrickJudge_3
// 13308       {
// 13309         //置左障碍标志
// 13310         PathType = PathBrickLeft;
        MOVS     R0,#+8
        LDR.N    R1,??DataTable67_10
        STRB     R0,[R1, #+0]
// 13311         return 1;
        MOVS     R0,#+1
        B.N      ??BrickJudge_2
// 13312       }
// 13313       else
// 13314       {
// 13315       }
// 13316     }
// 13317     //有效行不够，不用进行右边的确认，直接进入右障碍检测。
// 13318     else
// 13319     {
// 13320     }
// 13321 
// 13322   }
// 13323   
// 13324   
// 13325   //左障碍查找不成功或不需要查找，则开始右障碍查找。先看看是否满足基本条件。
// 13326   if(
// 13327     (BlackLeftHeadLine > BrickHeadRow)                                         //左线头太近
// 13328   ||(BlackLeftCrossDone != 0 && BlackLeftRow1RealLastLine  > BrickHeadRow)    //左线开启了十字再检测，且第1段黑线起始行太近。
// 13329     )
??BrickJudge_3:
        LDR.N    R0,??DataTable67_24
        LDRB     R0,[R0, #+0]
        CMP      R0,#+16
        BGE.N    ??BrickJudge_33
        LDR.W    R0,??DataTable69
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??BrickJudge_34
        LDR.W    R0,??DataTable69_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+16
        BLT.N    ??BrickJudge_34
// 13330   {
// 13331     //不满足基本条件，左右障碍都不可能，不用任何检测。直接返回失败。
// 13332     return 0;
??BrickJudge_33:
        MOVS     R0,#+0
        B.N      ??BrickJudge_2
// 13333   }
// 13334   else
// 13335   {
// 13336     //1.1 障碍边，右边。最小二乘法计算扫描起始行和结束行的黑点所在列。
// 13337     //取BrickSlopeRowNum个点作为最小二乘法的基准点。
// 13338     //以左上角为原点，向下为x轴正方向，向右为y轴正方向
// 13339     index = 0;    
??BrickJudge_34:
        MOVS     R0,#+0
// 13340     for(i = BrickEndRow + 1; ; i++)
        MOVS     R1,#+36
        B.N      ??BrickJudge_35
??BrickJudge_36:
        ADDS     R1,R1,#+1
// 13341     {
// 13342       if(BlackRightLoc[i][0] != MaxValUint8)
??BrickJudge_35:
        LDR.W    R2,??DataTable68_3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BEQ.N    ??BrickJudge_37
// 13343       {
// 13344         y[index] = BlackRightLoc[i][0];
        LDR.W    R2,??DataTable68_3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        ADD      R3,SP,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R2,[R0, R3]
// 13345         x[index] = i;
        ADD      R2,SP,#+8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 13346         index++;
        ADDS     R0,R0,#+1
// 13347       }
// 13348       if(index == BrickSlopeRowNum)
??BrickJudge_37:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+8
        BNE.N    ??BrickJudge_38
// 13349       {
// 13350         break;  
// 13351       }
// 13352       if(i == CameraHight - 1)
// 13353       {
// 13354         return 0;
// 13355       }
// 13356     }
// 13357     
// 13358     //最小二乘法
// 13359     //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
// 13360     a1 = LeastSquarea1(x, y, BrickSlopeRowNum);
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea1
        MOVS     R4,R0
// 13361     //右边，斜率应该是0~PathJudgeStraightSlopeLimit,否则斜率不对，返回失败。
// 13362     if(a1 > 0 && a1 < PathJudgeStraightSlopeLimit)
        SUBS     R0,R4,#+1
        MOVW     R1,#+2099
        CMP      R0,R1
        BCC.N    ??BrickJudge_39
// 13363     {
// 13364     }
// 13365     else
// 13366     {
// 13367       return 0;
        MOVS     R0,#+0
        B.N      ??BrickJudge_2
// 13368     }
??BrickJudge_38:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+59
        BNE.N    ??BrickJudge_36
        MOVS     R0,#+0
        B.N      ??BrickJudge_2
// 13369     a0 = LeastSquarea0(x, y, a1, BrickSlopeRowNum);
??BrickJudge_39:
        MOVS     R3,#+8
        MOVS     R2,R4
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea0
        MOVS     R5,R0
// 13370     //直角梯形的两个突出顶点所在列
// 13371     //起始行（近行）黑点所在列。
// 13372     BrickEndColR = (a0 + a1 * BrickEndRow) / LeastSquareMulti - BrickColCom;
        MOVS     R0,#+35
        MLA      R0,R0,R4,R5
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+5
        LDR.W    R1,??DataTable68_7
        STRB     R0,[R1, #+0]
// 13373     //结束行（远行）黑点所在列
// 13374     BrickHeadColR = (a0 + a1 * BrickHeadRow) / LeastSquareMulti - BrickColCom;
        MOVS     R0,#+15
        MLA      R0,R0,R4,R5
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        SUBS     R0,R0,#+5
        LDR.W    R1,??DataTable68_8
        STRB     R0,[R1, #+0]
// 13375     //直角梯形的直角边所在列。右障碍扫描的左边界。稍微限幅一下。
// 13376     //不能超过图像左边界
// 13377     BrickBorderColR = MaxRe(0, BrickEndColR - BrickScanColNum);
        LDR.W    R0,??DataTable68_7
        LDRB     R0,[R0, #+0]
        SUBS     R1,R0,#+60
        MOVS     R0,#+0
        BL       MaxRe
        LDR.W    R1,??DataTable68_9
        STRB     R0,[R1, #+0]
// 13378     //不能超过该行左线黑点。
// 13379     if(BlackLeftLoc[BrickEndRow][0] != MaxValUint8)
        LDR.N    R0,??DataTable67_34
        LDRB     R0,[R0, #+105]
        CMP      R0,#+255
        BEQ.N    ??BrickJudge_40
// 13380     {
// 13381       BrickBorderColR = MaxRe(BrickBorderColR, BlackLeftLoc[BrickEndRow][0]);
        LDR.N    R0,??DataTable67_34
        LDRB     R1,[R0, #+105]
        LDR.W    R0,??DataTable68_9
        LDRB     R0,[R0, #+0]
        BL       MaxRe
        LDR.W    R1,??DataTable68_9
        STRB     R0,[R1, #+0]
// 13382     }
// 13383     else
// 13384     {
// 13385     }
// 13386     
// 13387     //1.2 障碍边，开始扫描
// 13388     count2 = 0;
??BrickJudge_40:
        MOVS     R1,#+0
// 13389     for(row = BrickHeadRow; ; row++)
        MOVS     R6,#+15
        B.N      ??BrickJudge_41
??BrickJudge_42:
        ADDS     R6,R6,#+1
// 13390     {
// 13391       //对某一行的处理。
// 13392       //该行黑点计数
// 13393       count1 = 0;
??BrickJudge_41:
        MOVS     R2,#+0
// 13394       //从左往右扫描。
// 13395       tempend = (a0 + a1 * row) / LeastSquareMulti - BrickColCom;   //记得除以增加的倍数
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MLA      R0,R6,R4,R5
        MOV      R3,#+1000
        SDIV     R0,R0,R3
        SUBS     R0,R0,#+5
// 13396       for(col = BrickBorderColR; ; col++)
        LDR.W    R3,??DataTable68_9
        LDRB     R3,[R3, #+0]
        B.N      ??BrickJudge_43
??BrickJudge_44:
        ADDS     R3,R3,#+1
// 13397       {
// 13398         if(ImgNew[row][col] < LimitRightB)  //够黑
??BrickJudge_43:
        LDR.W    R7,??DataTable68_4
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MOVS     R12,#+250
        MLA      R7,R12,R6,R7
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R7,[R3, R7]
        LDR.W    R12,??DataTable68_10
        LDRB     R12,[R12, #+0]
        CMP      R7,R12
        BCS.N    ??BrickJudge_45
// 13399         {
// 13400           count1++;
        ADDS     R2,R2,#+1
// 13401         }
// 13402         else
// 13403         {
// 13404         }
// 13405         //向右扫描至边界。
// 13406         if(col >= tempend || col == CameraRealWidth - 1) break;
??BrickJudge_45:
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R3,R0
        BCS.N    ??BrickJudge_46
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+249
        BNE.N    ??BrickJudge_44
// 13407       }
// 13408       //该行黑点个数大于BrickLineBlackCountNum个时，则行计数加1.
// 13409       if(count1 > BrickLineBlackCountNum) 
??BrickJudge_46:
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+21
        BLT.N    ??BrickJudge_47
// 13410       {
// 13411         count2++;
        ADDS     R1,R1,#+1
// 13412         BrickLineCountNumRecord = count2;
        LDR.W    R0,??DataTable68_6
        STRB     R1,[R0, #+0]
// 13413         //满足黑点个数的行有BrickLineCountNum个时，则初步判断为右障碍。
// 13414         if(count2 > BrickLineCountNum) 
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BGE.N    ??BrickJudge_48
// 13415         {
// 13416           //不能直接返回成功，还需要对左边进行检测。
// 13417           break;
// 13418         }
// 13419         else
// 13420         {      
// 13421         }
// 13422       }
// 13423       else
// 13424       {
// 13425       }
// 13426       if(row == BrickEndRow) break;
??BrickJudge_47:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+35
        BNE.N    ??BrickJudge_42
// 13427     }
// 13428     
// 13429     //2. 非障碍边确认，左边。
// 13430     if(row != BrickEndRow)
??BrickJudge_48:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+35
        BEQ.W    ??BrickJudge_49
// 13431     {
// 13432       //2. 1 非障碍边最小二乘法
// 13433       index = 0;    
        MOVS     R0,#+0
// 13434       for(i = BrickEndRow + 1; ; i++)
        MOVS     R1,#+36
        B.N      ??BrickJudge_50
??BrickJudge_51:
        ADDS     R1,R1,#+1
// 13435       {
// 13436         if(BlackLeftLoc[i][0] != MaxValUint8)
??BrickJudge_50:
        LDR.N    R2,??DataTable67_34
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BEQ.N    ??BrickJudge_52
// 13437         {
// 13438           y[index] = BlackLeftLoc[i][0];
        LDR.N    R2,??DataTable67_34
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        ADD      R3,SP,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R2,[R0, R3]
// 13439           x[index] = i;
        ADD      R2,SP,#+8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 13440           index++;
        ADDS     R0,R0,#+1
// 13441         }
// 13442         if(index == BrickSlopeRowNum)
??BrickJudge_52:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+8
        BNE.N    ??BrickJudge_53
// 13443         {
// 13444           break;  
// 13445         }
// 13446         if(i == CameraHight - 1)
// 13447         {
// 13448           return 0;
// 13449         }
// 13450       }
// 13451       
// 13452       //最小二乘法
// 13453       //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
// 13454       a1 = LeastSquarea1(x, y, BrickSlopeRowNum);
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea1
        MOVS     R4,R0
// 13455       //左边，斜率应该是-PathJudgeStraightSlopeLimit~0,否则斜率不对，返回失败。
// 13456       if(a1 < 0 && a1 + PathJudgeStraightSlopeLimit > 0)
        CMP      R4,#+0
        BPL.N    ??BrickJudge_54
        ADDW     R0,R4,#+2100
        CMP      R0,#+1
        BGE.N    ??BrickJudge_55
// 13457       {
// 13458       }
// 13459       else
// 13460       {
// 13461         return 0;
??BrickJudge_54:
        MOVS     R0,#+0
        B.N      ??BrickJudge_2
// 13462       }
??BrickJudge_53:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+59
        BNE.N    ??BrickJudge_51
        MOVS     R0,#+0
        B.N      ??BrickJudge_2
// 13463       a0 = LeastSquarea0(x, y, a1, BrickSlopeRowNum);
??BrickJudge_55:
        MOVS     R3,#+8
        MOVS     R2,R4
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea0
        MOVS     R5,R0
// 13464       //直角梯形的两个突出顶点所在列
// 13465       //起始行（近行）黑点所在列。
// 13466       BrickEndColL = (a0 + a1 * BrickEndRow) / LeastSquareMulti + BrickColCom;
        MOVS     R0,#+35
        MLA      R0,R0,R4,R5
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        ADDS     R0,R0,#+5
        LDR.W    R1,??DataTable68
        STRB     R0,[R1, #+0]
// 13467       //结束行（远行）黑点所在列
// 13468       BrickHeadColL = (a0 + a1 * BrickHeadRow) / LeastSquareMulti + BrickColCom;
        MOVS     R0,#+15
        MLA      R0,R0,R4,R5
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        ADDS     R0,R0,#+5
        LDR.W    R1,??DataTable68_1
        STRB     R0,[R1, #+0]
// 13469       //直角梯形的直角边所在列。右障碍的非障碍边，也就是左边直角梯形的直角边。不能比右直角梯形的直角边还大。
// 13470       BrickBorderColL = MinRe(BrickEndColL + BrickScanColNum / 2, BrickBorderColR);
        LDR.W    R0,??DataTable68_9
        LDRB     R1,[R0, #+0]
        LDR.W    R0,??DataTable68
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+30
        BL       MinRe
        LDR.W    R1,??DataTable68_2
        STRB     R0,[R1, #+0]
// 13471    
// 13472       //2.2 非障碍边，开始扫描，找到黑点过多的行，则右障碍确认失败。
// 13473       for(row = BrickHeadRow; ; row++)
        MOVS     R6,#+15
        B.N      ??BrickJudge_56
??BrickJudge_57:
        ADDS     R6,R6,#+1
// 13474       {
// 13475         //对某一行的处理。
// 13476         //该行黑点计数
// 13477         count3 = 0;
??BrickJudge_56:
        MOVS     R7,#+0
// 13478         //从右往左扫描。
// 13479         tempend = (a0 + a1 * row) / LeastSquareMulti + BrickColCom;   //记得除以增加的倍数
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MLA      R0,R6,R4,R5
        MOV      R1,#+1000
        SDIV     R0,R0,R1
        ADDS     R0,R0,#+5
// 13480         //限幅。
// 13481         tempend = MinRe(tempend, BrickBorderColL);
        LDR.W    R1,??DataTable68_2
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       MinRe
// 13482         //黑点扫描。
// 13483         for(col = BrickBorderColL; ; col--)
        LDR.W    R1,??DataTable68_2
        LDRB     R3,[R1, #+0]
        B.N      ??BrickJudge_58
??BrickJudge_59:
        SUBS     R3,R3,#+1
// 13484         {
// 13485           if(ImgNew[row][col] < LimitLeftB)  //够黑
??BrickJudge_58:
        LDR.W    R1,??DataTable68_4
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        MOVS     R2,#+250
        MLA      R1,R2,R6,R1
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        LDRB     R1,[R3, R1]
        LDR.W    R2,??DataTable68_5
        LDRB     R2,[R2, #+0]
        CMP      R1,R2
        BCS.N    ??BrickJudge_60
// 13486           {
// 13487             count3++;
        ADDS     R7,R7,#+1
// 13488           }
// 13489           else
// 13490           {
// 13491           }
// 13492           //向左扫描至边界
// 13493           if(col <= tempend || col == 0) break;
??BrickJudge_60:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R0,R3
        BCS.N    ??BrickJudge_61
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        CMP      R3,#+0
        BNE.N    ??BrickJudge_59
// 13494         }
// 13495         //该行黑点个数大于BrickLineBlackCountNum个时，则行计数加1.
// 13496         if(count3 > BrickLineBlackCountNum) 
??BrickJudge_61:
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        CMP      R7,#+21
        BGE.N    ??BrickJudge_62
// 13497         {
// 13498           //存在有行黑点过多，则直接跳出。
// 13499           break;
// 13500         }
// 13501         else
// 13502         {
// 13503         }
// 13504         
// 13505         if(row == BrickEndRow) break;
??BrickJudge_63:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+35
        BNE.N    ??BrickJudge_57
// 13506       }
// 13507       
// 13508       //3. 最终确认
// 13509       if(row == BrickEndRow)
??BrickJudge_62:
        UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
        CMP      R6,#+35
        BNE.N    ??BrickJudge_64
// 13510       {
// 13511         //置右障碍标志
// 13512         PathType = PathBrickRight;
        MOVS     R0,#+9
        LDR.N    R1,??DataTable67_10
        STRB     R0,[R1, #+0]
// 13513         return 1;
        MOVS     R0,#+1
        B.N      ??BrickJudge_2
// 13514       }
// 13515       else
// 13516       {
// 13517         return 0;
??BrickJudge_64:
        MOVS     R0,#+0
        B.N      ??BrickJudge_2
// 13518       }
// 13519     }
// 13520     //有效行不够，不用进行右边的确认，直接返回失败。
// 13521     else
// 13522     {
// 13523       return 0;
??BrickJudge_49:
        MOVS     R0,#+0
??BrickJudge_2:
        ADD      SP,SP,#+20
        POP      {R4-R7,PC}       ;; return
// 13524     }
// 13525   }
// 13526   
// 13527 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67:
        DC32     BlackRightHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_1:
        DC32     AngleSpeDealDeviNow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_2:
        DC32     AngleSpeDealBackCount

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_3:
        DC32     DeviFuse

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_4:
        DC32     AngleSpeDealSlopeC

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_5:
        DC32     SlopeC

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_6:
        DC32     SlopeL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_7:
        DC32     SlopeR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_8:
        DC32     AngleConfirmLockFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_9:
        DC32     AngleConfirmMat

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_10:
        DC32     PathType

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_11:
        DC32     AngleConfirmMatCollect

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_12:
        DC32     AngleConfirmMatLimit

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_13:
        DC32     AngleSpeDealDir

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_14:
        DC32     AngleZoneConfirmLockFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_15:
        DC32     AngleSpeDealExitJudgeFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_16:
        DC32     AngleSpeDealFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_17:
        DC32     BlackLeftDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_18:
        DC32     BlackRightDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_19:
        DC32     BlackGetPreDir

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_20:
        DC32     BlackLeftStep1ScanRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_21:
        DC32     BlackRightStep1ScanRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_22:
        DC32     SingleBlackAllFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_23:
        DC32     BlackLeftEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_24:
        DC32     BlackLeftHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_25:
        DC32     BlackLeft5SlopeIndex

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_26:
        DC32     BlackLeft5Slope

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_27:
        DC32     flag000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_28:
        DC32     flag111

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_29:
        DC32     BlackRightEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_30:
        DC32     BlackRight5SlopeIndex

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_31:
        DC32     BlackRight5Slope

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_32:
        DC32     BlackRightCrossDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_33:
        DC32     BlackRightRow1RealLastLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable67_34:
        DC32     BlackLeftLoc
// 13528 
// 13529 
// 13530 
// 13531 //直角黑块检测。0未检测到，1检测到。
// 13532 //直角黑块有可能被误判成障碍，但障碍不可能被误判成直角黑块，所以先检测直角黑块。
// 13533 //判断条件为，两线头差在4以内，且都在第25行到第40行，则找最远线头再往远4行、5行的这两行，最小二乘法估出来每行两个点，
// 13534 //往内减去5列左右的裕量，然后看两点之间是不是都小于黑点阈值，若是，则判断成功。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 13535 uint8 AngleZoneJudge(void)
// 13536 {
AngleZoneJudge:
        PUSH     {R4,R5,LR}
        SUB      SP,SP,#+20
// 13537   uint8 countcol, count1, count2;
// 13538   
// 13539   int32 a0, a1;
// 13540   uint8 i, index;
// 13541   
// 13542   uint8 x[BrickSlopeRowNum];   //取多少个点在一开始有定义。
// 13543   uint8 y[BrickSlopeRowNum];
// 13544   uint8 col;
// 13545   
// 13546   //线尾不用作判断，不科学。
// 13547   
// 13548   if(
// 13549     (BlackLeftDone == 1 && BlackRightDone == 1)
// 13550   &&(AbsInt(BlackLeftHeadLine - BlackRightHeadLine) <= AngleZoneHeadLineNum)      //线头差必须在8以内
// 13551   &&(BlackLeftHeadLine < AngleZoneJudgeRowNear && BlackLeftHeadLine > AngleZoneJudgeRowFar)  //线头必须在某两行之间的区域，大概是25-40行之间
// 13552   &&(BlackRightHeadLine < AngleZoneJudgeRowNear && BlackRightHeadLine > AngleZoneJudgeRowFar)  //线头必须在某两行之间的区域，大概是25-40行之间  
// 13553     )
        LDR.W    R0,??DataTable71
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??AngleZoneJudge_0
        LDR.W    R0,??DataTable71_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??AngleZoneJudge_0
        LDR.W    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable72
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        BL       AbsInt
        CMP      R0,#+16
        BGE.N    ??AngleZoneJudge_0
        LDR.W    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+15
        CMP      R0,#+35
        BCS.N    ??AngleZoneJudge_0
        LDR.W    R0,??DataTable72
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+15
        CMP      R0,#+35
        BCC.N    ??AngleZoneJudge_1
// 13554   {
// 13555   }
// 13556   else
// 13557   {
// 13558     return 0;
??AngleZoneJudge_0:
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13559   }
// 13560   
// 13561   //最终大跳变检测，发现左线有大跳变。或右线头比左线头高。
// 13562   //则右线检测多一些黑块，左线检测少一些黑块。
// 13563   if(BlackBigChangeFinalCheckFlag == 1 || BlackRightHeadLine <= BlackLeftHeadLine)
??AngleZoneJudge_1:
        LDR.W    R0,??DataTable71_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??AngleZoneJudge_3
        LDR.W    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable72
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCC.W    ??AngleZoneJudge_4
// 13564   {
// 13565     //1. 右线。检测多一些黑块。
// 13566     //1.1 取右线头往远处5行左右。
// 13567     for(i = 0; ; i++)
??AngleZoneJudge_3:
        MOVS     R1,#+0
        B.N      ??AngleZoneJudge_5
??AngleZoneJudge_6:
        ADDS     R1,R1,#+1
// 13568     {
// 13569       AngleZoneJudgeRowR[i] = BlackRightHeadLine - i - 1;
??AngleZoneJudge_5:
        LDR.W    R0,??DataTable72
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+1
        LDR.W    R2,??DataTable71_4
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R0,[R1, R2]
// 13570         
// 13571       if(i == AngleZoneJudgeRowNum - 1) break;
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??AngleZoneJudge_6
// 13572     }
// 13573     //1.2 最小二乘法
// 13574     //取AngleZoneSlopeRowNum个点作为最小二乘法的基准点。
// 13575     //以左上角为原点，向下为x轴正方向，向右为y轴正方向
// 13576     //考虑到直角黑块大跳变现在基本可以滤除掉了，所以直角黑块定位的时候，采用线头左右开始往近处的8行，而不是最近的8行。
// 13577     index = 0;
        MOVS     R0,#+0
// 13578     for(i = BlackRightHeadLine + 2; ; i++)
        LDR.W    R1,??DataTable72
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+2
        B.N      ??AngleZoneJudge_7
??AngleZoneJudge_8:
        ADDS     R1,R1,#+1
// 13579     {
// 13580       if(BlackRightLoc[i][0] != MaxValUint8)
??AngleZoneJudge_7:
        LDR.W    R2,??DataTable68_3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BEQ.N    ??AngleZoneJudge_9
// 13581       {
// 13582         y[index] = BlackRightLoc[i][0];
        LDR.W    R2,??DataTable68_3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        ADD      R3,SP,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R2,[R0, R3]
// 13583         x[index] = i;
        ADD      R2,SP,#+8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 13584         index++;
        ADDS     R0,R0,#+1
// 13585       }
// 13586       if(index == AngleJudgeSlopeRowNum)
??AngleZoneJudge_9:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+8
        BNE.N    ??AngleZoneJudge_10
// 13587       {
// 13588         break;  
// 13589       }
// 13590       
// 13591       if(i == CameraHight - 1) return 0;
// 13592     }
// 13593     //最小二乘法
// 13594     //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
// 13595     a1 = LeastSquarea1(x, y, AngleJudgeSlopeRowNum);
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea1
        MOVS     R4,R0
// 13596     //右边，斜率应该是0~PathJudgeStraightSlopeLimit,否则斜率不对，返回失败。
// 13597     if(a1 > 0 && a1 < PathJudgeStraightSlopeLimit)
        SUBS     R0,R4,#+1
        MOVW     R1,#+2099
        CMP      R0,R1
        BCC.N    ??AngleZoneJudge_11
// 13598     {
// 13599     }
// 13600     else
// 13601     {
// 13602       return 0;
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13603     }
??AngleZoneJudge_10:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+59
        BNE.N    ??AngleZoneJudge_8
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13604     a0 = LeastSquarea0(x, y, a1, AngleJudgeSlopeRowNum);
??AngleZoneJudge_11:
        MOVS     R3,#+8
        MOVS     R2,R4
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea0
// 13605     //1.3 计算给定5行的右边界。标志位清零。
// 13606     //要往中间留AngleZoneCheckRowCom列的裕量。
// 13607     for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??AngleZoneJudge_12
??AngleZoneJudge_13:
        ADDS     R1,R1,#+1
// 13608     {
// 13609       //根据线头几行来最小二乘法还是比较准的，不用修正太多列。
// 13610       AngleZoneJudgeColR[i] = (a0 + a1 * AngleZoneJudgeRowR[i]) / LeastSquareMulti - AngleZoneJudgeRowCom;  
??AngleZoneJudge_12:
        LDR.W    R2,??DataTable71_4
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R2,[R1, R2]
        MLA      R2,R2,R4,R0
        MOV      R3,#+1000
        SDIV     R2,R2,R3
        SUBS     R2,R2,#+2
        LDR.W    R3,??DataTable71_5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R2,[R1, R3]
// 13611       AngleZoneJudgeColRFlag[i] = 0;
        MOVS     R2,#+0
        LDR.W    R3,??DataTable71_6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R2,[R1, R3]
// 13612       
// 13613       if(i == AngleZoneJudgeRowNum - 1) break;
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??AngleZoneJudge_13
// 13614     }
// 13615     //1.4 右边界确定后，往左一个赛道宽度内，只有有若干列都是黑点，则该行直角黑块判断成功。2行左右即可最终确认右线OK。
// 13616     for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??AngleZoneJudge_14
??AngleZoneJudge_15:
        ADDS     R1,R1,#+1
// 13617     {
// 13618       //每行的列黑点计数清零。
// 13619       countcol = 0;
??AngleZoneJudge_14:
        MOVS     R0,#+0
// 13620       //从左往右扫一个赛道宽度。赛道宽度预定为70列左右。
// 13621       if(AngleZoneJudgeColR[i] - AngleZoneJudgeRoadWidth < 0)
        LDR.W    R2,??DataTable71_5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R2,[R1, R2]
        SUBS     R2,R2,#+70
        CMP      R2,#+0
        BPL.N    ??AngleZoneJudge_16
// 13622       {
// 13623         return 0;
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13624       }
// 13625       else
// 13626       {
// 13627       }      
// 13628       for(col = AngleZoneJudgeColR[i] - AngleZoneJudgeRoadWidth; ; col++)
??AngleZoneJudge_16:
        LDR.W    R2,??DataTable71_5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R2,[R1, R2]
        SUBS     R2,R2,#+70
        B.N      ??AngleZoneJudge_17
??AngleZoneJudge_18:
        ADDS     R2,R2,#+1
// 13629       {
// 13630         //检测到有效黑点，计数加1.
// 13631         if(ImgNew[AngleZoneJudgeRowR[i]][col] < LimitRightB) countcol++;
??AngleZoneJudge_17:
        LDR.W    R3,??DataTable68_4
        LDR.W    R4,??DataTable71_4
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R4,[R1, R4]
        MOVS     R5,#+250
        MLA      R3,R5,R4,R3
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        LDRB     R3,[R2, R3]
        LDR.W    R4,??DataTable68_10
        LDRB     R4,[R4, #+0]
        CMP      R3,R4
        BCS.N    ??AngleZoneJudge_19
        ADDS     R0,R0,#+1
// 13632         //该行右黑点够多。置标志位。跳出。
// 13633         if(countcol >= AngleZoneJudgeBlackNumP)  //优势边取45列左右，比障碍多
??AngleZoneJudge_19:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+45
        BLT.N    ??AngleZoneJudge_20
// 13634         {
// 13635           AngleZoneJudgeColRFlag[i] = 1;
        MOVS     R2,#+1
        LDR.W    R3,??DataTable71_6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R2,[R1, R3]
// 13636           break;
        B.N      ??AngleZoneJudge_21
// 13637         }
// 13638         //直到第70列也没有凑够黑点数，跳出。
// 13639         if(col == AngleZoneJudgeColR[i]) break;
??AngleZoneJudge_20:
        LDR.W    R3,??DataTable71_5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R3,[R1, R3]
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,R3
        BNE.N    ??AngleZoneJudge_18
// 13640       }
// 13641       //记录该行的有效黑点数，以供确定合适的阈值。
// 13642       AngleZoneJudgeCountColR[i] = countcol;
??AngleZoneJudge_21:
        LDR.W    R2,??DataTable71_7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R0,[R1, R2]
// 13643         
// 13644       //到最后一行了，退出。
// 13645       if(i == AngleZoneJudgeRowNum - 1) break;
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??AngleZoneJudge_15
// 13646     }
// 13647     //1.5 检测是不是至少有2行满足条件。若有，则继续检测左线，若无，则直接返回失败。
// 13648     count1 = 0;
        MOVS     R4,#+0
// 13649     for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??AngleZoneJudge_22
??AngleZoneJudge_23:
        ADDS     R1,R1,#+1
// 13650     {
// 13651       if(AngleZoneJudgeColRFlag[i] == 1) count1++;
??AngleZoneJudge_22:
        LDR.W    R0,??DataTable71_6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R0,[R1, R0]
        CMP      R0,#+1
        BNE.N    ??AngleZoneJudge_24
        ADDS     R4,R4,#+1
// 13652       
// 13653       if(i == AngleZoneJudgeRowNum - 1) break;
??AngleZoneJudge_24:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??AngleZoneJudge_23
// 13654     }
// 13655     //反时限特性。两线头差值较大时，优势边的45列只要求一行。否则要求2行。
// 13656     if(AbsInt(BlackLeftHeadLine - BlackRightHeadLine) > 5)
        LDR.W    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable72
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        BL       AbsInt
        CMP      R0,#+6
        BLT.N    ??AngleZoneJudge_25
// 13657     {
// 13658       if(count1 >= 1)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BNE.N    ??AngleZoneJudge_26
// 13659       {
// 13660       }
// 13661       else
// 13662       {
// 13663         return 0;
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13664       }
// 13665     }
// 13666     else
// 13667     {
// 13668       if(count1 >= 2)
??AngleZoneJudge_25:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+2
        BGE.N    ??AngleZoneJudge_26
// 13669       {
// 13670       }
// 13671       else
// 13672       {
// 13673         return 0;
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13674       }
// 13675     }
// 13676     
// 13677     //2. 左线。检测少一些黑块。
// 13678     //2.1 取左线头往远处5行左右。劣势边线头过去的第一行一般是不可能有那么多黑点的，所以要再过去一行。
// 13679     for(i = 0; ; i++)
??AngleZoneJudge_26:
        MOVS     R1,#+0
        B.N      ??AngleZoneJudge_27
??AngleZoneJudge_28:
        ADDS     R1,R1,#+1
// 13680     {
// 13681       AngleZoneJudgeRowL[i] = BlackLeftHeadLine - i - 1 - 1;
??AngleZoneJudge_27:
        LDR.W    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+2
        LDR.W    R2,??DataTable71_8
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R0,[R1, R2]
// 13682         
// 13683       if(i == AngleZoneJudgeRowNum - 1) break;
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??AngleZoneJudge_28
// 13684     }
// 13685     //2.2 最小二乘法
// 13686     //取AngleZoneSlopeRowNum个点作为最小二乘法的基准点。
// 13687     //以左上角为原点，向下为x轴正方向，向右为y轴正方向
// 13688     //考虑到直角黑块大跳变现在基本可以滤除掉了，所以直角黑块定位的时候，采用线头左右开始往近处的8行，而不是最近的8行。
// 13689     index = 0;
        MOVS     R0,#+0
// 13690     for(i = BlackLeftHeadLine + 2; ; i++)
        LDR.W    R1,??DataTable71_2
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+2
        B.N      ??AngleZoneJudge_29
??AngleZoneJudge_30:
        ADDS     R1,R1,#+1
// 13691     {
// 13692       if(BlackLeftLoc[i][0] != MaxValUint8)
??AngleZoneJudge_29:
        LDR.W    R2,??DataTable71_9
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BEQ.N    ??AngleZoneJudge_31
// 13693       {
// 13694         y[index] = BlackLeftLoc[i][0];
        LDR.W    R2,??DataTable71_9
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        ADD      R3,SP,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R2,[R0, R3]
// 13695         x[index] = i;
        ADD      R2,SP,#+8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 13696         index++;
        ADDS     R0,R0,#+1
// 13697       }
// 13698       if(index == AngleJudgeSlopeRowNum)
??AngleZoneJudge_31:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+8
        BNE.N    ??AngleZoneJudge_32
// 13699       {
// 13700         break;  
// 13701       }
// 13702       
// 13703       if(i == CameraHight - 1) return 0;
// 13704     }
// 13705     //最小二乘法
// 13706     //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
// 13707     a1 = LeastSquarea1(x, y, AngleJudgeSlopeRowNum);
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea1
        MOVS     R4,R0
// 13708     //左边，斜率应该是-PathJudgeStraightSlopeLimit~0,否则斜率不对，返回失败。
// 13709     if(a1 < 0 && a1 + PathJudgeStraightSlopeLimit > 0)
        CMP      R4,#+0
        BPL.N    ??AngleZoneJudge_33
        ADDW     R0,R4,#+2100
        CMP      R0,#+1
        BGE.N    ??AngleZoneJudge_34
// 13710     {
// 13711     }
// 13712     else
// 13713     {
// 13714       return 0;
??AngleZoneJudge_33:
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13715     }
??AngleZoneJudge_32:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+59
        BNE.N    ??AngleZoneJudge_30
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13716     a0 = LeastSquarea0(x, y, a1, AngleJudgeSlopeRowNum);
??AngleZoneJudge_34:
        MOVS     R3,#+8
        MOVS     R2,R4
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea0
// 13717     //2.3 计算给定5行的左边界。标志位清零。
// 13718     //要往中间留AngleZoneCheckRowCom列的裕量。
// 13719     for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??AngleZoneJudge_35
??AngleZoneJudge_36:
        ADDS     R1,R1,#+1
// 13720     {
// 13721       //根据线头几行来最小二乘法还是比较准的，不用修正太多列。
// 13722       AngleZoneJudgeColL[i] = (a0 + a1 * AngleZoneJudgeRowL[i]) / LeastSquareMulti + AngleZoneJudgeRowCom;  
??AngleZoneJudge_35:
        LDR.W    R2,??DataTable71_8
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R2,[R1, R2]
        MLA      R2,R2,R4,R0
        MOV      R3,#+1000
        SDIV     R2,R2,R3
        ADDS     R2,R2,#+2
        LDR.W    R3,??DataTable72_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R2,[R1, R3]
// 13723       AngleZoneJudgeColLFlag[i] = 0;
        MOVS     R2,#+0
        LDR.W    R3,??DataTable72_2
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R2,[R1, R3]
// 13724       
// 13725       if(i == AngleZoneJudgeRowNum - 1) break;
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??AngleZoneJudge_36
// 13726     }
// 13727     //2.4 左边界确定后，往右一个赛道宽度内，只有有若干列都是黑点，则该行直角黑块判断成功。2行左右即可最终确认右线OK。
// 13728     for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??AngleZoneJudge_37
??AngleZoneJudge_38:
        ADDS     R1,R1,#+1
// 13729     {
// 13730       //每行的列黑点计数清零。
// 13731       countcol = 0;
??AngleZoneJudge_37:
        MOVS     R0,#+0
// 13732       //从右往左扫半个赛道宽度。赛道宽度预定为70列左右。
// 13733       if(AngleZoneJudgeColL[i] + AngleZoneJudgeRoadWidth / 2 > CameraRealWidth - 1) //劣势边只允许扫描半个赛道宽度。防止障碍被误判成直角黑块。
        LDR.W    R2,??DataTable72_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R2,[R1, R2]
        ADDS     R2,R2,#+35
        CMP      R2,#+250
        BLT.N    ??AngleZoneJudge_39
// 13734       {
// 13735         return 0;
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13736       }
// 13737       else
// 13738       {
// 13739       }
// 13740       for(col = AngleZoneJudgeColL[i] + AngleZoneJudgeRoadWidth /2 ; ; col--) //劣势边只允许扫描半个赛道宽度。防止障碍被误判成直角黑块。
??AngleZoneJudge_39:
        LDR.W    R2,??DataTable72_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R2,[R1, R2]
        ADDS     R2,R2,#+35
        B.N      ??AngleZoneJudge_40
??AngleZoneJudge_41:
        SUBS     R2,R2,#+1
// 13741       {
// 13742         //检测到有效黑点，计数加1.
// 13743         if(ImgNew[AngleZoneJudgeRowL[i]][col] < LimitLeftB) countcol++;
??AngleZoneJudge_40:
        LDR.W    R3,??DataTable68_4
        LDR.W    R4,??DataTable71_8
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R4,[R1, R4]
        MOVS     R5,#+250
        MLA      R3,R5,R4,R3
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        LDRB     R3,[R2, R3]
        LDR.W    R4,??DataTable68_5
        LDRB     R4,[R4, #+0]
        CMP      R3,R4
        BCS.N    ??AngleZoneJudge_42
        ADDS     R0,R0,#+1
// 13744         //该行右黑点够多。置标志位。跳出。
// 13745         if(countcol >= AngleZoneJudgeBlackNumN)  //劣势边取20列左右，比单线宽度多。
??AngleZoneJudge_42:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+20
        BLT.N    ??AngleZoneJudge_43
// 13746         {
// 13747           AngleZoneJudgeColLFlag[i] = 1;
        MOVS     R2,#+1
        LDR.W    R3,??DataTable72_2
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R2,[R1, R3]
// 13748           break;
        B.N      ??AngleZoneJudge_44
// 13749         }
// 13750         //直到第70列也没有凑够黑点数，跳出。
// 13751         if(col == AngleZoneJudgeColL[i]) break;
??AngleZoneJudge_43:
        LDR.W    R3,??DataTable72_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R3,[R1, R3]
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,R3
        BNE.N    ??AngleZoneJudge_41
// 13752       }
// 13753       //记录该行的有效黑点数，以供确定合适的阈值。
// 13754       AngleZoneJudgeCountColL[i] = countcol;
??AngleZoneJudge_44:
        LDR.W    R2,??DataTable72_3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R0,[R1, R2]
// 13755         
// 13756       //到最后一行了，退出。
// 13757       if(i == AngleZoneJudgeRowNum - 1) break;
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??AngleZoneJudge_38
// 13758     }
// 13759     //2.5 检测是不是至少有2行满足条件。若有，则确认这幅图像是直角黑块，更新赛道类型、线头、返回成功。若无，则返回失败。
// 13760     count2 = 0;
        MOVS     R4,#+0
// 13761     for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??AngleZoneJudge_45
??AngleZoneJudge_46:
        ADDS     R1,R1,#+1
// 13762     {
// 13763       if(AngleZoneJudgeColLFlag[i] == 1) count2++;
??AngleZoneJudge_45:
        LDR.W    R0,??DataTable72_2
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R0,[R1, R0]
        CMP      R0,#+1
        BNE.N    ??AngleZoneJudge_47
        ADDS     R4,R4,#+1
// 13764       
// 13765       if(i == AngleZoneJudgeRowNum - 1) break;
??AngleZoneJudge_47:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??AngleZoneJudge_46
// 13766     }
// 13767     if(count2 >= 2)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+2
        BLT.N    ??AngleZoneJudge_48
// 13768     {
// 13769       //赛道类型，直角黑色区域。
// 13770       PathType = PathAngleZone; 
        MOVS     R0,#+10
        LDR.W    R1,??DataTable72_4
        STRB     R0,[R1, #+0]
// 13771       
// 13772       //对线头作处理，远线头拉到近线头处来。使远处的行不至于太偏。
// 13773       //线头相同，不用处理。
// 13774       if(BlackLeftHeadLine == BlackRightHeadLine)
        LDR.W    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable72
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BEQ.N    ??AngleZoneJudge_49
// 13775       {
// 13776       }
// 13777       //左线头更远
// 13778       else if(BlackLeftHeadLine < BlackRightHeadLine)
        LDR.W    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable72
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCS.N    ??AngleZoneJudge_50
// 13779       {
// 13780         //删掉左线头超出右线头的部分。
// 13781         for(i = BlackLeftHeadLine; ; i++)
        LDR.W    R0,??DataTable71_2
        LDRB     R1,[R0, #+0]
        B.N      ??AngleZoneJudge_51
// 13782         {
// 13783           if(i == BlackRightHeadLine) break;
// 13784           
// 13785           BlackLeftLoc[i][0] = MaxValUint8;
??AngleZoneJudge_52:
        MOVS     R0,#+255
        LDR.W    R2,??DataTable71_9
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        STRB     R0,[R2, #+0]
        ADDS     R1,R1,#+1
??AngleZoneJudge_51:
        LDR.W    R0,??DataTable72
        LDRB     R0,[R0, #+0]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,R0
        BNE.N    ??AngleZoneJudge_52
// 13786         }
// 13787         //左线头的值更新。
// 13788         BlackLeftHeadLine = BlackRightHeadLine;
        LDR.W    R0,??DataTable72
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable71_2
        STRB     R0,[R1, #+0]
        B.N      ??AngleZoneJudge_49
// 13789       }
// 13790       //右线头更远
// 13791       else
// 13792       {
// 13793         //删掉右线头超出左线头的部分。
// 13794         for(i = BlackRightHeadLine; ; i++)
??AngleZoneJudge_50:
        LDR.W    R0,??DataTable72
        LDRB     R1,[R0, #+0]
        B.N      ??AngleZoneJudge_53
// 13795         {
// 13796           if(i == BlackLeftHeadLine) break;
// 13797           
// 13798           BlackRightLoc[i][0] = MaxValUint8;
??AngleZoneJudge_54:
        MOVS     R0,#+255
        LDR.W    R2,??DataTable68_3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        STRB     R0,[R2, #+0]
        ADDS     R1,R1,#+1
??AngleZoneJudge_53:
        LDR.W    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,R0
        BNE.N    ??AngleZoneJudge_54
// 13799         }
// 13800         //右线头的值更新。
// 13801         BlackRightHeadLine = BlackLeftHeadLine;        
        LDR.W    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable72
        STRB     R0,[R1, #+0]
// 13802       }
// 13803             
// 13804       return 1;
??AngleZoneJudge_49:
        MOVS     R0,#+1
        B.N      ??AngleZoneJudge_2
// 13805     }
// 13806     else
// 13807     {
// 13808       return 0;
??AngleZoneJudge_48:
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13809     }
// 13810 
// 13811   }
// 13812   //最终大跳变检测，发现右线有大跳变。或左线头比右线头高。
// 13813   //则左线检测多一些黑块，右线检测少一些黑块。
// 13814   else if(BlackBigChangeFinalCheckFlag == 2  || BlackLeftHeadLine < BlackRightHeadLine)
??AngleZoneJudge_4:
        LDR.W    R0,??DataTable71_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+2
        BEQ.N    ??AngleZoneJudge_55
        LDR.W    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable72
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCS.W    ??AngleZoneJudge_56
// 13815   {
// 13816     //1. 左线。检测多一些黑块。
// 13817     //2.1 取左线头往远处5行左右。
// 13818     for(i = 0; ; i++)
??AngleZoneJudge_55:
        MOVS     R1,#+0
        B.N      ??AngleZoneJudge_57
??AngleZoneJudge_58:
        ADDS     R1,R1,#+1
// 13819     {
// 13820       AngleZoneJudgeRowL[i] = BlackLeftHeadLine - i - 1;
??AngleZoneJudge_57:
        LDR.W    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+1
        LDR.W    R2,??DataTable71_8
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R0,[R1, R2]
// 13821         
// 13822       if(i == AngleZoneJudgeRowNum - 1) break;
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??AngleZoneJudge_58
// 13823     }
// 13824     //1.2 最小二乘法
// 13825     //取AngleZoneSlopeRowNum个点作为最小二乘法的基准点。
// 13826     //以左上角为原点，向下为x轴正方向，向右为y轴正方向
// 13827     //考虑到直角黑块大跳变现在基本可以滤除掉了，所以直角黑块定位的时候，采用线头左右开始往近处的8行，而不是最近的8行。
// 13828     index = 0;
        MOVS     R0,#+0
// 13829     for(i = BlackLeftHeadLine + 2; ; i++)
        LDR.W    R1,??DataTable71_2
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+2
        B.N      ??AngleZoneJudge_59
??AngleZoneJudge_60:
        ADDS     R1,R1,#+1
// 13830     {
// 13831       if(BlackLeftLoc[i][0] != MaxValUint8)
??AngleZoneJudge_59:
        LDR.W    R2,??DataTable71_9
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BEQ.N    ??AngleZoneJudge_61
// 13832       {
// 13833         y[index] = BlackLeftLoc[i][0];
        LDR.W    R2,??DataTable71_9
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        ADD      R3,SP,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R2,[R0, R3]
// 13834         x[index] = i;
        ADD      R2,SP,#+8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 13835         index++;
        ADDS     R0,R0,#+1
// 13836       }
// 13837       if(index == AngleJudgeSlopeRowNum)
??AngleZoneJudge_61:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+8
        BNE.N    ??AngleZoneJudge_62
// 13838       {
// 13839         break;  
// 13840       }
// 13841       
// 13842       if(i == CameraHight - 1) return 0;
// 13843     }
// 13844     //最小二乘法
// 13845     //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
// 13846     a1 = LeastSquarea1(x, y, AngleJudgeSlopeRowNum);
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea1
        MOVS     R4,R0
// 13847     //左边，斜率应该是-PathJudgeStraightSlopeLimit~0,否则斜率不对，返回失败。
// 13848     if(a1 < 0 && a1 + PathJudgeStraightSlopeLimit > 0)
        CMP      R4,#+0
        BPL.N    ??AngleZoneJudge_63
        ADDW     R0,R4,#+2100
        CMP      R0,#+1
        BGE.N    ??AngleZoneJudge_64
// 13849     {
// 13850     }
// 13851     else
// 13852     {
// 13853       return 0;
??AngleZoneJudge_63:
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13854     }
??AngleZoneJudge_62:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+59
        BNE.N    ??AngleZoneJudge_60
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13855     a0 = LeastSquarea0(x, y, a1, AngleJudgeSlopeRowNum);
??AngleZoneJudge_64:
        MOVS     R3,#+8
        MOVS     R2,R4
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea0
// 13856     //1.3 计算给定5行的左边界。标志位清零。
// 13857     //要往中间留AngleZoneCheckRowCom列的裕量。
// 13858     for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??AngleZoneJudge_65
??AngleZoneJudge_66:
        ADDS     R1,R1,#+1
// 13859     {
// 13860       //根据线头几行来最小二乘法还是比较准的，不用修正太多列。
// 13861       AngleZoneJudgeColL[i] = (a0 + a1 * AngleZoneJudgeRowL[i]) / LeastSquareMulti + AngleZoneJudgeRowCom;  
??AngleZoneJudge_65:
        LDR.W    R2,??DataTable71_8
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R2,[R1, R2]
        MLA      R2,R2,R4,R0
        MOV      R3,#+1000
        SDIV     R2,R2,R3
        ADDS     R2,R2,#+2
        LDR.W    R3,??DataTable72_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R2,[R1, R3]
// 13862       AngleZoneJudgeColLFlag[i] = 0;
        MOVS     R2,#+0
        LDR.W    R3,??DataTable72_2
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R2,[R1, R3]
// 13863       
// 13864       if(i == AngleZoneJudgeRowNum - 1) break;
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??AngleZoneJudge_66
// 13865     }
// 13866     //1.4 左边界确定后，往右一个赛道宽度内，只有有若干列都是黑点，则该行直角黑块判断成功。2行左右即可最终确认右线OK。
// 13867     for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??AngleZoneJudge_67
??AngleZoneJudge_68:
        ADDS     R1,R1,#+1
// 13868     {
// 13869       //每行的列黑点计数清零。
// 13870       countcol = 0;
??AngleZoneJudge_67:
        MOVS     R0,#+0
// 13871       //从右往左扫一个赛道宽度。赛道宽度预定为70列左右。
// 13872       if(AngleZoneJudgeColL[i] + AngleZoneJudgeRoadWidth > CameraRealWidth - 1)
        LDR.W    R2,??DataTable72_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R2,[R1, R2]
        ADDS     R2,R2,#+70
        CMP      R2,#+250
        BLT.N    ??AngleZoneJudge_69
// 13873       {
// 13874         return 0;
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13875       }
// 13876       else
// 13877       {
// 13878       }
// 13879       for(col = AngleZoneJudgeColL[i] + AngleZoneJudgeRoadWidth; ; col--)
??AngleZoneJudge_69:
        LDR.W    R2,??DataTable72_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R2,[R1, R2]
        ADDS     R2,R2,#+70
        B.N      ??AngleZoneJudge_70
??AngleZoneJudge_71:
        SUBS     R2,R2,#+1
// 13880       {
// 13881         //检测到有效黑点，计数加1.
// 13882         if(ImgNew[AngleZoneJudgeRowL[i]][col] < LimitLeftB) countcol++;
??AngleZoneJudge_70:
        LDR.N    R3,??DataTable68_4
        LDR.W    R4,??DataTable71_8
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R4,[R1, R4]
        MOVS     R5,#+250
        MLA      R3,R5,R4,R3
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        LDRB     R3,[R2, R3]
        LDR.N    R4,??DataTable68_5
        LDRB     R4,[R4, #+0]
        CMP      R3,R4
        BCS.N    ??AngleZoneJudge_72
        ADDS     R0,R0,#+1
// 13883         //该行右黑点够多。置标志位。跳出。
// 13884         if(countcol >= AngleZoneJudgeBlackNumP)  //优势边取45列左右，比障碍多。
??AngleZoneJudge_72:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+45
        BLT.N    ??AngleZoneJudge_73
// 13885         {
// 13886           AngleZoneJudgeColLFlag[i] = 1;
        MOVS     R2,#+1
        LDR.W    R3,??DataTable72_2
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R2,[R1, R3]
// 13887           break;
        B.N      ??AngleZoneJudge_74
// 13888         }
// 13889         //直到第70列也没有凑够黑点数，跳出。
// 13890         if(col == AngleZoneJudgeColL[i]) break;
??AngleZoneJudge_73:
        LDR.W    R3,??DataTable72_1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R3,[R1, R3]
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,R3
        BNE.N    ??AngleZoneJudge_71
// 13891       }
// 13892       //记录该行的有效黑点数，以供确定合适的阈值。
// 13893       AngleZoneJudgeCountColL[i] = countcol;
??AngleZoneJudge_74:
        LDR.W    R2,??DataTable72_3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R0,[R1, R2]
// 13894         
// 13895       //到最后一行了，退出。
// 13896       if(i == AngleZoneJudgeRowNum - 1) break;
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??AngleZoneJudge_68
// 13897     }
// 13898     //1.5 检测是不是至少有2行满足条件。若有，则继续检测左线，若无，则直接返回失败。
// 13899     count2 = 0;
        MOVS     R4,#+0
// 13900     for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??AngleZoneJudge_75
??AngleZoneJudge_76:
        ADDS     R1,R1,#+1
// 13901     {
// 13902       if(AngleZoneJudgeColLFlag[i] == 1) count2++;
??AngleZoneJudge_75:
        LDR.W    R0,??DataTable72_2
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R0,[R1, R0]
        CMP      R0,#+1
        BNE.N    ??AngleZoneJudge_77
        ADDS     R4,R4,#+1
// 13903       
// 13904       if(i == AngleZoneJudgeRowNum - 1) break;
??AngleZoneJudge_77:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??AngleZoneJudge_76
// 13905     }
// 13906     //反时限特性。两线头差值较大时，优势边的45列只要求一行。否则要求2行。
// 13907     if(AbsInt(BlackLeftHeadLine - BlackRightHeadLine) > 5)
        LDR.W    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable72
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        BL       AbsInt
        CMP      R0,#+6
        BLT.N    ??AngleZoneJudge_78
// 13908     {
// 13909       if(count2 >= 1)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+0
        BNE.N    ??AngleZoneJudge_79
// 13910       {
// 13911       }
// 13912       else
// 13913       {
// 13914         return 0;
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13915       }
// 13916     }
// 13917     else
// 13918     {
// 13919       if(count2 >= 2)
??AngleZoneJudge_78:
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+2
        BGE.N    ??AngleZoneJudge_79
// 13920       {
// 13921       }
// 13922       else
// 13923       {
// 13924         return 0;
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13925       }
// 13926     }
// 13927        
// 13928     //2. 右线。检测少一些黑块。
// 13929     //2.1 取右线头往远处5行左右。劣势边线头过去的第一行一般是不可能有那么多黑点的，所以要再过去一行。
// 13930     for(i = 0; ; i++)
??AngleZoneJudge_79:
        MOVS     R1,#+0
        B.N      ??AngleZoneJudge_80
??AngleZoneJudge_81:
        ADDS     R1,R1,#+1
// 13931     {
// 13932       AngleZoneJudgeRowR[i] = BlackRightHeadLine - i - 1 - 1;
??AngleZoneJudge_80:
        LDR.W    R0,??DataTable72
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+2
        LDR.W    R2,??DataTable71_4
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R0,[R1, R2]
// 13933         
// 13934       if(i == AngleZoneJudgeRowNum - 1) break;
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??AngleZoneJudge_81
// 13935     }
// 13936     //2.2 最小二乘法
// 13937     //取AngleZoneSlopeRowNum个点作为最小二乘法的基准点。
// 13938     //以左上角为原点，向下为x轴正方向，向右为y轴正方向
// 13939     //考虑到直角黑块大跳变现在基本可以滤除掉了，所以直角黑块定位的时候，采用线头左右开始往近处的8行，而不是最近的8行。
// 13940     index = 0;
        MOVS     R0,#+0
// 13941     for(i = BlackRightHeadLine + 2; ; i++)
        LDR.W    R1,??DataTable72
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+2
        B.N      ??AngleZoneJudge_82
??AngleZoneJudge_83:
        ADDS     R1,R1,#+1
// 13942     {
// 13943       if(BlackRightLoc[i][0] != MaxValUint8)
??AngleZoneJudge_82:
        LDR.N    R2,??DataTable68_3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        CMP      R2,#+255
        BEQ.N    ??AngleZoneJudge_84
// 13944       {
// 13945         y[index] = BlackRightLoc[i][0];
        LDR.N    R2,??DataTable68_3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        LDRB     R2,[R2, #+0]
        ADD      R3,SP,#+0
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R2,[R0, R3]
// 13946         x[index] = i;
        ADD      R2,SP,#+8
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 13947         index++;
        ADDS     R0,R0,#+1
// 13948       }
// 13949       if(index == AngleJudgeSlopeRowNum)
??AngleZoneJudge_84:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+8
        BNE.N    ??AngleZoneJudge_85
// 13950       {
// 13951         break;  
// 13952       }
// 13953       
// 13954       if(i == CameraHight - 1) return 0;
// 13955     }
// 13956     //最小二乘法
// 13957     //y = a0 + a1 * x（整体扩大了LeastSquareMulti倍）
// 13958     a1 = LeastSquarea1(x, y, AngleJudgeSlopeRowNum);
        MOVS     R2,#+8
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea1
        MOVS     R4,R0
// 13959     //右边，斜率应该是0~PathJudgeStraightSlopeLimit,否则斜率不对，返回失败。
// 13960     if(a1 > 0 && a1 < PathJudgeStraightSlopeLimit)
        SUBS     R0,R4,#+1
        MOVW     R1,#+2099
        CMP      R0,R1
        BCC.N    ??AngleZoneJudge_86
// 13961     {
// 13962     }
// 13963     else
// 13964     {
// 13965       return 0;
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13966     }
??AngleZoneJudge_85:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+59
        BNE.N    ??AngleZoneJudge_83
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13967     a0 = LeastSquarea0(x, y, a1, AngleJudgeSlopeRowNum);
??AngleZoneJudge_86:
        MOVS     R3,#+8
        MOVS     R2,R4
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
        BL       LeastSquarea0
// 13968     //2.3 计算给定5行的右边界。标志位清零。
// 13969     //要往中间留AngleZoneCheckRowCom列的裕量。
// 13970     for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??AngleZoneJudge_87
??AngleZoneJudge_88:
        ADDS     R1,R1,#+1
// 13971     {
// 13972       //根据线头几行来最小二乘法还是比较准的，不用修正太多列。
// 13973       AngleZoneJudgeColR[i] = (a0 + a1 * AngleZoneJudgeRowR[i]) / LeastSquareMulti - AngleZoneJudgeRowCom;  
??AngleZoneJudge_87:
        LDR.W    R2,??DataTable71_4
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R2,[R1, R2]
        MLA      R2,R2,R4,R0
        MOV      R3,#+1000
        SDIV     R2,R2,R3
        SUBS     R2,R2,#+2
        LDR.W    R3,??DataTable71_5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R2,[R1, R3]
// 13974       AngleZoneJudgeColRFlag[i] = 0;
        MOVS     R2,#+0
        LDR.W    R3,??DataTable71_6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R2,[R1, R3]
// 13975       
// 13976       if(i == AngleZoneJudgeRowNum - 1) break;
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??AngleZoneJudge_88
// 13977     }
// 13978     //2.4 右边界确定后，往左一个赛道宽度内，只有有若干列都是黑点，则该行直角黑块判断成功。2行左右即可最终确认右线OK。
// 13979     for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??AngleZoneJudge_89
??AngleZoneJudge_90:
        ADDS     R1,R1,#+1
// 13980     {
// 13981       //每行的列黑点计数清零。
// 13982       countcol = 0;
??AngleZoneJudge_89:
        MOVS     R0,#+0
// 13983       //从左往右扫半个赛道宽度。赛道宽度预定为70列左右。
// 13984       if(AngleZoneJudgeColR[i] - AngleZoneJudgeRoadWidth / 2 < 0) //劣势边只允许扫描半个赛道宽度。防止障碍被误判成直角黑块。
        LDR.W    R2,??DataTable71_5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R2,[R1, R2]
        SUBS     R2,R2,#+35
        CMP      R2,#+0
        BPL.N    ??AngleZoneJudge_91
// 13985       {
// 13986         return 0;
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 13987       }
// 13988       else
// 13989       {
// 13990       }      
// 13991       for(col = AngleZoneJudgeColR[i] - AngleZoneJudgeRoadWidth / 2; ; col++) //劣势边只允许扫描半个赛道宽度。防止障碍被误判成直角黑块。
??AngleZoneJudge_91:
        LDR.W    R2,??DataTable71_5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R2,[R1, R2]
        SUBS     R2,R2,#+35
        B.N      ??AngleZoneJudge_92
??AngleZoneJudge_93:
        ADDS     R2,R2,#+1
// 13992       {
// 13993         //检测到有效黑点，计数加1.
// 13994         if(ImgNew[AngleZoneJudgeRowR[i]][col] < LimitRightB) countcol++;
??AngleZoneJudge_92:
        LDR.N    R3,??DataTable68_4
        LDR.W    R4,??DataTable71_4
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R4,[R1, R4]
        MOVS     R5,#+250
        MLA      R3,R5,R4,R3
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        LDRB     R3,[R2, R3]
        LDR.N    R4,??DataTable68_10
        LDRB     R4,[R4, #+0]
        CMP      R3,R4
        BCS.N    ??AngleZoneJudge_94
        ADDS     R0,R0,#+1
// 13995         //该行右黑点够多。置标志位。跳出。
// 13996         if(countcol >= AngleZoneJudgeBlackNumN)  //劣势边取20列左右，比单线宽度多
??AngleZoneJudge_94:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+20
        BLT.N    ??AngleZoneJudge_95
// 13997         {
// 13998           AngleZoneJudgeColRFlag[i] = 1;
        MOVS     R2,#+1
        LDR.W    R3,??DataTable71_6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R2,[R1, R3]
// 13999           break;
        B.N      ??AngleZoneJudge_96
// 14000         }
// 14001         //直到第70列也没有凑够黑点数，跳出。
// 14002         if(col == AngleZoneJudgeColR[i]) break;
??AngleZoneJudge_95:
        LDR.W    R3,??DataTable71_5
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R3,[R1, R3]
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,R3
        BNE.N    ??AngleZoneJudge_93
// 14003       }
// 14004       //记录该行的有效黑点数，以供确定合适的阈值。
// 14005       AngleZoneJudgeCountColR[i] = countcol;      
??AngleZoneJudge_96:
        LDR.W    R2,??DataTable71_7
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        STRB     R0,[R1, R2]
// 14006         
// 14007       //到最后一行了，退出。
// 14008       if(i == AngleZoneJudgeRowNum - 1) break;
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??AngleZoneJudge_90
// 14009     }
// 14010     //2.5 检测是不是至少有2行满足条件。若有，则确认这幅图像是直角黑块，更新赛道类型、线头、返回成功。若无，则返回失败。
// 14011     count1 = 0;
        MOVS     R4,#+0
// 14012     for(i = 0; ; i++)
        MOVS     R1,#+0
        B.N      ??AngleZoneJudge_97
??AngleZoneJudge_98:
        ADDS     R1,R1,#+1
// 14013     {
// 14014       if(AngleZoneJudgeColRFlag[i] == 1) count1++;
??AngleZoneJudge_97:
        LDR.W    R0,??DataTable71_6
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LDRB     R0,[R1, R0]
        CMP      R0,#+1
        BNE.N    ??AngleZoneJudge_99
        ADDS     R4,R4,#+1
// 14015       
// 14016       if(i == AngleZoneJudgeRowNum - 1) break;
??AngleZoneJudge_99:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BNE.N    ??AngleZoneJudge_98
// 14017     }
// 14018     if(count1 >= 2)
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        CMP      R4,#+2
        BLT.N    ??AngleZoneJudge_100
// 14019     {
// 14020       //赛道类型，直角黑色区域。
// 14021       PathType = PathAngleZone; 
        MOVS     R0,#+10
        LDR.W    R1,??DataTable72_4
        STRB     R0,[R1, #+0]
// 14022       
// 14023       //对线头作处理，远线头拉到近线头处来。使远处的行不至于太偏。
// 14024       //线头相同，不用处理。
// 14025       if(BlackLeftHeadLine == BlackRightHeadLine)
        LDR.W    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable72
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BEQ.N    ??AngleZoneJudge_101
// 14026       {
// 14027       }
// 14028       //左线头更远
// 14029       else if(BlackLeftHeadLine < BlackRightHeadLine)
        LDR.W    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable72
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCS.N    ??AngleZoneJudge_102
// 14030       {
// 14031         //删掉左线头超出右线头的部分。
// 14032         for(i = BlackLeftHeadLine; ; i++)
        LDR.W    R0,??DataTable71_2
        LDRB     R1,[R0, #+0]
        B.N      ??AngleZoneJudge_103
// 14033         {
// 14034           if(i == BlackRightHeadLine) break;
// 14035           
// 14036           BlackLeftLoc[i][0] = MaxValUint8;
??AngleZoneJudge_104:
        MOVS     R0,#+255
        LDR.W    R2,??DataTable71_9
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        STRB     R0,[R2, #+0]
        ADDS     R1,R1,#+1
??AngleZoneJudge_103:
        LDR.W    R0,??DataTable72
        LDRB     R0,[R0, #+0]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,R0
        BNE.N    ??AngleZoneJudge_104
// 14037         }
// 14038         //左线头的值更新。
// 14039         BlackLeftHeadLine = BlackRightHeadLine;
        LDR.W    R0,??DataTable72
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable71_2
        STRB     R0,[R1, #+0]
        B.N      ??AngleZoneJudge_101
// 14040       }
// 14041       //右线头更远
// 14042       else
// 14043       {
// 14044         //删掉右线头超出左线头的部分。
// 14045         for(i = BlackRightHeadLine; ; i++)
??AngleZoneJudge_102:
        LDR.W    R0,??DataTable72
        LDRB     R1,[R0, #+0]
        B.N      ??AngleZoneJudge_105
// 14046         {
// 14047           if(i == BlackLeftHeadLine) break;
// 14048           
// 14049           BlackRightLoc[i][0] = MaxValUint8;
??AngleZoneJudge_106:
        MOVS     R0,#+255
        LDR.N    R2,??DataTable68_3
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R1,R2
        STRB     R0,[R2, #+0]
        ADDS     R1,R1,#+1
??AngleZoneJudge_105:
        LDR.W    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,R0
        BNE.N    ??AngleZoneJudge_106
// 14050         }
// 14051         //右线头的值更新。
// 14052         BlackRightHeadLine = BlackLeftHeadLine;        
        LDR.W    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable72
        STRB     R0,[R1, #+0]
// 14053       }
// 14054             
// 14055       return 1;      
??AngleZoneJudge_101:
        MOVS     R0,#+1
        B.N      ??AngleZoneJudge_2
// 14056     }
// 14057     else
// 14058     {
// 14059       return 0;
??AngleZoneJudge_100:
        MOVS     R0,#+0
        B.N      ??AngleZoneJudge_2
// 14060     }
// 14061     
// 14062   }
// 14063   //理论上不会走到这里，左右线头一定有个高低。
// 14064   else
// 14065   {
// 14066   }
// 14067   
// 14068   //常态是检测失败。
// 14069   return 0;
??AngleZoneJudge_56:
        MOVS     R0,#+0
??AngleZoneJudge_2:
        ADD      SP,SP,#+20
        POP      {R4,R5,PC}       ;; return
// 14070 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable68:
        DC32     BrickEndColL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable68_1:
        DC32     BrickHeadColL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable68_2:
        DC32     BrickBorderColL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable68_3:
        DC32     BlackRightLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable68_4:
        DC32     ImgNew

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable68_5:
        DC32     LimitLeftB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable68_6:
        DC32     BrickLineCountNumRecord

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable68_7:
        DC32     BrickEndColR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable68_8:
        DC32     BrickHeadColR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable68_9:
        DC32     BrickBorderColR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable68_10:
        DC32     LimitRightB
// 14071 
// 14072 
// 14073 //直角黑块确认函数

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 14074 uint8 AngleZoneConfirm(void)
// 14075 {
AngleZoneConfirm:
        PUSH     {R7,LR}
// 14076   
// 14077   uint8 i;
// 14078   
// 14079   //直角黑块锁存标志没有被置位的时候才进行直角黑块计数，若已被置位，则不用进行直角黑块计数。
// 14080   if(AngleZoneConfirmLockFlag == 0)
        LDR.W    R0,??DataTable76
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??AngleZoneConfirm_0
// 14081   {
// 14082     //A次计数内有B次直角黑块成功，则判断为直角黑块。先入先出队列。
// 14083     for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??AngleZoneConfirm_1
??AngleZoneConfirm_2:
        ADDS     R0,R0,#+1
// 14084     {
// 14085       AngleZoneConfirmMat[i] = AngleZoneConfirmMat[i + 1];
??AngleZoneConfirm_1:
        LDR.W    R1,??DataTable74
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        ADDS     R1,R0,R1
        LDRB     R1,[R1, #+1]
        LDR.W    R2,??DataTable74
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 14086       if(i == AngleZoneConfirmMatNum - 2) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+4
        BNE.N    ??AngleZoneConfirm_2
// 14087     }
// 14088     //成功
// 14089     if(PathType == PathAngleZone)
        LDR.W    R0,??DataTable72_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+10
        BNE.N    ??AngleZoneConfirm_3
// 14090     {
// 14091       //判定为直角黑块则新来的值置1。
// 14092       AngleZoneConfirmMat[AngleZoneConfirmMatNum - 1] = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable74
        STRB     R0,[R1, #+5]
        B.N      ??AngleZoneConfirm_4
// 14093     }
// 14094     else
// 14095     {
// 14096       //判定为非直角黑块则新来的值置0.
// 14097       AngleZoneConfirmMat[AngleZoneConfirmMatNum - 1] = 0;
??AngleZoneConfirm_3:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable74
        STRB     R0,[R1, #+5]
// 14098     }
// 14099     //收集AngleZoneConfirmMat数组里1的个数。
// 14100     AngleZoneConfirmMatCollect = 0;
??AngleZoneConfirm_4:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable74_1
        STRB     R0,[R1, #+0]
// 14101     for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??AngleZoneConfirm_5
??AngleZoneConfirm_6:
        ADDS     R0,R0,#+1
// 14102     {
// 14103       if(AngleZoneConfirmMat[i] == 1) AngleZoneConfirmMatCollect++;
??AngleZoneConfirm_5:
        LDR.W    R1,??DataTable74
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDRB     R1,[R0, R1]
        CMP      R1,#+1
        BNE.N    ??AngleZoneConfirm_7
        LDR.W    R1,??DataTable74_1
        LDRB     R1,[R1, #+0]
        ADDS     R1,R1,#+1
        LDR.W    R2,??DataTable74_1
        STRB     R1,[R2, #+0]
// 14104       
// 14105       if(i == AngleZoneConfirmMatNum - 1) break;
??AngleZoneConfirm_7:
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+5
        BNE.N    ??AngleZoneConfirm_6
// 14106     }
// 14107     //大于若干次，则锁存为直角黑块。
// 14108     if(AngleZoneConfirmMatCollect >= AngleZoneConfirmMatLimit)
        LDR.W    R0,??DataTable74_1
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable74_2
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCC.N    ??AngleZoneConfirm_0
// 14109     {
// 14110       //锁存标志位置位。
// 14111       AngleZoneConfirmLockFlag = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable76
        STRB     R0,[R1, #+0]
// 14112       //锁存标志位置位时，同时把1米距离内的计数值清零。
// 14113       AngleZoneConfirmLockMeterCount = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable75
        STRB     R0,[R1, #+0]
// 14114       //数组清空，防止重复锁存。
// 14115       for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??AngleZoneConfirm_8
??AngleZoneConfirm_9:
        ADDS     R0,R0,#+1
// 14116       {
// 14117         AngleZoneConfirmMat[i] = 0;
??AngleZoneConfirm_8:
        MOVS     R1,#+0
        LDR.W    R2,??DataTable74
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 14118         if(i == AngleZoneConfirmMatNum - 1) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+5
        BNE.N    ??AngleZoneConfirm_9
// 14119       }
// 14120 
// 14121       //PatyType在AngleZoneJudge中已经更新。
// 14122     }
// 14123     else
// 14124     {
// 14125     }
// 14126   }
// 14127   //直角黑块锁存已被置位，则不用进行直角黑块计数。
// 14128   else
// 14129   {
// 14130   }
// 14131   
// 14132   //若直角黑块锁存标志位置位，则对1米的距离内保持锁存，若检测到不到线头高度差，则释放。
// 14133   //按2 m/s速度，跑1米大概需要0.5s，也就是30个16ms，3m/s对应20个16ms.所以应取30个以上。
// 14134   if(AngleZoneConfirmLockFlag == 1)
??AngleZoneConfirm_0:
        LDR.W    R0,??DataTable76
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??AngleZoneConfirm_10
// 14135   {
// 14136     //直角黑块锁存期间，若线头差小于4，则远处线头删至近处线头。
// 14137     if(AbsInt(BlackLeftHeadLine - BlackRightHeadLine) < 4)
        LDR.N    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable72
        LDRB     R1,[R1, #+0]
        SUBS     R0,R0,R1
        BL       AbsInt
        CMP      R0,#+4
        BGE.N    ??AngleZoneConfirm_11
// 14138     {
// 14139       //线头相同，不用处理。
// 14140       if(BlackLeftHeadLine == BlackRightHeadLine)
        LDR.N    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable72
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BEQ.N    ??AngleZoneConfirm_11
// 14141       {
// 14142       }
// 14143       //左线头更远
// 14144       else if(BlackLeftHeadLine < BlackRightHeadLine)
        LDR.N    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable72
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCS.N    ??AngleZoneConfirm_12
// 14145       {   
// 14146         //删掉左线头超出右线头的部分。
// 14147         for(i = BlackLeftHeadLine; ; i++)
        LDR.N    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        B.N      ??AngleZoneConfirm_13
// 14148         {
// 14149           if(i == BlackRightHeadLine) break;
// 14150           
// 14151           BlackLeftLoc[i][0] = MaxValUint8;
??AngleZoneConfirm_14:
        MOVS     R1,#+255
        LDR.N    R2,??DataTable71_9
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
        ADDS     R0,R0,#+1
??AngleZoneConfirm_13:
        LDR.W    R1,??DataTable72
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BNE.N    ??AngleZoneConfirm_14
// 14152         }
// 14153         //左线头的值更新。
// 14154         BlackLeftHeadLine = BlackRightHeadLine;
        LDR.W    R0,??DataTable72
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable71_2
        STRB     R0,[R1, #+0]
        B.N      ??AngleZoneConfirm_11
// 14155       }
// 14156       //右线头更远
// 14157       else
// 14158       {
// 14159         //删掉右线头超出左线头的部分。
// 14160         for(i = BlackRightHeadLine; ; i++)
??AngleZoneConfirm_12:
        LDR.W    R0,??DataTable72
        LDRB     R0,[R0, #+0]
        B.N      ??AngleZoneConfirm_15
// 14161         {
// 14162           if(i == BlackLeftHeadLine) break;
// 14163           
// 14164           BlackRightLoc[i][0] = MaxValUint8;
??AngleZoneConfirm_16:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable75_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
        ADDS     R0,R0,#+1
??AngleZoneConfirm_15:
        LDR.N    R1,??DataTable71_2
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BNE.N    ??AngleZoneConfirm_16
// 14165         }
// 14166         //右线头的值更新。
// 14167         BlackRightHeadLine = BlackLeftHeadLine;        
        LDR.N    R0,??DataTable71_2
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable72
        STRB     R0,[R1, #+0]
// 14168       }
// 14169     }
// 14170     else
// 14171     {
// 14172     }
// 14173     
// 14174     //Count的意义：
// 14175     //1. 直角黑块锁存确认后，Count清零。
// 14176     //2. 直角黑块锁存期间：2.1. 若没有检测到 障碍 或者 直角线头差，则计数加1。若连续计数直至达到阈值，则觉得应该是出直角的直角黑块，则计数清零，允许再次检测直角。
// 14177     //                     2.2. 若检测到了，则计数清零
// 14178     //3. 直角黑块非锁存期间：不做对计数做任何处理。
// 14179     if(AngleZoneConfirmLockFlag == 1)
??AngleZoneConfirm_11:
        LDR.W    R0,??DataTable76
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??AngleZoneConfirm_10
// 14180     {
// 14181       if(PathType == PathTypeAngleL || PathType == PathTypeAngleR || PathType == PathBrickLeft || PathType == PathBrickRight)
        LDR.W    R0,??DataTable72_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+4
        BEQ.N    ??AngleZoneConfirm_17
        LDR.W    R0,??DataTable72_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+5
        BEQ.N    ??AngleZoneConfirm_17
        LDR.W    R0,??DataTable72_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+8
        BEQ.N    ??AngleZoneConfirm_17
        LDR.W    R0,??DataTable72_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+9
        BNE.N    ??AngleZoneConfirm_18
// 14182       {
// 14183         //计数清零
// 14184         AngleZoneConfirmLockMeterCount = 0;
??AngleZoneConfirm_17:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable75
        STRB     R0,[R1, #+0]
        B.N      ??AngleZoneConfirm_10
// 14185       }
// 14186       else
// 14187       {
// 14188         AngleZoneConfirmLockMeterCount++;
??AngleZoneConfirm_18:
        LDR.W    R0,??DataTable75
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.W    R1,??DataTable75
        STRB     R0,[R1, #+0]
// 14189         if(AngleZoneConfirmLockMeterCount > AngleZoneConfirmLockMeterCountLimit)
        LDR.W    R0,??DataTable75
        LDRB     R0,[R0, #+0]
        CMP      R0,#+41
        BLT.N    ??AngleZoneConfirm_10
// 14190         {
// 14191           //1米左右的距离仍没有检测到高度差，释放锁存标志位，再次检测直角黑块。
// 14192           AngleZoneConfirmLockFlag = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable76
        STRB     R0,[R1, #+0]
// 14193         }
// 14194         else
// 14195         {      
// 14196         }
// 14197       }
// 14198     }
// 14199     else
// 14200     {
// 14201     }
// 14202   }
// 14203   else
// 14204   {
// 14205   }
// 14206 
// 14207   
// 14208   return 1;
??AngleZoneConfirm_10:
        MOVS     R0,#+1
        POP      {R1,PC}          ;; return
// 14209 
// 14210   
// 14211   
// 14212 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable69:
        DC32     BlackLeftCrossDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable69_1:
        DC32     BlackLeftRow1RealLastLine
// 14213 
// 14214 
// 14215 //赛道类型判断
// 14216 //返回0出错，1正常。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 14217 uint8 PathJudgeNew(void)
// 14218 {
PathJudgeNew:
        PUSH     {R7,LR}
// 14219   
// 14220   //0. 默认赛道类型未知。
// 14221   PathType = PathTypeUnknown;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable72_4
        STRB     R0,[R1, #+0]
// 14222   
// 14223 
// 14224   //1. 直角线头差 、 障碍 的 锁存 或 特殊控制 期间，不进行直角、直角黑块、障碍的检测 以及 直道 的检测。
// 14225   if(
// 14226     (AngleConfirmLockFlag == 1)   //直角锁存期间
// 14227   ||(AngleSpeDealFlag == 1)       //直角强制控制期间
// 14228   ||(BrickConfirmLockFlag == 1)   //障碍锁存期间
// 14229   ||(BrickSpeDealFlag == 1)       //障碍特殊控制期间
// 14230   ||(GyroResultForbidFlag == 1)   //坡道禁止赛道类型判断期间
// 14231     )
        LDR.W    R0,??DataTable76_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??PathJudgeNew_0
        LDR.W    R0,??DataTable76_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??PathJudgeNew_0
        LDR.W    R0,??DataTable76_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??PathJudgeNew_0
        LDR.W    R0,??DataTable76_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BEQ.N    ??PathJudgeNew_0
        LDR.W    R0,??DataTable76_5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??PathJudgeNew_1
// 14232   {
// 14233     //连续长直道计数清零。
// 14234     PathRealStraightCount = 0;
??PathJudgeNew_0:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable77
        STRB     R0,[R1, #+0]
// 14235     //锁存或特殊控制期间，说明障碍或直角已经判断成功，可以将直角黑块锁存标志复位，允许判断直角黑块。
// 14236     AngleZoneConfirmLockFlag = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable76
        STRB     R0,[R1, #+0]
        B.N      ??PathJudgeNew_2
// 14237   }
// 14238   else
// 14239   {
// 14240     //判断停车线
// 14241     //if(StopLineCheck()){StopLineCheckFlag = 1;}
// 14242     //十字的二重判定
// 14243     //if(ShiZhiCheck()) { ShiZhiFlag = 1; } else {ShiZhiFlag = 0;}
// 14244     //2.1 直角黑块未锁存期间，检测直角黑块 或 障碍物 或 直道， 不检测直角线头差。
// 14245     if(AngleZoneConfirmLockFlag == 0)
??PathJudgeNew_1:
        LDR.W    R0,??DataTable76
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??PathJudgeNew_3
// 14246     {
// 14247       //2.1.1. 判断直道。
// 14248       if(PathJudgeNewStraight() == 1)
        BL       PathJudgeNewStraight
// 14249       {
// 14250       }
// 14251       else
// 14252       {
// 14253       }
// 14254 
// 14255       //2.1.2. 先检测直角黑块检测    //这届不检测了
// 14256       //AngleZoneJudge();
// 14257       //2.1.3. 若直角黑块检测不成功，再检测障碍物。
// 14258       if(PathType != PathAngleZone)
        LDR.N    R0,??DataTable72_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+10
        BEQ.N    ??PathJudgeNew_2
// 14259       {
// 14260         BrickJudge();
        BL       BrickJudge
        B.N      ??PathJudgeNew_2
// 14261       }
// 14262       //直角黑块检测成功，就不用检测障碍物了。
// 14263       else
// 14264       {
// 14265 
// 14266       }    
// 14267     }
// 14268     //2.2 直角黑块锁存期间，检测障碍物 和 直角线头差。不检测直角黑块 和 直道。
// 14269     else
// 14270     {
// 14271       //2.2.1锁存期间，先检测障碍物。
// 14272       BrickJudge();
??PathJudgeNew_3:
        BL       BrickJudge
// 14273       //2.2.2 障碍物未检测成功，则检测直角线头差。 
// 14274       if(PathType != PathBrickLeft && PathType != PathBrickRight)
// 14275       {
// 14276         //AngleStep1Judge();
// 14277         
// 14278       }
// 14279       //确认为障碍，不进行直角线头差的检测。为了避免错误，直角线头差中还必须包括对黑块的扫描。
// 14280       else
// 14281       {
// 14282       }      
// 14283       
// 14284     }
// 14285   }
// 14286 
// 14287   //3. 长直道判断
// 14288   if(PathType == PathTypeStraight)
??PathJudgeNew_2:
        LDR.N    R0,??DataTable72_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??PathJudgeNew_4
// 14289   {
// 14290     //新加入的停车线的检测，在直角和障碍均检测不到时检测
// 14291     //if(StopLineCheck()){StopLineCheckFlag = 1;light_control(PORTE, 26, Light_ON);}
// 14292     
// 14293     //连续长直道计数加1。
// 14294     PathRealStraightCount++;
        LDR.W    R0,??DataTable77
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.W    R1,??DataTable77
        STRB     R0,[R1, #+0]
// 14295     //连续计数达到阈值
// 14296     if(PathRealStraightCount > PathRealStraightCountLimit)
        LDR.W    R0,??DataTable78
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable77
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCS.N    ??PathJudgeNew_5
// 14297     {
// 14298       //长直道标志置1.
// 14299       PathRealStraightFlag = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable78_1
        STRB     R0,[R1, #+0]
// 14300       //计数清零
// 14301       PathRealStraightCount = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable77
        STRB     R0,[R1, #+0]
        B.N      ??PathJudgeNew_6
// 14302     }
// 14303     else if(PathRealStraightCount > 5)
??PathJudgeNew_5:
        LDR.W    R0,??DataTable77
        LDRB     R0,[R0, #+0]
        CMP      R0,#+6
        BLT.N    ??PathJudgeNew_6
// 14304     {
// 14305         xiaoZhiDaoFlag = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable78_2
        STRB     R0,[R1, #+0]
        B.N      ??PathJudgeNew_6
// 14306     }
// 14307     else
// 14308     {
// 14309     }
// 14310     
// 14311   }
// 14312   else
// 14313   {
// 14314     //一旦检测到非直道，则计数清零。
// 14315     PathRealStraightCount = 0;
??PathJudgeNew_4:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable77
        STRB     R0,[R1, #+0]
// 14316     //一旦检测到非直道，则长直道标志复位。
// 14317     PathRealStraightFlag = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_1
        STRB     R0,[R1, #+0]
// 14318     xiaoZhiDaoFlag = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_2
        STRB     R0,[R1, #+0]
// 14319   }
// 14320   
// 14321   
// 14322   
// 14323   
// 14324   
// 14325 //  //1. 判断直道。
// 14326 //  if(PathJudgeNewStraight() == 1)
// 14327 //  {
// 14328 //    //2. 直角锁存或特殊控制、障碍锁存或特殊控制期间，不进行直角、直角黑块、障碍的检测。
// 14329 //    if(AngleConfirmLockFlag == 1 || AngleSpeDealFlag == 1 || BrickConfirmLockFlag == 1 || BrickSpeDealFlag == 1)
// 14330 //    {
// 14331 //    }
// 14332 //    else
// 14333 //    {
// 14334 //      //3. 直角黑块未锁存期间，检测直角黑块 或 障碍物，不检测直角线头差。
// 14335 //      if(AngleZoneConfirmLockFlag == 0)
// 14336 //      {
// 14337 //        //4. 先检测直角黑块检测
// 14338 //        AngleZoneJudge();
// 14339 //        //5. 若直角黑块检测不成功，再检测障碍物。
// 14340 //        if(PathType != PathAngleZone)
// 14341 //        {
// 14342 //          BrickJudge();
// 14343 //        }
// 14344 //        //直角黑块检测成功，就不用检测障碍物了。
// 14345 //        else
// 14346 //        {
// 14347 //        }    
// 14348 //      }
// 14349 //      //直角黑块锁存期间，检测直角线头差。不检测直角黑块 和 障碍物。
// 14350 //      else
// 14351 //      {
// 14352 //        AngleStep1Judge();
// 14353 //      }
// 14354 //    }
// 14355 //  }
// 14356 //  //不是直道，直接退出。
// 14357 //  else
// 14358 //  {
// 14359 //  }      
// 14360       
// 14361       
// 14362       
// 14363       
// 14364 //  //判断直道。
// 14365 //  if(PathJudgeNewStraight() == 1)
// 14366 //  {
// 14367 //    //障碍或直角的锁存和强制控制期间，不需要进行障碍或直角检测，以免误判 或 重复锁存。
// 14368 //    if(AngleConfirmLockFlag == 0 && AngleSpeDealFlag == 0
// 14369 //    && BrickConfirmLockFlag == 0 && BrickSpeDealFlag == 0)
// 14370 //    {
// 14371 //      //障碍判断
// 14372 //      BrickJudge();
// 14373 //      if(PathType != PathBrickLeft && PathType != PathBrickRight)
// 14374 //      {
// 14375 //        //如果不是障碍，则可以进一步判断是不是直角弯。
// 14376 //        //直角先去掉，专门测砖块。   //AngleStep1Judge();
// 14377 //      }
// 14378 //      else
// 14379 //      {
// 14380 //      }
// 14381 //    }
// 14382 //    else
// 14383 //    {
// 14384 //    }
// 14385 //  }
// 14386 //  else
// 14387 //  {
// 14388 //  }
// 14389   
// 14390   return 1;
??PathJudgeNew_6:
        MOVS     R0,#+1
        POP      {R1,PC}          ;; return
// 14391 }
// 14392 
// 14393 
// 14394 //各种变量的初始化赋值函数

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 14395 uint8 VariablesInit(void)
// 14396 {
// 14397   uint8 i;
// 14398   
// 14399   LimitLeftWB = LimitLeftWBMin;    //黑白像素点的差值，两个点的差必须要大于这个值，才能认为有跳变。
VariablesInit:
        LDR.W    R0,??DataTable78_3
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_4
        STRB     R0,[R1, #+0]
// 14400   LimitLeftW  = LimitLeftWMin;      //白点必须要大于此值
        LDR.W    R0,??DataTable78_5
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_6
        STRB     R0,[R1, #+0]
// 14401   LimitLeftB  = LimitLeftBMax;      //黑点必须要小于此值
        LDR.W    R0,??DataTable78_7
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_8
        STRB     R0,[R1, #+0]
// 14402 
// 14403   //每幅有效图像的左线线头对应的3个阈值，单独储存，每幅有效图像刷新一次。
// 14404   LimitLeftHeadWB = LimitLeftWBMin;    
        LDR.W    R0,??DataTable78_3
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_9
        STRB     R0,[R1, #+0]
// 14405   LimitLeftHeadW  = LimitLeftWMin;      
        LDR.W    R0,??DataTable78_5
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_10
        STRB     R0,[R1, #+0]
// 14406   LimitLeftHeadB  = LimitLeftBMax;
        LDR.W    R0,??DataTable78_7
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_11
        STRB     R0,[R1, #+0]
// 14407   
// 14408   LimitRightWB = LimitRightWBMin;    //黑白像素点的差值，两个点的差必须要大于这个值，才能认为有跳变。
        LDR.W    R0,??DataTable78_12
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_13
        STRB     R0,[R1, #+0]
// 14409   LimitRightW  = LimitRightWMin;      //白点必须要大于此值
        LDR.W    R0,??DataTable78_14
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_15
        STRB     R0,[R1, #+0]
// 14410   LimitRightB  = LimitRightBMax;      //黑点必须要小于此值
        LDR.W    R0,??DataTable78_16
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_17
        STRB     R0,[R1, #+0]
// 14411 
// 14412   //每幅有效图像的左线线头对应的3个阈值，单独储存，每幅有效图像刷新一次。
// 14413   LimitRightHeadWB = LimitRightWBMin;    
        LDR.W    R0,??DataTable78_12
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_18
        STRB     R0,[R1, #+0]
// 14414   LimitRightHeadW = LimitRightWMin;      
        LDR.W    R0,??DataTable78_14
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_19
        STRB     R0,[R1, #+0]
// 14415   LimitRightHeadB = LimitRightBMax;  
        LDR.W    R0,??DataTable78_16
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_20
        STRB     R0,[R1, #+0]
// 14416   
// 14417   //左右黑线跳变沿检测的起始列。需要考虑中间单线的宽度。
// 14418   BlackLeftLastEdgeStartCol = CameraRealWidth/2 + SingleBlackWidthMax[CameraHight-1];
        LDR.W    R0,??DataTable78_21
        LDRB     R0,[R0, #+59]
        ADDS     R0,R0,#+125
        LDR.W    R1,??DataTable78_22
        STRB     R0,[R1, #+0]
// 14419   BlackLeftEdgeStartCol = CameraRealWidth/2 + SingleBlackWidthMax[CameraHight-1];
        LDR.W    R0,??DataTable78_21
        LDRB     R0,[R0, #+59]
        ADDS     R0,R0,#+125
        LDR.W    R1,??DataTable78_23
        STRB     R0,[R1, #+0]
// 14420   
// 14421   BlackRightLastEdgeStartCol = CameraRealWidth/2 - SingleBlackWidthMax[CameraHight-1]; 
        LDR.W    R0,??DataTable78_21
        LDRB     R0,[R0, #+59]
        RSBS     R0,R0,#+125
        LDR.W    R1,??DataTable78_24
        STRB     R0,[R1, #+0]
// 14422   BlackRightEdgeStartCol = CameraRealWidth/2 - SingleBlackWidthMax[CameraHight-1];
        LDR.W    R0,??DataTable78_21
        LDRB     R0,[R0, #+59]
        RSBS     R0,R0,#+125
        LDR.W    R1,??DataTable78_25
        STRB     R0,[R1, #+0]
// 14423   
// 14424   //中心线获取时的赛道半宽，针对单线的情况。初始化为一个最大黑线宽度。
// 14425   RoadHalfWidthSingle = SingleBlackWidthMax[CameraHight - 1];
        LDR.W    R0,??DataTable78_21
        LDRB     R0,[R0, #+59]
        LDR.W    R1,??DataTable78_26
        STRB     R0,[R1, #+0]
// 14426   
// 14427   //直角弯标志存储数组，初始化为均不是直角。
// 14428   for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??VariablesInit_0
??VariablesInit_1:
        ADDS     R0,R0,#+1
// 14429   {
// 14430     AngleConfirmMat[i] = 0;
??VariablesInit_0:
        MOVS     R1,#+0
        LDR.W    R2,??DataTable78_27
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 14431     if(i == AngleConfirmMatNum - 1) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+5
        BNE.N    ??VariablesInit_1
// 14432   }
// 14433   
// 14434   //双线半宽
// 14435   RoadHalfWidth = 100;
        MOVS     R0,#+100
        LDR.W    R1,??DataTable78_28
        STRB     R0,[R1, #+0]
// 14436   RoadHalfWidthLast = RoadHalfWidth;
        LDR.W    R0,??DataTable78_28
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_29
        STRB     R0,[R1, #+0]
// 14437   
// 14438   return 1;
        MOVS     R0,#+1
        BX       LR               ;; return
// 14439 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable71:
        DC32     BlackLeftDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable71_1:
        DC32     BlackRightDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable71_2:
        DC32     BlackLeftHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable71_3:
        DC32     BlackBigChangeFinalCheckFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable71_4:
        DC32     AngleZoneJudgeRowR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable71_5:
        DC32     AngleZoneJudgeColR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable71_6:
        DC32     AngleZoneJudgeColRFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable71_7:
        DC32     AngleZoneJudgeCountColR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable71_8:
        DC32     AngleZoneJudgeRowL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable71_9:
        DC32     BlackLeftLoc
// 14440 
// 14441 
// 14442 
// 14443 
// 14444 
// 14445 
// 14446 
// 14447 
// 14448 
// 14449 //======================================================================
// 14450 //函数名：ImageProParaInit
// 14451 //功  能：每幅图像处理之前的参数初始化函数
// 14452 //参  数：
// 14453 //返  回：
// 14454 //影  响：
// 14455 //说  明：
// 14456 //      
// 14457 //             
// 14458 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 14459 uint8 ImageProParaInit(void)
// 14460 {
// 14461   uint8 i;
// 14462   
// 14463   //图像处理成功标志位，默认置1.
// 14464   ImgBlackSucceedFlag = 1;
ImageProParaInit:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable78_30
        STRB     R0,[R1, #+0]
// 14465   ImgCenterSucceedFlag = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable78_31
        STRB     R0,[R1, #+0]
// 14466   //小S弯判断标志初始化为失败。
// 14467   PathSmallSDoneFlag = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_32
        STRB     R0,[R1, #+0]
// 14468    
// 14469   //中心线数组赋无效值。
// 14470   for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??ImageProParaInit_0
??ImageProParaInit_1:
        ADDS     R0,R0,#+1
// 14471   {
// 14472     CenterLineLoc[i] = MaxValInt16;
??ImageProParaInit_0:
        MOVW     R1,#+32767
        LDR.W    R2,??DataTable78_33
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRH     R1,[R2, R0, LSL #+1]
// 14473     if(i == CameraHight - 1) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??ImageProParaInit_1
// 14474   }
// 14475 
// 14476   //赛道半宽记录值
// 14477   for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??ImageProParaInit_2
??ImageProParaInit_3:
        ADDS     R0,R0,#+1
// 14478   {
// 14479     RoadHalfWidthRecord[i] = MaxValUint8;
??ImageProParaInit_2:
        MOVS     R1,#+255
        LDR.W    R2,??DataTable78_34
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 14480     if(i == CameraHight - 1) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??ImageProParaInit_3
// 14481   }
// 14482   
// 14483   //通过赛道半宽判断出来的单线错误标志，初始化为未进入。
// 14484   RoadHalfWidthWrongFlag = 2;
        MOVS     R0,#+2
        LDR.W    R1,??DataTable78_35
        STRB     R0,[R1, #+0]
// 14485   
// 14486   //单线地板变量的处理。
// 14487   SingleDoneFlag = 0;       
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_36
        STRB     R0,[R1, #+0]
// 14488   SingleFloorFlag = 0;            
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_37
        STRB     R0,[R1, #+0]
// 14489   SingleFloorConfirmCount = 0;     
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_38
        STRB     R0,[R1, #+0]
// 14490   SingleFloorConfirmCountMax = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_39
        STRB     R0,[R1, #+0]
// 14491 
// 14492   //每行的单线确认标志初始化为失败。
// 14493   for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??ImageProParaInit_4
??ImageProParaInit_5:
        ADDS     R0,R0,#+1
// 14494   {
// 14495     SingleBlackFlag[i] = 0;
??ImageProParaInit_4:
        MOVS     R1,#+0
        LDR.W    R2,??DataTable78_40
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 14496     if(i == CameraHight - 1) break;
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+59
        BNE.N    ??ImageProParaInit_5
// 14497   }
// 14498   //总幅图像的单线标志，先存上一次的标志，再初始化为0.
// 14499   SingleBlackLastAllFlag = SingleBlackAllFlag;
        LDR.W    R0,??DataTable78_41
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_42
        STRB     R0,[R1, #+0]
// 14500   SingleBlackAllFlag = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_41
        STRB     R0,[R1, #+0]
// 14501   
// 14502   //单线错误标志。0没错误，1有错误。每幅图初始化为0.
// 14503   BlackSingleFlag = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_43
        STRB     R0,[R1, #+0]
// 14504   
// 14505   flag222 = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_44
        STR      R0,[R1, #+0]
// 14506   
// 14507   BrickLineCountNumRecord = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_45
        STRB     R0,[R1, #+0]
// 14508   
// 14509   //最终大跳变检测标志位
// 14510   BlackBigChangeFinalCheckFlag = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_46
        STRB     R0,[R1, #+0]
// 14511   
// 14512   //直角黑块
// 14513   for(i = 0; ; i++)
        MOVS     R0,#+0
        B.N      ??ImageProParaInit_6
??ImageProParaInit_7:
        ADDS     R0,R0,#+1
// 14514   {
// 14515     AngleZoneJudgeRowL[i] = 0;  //直角黑块，根据线头选中的要检测的左线行。
??ImageProParaInit_6:
        MOVS     R1,#+0
        LDR.W    R2,??DataTable78_47
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 14516     AngleZoneJudgeRowR[i] = 0;  //直角黑块，根据线头选中的要检测的右线行。
        MOVS     R1,#+0
        LDR.W    R2,??DataTable78_48
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 14517     AngleZoneJudgeColL[i] = 0;  //直角黑块，左线定位的所在列。
        MOVS     R1,#+0
        LDR.N    R2,??DataTable72_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 14518     AngleZoneJudgeCountColL[i] = 0;
        MOVS     R1,#+0
        LDR.N    R2,??DataTable72_3
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 14519     AngleZoneJudgeColLFlag[i] = 0; //直角黑块，左线该行的有效黑点满足要求时置位。
        MOVS     R1,#+0
        LDR.N    R2,??DataTable72_2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 14520     AngleZoneJudgeColR[i] = 0;  //直角黑块，右线定位的所在列。
        MOVS     R1,#+0
        LDR.W    R2,??DataTable78_49
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 14521     AngleZoneJudgeColRFlag[i] = 0; //直角黑块，右线该行的有效黑点满足要求时置位。 
        MOVS     R1,#+0
        LDR.W    R2,??DataTable78_50
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 14522     AngleZoneJudgeCountColR[i] = 0;
        MOVS     R1,#+0
        LDR.W    R2,??DataTable78_51
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRB     R1,[R0, R2]
// 14523     
// 14524     if(i == AngleZoneJudgeRowNum - 1) break;   
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+4
        BNE.N    ??ImageProParaInit_7
// 14525   }
// 14526   
// 14527   //障碍
// 14528   BrickEndColL = 0;    //障碍物，左直角梯形，起始行（近行）黑点所在列。
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_52
        STRB     R0,[R1, #+0]
// 14529   BrickHeadColL = 0;   //障碍物，左直角梯形，结束行（远行）黑点所在列。
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_53
        STRB     R0,[R1, #+0]
// 14530   BrickBorderColL = 0; //障碍物，左直角梯形，直角边所在列。
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_54
        STRB     R0,[R1, #+0]
// 14531   BrickEndColR = 0;    //障碍物，右直角梯形，起始行（近行）黑点所在列。
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_55
        STRB     R0,[R1, #+0]
// 14532   BrickHeadColR = 0;   //障碍物，右直角梯形，结束行（远行）黑点所在列。
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_56
        STRB     R0,[R1, #+0]
// 14533   BrickBorderColR = 0; //障碍物，右直角梯形，直角边所在列。  
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_57
        STRB     R0,[R1, #+0]
// 14534   BrickSpeDealCenFlag = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable78_58
        STRB     R0,[R1, #+0]
// 14535   
// 14536   return 1;
        MOVS     R0,#+1
        BX       LR               ;; return
// 14537   
// 14538 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable72:
        DC32     BlackRightHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable72_1:
        DC32     AngleZoneJudgeColL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable72_2:
        DC32     AngleZoneJudgeColLFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable72_3:
        DC32     AngleZoneJudgeCountColL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable72_4:
        DC32     PathType
// 14539 
// 14540 //图像成功后的处理。
// 14541 //只有图像处理成功了，才会进行赛道类型判断，才会进行偏差获取，舵机电机控制值才会更新。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 14542 uint8 ImgProSucceedDeal(void)
// 14543 {
ImgProSucceedDeal:
        PUSH     {R7,LR}
// 14544   uint8 startline;
// 14545   
// 14546   //上一幅图最终的赛道半宽，图像成功才会切换。
// 14547   RoadHalfWidthLast = RoadHalfWidth;
        LDR.W    R0,??DataTable78_28
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_29
        STRB     R0,[R1, #+0]
// 14548   
// 14549   /*
// 14550   //赛道类型判断
// 14551   //到这里时，中心线提取成功，左右黑线至少有一个提取成功。
// 14552   PathJudgeDone = 1; //赛道类型判断标志位，默认成功
// 14553   if(!PathJudge())
// 14554   {
// 14555     PathJudgeDone = 0;  //赛道类型判断标志位，判断失败。
// 14556     PathType = 0;       //赛道类型置为未知。
// 14557     //uart_sendN(UART0, (uint8 *)"\nPathJudge Failed!", 18);
// 14558     //return 0;         //赛道类型判断失败了还能继续，不用返回0.
// 14559   }
// 14560   else
// 14561   {
// 14562   }
// 14563   */
// 14564   
// 14565   //发送中心线数组，不用发送float型的数据，同样的处理可以由上位机完成。
// 14566   //SendCenterLineLoc(CenterLineLoc);
// 14567   
// 14568   //SendImage(ImgNew);  
// 14569   
// 14570   //因为采用多行控制，所以把小S弯对偏差的特殊处理去掉了。
// 14571   /*
// 14572   //对小S弯的特殊处理。
// 14573   if(PathType == PathTypeSmallSL || PathType == PathTypeSmallSR)
// 14574   {
// 14575     //若为小S弯，则特殊处理。
// 14576     PathTypeSmallDeal();
// 14577   }
// 14578   else
// 14579   {
// 14580     //若不为小S弯，则正常求取偏差
// 14581     DeviationGet();        
// 14582   }
// 14583   */
// 14584        
// 14585    //多行偏差算法。
// 14586   //BiasFuse();
// 14587   DeviationFuse();
        BL       DeviationFuse
// 14588   MtrGet();//计算DeviFuse,DeviFuse_dot的隶属度
        BL       MtrGet
// 14589   
// 14590   EmergencyStopCount = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable78_59
        STRB     R0,[R1, #+0]
// 14591   
// 14592   //下一幅图像的黑线起始扫描列更新，
// 14593   ////////////必须保证第CameraHight - 1行有效。
// 14594   BlackLeftLastEdgeStartCol = BlackLeftEdgeStartCol;
        LDR.W    R0,??DataTable78_23
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_22
        STRB     R0,[R1, #+0]
// 14595   BlackRightLastEdgeStartCol = BlackRightEdgeStartCol;
        LDR.W    R0,??DataTable78_25
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_24
        STRB     R0,[R1, #+0]
// 14596 
// 14597 //  //障碍特殊控制期间，不需要更新扫描起点。
// 14598 //  if(BrickSpeDealFlag == 1)
// 14599 //  {
// 14600 //    startline = BlackCenEdgeStartCol;
// 14601 //  }
// 14602 //  //不是障碍特殊控制，则正常取扫描起点。
// 14603 //  else
// 14604 //  {
// 14605     //若第CameraHight-1行的中心线数组有效，则取它。
// 14606     if(CenterLineLoc[CameraHight-1] != MaxValInt16)
        LDR.W    R0,??DataTable78_33
        LDRSH    R0,[R0, #+118]
        MOVW     R1,#+32767
        CMP      R0,R1
        BEQ.N    ??ImgProSucceedDeal_0
// 14607     {
// 14608       startline = CenterLineLoc[CameraHight-1];
        LDR.W    R0,??DataTable78_33
        LDRH     R0,[R0, #+118]
        B.N      ??ImgProSucceedDeal_1
// 14609     }
// 14610     //若无效，则取第CameraHight-7(大于5行才能根据斜率来算)行对应的矫正行的BiasCal的计算值（根据斜率估算）
// 14611     else
// 14612     {
// 14613       //startline = CameraRealWidth / 2 - BiasCal(BlackUdisLeftLocation[CameraHight-7].y);
// 14614       //这种情况一般是十字，这时不用根据BiasCal来计算，直接用上一幅图的就好。否则会算得很乱。 
// 14615       startline = BlackCenEdgeStartCol;
??ImgProSucceedDeal_0:
        LDR.W    R0,??DataTable78_60
        LDRB     R0,[R0, #+0]
// 14616     }
// 14617 //  }
// 14618   
// 14619   //扫描起点的定位点
// 14620   BlackCenEdgeStartCol = BoundaryLimitRe(startline,
// 14621                                          BlackCenEdgeStartColLimitL,
// 14622                                          BlackCenEdgeStartColLimitR
// 14623                                          );
??ImgProSucceedDeal_1:
        MOVS     R2,#+220
        MOVS     R1,#+30
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BoundaryLimitRe
        LDR.W    R1,??DataTable78_60
        STRB     R0,[R1, #+0]
// 14624   //若上一幅图是单线，则左右两边放宽，2个单线宽度。
// 14625   if(SingleBlackLastAllFlag == 1)
        LDR.W    R0,??DataTable78_42
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??ImgProSucceedDeal_2
// 14626   {
// 14627     //BlackLeftEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] + SingleBlackWidthMax[CameraHight-1],
// 14628     //左扫描起点等于定位点向右2个单线宽度。
// 14629     BlackLeftEdgeStartCol = BoundaryLimitRe(MinRe(CameraRealWidth - 1, BlackCenEdgeStartCol + 2 * SingleBlackWidthMax[CameraHight-1]),
// 14630                                             0,
// 14631                                             CameraRealWidth-1
// 14632                                             );
        LDR.W    R0,??DataTable78_60
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_21
        LDRB     R1,[R1, #+59]
        LSLS     R1,R1,#+1
        ADDS     R1,R1,R0
        MOVS     R0,#+249
        BL       MinRe
        MOVS     R2,#+249
        MOVS     R1,#+0
        BL       BoundaryLimitRe
        LDR.W    R1,??DataTable78_23
        STRB     R0,[R1, #+0]
// 14633     //BlackRightEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] - SingleBlackWidthMax[CameraHight-1],
// 14634     //右扫描起点等于定位点向左2个单线宽度。
// 14635     BlackRightEdgeStartCol = BoundaryLimitRe(MaxRe(0, BlackCenEdgeStartCol - 2 * SingleBlackWidthMax[CameraHight-1]),
// 14636                                              0,
// 14637                                              CameraRealWidth-1
// 14638                                             );        
        LDR.W    R0,??DataTable78_60
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_21
        LDRB     R1,[R1, #+59]
        SUBS     R1,R0,R1, LSL #+1
        MOVS     R0,#+0
        BL       MaxRe
        MOVS     R2,#+249
        MOVS     R1,#+0
        BL       BoundaryLimitRe
        LDR.W    R1,??DataTable78_25
        STRB     R0,[R1, #+0]
        B.N      ??ImgProSucceedDeal_3
// 14639   }
// 14640   //上一幅图不是单线，双线正常处理。
// 14641   else
// 14642   {
// 14643     //不是障碍特殊处理阶段。左右各取1个单线宽度。
// 14644     if(BrickSpeDealFlag == 0)
??ImgProSucceedDeal_2:
        LDR.W    R0,??DataTable76_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??ImgProSucceedDeal_4
// 14645     {
// 14646       //BlackLeftEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] + SingleBlackWidthMax[CameraHight-1],
// 14647       //左扫描起点等于定位点向右1个单线宽度。
// 14648       BlackLeftEdgeStartCol = BoundaryLimitRe(MinRe(CameraRealWidth - 1, BlackCenEdgeStartCol + SingleBlackWidthMax[CameraHight-1]),
// 14649                                               0,
// 14650                                               CameraRealWidth-1
// 14651                                               );
        LDR.W    R0,??DataTable78_60
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_21
        LDRB     R1,[R1, #+59]
        ADDS     R1,R1,R0
        MOVS     R0,#+249
        BL       MinRe
        MOVS     R2,#+249
        MOVS     R1,#+0
        BL       BoundaryLimitRe
        LDR.W    R1,??DataTable78_23
        STRB     R0,[R1, #+0]
// 14652       //BlackRightEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] - SingleBlackWidthMax[CameraHight-1],
// 14653       //右扫描起点等于定位点向左1个单线宽度。
// 14654       BlackRightEdgeStartCol = BoundaryLimitRe(MaxRe(0, BlackCenEdgeStartCol - SingleBlackWidthMax[CameraHight-1]),
// 14655                                                0,
// 14656                                                CameraRealWidth-1
// 14657                                               );    
        LDR.W    R0,??DataTable78_60
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_21
        LDRB     R1,[R1, #+59]
        SUBS     R1,R0,R1
        MOVS     R0,#+0
        BL       MaxRe
        MOVS     R2,#+249
        MOVS     R1,#+0
        BL       BoundaryLimitRe
        LDR.W    R1,??DataTable78_25
        STRB     R0,[R1, #+0]
        B.N      ??ImgProSucceedDeal_3
// 14658     }
// 14659     //障碍特殊处理阶段
// 14660     else
// 14661     {
// 14662       //左障碍，右线扫描起点向左一个单线宽度，左线扫描起点就取中心线处。
// 14663       if(BrickSpeDealDir == 0)
??ImgProSucceedDeal_4:
        LDR.W    R0,??DataTable78_61
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??ImgProSucceedDeal_5
// 14664       {
// 14665         //BlackLeftEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] + SingleBlackWidthMax[CameraHight-1],
// 14666         //左扫描起点取定位点。
// 14667         BlackLeftEdgeStartCol = BoundaryLimitRe(MinRe(CameraRealWidth - 1, BlackCenEdgeStartCol + 1),
// 14668                                                 0,
// 14669                                                 CameraRealWidth-1
// 14670                                                 );
        LDR.W    R0,??DataTable78_60
        LDRB     R0,[R0, #+0]
        ADDS     R1,R0,#+1
        MOVS     R0,#+249
        BL       MinRe
        MOVS     R2,#+249
        MOVS     R1,#+0
        BL       BoundaryLimitRe
        LDR.W    R1,??DataTable78_23
        STRB     R0,[R1, #+0]
// 14671         //BlackRightEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] - SingleBlackWidthMax[CameraHight-1],
// 14672         //右扫描起点等于定位点向左3个单线宽度。
// 14673         BlackRightEdgeStartCol = BoundaryLimitRe(MaxRe(0, BlackCenEdgeStartCol - 3 * SingleBlackWidthMax[CameraHight-1]),
// 14674                                                  0,
// 14675                                                  CameraRealWidth-1
// 14676                                                 );
        LDR.W    R0,??DataTable78_60
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_21
        LDRB     R1,[R1, #+59]
        MOVS     R2,#+3
        MLS      R1,R2,R1,R0
        MOVS     R0,#+0
        BL       MaxRe
        MOVS     R2,#+249
        MOVS     R1,#+0
        BL       BoundaryLimitRe
        LDR.W    R1,??DataTable78_25
        STRB     R0,[R1, #+0]
// 14677         //右扫描起点必须至少在右线左边3个单线宽度。
// 14678         if(BlackRightLoc[CameraHight - 1][0] != MaxValUint8)
        LDR.W    R0,??DataTable75_1
        LDRB     R0,[R0, #+177]
        CMP      R0,#+255
        BEQ.N    ??ImgProSucceedDeal_3
// 14679         {
// 14680           BlackRightEdgeStartCol = BoundaryLimitRe(MinRe(BlackRightEdgeStartCol, BlackRightLoc[CameraHight - 1][0] - 3 * SingleBlackWidthMax[CameraHight-1]),
// 14681                                                   0,
// 14682                                                   CameraRealWidth-1
// 14683                                                   );
        LDR.W    R0,??DataTable75_1
        LDRB     R0,[R0, #+177]
        LDR.W    R1,??DataTable78_21
        LDRB     R1,[R1, #+59]
        MOVS     R2,#+3
        MLS      R1,R2,R1,R0
        LDR.W    R0,??DataTable78_25
        LDRB     R0,[R0, #+0]
        BL       MinRe
        MOVS     R2,#+249
        MOVS     R1,#+0
        BL       BoundaryLimitRe
        LDR.W    R1,??DataTable78_25
        STRB     R0,[R1, #+0]
        B.N      ??ImgProSucceedDeal_3
// 14684         }
// 14685         else
// 14686         {
// 14687         }        
// 14688       }
// 14689       //右障碍，左线扫描起点向右一个单线宽度，右线扫描起点就取中心线处。
// 14690       else
// 14691       {
// 14692         //BlackLeftEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] + SingleBlackWidthMax[CameraHight-1],
// 14693         //左扫描起点等于定位点向右3个单线宽度
// 14694         BlackLeftEdgeStartCol = BoundaryLimitRe(MinRe(CameraRealWidth - 1, BlackCenEdgeStartCol + 3 * SingleBlackWidthMax[CameraHight-1]),
// 14695                                                 0,
// 14696                                                 CameraRealWidth-1
// 14697                                                 );
??ImgProSucceedDeal_5:
        LDR.W    R0,??DataTable78_60
        LDRB     R0,[R0, #+0]
        LDR.W    R1,??DataTable78_21
        LDRB     R1,[R1, #+59]
        MOVS     R2,#+3
        MULS     R1,R2,R1
        ADDS     R1,R1,R0
        MOVS     R0,#+249
        BL       MinRe
        MOVS     R2,#+249
        MOVS     R1,#+0
        BL       BoundaryLimitRe
        LDR.W    R1,??DataTable78_23
        STRB     R0,[R1, #+0]
// 14698         //BlackRightEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] - SingleBlackWidthMax[CameraHight-1],
// 14699         //右扫描起点取定位点。
// 14700         BlackRightEdgeStartCol = BoundaryLimitRe(MaxRe(0, BlackCenEdgeStartCol - 1),
// 14701                                                  0,
// 14702                                                  CameraRealWidth-1
// 14703                                                 );
        LDR.W    R0,??DataTable78_60
        LDRB     R0,[R0, #+0]
        SUBS     R1,R0,#+1
        MOVS     R0,#+0
        BL       MaxRe
        MOVS     R2,#+249
        MOVS     R1,#+0
        BL       BoundaryLimitRe
        LDR.W    R1,??DataTable78_25
        STRB     R0,[R1, #+0]
// 14704         
// 14705         //左扫描起点必须至少在左线右边3个单线宽度。
// 14706         if(BlackLeftLoc[CameraHight - 1][0] != MaxValUint8)
        LDR.W    R0,??DataTable78_62
        LDRB     R0,[R0, #+177]
        CMP      R0,#+255
        BEQ.N    ??ImgProSucceedDeal_3
// 14707         {
// 14708           BlackLeftEdgeStartCol = BoundaryLimitRe(MaxRe(BlackLeftEdgeStartCol, BlackLeftLoc[CameraHight - 1][0] + 3 * SingleBlackWidthMax[CameraHight-1]),
// 14709                                                   0,
// 14710                                                   CameraRealWidth-1
// 14711                                                   );
        LDR.W    R0,??DataTable78_62
        LDRB     R0,[R0, #+177]
        LDR.W    R1,??DataTable78_21
        LDRB     R1,[R1, #+59]
        MOVS     R2,#+3
        MULS     R1,R2,R1
        ADDS     R1,R1,R0
        LDR.W    R0,??DataTable78_23
        LDRB     R0,[R0, #+0]
        BL       MaxRe
        MOVS     R2,#+249
        MOVS     R1,#+0
        BL       BoundaryLimitRe
        LDR.W    R1,??DataTable78_23
        STRB     R0,[R1, #+0]
// 14712         }
// 14713         else
// 14714         {
// 14715         }
// 14716       }
// 14717     }
// 14718   }
// 14719   
// 14720 
// 14721   
// 14722   //右线扫描起点必须在左线扫描起点左边
// 14723   BlackRightEdgeStartCol = MinRe(BlackRightEdgeStartCol, BlackLeftEdgeStartCol);
??ImgProSucceedDeal_3:
        LDR.W    R0,??DataTable78_23
        LDRB     R1,[R0, #+0]
        LDR.W    R0,??DataTable78_25
        LDRB     R0,[R0, #+0]
        BL       MinRe
        LDR.W    R1,??DataTable78_25
        STRB     R0,[R1, #+0]
// 14724 
// 14725   return 1;
        MOVS     R0,#+1
        POP      {R1,PC}          ;; return
// 14726 }
// 14727 
// 14728 
// 14729 //图像失败后的处理。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 14730 uint8 ImgProFailDeal(void)
// 14731 {
ImgProFailDeal:
        PUSH     {R7,LR}
// 14732   uint8 startline;
// 14733   int tempB, tempW, tempWB;
// 14734   
// 14735   
// 14736   //图像失败，偏差仍更新
// 14737   /*
// 14738   DeviPrePrePre=DeviPrePre;
// 14739   DeviPrePre=DeviPre;
// 14740   DeviPre=DeviFuse;
// 14741   DeviFuse=DeviPre+((DeviPre-DeviPrePre)*7+(DeviPrePre-DeviPrePrePre)*3)/10;
// 14742   MtrGet();//计算DeviFuse,DeviFuse_dot的隶属度
// 14743   */
// 14744   
// 14745   //紧急停车很危险，容易造成程序死循环，所以要慎用。用开关控制用不用。
// 14746   if(EmergencyStopSwitch == 1)
// 14747   {
// 14748     //图像处理失败计数，用作紧急停车。
// 14749     EmergencyStopCount++;
// 14750     if(EmergencyStopCount > EmergencyStopCountNum)
// 14751     {
// 14752       //计数器清零。
// 14753       EmergencyStopCount = 0;
// 14754       //紧急停车标志位。
// 14755       EmergencyStopFlag = 1;
// 14756       
// 14757       //紧急停车处理，电机输出0，并死循环，等待掉电。
// 14758       FTM0_C4V = 0;
// 14759       FTM0_C5V = 0;
// 14760       FTM0_C6V = 0;
// 14761       FTM0_C7V = 0;
// 14762       //死循环
// 14763       while(1) ;
// 14764     }
// 14765     else
// 14766     {
// 14767       
// 14768     }
// 14769   }
// 14770   else
// 14771   {
// 14772     
// 14773   }
// 14774   
// 14775   //赛道半宽判断出的单线错误标志置位时，扫描起点复位。直角弯不允许更新。
// 14776   if(RoadHalfWidthWrongFlag == 1 && AngleSpeDealFlag == 0)
        LDR.W    R0,??DataTable78_35
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??ImgProFailDeal_0
        LDR.W    R0,??DataTable76_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??ImgProFailDeal_0
// 14777   {
// 14778     //左线悬空
// 14779     if(RoadHalfWidthWrongDir == 0)
        LDR.W    R0,??DataTable78_63
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??ImgProFailDeal_1
// 14780     {
// 14781       //左线最有可能是单线。
// 14782       if(BlackLeftLoc[BlackLeftStep1ScanRow][0] != MaxValUint8)
        LDR.W    R0,??DataTable78_62
        LDR.W    R1,??DataTable78_64
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??ImgProFailDeal_2
// 14783       {
// 14784         startline = BlackLeftLoc[BlackLeftStep1ScanRow][0];
        LDR.W    R0,??DataTable78_62
        LDR.W    R1,??DataTable78_64
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        B.N      ??ImgProFailDeal_3
// 14785       }
// 14786       else
// 14787       {
// 14788         startline = CameraRealWidth / 2;
??ImgProFailDeal_2:
        MOVS     R0,#+125
        B.N      ??ImgProFailDeal_3
// 14789       }
// 14790     }
// 14791     //右线悬空
// 14792     else if(RoadHalfWidthWrongDir == 1)
??ImgProFailDeal_1:
        LDR.W    R0,??DataTable78_63
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??ImgProFailDeal_4
// 14793     {
// 14794       //右线最有可能是单线。
// 14795       if(BlackRightLoc[BlackRightStep1ScanRow][0] != MaxValUint8)
        LDR.N    R0,??DataTable75_1
        LDR.W    R1,??DataTable78_65
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??ImgProFailDeal_5
// 14796       {
// 14797         startline = BlackRightLoc[BlackRightStep1ScanRow][0];
        LDR.N    R0,??DataTable75_1
        LDR.W    R1,??DataTable78_65
        LDRB     R1,[R1, #+0]
        MOVS     R2,#+3
        MLA      R0,R2,R1,R0
        LDRB     R0,[R0, #+0]
        B.N      ??ImgProFailDeal_3
// 14798       }
// 14799       else
// 14800       {
// 14801         startline = CameraRealWidth / 2;
??ImgProFailDeal_5:
        MOVS     R0,#+125
        B.N      ??ImgProFailDeal_3
// 14802       }            
// 14803     }
// 14804     else 
// 14805     {    
// 14806       //理论上不可能走到这里。
// 14807       startline = CameraRealWidth / 2;
??ImgProFailDeal_4:
        MOVS     R0,#+125
// 14808     }
// 14809     
// 14810     //扫描起点的定位点
// 14811     BlackCenEdgeStartCol = BoundaryLimitRe(startline,
// 14812                                            BlackCenEdgeStartColLimitL,
// 14813                                            BlackCenEdgeStartColLimitR
// 14814                                            );
??ImgProFailDeal_3:
        MOVS     R2,#+220
        MOVS     R1,#+30
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        BL       BoundaryLimitRe
        LDR.W    R1,??DataTable78_60
        STRB     R0,[R1, #+0]
// 14815     
// 14816     
// 14817     //BlackLeftEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] + SingleBlackWidthMax[CameraHight-1],
// 14818     //左扫描起点等于定位点向左1个单线宽度。
// 14819     BlackLeftEdgeStartCol = BoundaryLimitRe(BlackCenEdgeStartCol + SingleBlackWidthMax[CameraHight-1],
// 14820                                             0,
// 14821                                             CameraRealWidth-1
// 14822                                             );
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable78_60
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable78_21
        LDRB     R3,[R3, #+59]
        ADDS     R0,R3,R0
        BL       BoundaryLimitRe
        LDR.W    R1,??DataTable78_23
        STRB     R0,[R1, #+0]
// 14823     //BlackRightEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] - SingleBlackWidthMax[CameraHight-1],
// 14824     //右扫描起点等于定位点向右1个单线宽度。
// 14825     BlackRightEdgeStartCol = BoundaryLimitRe(BlackCenEdgeStartCol - SingleBlackWidthMax[CameraHight-1],
// 14826                                              0,
// 14827                                              CameraRealWidth-1
// 14828                                             );
        MOVS     R2,#+249
        MOVS     R1,#+0
        LDR.W    R0,??DataTable78_60
        LDRB     R0,[R0, #+0]
        LDR.W    R3,??DataTable78_21
        LDRB     R3,[R3, #+59]
        SUBS     R0,R0,R3
        BL       BoundaryLimitRe
        LDR.W    R1,??DataTable78_25
        STRB     R0,[R1, #+0]
// 14829     
// 14830     //右线扫描起点必须在左线扫描起点左边
// 14831     BlackRightEdgeStartCol = MinRe(BlackRightEdgeStartCol, BlackLeftEdgeStartCol);
        LDR.W    R0,??DataTable78_23
        LDRB     R1,[R0, #+0]
        LDR.W    R0,??DataTable78_25
        LDRB     R0,[R0, #+0]
        BL       MinRe
        LDR.W    R1,??DataTable78_25
        STRB     R0,[R1, #+0]
// 14832   }
// 14833   else
// 14834   {    
// 14835   }
// 14836   
// 14837   //只要不是直角弯导致的图像失败，则猜测可能是图像线头阈值太严格。线头阈值放宽一点点。 
// 14838   if(AngleSpeDealFlag == 0)
??ImgProFailDeal_0:
        LDR.N    R0,??DataTable76_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.W    ??ImgProFailDeal_6
// 14839   {
// 14840     //左线线头阈值放宽一点点。
// 14841     //差值的处理，留有裕度，且有上下界。放宽一半裕度。
// 14842     tempWB = LimitLeftHeadWB - LimitLeftWBMargin / 2; 
        LDR.W    R0,??DataTable78_9
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+10
// 14843     if(tempWB < LimitLeftWBMin) tempWB = LimitLeftWBMin;
        LDR.W    R1,??DataTable78_3
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BGE.N    ??ImgProFailDeal_7
        LDR.W    R0,??DataTable78_3
        LDRB     R0,[R0, #+0]
        B.N      ??ImgProFailDeal_8
// 14844     else if(tempWB > LimitLeftWBMax) tempWB = LimitLeftWBMax;
??ImgProFailDeal_7:
        LDR.W    R1,??DataTable78_66
        LDRB     R1,[R1, #+0]
        CMP      R1,R0
        BGE.N    ??ImgProFailDeal_8
        LDR.W    R0,??DataTable78_66
        LDRB     R0,[R0, #+0]
// 14845     else ;
// 14846     LimitLeftHeadWB = tempWB;
??ImgProFailDeal_8:
        LDR.W    R1,??DataTable78_9
        STRB     R0,[R1, #+0]
// 14847     
// 14848     //白点的处理，留有裕度，且有上下界。放宽一半裕度。
// 14849     tempW = LimitLeftHeadW - LimitLeftWMargin / 2;
        LDR.W    R0,??DataTable78_10
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+20
// 14850     if(tempW < LimitLeftWMin) tempW = LimitLeftWMin;
        LDR.W    R1,??DataTable78_5
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BGE.N    ??ImgProFailDeal_9
        LDR.W    R0,??DataTable78_5
        LDRB     R0,[R0, #+0]
        B.N      ??ImgProFailDeal_10
// 14851     else if(tempW > LimitLeftWMax) tempW = LimitLeftWMax;
??ImgProFailDeal_9:
        LDR.W    R1,??DataTable78_67
        LDRB     R1,[R1, #+0]
        CMP      R1,R0
        BGE.N    ??ImgProFailDeal_10
        LDR.W    R0,??DataTable78_67
        LDRB     R0,[R0, #+0]
// 14852     else ;
// 14853     LimitLeftHeadW = tempW;
??ImgProFailDeal_10:
        LDR.W    R1,??DataTable78_10
        STRB     R0,[R1, #+0]
// 14854     
// 14855     //黑点的处理，留有裕度，且有上下界。放宽一半裕度。
// 14856     tempB = LimitLeftHeadB + LimitLeftBMargin / 2;
        LDR.W    R0,??DataTable78_11
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+17
// 14857     if(tempB < LimitLeftBMin) tempB = LimitLeftBMin;
        LDR.W    R1,??DataTable78_68
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BGE.N    ??ImgProFailDeal_11
        LDR.W    R0,??DataTable78_68
        LDRB     R0,[R0, #+0]
        B.N      ??ImgProFailDeal_12
// 14858     else if(tempB > LimitLeftBMax) tempB = LimitLeftBMax;
??ImgProFailDeal_11:
        LDR.N    R1,??DataTable78_7
        LDRB     R1,[R1, #+0]
        CMP      R1,R0
        BGE.N    ??ImgProFailDeal_12
        LDR.N    R0,??DataTable78_7
        LDRB     R0,[R0, #+0]
// 14859     else ;
// 14860     //黑色阈值不能超过白色
// 14861     if(tempB >= LimitLeftHeadW)
??ImgProFailDeal_12:
        LDR.N    R1,??DataTable78_10
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BLT.N    ??ImgProFailDeal_13
// 14862     {
// 14863       tempB = LimitLeftHeadW - 1;
        LDR.N    R0,??DataTable78_10
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
// 14864     }
// 14865     else
// 14866     {
// 14867     }             
// 14868     LimitLeftHeadB = tempB;  
??ImgProFailDeal_13:
        LDR.N    R1,??DataTable78_11
        STRB     R0,[R1, #+0]
// 14869     
// 14870     
// 14871     //右线线头阈值放宽一点点。
// 14872     //差值的处理，留有裕度，且有上下界。放宽一半裕度。
// 14873     tempWB = LimitRightHeadWB - LimitRightWBMargin / 2; 
        LDR.N    R0,??DataTable78_18
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+10
// 14874     if(tempWB < LimitRightWBMin) tempWB = LimitRightWBMin;
        LDR.N    R1,??DataTable78_12
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BGE.N    ??ImgProFailDeal_14
        LDR.N    R0,??DataTable78_12
        LDRB     R0,[R0, #+0]
        B.N      ??ImgProFailDeal_15
// 14875     else if(tempWB > LimitRightWBMax) tempWB = LimitRightWBMax;
??ImgProFailDeal_14:
        LDR.W    R1,??DataTable78_69
        LDRB     R1,[R1, #+0]
        CMP      R1,R0
        BGE.N    ??ImgProFailDeal_15
        LDR.W    R0,??DataTable78_69
        LDRB     R0,[R0, #+0]
// 14876     else ;
// 14877     LimitRightHeadWB = tempWB;
??ImgProFailDeal_15:
        LDR.N    R1,??DataTable78_18
        STRB     R0,[R1, #+0]
// 14878     
// 14879     //白点的处理，留有裕度，且有上下界。放宽一半裕度。
// 14880     tempW = LimitRightHeadW - LimitRightWMargin / 2;
        LDR.N    R0,??DataTable78_19
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+20
// 14881     if(tempW < LimitRightWMin) tempW = LimitRightWMin;
        LDR.N    R1,??DataTable78_14
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BGE.N    ??ImgProFailDeal_16
        LDR.N    R0,??DataTable78_14
        LDRB     R0,[R0, #+0]
        B.N      ??ImgProFailDeal_17
// 14882     else if(tempW > LimitRightWMax) tempW = LimitRightWMax;
??ImgProFailDeal_16:
        LDR.W    R1,??DataTable78_70
        LDRB     R1,[R1, #+0]
        CMP      R1,R0
        BGE.N    ??ImgProFailDeal_17
        LDR.W    R0,??DataTable78_70
        LDRB     R0,[R0, #+0]
// 14883     else ;
// 14884     LimitRightHeadW = tempW;
??ImgProFailDeal_17:
        LDR.N    R1,??DataTable78_19
        STRB     R0,[R1, #+0]
// 14885     
// 14886     //黑点的处理，留有裕度，且有上下界。放宽一半裕度。
// 14887     tempB = LimitRightHeadB + LimitRightBMargin / 2;
        LDR.N    R0,??DataTable78_20
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+17
// 14888     if(tempB < LimitRightBMin) tempB = LimitRightBMin;
        LDR.W    R1,??DataTable78_71
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BGE.N    ??ImgProFailDeal_18
        LDR.W    R0,??DataTable78_71
        LDRB     R0,[R0, #+0]
        B.N      ??ImgProFailDeal_19
// 14889     else if(tempB > LimitRightBMax) tempB = LimitRightBMax;
??ImgProFailDeal_18:
        LDR.N    R1,??DataTable78_16
        LDRB     R1,[R1, #+0]
        CMP      R1,R0
        BGE.N    ??ImgProFailDeal_19
        LDR.N    R0,??DataTable78_16
        LDRB     R0,[R0, #+0]
// 14890     else ;
// 14891     //黑色阈值不能超过白色
// 14892     if(tempB >= LimitRightHeadW)
??ImgProFailDeal_19:
        LDR.N    R1,??DataTable78_19
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BLT.N    ??ImgProFailDeal_20
// 14893     {
// 14894       tempB = LimitRightHeadW - 1;
        LDR.N    R0,??DataTable78_19
        LDRB     R0,[R0, #+0]
        SUBS     R0,R0,#+1
// 14895     }
// 14896     else
// 14897     {
// 14898     }             
// 14899     LimitRightHeadB = tempB;  
??ImgProFailDeal_20:
        LDR.N    R1,??DataTable78_20
        STRB     R0,[R1, #+0]
// 14900   }
// 14901   else
// 14902   {
// 14903   }
// 14904   
// 14905   
// 14906   
// 14907   //下一幅图像的黑线起始扫描列更新，暂时保持不变。
// 14908   BlackLeftLastEdgeStartCol = BlackLeftEdgeStartCol;
??ImgProFailDeal_6:
        LDR.N    R0,??DataTable78_23
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable78_22
        STRB     R0,[R1, #+0]
// 14909   BlackRightLastEdgeStartCol = BlackRightEdgeStartCol;
        LDR.N    R0,??DataTable78_25
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable78_24
        STRB     R0,[R1, #+0]
// 14910 //  BlackLeftEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] + SingleBlackWidthMax[CameraHight-1],
// 14911 //                                          0,
// 14912 //                                          CameraRealWidth-1
// 14913 //                                          );
// 14914 //  BlackRightEdgeStartCol = BoundaryLimitRe(CenterLineLoc[CameraHight-1] - SingleBlackWidthMax[CameraHight-1],
// 14915 //                                           0,
// 14916 //                                           CameraRealWidth-1
// 14917 //                                          );
// 14918   
// 14919   return 1;
        MOVS     R0,#+1
        POP      {R1,PC}          ;; return
// 14920 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable74:
        DC32     AngleZoneConfirmMat

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable74_1:
        DC32     AngleZoneConfirmMatCollect

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable74_2:
        DC32     AngleZoneConfirmMatLimit
// 14921 
// 14922 
// 14923 
// 14924 //坡道禁止赛道类型判断期间的线头平齐

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 14925 uint8 GyroResultForbidSpeDeal(void)
// 14926 {
// 14927   uint8 row;
// 14928   
// 14929   //标志置位期间，将线头平齐。
// 14930   if(GyroResultForbidFlag == 1 && BlackLeftDone == 1 && BlackRightDone == 1 && BlackLeftHeadLine != MaxValUint8 && BlackRightHeadLine != MaxValUint8)
GyroResultForbidSpeDeal:
        LDR.N    R0,??DataTable76_5
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??GyroResultForbidSpeDeal_0
        LDR.N    R0,??DataTable78_72
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??GyroResultForbidSpeDeal_0
        LDR.N    R0,??DataTable78_73
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??GyroResultForbidSpeDeal_0
        LDR.N    R0,??DataTable78_74
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??GyroResultForbidSpeDeal_0
        LDR.N    R0,??DataTable75_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+255
        BEQ.N    ??GyroResultForbidSpeDeal_0
// 14931   {
// 14932     //右线头高，且两线头差别不大时。
// 14933     if(BlackLeftHeadLine > BlackRightHeadLine && BlackLeftHeadLine <= BlackRightHeadLine + 5)
        LDR.N    R0,??DataTable75_2
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable78_74
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCS.N    ??GyroResultForbidSpeDeal_1
        LDR.N    R0,??DataTable75_2
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+5
        LDR.N    R1,??DataTable78_74
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BLT.N    ??GyroResultForbidSpeDeal_1
// 14934     {
// 14935       //对右线头削顶。
// 14936       for(row = BlackRightHeadLine; ; row++)
        LDR.N    R0,??DataTable75_2
        LDRB     R0,[R0, #+0]
        B.N      ??GyroResultForbidSpeDeal_2
??GyroResultForbidSpeDeal_3:
        ADDS     R0,R0,#+1
// 14937       {
// 14938         BlackRightLoc[row][0] = MaxValUint8;
??GyroResultForbidSpeDeal_2:
        MOVS     R1,#+255
        LDR.N    R2,??DataTable75_1
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 14939         
// 14940         if(row == BlackLeftHeadLine) break;
        LDR.N    R1,??DataTable78_74
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BNE.N    ??GyroResultForbidSpeDeal_3
// 14941       }
// 14942       //更新右线头
// 14943       BlackRightHeadLine = BlackLeftHeadLine;
        LDR.N    R0,??DataTable78_74
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable75_2
        STRB     R0,[R1, #+0]
        B.N      ??GyroResultForbidSpeDeal_0
// 14944     }
// 14945     //左线头高，且两线头差别不大时。
// 14946     else if(BlackRightHeadLine > BlackLeftHeadLine && BlackRightHeadLine <= BlackLeftHeadLine + 5)
??GyroResultForbidSpeDeal_1:
        LDR.N    R0,??DataTable78_74
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable75_2
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BCS.N    ??GyroResultForbidSpeDeal_0
        LDR.N    R0,??DataTable78_74
        LDRB     R0,[R0, #+0]
        ADDS     R0,R0,#+5
        LDR.N    R1,??DataTable75_2
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BLT.N    ??GyroResultForbidSpeDeal_0
// 14947     {
// 14948       //对左线头削顶。
// 14949       for(row = BlackLeftHeadLine; ; row++)
        LDR.N    R0,??DataTable78_74
        LDRB     R0,[R0, #+0]
        B.N      ??GyroResultForbidSpeDeal_4
??GyroResultForbidSpeDeal_5:
        ADDS     R0,R0,#+1
// 14950       {
// 14951         BlackLeftLoc[row][0] = MaxValUint8;
??GyroResultForbidSpeDeal_4:
        MOVS     R1,#+255
        LDR.N    R2,??DataTable78_62
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        MOVS     R3,#+3
        MLA      R2,R3,R0,R2
        STRB     R1,[R2, #+0]
// 14952         
// 14953         if(row == BlackRightHeadLine) break;
        LDR.N    R1,??DataTable75_2
        LDRB     R1,[R1, #+0]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,R1
        BNE.N    ??GyroResultForbidSpeDeal_5
// 14954       }
// 14955       //更新左线头
// 14956       BlackLeftHeadLine = BlackRightHeadLine;
        LDR.N    R0,??DataTable75_2
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??DataTable78_74
        STRB     R0,[R1, #+0]
// 14957     }
// 14958     //否则不做线头平齐处理。
// 14959     else
// 14960     {
// 14961     }
// 14962   }
// 14963   else
// 14964   {
// 14965   }
// 14966   
// 14967   
// 14968   return 1;
??GyroResultForbidSpeDeal_0:
        MOVS     R0,#+1
        BX       LR               ;; return
// 14969 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable75:
        DC32     AngleZoneConfirmLockMeterCount

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable75_1:
        DC32     BlackRightLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable75_2:
        DC32     BlackRightHeadLine
// 14970 
// 14971 
// 14972 //======================================================================
// 14973 //函数名：ImagePro
// 14974 //功  能：图像处理函数。图像尺寸缩减，黑线提取，中心线提取。
// 14975 //参  数：无
// 14976 //返  回：1成功 0失败
// 14977 //影  响：
// 14978 //说  明：1. 黑线提取失败后，不会执行中心线提取函数。返回失败。
// 14979 //        2. 黑线提取失败后，后面的运动控制的参数不用更改，延用上一次的参数。
// 14980 //             
// 14981 //======================================================================

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 14982 uint8 ImagePro(void)
// 14983 {
ImagePro:
        PUSH     {R7,LR}
// 14984     ErrorCountNow5++;
        LDR.N    R0,??DataTable78_75
        LDRH     R0,[R0, #+0]
        ADDS     R0,R0,#+1
        LDR.N    R1,??DataTable78_75
        STRH     R0,[R1, #+0]
// 14985   
// 14986     //图像取需要的列，重新赋值是为了后面的编程方便。
// 14987     ImgPut();
        BL       ImgPut
// 14988 
// 14989     //图像处理之前的参数初始化。
// 14990     ImageProParaInit();
        BL       ImageProParaInit
// 14991    
// 14992     //黑线提取函数
// 14993     if(BlackGet() == 0)
        BL       BlackGet
        CMP      R0,#+0
        BNE.N    ??ImagePro_0
// 14994     {
// 14995         //uart_sendN(UART0, (uint8 *)"\nBlackGet Failed!", 17);  
// 14996         CenterLineResult = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable78_76
        STRB     R0,[R1, #+0]
// 14997         PathJudgeDone = 0;             //赛道类型判断失败。
        MOVS     R0,#+0
        LDR.N    R1,??DataTable78_77
        STRB     R0,[R1, #+0]
// 14998         PathType = PathTypeUnknown;    //赛道类型置为未知。
        MOVS     R0,#+0
        LDR.N    R1,??DataTable78_78
        STRB     R0,[R1, #+0]
// 14999         ImgBlackSucceedFlag = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable78_30
        STRB     R0,[R1, #+0]
// 15000     }
// 15001     //黑线提取成功后的处理。
// 15002     else
// 15003     {
// 15004     }
// 15005 
// 15006     //赛道类型判断
// 15007     //到这里时，左右黑线至少有一个提取成功，中心线还没有提取。
// 15008     PathJudgeNew();
??ImagePro_0:
        BL       PathJudgeNew
// 15009     
// 15010     //直角黑块确认。//这届不使用
// 15011     //AngleZoneConfirm();
// 15012     
// 15013     //障碍物确认 与 避障处理，会改变CenterLineLoc[]数组的值。
// 15014     BrickAvoid();
        BL       BrickAvoid
// 15015     
// 15016     //坡道禁止赛道类型判断期间的线头平齐
// 15017     GyroResultForbidSpeDeal();
        BL       GyroResultForbidSpeDeal
// 15018  
// 15019     //中心线提取函数。里面有中心线的线头线尾查找。
// 15020     //除非图像太差，否则该函数基本上不会返回0.
// 15021     //黑线提取失败后，不允许中心线提取。
// 15022     CenterLineResult = 1;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable78_76
        STRB     R0,[R1, #+0]
// 15023     if(ImgBlackSucceedFlag == 0 || CenterLineGetRaw() == 0)
        LDR.N    R0,??DataTable78_30
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??ImagePro_1
        BL       CenterLineGetRaw
        CMP      R0,#+0
        BNE.N    ??ImagePro_2
// 15024     {
// 15025       //uart_sendN(UART0, (uint8 *)"\nCenterLineGet Failed!", 22); 
// 15026       CenterHeadLine = MaxValUint8;
??ImagePro_1:
        MOVS     R0,#+255
        LDR.N    R1,??DataTable78_79
        STRB     R0,[R1, #+0]
// 15027       CenterEndLine = MaxValUint8;
        MOVS     R0,#+255
        LDR.N    R1,??DataTable78_80
        STRB     R0,[R1, #+0]
// 15028       CenterLineResult = 0; //
        MOVS     R0,#+0
        LDR.N    R1,??DataTable78_76
        STRB     R0,[R1, #+0]
// 15029       PathJudgeDone = 0;   //赛道类型判断失败。
        MOVS     R0,#+0
        LDR.N    R1,??DataTable78_77
        STRB     R0,[R1, #+0]
// 15030       PathType = 0;        //赛道类型置为未知。
        MOVS     R0,#+0
        LDR.N    R1,??DataTable78_78
        STRB     R0,[R1, #+0]
// 15031       ImgCenterSucceedFlag = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable78_31
        STRB     R0,[R1, #+0]
// 15032     }
// 15033     else
// 15034     {
// 15035     }
// 15036     
// 15037     //必须黑线和中心线都提取成功后才能视为图像处理成功。
// 15038     if(ImgBlackSucceedFlag == 1 && ImgCenterSucceedFlag == 1)
??ImagePro_2:
        LDR.N    R0,??DataTable78_30
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??ImagePro_3
        LDR.N    R0,??DataTable78_31
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??ImagePro_3
// 15039     {
// 15040       GPIO_PDOR_REG(PORTA) |= (1<<17);
        LDR.N    R0,??DataTable78_81  ;; 0x400ff000
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x20000
        LDR.N    R1,??DataTable78_81  ;; 0x400ff000
        STR      R0,[R1, #+0]
// 15041       ImgProSucceedFlag = 1;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable78_82
        STRB     R0,[R1, #+0]
        B.N      ??ImagePro_4
// 15042     }
// 15043     else
// 15044     {
// 15045       GPIO_PDOR_REG(PORTA) &= ~(1<<17);
??ImagePro_3:
        LDR.N    R0,??DataTable78_81  ;; 0x400ff000
        LDR      R0,[R0, #+0]
        BICS     R0,R0,#0x20000
        LDR.N    R1,??DataTable78_81  ;; 0x400ff000
        STR      R0,[R1, #+0]
// 15046       ImgProSucceedFlag = 0;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable78_82
        STRB     R0,[R1, #+0]
// 15047     }
// 15048    
// 15049     
// 15050     if(ImgProSucceedFlag == 1)
??ImagePro_4:
        LDR.N    R0,??DataTable78_82
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??ImagePro_5
// 15051     {
// 15052       //图像处理成功后的处理。
// 15053       ImgProSucceedDeal();
        BL       ImgProSucceedDeal
        B.N      ??ImagePro_6
// 15054     }
// 15055     else
// 15056     {
// 15057       //图像处理失败后的处理。
// 15058       ImgProFailDeal();
??ImagePro_5:
        BL       ImgProFailDeal
// 15059     }
// 15060     
// 15061     //判断是否跑出赛道，10次图像失败就认为跑出赛道（刚开始做车的阶段先注释掉）
// 15062     /*if(CenterHeadLine==MaxValUint8 && CenterEndLine==MaxValUint8)
// 15063     {
// 15064       if(++ImgProFailCount > 10)
// 15065       {
// 15066         RunOutFlag = 1;
// 15067       }
// 15068     }
// 15069     else
// 15070     {
// 15071         ImgProFailCount = 0;
// 15072     }*/
// 15073     
// 15074     //偏差滤波。
// 15075     //DeviNowFilter();
// 15076     
// 15077     //直角弯确认函数。在偏差求取后面，因为此时是绝对瞎眼。
// 15078     //若干次直角弯确认后，才会最终确认为直角弯。
// 15079     //最终确认后，会进行若干次的特殊处理。
// 15080     //特殊处理时，不受图像成功标志位的影响。
// 15081     //特殊处理时，会对几个Level和DeviNow进行特殊赋值。
// 15082     //有想过针对最后一次有效的Devi进行分类的特殊处理，但似乎没有必要。
// 15083     
// 15084     //这届不需要确认直角弯
// 15085     //AngleStep2Confirm();
// 15086     
// 15087     return ImgProSucceedFlag;
??ImagePro_6:
        LDR.N    R0,??DataTable78_82
        LDRB     R0,[R0, #+0]
        POP      {R1,PC}          ;; return
// 15088 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable76:
        DC32     AngleZoneConfirmLockFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable76_1:
        DC32     AngleConfirmLockFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable76_2:
        DC32     AngleSpeDealFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable76_3:
        DC32     BrickConfirmLockFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable76_4:
        DC32     BrickSpeDealFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable76_5:
        DC32     GyroResultForbidFlag
// 15089 
// 15090 
// 15091 
// 15092 //发送图像时专用的图像数组更新。

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 15093 void ImgSendPut(void)
// 15094 {
ImgSendPut:
        PUSH     {R4-R7}
// 15095     uint16 i, j, k, temp1, temp2;   
// 15096     
// 15097     temp1 = CameraRealLeftCol;
        LDR.N    R0,??DataTable78_83
        LDRB     R3,[R0, #+0]
// 15098     temp2 = CameraRealLeftCol + CameraRealWidth;
        LDR.N    R0,??DataTable78_83
        LDRB     R0,[R0, #+0]
        ADDS     R4,R0,#+250
// 15099     //temp1 = CameraWidth/2 - CameraRealWidth/2 - 1;
// 15100     //temp2 = CameraWidth/2 + CameraRealWidth/2 - 1;
// 15101     
// 15102     for(i = 0; i < CameraHight; i++)
        MOVS     R0,#+0
        B.N      ??ImgSendPut_0
// 15103     {
// 15104       k = 0;
// 15105       for(j = temp1; j < temp2; j++)
// 15106       {
// 15107         ImgNew[i][k] = ImgRaw[i][j];
??ImgSendPut_1:
        LDR.N    R5,??DataTable78_84
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        MOVS     R6,#+250
        MLA      R5,R6,R0,R5
        UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
        LDR.N    R6,??DataTable78_85
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        MOV      R7,#+320
        MLA      R6,R7,R0,R6
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        LDRB     R6,[R1, R6]
        STRB     R6,[R2, R5]
// 15108         k++;
        ADDS     R2,R2,#+1
// 15109       }
        ADDS     R1,R1,#+1
??ImgSendPut_2:
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
        CMP      R1,R4
        BCC.N    ??ImgSendPut_1
        ADDS     R0,R0,#+1
??ImgSendPut_0:
        UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
        CMP      R0,#+60
        BGE.N    ??ImgSendPut_3
        MOVS     R2,#+0
        MOVS     R1,R3
        B.N      ??ImgSendPut_2
// 15110     }
// 15111 }
??ImgSendPut_3:
        POP      {R4-R7}
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable77:
        DC32     PathRealStraightCount
// 15112 
// 15113 //图像发送模式专用函数

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 15114 uint8 ImageSend(void)
// 15115 {
ImageSend:
        PUSH     {R7,LR}
// 15116     //发送图像时专用的图像数组更新。
// 15117     ImgPut();
        BL       ImgPut
// 15118     
// 15119     //发送图像存储数组到上位机
// 15120     SendImage(ImgNew);      
        LDR.N    R0,??DataTable78_84
        BL       SendImage
// 15121     
// 15122     return 1;
        MOVS     R0,#+1
        POP      {R1,PC}          ;; return
// 15123 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78:
        DC32     PathRealStraightCountLimit

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_1:
        DC32     PathRealStraightFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_2:
        DC32     xiaoZhiDaoFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_3:
        DC32     LimitLeftWBMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_4:
        DC32     LimitLeftWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_5:
        DC32     LimitLeftWMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_6:
        DC32     LimitLeftW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_7:
        DC32     LimitLeftBMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_8:
        DC32     LimitLeftB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_9:
        DC32     LimitLeftHeadWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_10:
        DC32     LimitLeftHeadW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_11:
        DC32     LimitLeftHeadB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_12:
        DC32     LimitRightWBMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_13:
        DC32     LimitRightWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_14:
        DC32     LimitRightWMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_15:
        DC32     LimitRightW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_16:
        DC32     LimitRightBMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_17:
        DC32     LimitRightB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_18:
        DC32     LimitRightHeadWB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_19:
        DC32     LimitRightHeadW

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_20:
        DC32     LimitRightHeadB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_21:
        DC32     SingleBlackWidthMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_22:
        DC32     BlackLeftLastEdgeStartCol

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_23:
        DC32     BlackLeftEdgeStartCol

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_24:
        DC32     BlackRightLastEdgeStartCol

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_25:
        DC32     BlackRightEdgeStartCol

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_26:
        DC32     RoadHalfWidthSingle

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_27:
        DC32     AngleConfirmMat

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_28:
        DC32     RoadHalfWidth

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_29:
        DC32     RoadHalfWidthLast

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_30:
        DC32     ImgBlackSucceedFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_31:
        DC32     ImgCenterSucceedFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_32:
        DC32     PathSmallSDoneFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_33:
        DC32     CenterLineLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_34:
        DC32     RoadHalfWidthRecord

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_35:
        DC32     RoadHalfWidthWrongFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_36:
        DC32     SingleDoneFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_37:
        DC32     SingleFloorFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_38:
        DC32     SingleFloorConfirmCount

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_39:
        DC32     SingleFloorConfirmCountMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_40:
        DC32     SingleBlackFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_41:
        DC32     SingleBlackAllFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_42:
        DC32     SingleBlackLastAllFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_43:
        DC32     BlackSingleFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_44:
        DC32     flag222

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_45:
        DC32     BrickLineCountNumRecord

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_46:
        DC32     BlackBigChangeFinalCheckFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_47:
        DC32     AngleZoneJudgeRowL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_48:
        DC32     AngleZoneJudgeRowR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_49:
        DC32     AngleZoneJudgeColR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_50:
        DC32     AngleZoneJudgeColRFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_51:
        DC32     AngleZoneJudgeCountColR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_52:
        DC32     BrickEndColL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_53:
        DC32     BrickHeadColL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_54:
        DC32     BrickBorderColL

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_55:
        DC32     BrickEndColR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_56:
        DC32     BrickHeadColR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_57:
        DC32     BrickBorderColR

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_58:
        DC32     BrickSpeDealCenFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_59:
        DC32     EmergencyStopCount

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_60:
        DC32     BlackCenEdgeStartCol

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_61:
        DC32     BrickSpeDealDir

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_62:
        DC32     BlackLeftLoc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_63:
        DC32     RoadHalfWidthWrongDir

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_64:
        DC32     BlackLeftStep1ScanRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_65:
        DC32     BlackRightStep1ScanRow

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_66:
        DC32     LimitLeftWBMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_67:
        DC32     LimitLeftWMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_68:
        DC32     LimitLeftBMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_69:
        DC32     LimitRightWBMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_70:
        DC32     LimitRightWMax

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_71:
        DC32     LimitRightBMin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_72:
        DC32     BlackLeftDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_73:
        DC32     BlackRightDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_74:
        DC32     BlackLeftHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_75:
        DC32     ErrorCountNow5

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_76:
        DC32     CenterLineResult

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_77:
        DC32     PathJudgeDone

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_78:
        DC32     PathType

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_79:
        DC32     CenterHeadLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_80:
        DC32     CenterEndLine

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_81:
        DC32     0x400ff000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_82:
        DC32     ImgProSucceedFlag

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_83:
        DC32     CameraRealLeftCol

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_84:
        DC32     ImgNew

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable78_85:
        DC32     ImgRaw

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
// 15124 
// 
// 17 920 bytes in section .bss
//     72 bytes in section .data
//    700 bytes in section .rodata
// 57 596 bytes in section .text
// 
// 57 596 bytes of CODE  memory
//    700 bytes of CONST memory
// 17 992 bytes of DATA  memory
//
//Errors: none
//Warnings: 14
