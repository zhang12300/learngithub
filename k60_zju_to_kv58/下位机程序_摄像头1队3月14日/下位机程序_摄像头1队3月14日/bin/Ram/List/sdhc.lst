###############################################################################
#
# IAR ANSI C/C++ Compiler V8.10.1.12857/W32 for ARM       30/Aug/2018  15:16:04
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Lenovo\Desktop\class3\@@@@@_@@@1@3@14@\@@@@@_@@@1@3@14@\src\Sources\C\SD_C\sdhc.c
#    Command line =  
#        -f C:\Users\Lenovo\AppData\Local\Temp\EWC6EA.tmp
#        (C:\Users\Lenovo\Desktop\class3\@@@@@_@@@1@3@14@\@@@@@_@@@1@3@14@\src\Sources\C\SD_C\sdhc.c
#        -D IAR -D TWR_K60N512 --preprocess
#        C:\Users\Lenovo\Desktop\class3\@@@@@_@@@1@3@14@\@@@@@_@@@1@3@14@\bin\Ram\List
#        -lCN
#        C:\Users\Lenovo\Desktop\class3\@@@@@_@@@1@3@14@\@@@@@_@@@1@3@14@\bin\Ram\List
#        -lB
#        C:\Users\Lenovo\Desktop\class3\@@@@@_@@@1@3@14@\@@@@@_@@@1@3@14@\bin\Ram\List
#        -o
#        C:\Users\Lenovo\Desktop\class3\@@@@@_@@@1@3@14@\@@@@@_@@@1@3@14@\bin\Ram\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\INC\c\DLib_Config_Full.h"
#        -I
#        C:\Users\Lenovo\Desktop\class3\@@@@@_@@@1@3@14@\@@@@@_@@@1@3@14@\src\Sources\H\
#        -I
#        C:\Users\Lenovo\Desktop\class3\@@@@@_@@@1@3@14@\@@@@@_@@@1@3@14@\src\Sources\H\Component_H\
#        -I
#        C:\Users\Lenovo\Desktop\class3\@@@@@_@@@1@3@14@\@@@@@_@@@1@3@14@\src\Sources\H\Frame_H\
#        -I
#        C:\Users\Lenovo\Desktop\class3\@@@@@_@@@1@3@14@\@@@@@_@@@1@3@14@\src\Sources\H\Function_H\
#        -I
#        C:\Users\Lenovo\Desktop\class3\@@@@@_@@@1@3@14@\@@@@@_@@@1@3@14@\src\Sources\H\SD_H\
#        -I D:\quartus\quartus\cusp\80\synthinclude\ -Ol --use_c++_inline -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Include\" -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        C:\Users\Lenovo\Desktop\class3\@@@@@_@@@1@3@14@\@@@@@_@@@1@3@14@\bin\Ram\List\sdhc.lst
#    Object file  =  
#        C:\Users\Lenovo\Desktop\class3\@@@@@_@@@1@3@14@\@@@@@_@@@1@3@14@\bin\Ram\Obj\sdhc.o
#
###############################################################################

C:\Users\Lenovo\Desktop\class3\@@@@@_@@@1@3@14@\@@@@@_@@@1@3@14@\src\Sources\C\SD_C\sdhc.c
      1          #include "sdhc.h"
      2          

   \                                 In section .data, align 4
      3          uint32 core_clk_khz_sd = 150000;
   \                     core_clk_khz_sd:
   \   00000000   0x000249F0         DC32 150000

   \                                 In section .bss, align 4
      4          SDCARD_STRUCT 		SDHC_Card;
   \                     SDHC_Card:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
      5          SDCARD_INIT_STRUCT  SDHC_Init;
   \                     SDHC_Init:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
      6          ESDHC_INFO_STRUCT	SDHC_Info;
   \                     SDHC_Info:
   \   00000000                      DS8 516

   \                                 In section .bss, align 4
      7          ESDHC_DEVICE_STRUCT SDHC_Device;
   \                     SDHC_Device:
   \   00000000                      DS8 8
      8          

   \                                 In section .rodata, align 4
      9          const ESDHC_INIT_STRUCT K60_SDHC0_init =
   \                     K60_SDHC0_init:
   \   00000000   0x00000000         DC32 0, 25000000
   \              0x017D7840   
     10          {
     11              0,                          /* ESDHC device number */
     12              25000000,                   /* ESDHC baudrate      */
     13              //200000000            /* ESDHC clock source  */
     14          };
     15          
     16          
     17          //SD卡命令实际使用到的命令有 32条，其中基本命令 25条，用户应用命令 7条

   \                                 In section .rodata, align 4
     18          const unsigned long ESDHC_COMMAND_XFERTYP[] =
   \                     ESDHC_COMMAND_XFERTYP:
   \   00000000   0x00000000         DC32 0, 16777216, 34144256, 52035584, 67108864, 84017152, 102367232
   \              0x01000000   
   \              0x02090000   
   \              0x031A0000   
   \              0x04000000   
   \              0x05020000   
   \              0x061A0000   
   \   0000001C   0x071B0000         DC32 119209984, 135921664, 151584768, 168361984, 186253312, 215678976
   \              0x081A0000   
   \              0x09090000   
   \              0x0A090000   
   \              0x0B1A0000   
   \              0x0CDB0000   
   \   00000034   0x0D1A0000         DC32 219807744, 0, 251658240, 270139392, 286916608, 303693824, 0
   \              0x00000000   
   \              0x0F000000   
   \              0x101A0000   
   \              0x111A0000   
   \              0x121A0000   
   \              0x00000000   
   \   00000050   0x141A0000         DC32 337248256, 0, 370802688, 387579904, 404357120, 421134336
   \              0x00000000   
   \              0x161A0000   
   \              0x171A0000   
   \              0x181A0000   
   \              0x191A0000   
   \   00000068   0x1A1A0000         DC32 437911552, 454688768, 471531520, 488308736, 505020416, 0
   \              0x1B1A0000   
   \              0x1C1B0000   
   \              0x1D1B0000   
   \              0x1E1A0000   
   \              0x00000000   
   \   00000080   0x201A0000         DC32 538574848, 555352064, 572129280, 588906496, 605683712, 622460928
   \              0x211A0000   
   \              0x221A0000   
   \              0x231A0000   
   \              0x241A0000   
   \              0x251A0000   
   \   00000098   0x261B0000         DC32 639303680, 654442496, 672792576, 687996928, 706412544, 0, 0, 0, 0
   \              0x27020000   
   \              0x281A0000   
   \              0x29020000   
   \              0x2A1B0000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \   000000BC   0x00000000         DC32 0, 0, 0, 0, 857341952, 874119168, 890896384, 0, 924450816
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x331A0000   
   \              0x341A0000   
   \              0x351A0000   
   \              0x00000000   
   \              0x371A0000   
   \   000000E0   0x381B0000         DC32 941293568, 0, 0, 0, 1008402432, 1025179648, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x3C1B0000   
   \              0x3D1B0000   
   \              0x00000000   
   \              0x00000000   
     19          {
     20              /* CMD0 */
     21              SDHC_XFERTYP_CMDINX(ESDHC_CMD0) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO),
     22              SDHC_XFERTYP_CMDINX(ESDHC_CMD1) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO),
     23              SDHC_XFERTYP_CMDINX(ESDHC_CMD2) | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_136),
     24              SDHC_XFERTYP_CMDINX(ESDHC_CMD3) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     25              SDHC_XFERTYP_CMDINX(ESDHC_CMD4) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO),
     26              /* CMD5 */
     27              SDHC_XFERTYP_CMDINX(ESDHC_CMD5) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     28              SDHC_XFERTYP_CMDINX(ESDHC_CMD6) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     29              SDHC_XFERTYP_CMDINX(ESDHC_CMD7) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     30              SDHC_XFERTYP_CMDINX(ESDHC_CMD8) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     31              SDHC_XFERTYP_CMDINX(ESDHC_CMD9) | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_136),
     32              /* CMD10 */
     33              SDHC_XFERTYP_CMDINX(ESDHC_CMD10) | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_136),
     34              SDHC_XFERTYP_CMDINX(ESDHC_CMD11) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     35              SDHC_XFERTYP_CMDINX(ESDHC_CMD12) | SDHC_XFERTYP_CMDTYP(ESDHC_XFERTYP_CMDTYP_ABORT) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     36              SDHC_XFERTYP_CMDINX(ESDHC_CMD13) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     37              0,
     38              /* CMD15 */
     39              SDHC_XFERTYP_CMDINX(ESDHC_CMD15) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO),
     40              SDHC_XFERTYP_CMDINX(ESDHC_CMD16) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     41              SDHC_XFERTYP_CMDINX(ESDHC_CMD17) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     42              SDHC_XFERTYP_CMDINX(ESDHC_CMD18) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     43              0,
     44              /* CMD20 */
     45              SDHC_XFERTYP_CMDINX(ESDHC_CMD20) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     46              0,
     47              SDHC_XFERTYP_CMDINX(ESDHC_ACMD22) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     48              SDHC_XFERTYP_CMDINX(ESDHC_ACMD23) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     49              SDHC_XFERTYP_CMDINX(ESDHC_CMD24) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     50              /* CMD25 */
     51              SDHC_XFERTYP_CMDINX(ESDHC_CMD25) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     52              SDHC_XFERTYP_CMDINX(ESDHC_CMD26) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     53              SDHC_XFERTYP_CMDINX(ESDHC_CMD27) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     54              SDHC_XFERTYP_CMDINX(ESDHC_CMD28) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     55              SDHC_XFERTYP_CMDINX(ESDHC_CMD29) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     56              /* CMD30 */
     57              SDHC_XFERTYP_CMDINX(ESDHC_CMD30) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     58              0,
     59              SDHC_XFERTYP_CMDINX(ESDHC_CMD32) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     60              SDHC_XFERTYP_CMDINX(ESDHC_CMD33) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     61              SDHC_XFERTYP_CMDINX(ESDHC_CMD34) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     62              /* CMD35 */
     63              SDHC_XFERTYP_CMDINX(ESDHC_CMD35) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     64              SDHC_XFERTYP_CMDINX(ESDHC_CMD36) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     65              SDHC_XFERTYP_CMDINX(ESDHC_CMD37) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     66              SDHC_XFERTYP_CMDINX(ESDHC_CMD38) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     67              SDHC_XFERTYP_CMDINX(ESDHC_CMD39) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     68              /* CMD40 */
     69              SDHC_XFERTYP_CMDINX(ESDHC_CMD40) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     70              SDHC_XFERTYP_CMDINX(ESDHC_ACMD41) | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     71              SDHC_XFERTYP_CMDINX(ESDHC_CMD42) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     72              0,
     73              0,
     74              /* CMD45 */
     75              0,
     76              0,
     77              0,
     78              0,
     79              0,
     80              /* CMD50 */
     81              0,
     82              SDHC_XFERTYP_CMDINX(ESDHC_ACMD51) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     83              SDHC_XFERTYP_CMDINX(ESDHC_CMD52) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     84              SDHC_XFERTYP_CMDINX(ESDHC_CMD53) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     85              0,
     86              /* CMD55 */
     87              SDHC_XFERTYP_CMDINX(ESDHC_CMD55) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48),
     88              SDHC_XFERTYP_CMDINX(ESDHC_CMD56) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     89              0,
     90              0,
     91              0,
     92              /* CMD60 */
     93              SDHC_XFERTYP_CMDINX(ESDHC_CMD60) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     94              SDHC_XFERTYP_CMDINX(ESDHC_CMD61) | SDHC_XFERTYP_CICEN_MASK | SDHC_XFERTYP_CCCEN_MASK | SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY),
     95              0,
     96              0
     97          };
     98          
     99          

   \                                 In section .text, align 2, keep-with-next
    100          void SDHC_set_baudrate
    101          (
    102              /* [IN] Module input clock in Hz */
    103              uint32         clock,
    104          
    105              /* [IN] Desired baudrate in Hz */
    106              uint32         baudrate
    107          )
    108          {
   \                     SDHC_set_baudrate: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    109              uint32 pres, div, min, minpres = 0x80, mindiv = 0x0F;
   \   00000002   0x2580             MOVS     R5,#+128
   \   00000004   0x260F             MOVS     R6,#+15
    110              int32  val;
    111          
    112              /* Find closest setting */
    113              min = (uint32) - 1;
   \   00000006   0xF05F 0x34FF      MOVS     R4,#-1
    114              for (pres = 2; pres <= 256; pres <<= 1)
   \   0000000A   0x2202             MOVS     R2,#+2
   \   0000000C   0xE00E             B.N      ??SDHC_set_baudrate_0
    115              {
    116                  for (div = 1; div <= 16; div++)
    117                  {
    118                      val = pres * div * baudrate - clock;
   \                     ??SDHC_set_baudrate_1: (+1)
   \   0000000E   0xFB03 0xF702      MUL      R7,R3,R2
   \   00000012   0x434F             MULS     R7,R1,R7
   \   00000014   0x1A3F             SUBS     R7,R7,R0
    119                      if (val >= 0)
   \   00000016   0x2F00             CMP      R7,#+0
   \   00000018   0xD404             BMI.N    ??SDHC_set_baudrate_2
    120                      {
    121                          if (min > val)
   \   0000001A   0x42A7             CMP      R7,R4
   \   0000001C   0xD202             BCS.N    ??SDHC_set_baudrate_2
    122                          {
    123                              min = val;
   \   0000001E   0x003C             MOVS     R4,R7
    124                              minpres = pres;
   \   00000020   0x0015             MOVS     R5,R2
    125                              mindiv = div;
   \   00000022   0x001E             MOVS     R6,R3
    126                          }
    127                      }
    128                  }
   \                     ??SDHC_set_baudrate_2: (+1)
   \   00000024   0x1C5B             ADDS     R3,R3,#+1
   \                     ??SDHC_set_baudrate_3: (+1)
   \   00000026   0x2B11             CMP      R3,#+17
   \   00000028   0xD3F1             BCC.N    ??SDHC_set_baudrate_1
   \   0000002A   0x0052             LSLS     R2,R2,#+1
   \                     ??SDHC_set_baudrate_0: (+1)
   \   0000002C   0xF240 0x1301      MOVW     R3,#+257
   \   00000030   0x429A             CMP      R2,R3
   \   00000032   0xD201             BCS.N    ??SDHC_set_baudrate_4
   \   00000034   0x2301             MOVS     R3,#+1
   \   00000036   0xE7F6             B.N      ??SDHC_set_baudrate_3
    129              }
    130          
    131              /* Disable ESDHC clocks */
    132              SDHC_SYSCTL &= (~ SDHC_SYSCTL_SDCLKEN_MASK);
   \                     ??SDHC_set_baudrate_4: (+1)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable5  ;; 0x400b102c
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0xF030 0x0008      BICS     R0,R0,#0x8
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable5  ;; 0x400b102c
   \   00000046   0x6008             STR      R0,[R1, #+0]
    133          
    134              /* Change dividers */
    135              div = SDHC_SYSCTL & (~ (SDHC_SYSCTL_DTOCV_MASK | SDHC_SYSCTL_SDCLKFS_MASK | SDHC_SYSCTL_DVS_MASK));
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable5  ;; 0x400b102c
   \   0000004C   0x6803             LDR      R3,[R0, #+0]
   \   0000004E   0xF36F 0x1313      BFC      R3,#+4,#+16
    136              SDHC_SYSCTL = div | (SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_SDCLKFS(minpres >> 1) | SDHC_SYSCTL_DVS(mindiv - 1));
   \   00000052   0x01ED             LSLS     R5,R5,#+7
   \   00000054   0xF415 0x457F      ANDS     R5,R5,#0xFF00
   \   00000058   0x432B             ORRS     R3,R5,R3
   \   0000005A   0x1E76             SUBS     R6,R6,#+1
   \   0000005C   0x0136             LSLS     R6,R6,#+4
   \   0000005E   0xF016 0x06F0      ANDS     R6,R6,#0xF0
   \   00000062   0x4333             ORRS     R3,R6,R3
   \   00000064   0xF453 0x2360      ORRS     R3,R3,#0xE0000
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable5  ;; 0x400b102c
   \   0000006C   0x6003             STR      R3,[R0, #+0]
    137          
    138              /* Wait for stable clock */
    139              while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB_MASK));
   \                     ??SDHC_set_baudrate_5: (+1)
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x400b1024
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x0700             LSLS     R0,R0,#+28
   \   00000076   0xD5FA             BPL.N    ??SDHC_set_baudrate_5
    140          
    141          
    142              /* Enable ESDHC clocks */
    143              SDHC_SYSCTL |= SDHC_SYSCTL_SDCLKEN_MASK;
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable5  ;; 0x400b102c
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable5  ;; 0x400b102c
   \   00000086   0x6008             STR      R0,[R1, #+0]
    144              SDHC_IRQSTAT |= SDHC_IRQSTAT_DTOE_MASK;
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable5_2  ;; 0x400b1030
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0xF450 0x1080      ORRS     R0,R0,#0x100000
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable5_2  ;; 0x400b1030
   \   00000096   0x6008             STR      R0,[R1, #+0]
    145          }
   \   00000098   0xBCF0             POP      {R4-R7}
   \   0000009A   0x4770             BX       LR               ;; return
    146          
    147          

   \                                 In section .text, align 2, keep-with-next
    148          uint32 SDHC_init
    149          (
    150              /* [IN/OUT] Device runtime information */
    151              ESDHC_INFO_STRUCT_PTR  esdhc_info_ptr,
    152          
    153              /* [IN] Device initialization data */
    154              ESDHC_INIT_STRUCT_CPTR esdhc_init_ptr
    155          )
    156          {
   \                     SDHC_init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    157          
    158              esdhc_info_ptr->CARD = ESDHC_CARD_NONE;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
    159          
    160              /* Reset ESDHC */
    161              SDHC_SYSCTL = SDHC_SYSCTL_RSTA_MASK | SDHC_SYSCTL_SDCLKFS(0x80);
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable5_3  ;; 0x1008000
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable5  ;; 0x400b102c
   \   00000010   0x6008             STR      R0,[R1, #+0]
    162              while (SDHC_SYSCTL & SDHC_SYSCTL_RSTA_MASK) {};
   \                     ??SDHC_init_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable5  ;; 0x400b102c
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x01C0             LSLS     R0,R0,#+7
   \   0000001A   0xD4FA             BMI.N    ??SDHC_init_0
    163          
    164              /* Initial values */
    165              SDHC_VENDOR = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable5_4  ;; 0x400b10c0
   \   00000022   0x6008             STR      R0,[R1, #+0]
    166              SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(512);
   \   00000024   0xF45F 0x3081      MOVS     R0,#+66048
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable5_5  ;; 0x400b1004
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    167              SDHC_PROCTL = SDHC_PROCTL_EMODE(ESDHC_PROCTL_EMODE_INVARIANT) | SDHC_PROCTL_D3CD_MASK;
   \   0000002E   0x2028             MOVS     R0,#+40
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable5_6  ;; 0x400b1028
   \   00000034   0x6008             STR      R0,[R1, #+0]
    168              SDHC_WML = SDHC_WML_RDWML(1) | SDHC_WML_WRWML(1);
   \   00000036   0xF05F 0x1001      MOVS     R0,#+65537
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable5_7  ;; 0x400b1044
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    169          
    170              /* Set the ESDHC initial baud rate divider and start */
    171              //SDHC_set_baudrate (esdhc_init_ptr->CLOCK_SPEED,380000);
    172              SDHC_set_baudrate (core_clk_khz_sd * 1000, 380000);
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable5_8  ;; 0x5cc60
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable5_9
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF44F 0x727A      MOV      R2,#+1000
   \   0000004E   0x4350             MULS     R0,R2,R0
   \   00000050   0x.... 0x....      BL       SDHC_set_baudrate
    173          
    174              /* Poll inhibit bits */
    175              while (SDHC_PRSSTAT & (SDHC_PRSSTAT_CIHB_MASK | SDHC_PRSSTAT_CDIHB_MASK)) {};
   \                     ??SDHC_init_1: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x400b1024
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xF010 0x0F03      TST      R0,#0x3
   \   0000005E   0xD1F9             BNE.N    ??SDHC_init_1
    176          
    177              /* 初始化管脚复用 */
    178              PORTE_PCR(0) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D1  */
   \   00000060   0xF240 0x4043      MOVW     R0,#+1091
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable5_10  ;; 0x4004d000
   \   00000068   0x6008             STR      R0,[R1, #+0]
    179              PORTE_PCR(1) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D0  */
   \   0000006A   0xF240 0x4043      MOVW     R0,#+1091
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable5_11  ;; 0x4004d004
   \   00000072   0x6008             STR      R0,[R1, #+0]
    180              PORTE_PCR(2) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          /* ESDHC.CLK */
   \   00000074   0xF44F 0x6088      MOV      R0,#+1088
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable5_12  ;; 0x4004d008
   \   0000007C   0x6008             STR      R0,[R1, #+0]
    181              PORTE_PCR(3) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.CMD */
   \   0000007E   0xF240 0x4043      MOVW     R0,#+1091
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable5_13  ;; 0x4004d00c
   \   00000086   0x6008             STR      R0,[R1, #+0]
    182              PORTE_PCR(4) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D3  */
   \   00000088   0xF240 0x4043      MOVW     R0,#+1091
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable5_14  ;; 0x4004d010
   \   00000090   0x6008             STR      R0,[R1, #+0]
    183              PORTE_PCR(5) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D2  */
   \   00000092   0xF240 0x4043      MOVW     R0,#+1091
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable5_15  ;; 0x4004d014
   \   0000009A   0x6008             STR      R0,[R1, #+0]
    184          
    185              /* Enable clock gate to SDHC module */
    186              SIM_SCGC3 |= SIM_SCGC3_SDHC_MASK;
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable5_16  ;; 0x40048030
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable5_16  ;; 0x40048030
   \   000000AA   0x6008             STR      R0,[R1, #+0]
    187          
    188              /* Enable requests */
    189              SDHC_IRQSTAT = 0xFFFF;
   \   000000AC   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable5_2  ;; 0x400b1030
   \   000000B4   0x6008             STR      R0,[R1, #+0]
    190              SDHC_IRQSTATEN = 	  SDHC_IRQSTATEN_DEBESEN_MASK | SDHC_IRQSTATEN_DCESEN_MASK | SDHC_IRQSTATEN_DTOESEN_MASK
    191                                    | SDHC_IRQSTATEN_CIESEN_MASK | SDHC_IRQSTATEN_CEBESEN_MASK | SDHC_IRQSTATEN_CCESEN_MASK | SDHC_IRQSTATEN_CTOESEN_MASK
    192                                    | SDHC_IRQSTATEN_BRRSEN_MASK | SDHC_IRQSTATEN_BWRSEN_MASK | SDHC_IRQSTATEN_CRMSEN_MASK
    193                                    | SDHC_IRQSTATEN_TCSEN_MASK | SDHC_IRQSTATEN_CCSEN_MASK;
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable5_17  ;; 0x7f00b3
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable5_18  ;; 0x400b1034
   \   000000BE   0x6008             STR      R0,[R1, #+0]
    194          
    195              /* 80 initial clocks */
    196              SDHC_SYSCTL |= SDHC_SYSCTL_INITA_MASK;
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable5  ;; 0x400b102c
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable5  ;; 0x400b102c
   \   000000CE   0x6008             STR      R0,[R1, #+0]
    197              while (SDHC_SYSCTL & SDHC_SYSCTL_INITA_MASK) {};
   \                     ??SDHC_init_2: (+1)
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable5  ;; 0x400b102c
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x0100             LSLS     R0,R0,#+4
   \   000000D8   0xD4FA             BMI.N    ??SDHC_init_2
    198          
    199              /* Check card */
    200              if (SDHC_PRSSTAT & SDHC_PRSSTAT_CINS_MASK)
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x400b1024
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0x03C0             LSLS     R0,R0,#+15
   \   000000E2   0xD501             BPL.N    ??SDHC_init_3
    201              {
    202                  esdhc_info_ptr->CARD = ESDHC_CARD_UNKNOWN;
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0x6020             STR      R0,[R4, #+0]
    203              }
    204              SDHC_IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \                     ??SDHC_init_3: (+1)
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable5_2  ;; 0x400b1030
   \   000000EC   0x6800             LDR      R0,[R0, #+0]
   \   000000EE   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable5_2  ;; 0x400b1030
   \   000000F6   0x6008             STR      R0,[R1, #+0]
    205          
    206              return ESDHC_OK;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xBD10             POP      {R4,PC}          ;; return
    207          }
    208          
    209          /*FUNCTION****************************************************************
    210          *
    211          * Function Name    : _esdhc_is_running
    212          * Returned Value   : TRUE if running, FALSE otherwise
    213          * Comments         :
    214          *    Checks whether eSDHC module is currently in use.
    215          *
    216          *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    217          uint8 SDHC_is_running(void)
    218          {
    219              return (0 != (SDHC_PRSSTAT & (SDHC_PRSSTAT_RTA_MASK | SDHC_PRSSTAT_WTA_MASK | SDHC_PRSSTAT_DLA_MASK | SDHC_PRSSTAT_CDIHB_MASK | SDHC_PRSSTAT_CIHB_MASK)));
   \                     SDHC_is_running: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x400b1024
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF240 0x3107      MOVW     R1,#+775
   \   0000000A   0x4208             TST      R0,R1
   \   0000000C   0xD001             BEQ.N    ??SDHC_is_running_0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE000             B.N      ??SDHC_is_running_1
   \                     ??SDHC_is_running_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??SDHC_is_running_1: (+1)
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x4770             BX       LR               ;; return
    220          }
    221          
    222          /*FUNCTION****************************************************************
    223          *
    224          * Function Name    : SDHC_status_wait
    225          * Returned Value   : bits set for given mask
    226          * Comments         :
    227          *    Waits for ESDHC interrupt status register bits according to given mask.
    228          *
    229          *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    230          uint32 SDHC_status_wait(uint32	mask)        /* [IN] Mask of IRQSTAT bits to wait for */
    231          {
   \                     SDHC_status_wait: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    232              uint32	result;
    233              do
    234              {
    235                  result = SDHC_IRQSTAT & mask;
   \                     ??SDHC_status_wait_0: (+1)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable5_2  ;; 0x400b1030
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4008             ANDS     R0,R1,R0
    236              }
    237              while (0 == result);
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD0F9             BEQ.N    ??SDHC_status_wait_0
    238              return result;
   \   0000000E   0x4770             BX       LR               ;; return
    239          }
    240          
    241          /*FUNCTION****************************************************************
    242          *
    243          * Function Name    : SDHC_send_command
    244          * Returned Value   : 0 on success, 1 on error, -1 on timeout
    245          * Comments         :
    246          *    One ESDHC command transaction.
    247          *
    248          *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    249          uint32 SDHC_send_command (ESDHC_COMMAND_STRUCT_PTR command) /* [IN/OUT] Command specification */
    250          {
   \                     SDHC_send_command: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    251              uint32	xfertyp;
    252          
    253              /* Check command */
    254              xfertyp = ESDHC_COMMAND_XFERTYP[command->COMMAND & 0x3F];
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable5_19
   \   00000008   0x7829             LDRB     R1,[R5, #+0]
   \   0000000A   0xF011 0x013F      ANDS     R1,R1,#0x3F
   \   0000000E   0xF850 0x4021      LDR      R4,[R0, R1, LSL #+2]
    255              if ((0 == xfertyp) && (0 != command->COMMAND))
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD104             BNE.N    ??SDHC_send_command_0
   \   00000016   0x7828             LDRB     R0,[R5, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD001             BEQ.N    ??SDHC_send_command_0
    256              {
    257                  return 1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE0B0             B.N      ??SDHC_send_command_1
    258              }
    259          
    260              /* Card removal check preparation */
    261              SDHC_IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \                     ??SDHC_send_command_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable5_2  ;; 0x400b1030
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable5_2  ;; 0x400b1030
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    262          
    263              /* Wait for cmd line idle */
    264              while (SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB_MASK) {};
   \                     ??SDHC_send_command_2: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x400b1024
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x07C0             LSLS     R0,R0,#+31
   \   00000038   0xD4FA             BMI.N    ??SDHC_send_command_2
    265          
    266              /* Setup command */
    267              SDHC_CMDARG = command->ARGUMENT;
   \   0000003A   0x6868             LDR      R0,[R5, #+4]
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable5_20  ;; 0x400b1008
   \   00000040   0x6008             STR      R0,[R1, #+0]
    268              xfertyp &= (~ SDHC_XFERTYP_CMDTYP_MASK);
   \   00000042   0xF434 0x0440      BICS     R4,R4,#0xC00000
    269              xfertyp |= SDHC_XFERTYP_CMDTYP(command->TYPE);
   \   00000046   0x7868             LDRB     R0,[R5, #+1]
   \   00000048   0x0580             LSLS     R0,R0,#+22
   \   0000004A   0xF410 0x0040      ANDS     R0,R0,#0xC00000
   \   0000004E   0x4304             ORRS     R4,R0,R4
    270              if (ESDHC_TYPE_RESUME == command->TYPE)
   \   00000050   0x7868             LDRB     R0,[R5, #+1]
   \   00000052   0x2802             CMP      R0,#+2
   \   00000054   0xD101             BNE.N    ??SDHC_send_command_3
    271              {
    272                  xfertyp |= SDHC_XFERTYP_DPSEL_MASK;
   \   00000056   0xF454 0x1400      ORRS     R4,R4,#0x200000
    273              }
    274              if (ESDHC_TYPE_SWITCH_BUSY == command->TYPE)
   \                     ??SDHC_send_command_3: (+1)
   \   0000005A   0x7868             LDRB     R0,[R5, #+1]
   \   0000005C   0x2804             CMP      R0,#+4
   \   0000005E   0xD10D             BNE.N    ??SDHC_send_command_4
    275              {
    276                  if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) == SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48))
   \   00000060   0xF414 0x3040      ANDS     R0,R4,#0x30000
   \   00000064   0xF5B0 0x3F00      CMP      R0,#+131072
   \   00000068   0xD104             BNE.N    ??SDHC_send_command_5
    277                  {
    278                      xfertyp &= (~ SDHC_XFERTYP_RSPTYP_MASK);
   \   0000006A   0xF434 0x3440      BICS     R4,R4,#0x30000
    279                      xfertyp |= SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY);
   \   0000006E   0xF454 0x3440      ORRS     R4,R4,#0x30000
   \   00000072   0xE003             B.N      ??SDHC_send_command_4
    280                  }
    281                  else
    282                  {
    283                      xfertyp &= (~ SDHC_XFERTYP_RSPTYP_MASK);
   \                     ??SDHC_send_command_5: (+1)
   \   00000074   0xF434 0x3440      BICS     R4,R4,#0x30000
    284                      xfertyp |= SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48);
   \   00000078   0xF454 0x3400      ORRS     R4,R4,#0x20000
    285                  }
    286              }
    287              SDHC_BLKATTR &= (~ SDHC_BLKATTR_BLKCNT_MASK);
   \                     ??SDHC_send_command_4: (+1)
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable5_5  ;; 0x400b1004
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable5_5  ;; 0x400b1004
   \   00000088   0x6008             STR      R0,[R1, #+0]
    288              if (0 != command->BLOCKS)
   \   0000008A   0x68E8             LDR      R0,[R5, #+12]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD01F             BEQ.N    ??SDHC_send_command_6
    289              {
    290                  if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) != SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_48BUSY))
   \   00000090   0xF414 0x3040      ANDS     R0,R4,#0x30000
   \   00000094   0xF5B0 0x3F40      CMP      R0,#+196608
   \   00000098   0xD001             BEQ.N    ??SDHC_send_command_7
    291                  {
    292                      xfertyp |= SDHC_XFERTYP_DPSEL_MASK;
   \   0000009A   0xF454 0x1400      ORRS     R4,R4,#0x200000
    293                  }
    294                  if (command->READ)
   \                     ??SDHC_send_command_7: (+1)
   \   0000009E   0x7A28             LDRB     R0,[R5, #+8]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD001             BEQ.N    ??SDHC_send_command_8
    295                  {
    296                      xfertyp |= SDHC_XFERTYP_DTDSEL_MASK;
   \   000000A4   0xF054 0x0410      ORRS     R4,R4,#0x10
    297                  }
    298                  if (command->BLOCKS > 1)
   \                     ??SDHC_send_command_8: (+1)
   \   000000A8   0x68E8             LDR      R0,[R5, #+12]
   \   000000AA   0x2802             CMP      R0,#+2
   \   000000AC   0xD301             BCC.N    ??SDHC_send_command_9
    299                  {
    300                      xfertyp |= SDHC_XFERTYP_MSBSEL_MASK;
   \   000000AE   0xF054 0x0420      ORRS     R4,R4,#0x20
    301                  }
    302                  if ((uint32) - 1 != command->BLOCKS)
   \                     ??SDHC_send_command_9: (+1)
   \   000000B2   0x68E8             LDR      R0,[R5, #+12]
   \   000000B4   0xF110 0x0F01      CMN      R0,#+1
   \   000000B8   0xD00A             BEQ.N    ??SDHC_send_command_6
    303                  {
    304                      SDHC_BLKATTR |= SDHC_BLKATTR_BLKCNT(command->BLOCKS);
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable5_5  ;; 0x400b1004
   \   000000BE   0x6800             LDR      R0,[R0, #+0]
   \   000000C0   0x68E9             LDR      R1,[R5, #+12]
   \   000000C2   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable5_5  ;; 0x400b1004
   \   000000CA   0x6008             STR      R0,[R1, #+0]
    305                      xfertyp |= SDHC_XFERTYP_BCEN_MASK;
   \   000000CC   0xF054 0x0402      ORRS     R4,R4,#0x2
    306                  }
    307              }
    308          
    309              /* Issue command */
    310              SDHC_DSADDR = 0;
   \                     ??SDHC_send_command_6: (+1)
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable5_21  ;; 0x400b1000
   \   000000D6   0x6008             STR      R0,[R1, #+0]
    311              SDHC_XFERTYP = xfertyp;
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable5_22  ;; 0x400b100c
   \   000000DC   0x6004             STR      R4,[R0, #+0]
    312          
    313              /* Wait for response */
    314              if (SDHC_status_wait (SDHC_IRQSTAT_CIE_MASK | SDHC_IRQSTAT_CEBE_MASK | SDHC_IRQSTAT_CCE_MASK | SDHC_IRQSTAT_CC_MASK) != SDHC_IRQSTAT_CC_MASK)
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable5_23  ;; 0xe0001
   \   000000E2   0x.... 0x....      BL       SDHC_status_wait
   \   000000E6   0x2801             CMP      R0,#+1
   \   000000E8   0xD00B             BEQ.N    ??SDHC_send_command_10
    315              {
    316                  SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CIE_MASK | SDHC_IRQSTAT_CEBE_MASK | SDHC_IRQSTAT_CCE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable5_2  ;; 0x400b1030
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0xF440 0x2070      ORR      R0,R0,#0xF0000
   \   000000F4   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable5_2  ;; 0x400b1030
   \   000000FC   0x6008             STR      R0,[R1, #+0]
    317                  return 1;
   \   000000FE   0x2001             MOVS     R0,#+1
   \   00000100   0xE03F             B.N      ??SDHC_send_command_1
    318              }
    319          
    320              /* Check card removal */
    321              if (SDHC_IRQSTAT & SDHC_IRQSTAT_CRM_MASK)
   \                     ??SDHC_send_command_10: (+1)
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable5_2  ;; 0x400b1030
   \   00000106   0x6800             LDR      R0,[R0, #+0]
   \   00000108   0x0600             LSLS     R0,R0,#+24
   \   0000010A   0xD509             BPL.N    ??SDHC_send_command_11
    322              {
    323                  SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable5_2  ;; 0x400b1030
   \   00000110   0x6800             LDR      R0,[R0, #+0]
   \   00000112   0xF050 0x1001      ORRS     R0,R0,#0x10001
   \   00000116   0x.... 0x....      LDR.W    R1,??DataTable5_2  ;; 0x400b1030
   \   0000011A   0x6008             STR      R0,[R1, #+0]
    324                  return 1;
   \   0000011C   0x2001             MOVS     R0,#+1
   \   0000011E   0xE030             B.N      ??SDHC_send_command_1
    325              }
    326          
    327              /* Get response, if available */
    328              if (SDHC_IRQSTAT & SDHC_IRQSTAT_CTOE_MASK)
   \                     ??SDHC_send_command_11: (+1)
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable5_2  ;; 0x400b1030
   \   00000124   0x6800             LDR      R0,[R0, #+0]
   \   00000126   0x03C0             LSLS     R0,R0,#+15
   \   00000128   0xD50A             BPL.N    ??SDHC_send_command_12
    329              {
    330                  SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE_MASK | SDHC_IRQSTAT_CC_MASK;
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable5_2  ;; 0x400b1030
   \   0000012E   0x6800             LDR      R0,[R0, #+0]
   \   00000130   0xF050 0x1001      ORRS     R0,R0,#0x10001
   \   00000134   0x.... 0x....      LDR.W    R1,??DataTable5_2  ;; 0x400b1030
   \   00000138   0x6008             STR      R0,[R1, #+0]
    331                  return -1;
   \   0000013A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000013E   0xE020             B.N      ??SDHC_send_command_1
    332              }
    333              if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) != SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_NO))
   \                     ??SDHC_send_command_12: (+1)
   \   00000140   0xF414 0x3F40      TST      R4,#0x30000
   \   00000144   0xD014             BEQ.N    ??SDHC_send_command_13
    334              {
    335                  command->RESPONSE[0] = SDHC_CMDRSP(0);
   \   00000146   0x.... 0x....      LDR.W    R0,??DataTable5_24  ;; 0x400b1010
   \   0000014A   0x6800             LDR      R0,[R0, #+0]
   \   0000014C   0x6128             STR      R0,[R5, #+16]
    336                  if ((xfertyp & SDHC_XFERTYP_RSPTYP_MASK) == SDHC_XFERTYP_RSPTYP(ESDHC_XFERTYP_RSPTYP_136))
   \   0000014E   0xF414 0x3440      ANDS     R4,R4,#0x30000
   \   00000152   0xF5B4 0x3F80      CMP      R4,#+65536
   \   00000156   0xD10B             BNE.N    ??SDHC_send_command_13
    337                  {
    338                      command->RESPONSE[1] = SDHC_CMDRSP(1);
   \   00000158   0x.... 0x....      LDR.W    R0,??DataTable5_25  ;; 0x400b1014
   \   0000015C   0x6800             LDR      R0,[R0, #+0]
   \   0000015E   0x6168             STR      R0,[R5, #+20]
    339                      command->RESPONSE[2] = SDHC_CMDRSP(2);
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable5_26  ;; 0x400b1018
   \   00000164   0x6800             LDR      R0,[R0, #+0]
   \   00000166   0x61A8             STR      R0,[R5, #+24]
    340                      command->RESPONSE[3] = SDHC_CMDRSP(3);
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable5_27  ;; 0x400b101c
   \   0000016C   0x6800             LDR      R0,[R0, #+0]
   \   0000016E   0x61E8             STR      R0,[R5, #+28]
    341                  }
    342              }
    343          
    344              SDHC_IRQSTAT |= SDHC_IRQSTAT_CC_MASK;
   \                     ??SDHC_send_command_13: (+1)
   \   00000170   0x.... 0x....      LDR.W    R0,??DataTable5_2  ;; 0x400b1030
   \   00000174   0x6800             LDR      R0,[R0, #+0]
   \   00000176   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000017A   0x.... 0x....      LDR.W    R1,??DataTable5_2  ;; 0x400b1030
   \   0000017E   0x6008             STR      R0,[R1, #+0]
    345          
    346              return 0;
   \   00000180   0x2000             MOVS     R0,#+0
   \                     ??SDHC_send_command_1: (+1)
   \   00000182   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    347          }
    348          
    349          
    350          /*FUNCTION****************************************************************
    351          *
    352          * Function Name    : _esdhc_ioctl
    353          * Returned Value   : MQX error code
    354          * Comments         :
    355          *    This function performs miscellaneous services for the ESDHC I/O device.
    356          *
    357          *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    358          int32 SDHC_ioctl
    359          (
    360              /* [IN] The command to perform */
    361              uint32              cmd,
    362          
    363              /* [IN/OUT] Parameters for the command */
    364              void                *param_ptr
    365          )
    366          {
   \                     SDHC_ioctl: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x000C             MOVS     R4,R1
    367              ESDHC_INFO_STRUCT_PTR   esdhc_info_ptr;
    368              ESDHC_DEVICE_STRUCT_PTR esdhc_device_ptr;
    369              ESDHC_INIT_STRUCT_CPTR  esdhc_init_ptr;
    370              ESDHC_COMMAND_STRUCT    command;
    371              uint8                   mem, io, mmc, ceata, mp, hc;
    372              int32                  val;
    373              uint32                  result = ESDHC_OK;
   \   00000008   0x2500             MOVS     R5,#+0
    374              uint32             	    *param32_ptr = param_ptr;
    375          
    376              /* Check parameters */
    377              esdhc_info_ptr = (ESDHC_INFO_STRUCT_PTR)&SDHC_Info;
   \   0000000A   0x.... 0x....      LDR.W    R9,??DataTable5_28
    378          
    379              if (NULL == esdhc_info_ptr)
   \   0000000E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000012   0xD102             BNE.N    ??SDHC_ioctl_0
    380              {
    381                  return IO_DEVICE_DOES_NOT_EXIST;
   \   00000014   0xF640 0x2001      MOVW     R0,#+2561
   \   00000018   0xE31A             B.N      ??SDHC_ioctl_1
    382              }
    383          
    384              esdhc_device_ptr = &SDHC_Device;
   \                     ??SDHC_ioctl_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable5_29
    385              if (NULL == esdhc_device_ptr)
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD102             BNE.N    ??SDHC_ioctl_2
    386              {
    387                  return IO_ERROR_DEVICE_INVALID;
   \   00000022   0xF640 0x200B      MOVW     R0,#+2571
   \   00000026   0xE313             B.N      ??SDHC_ioctl_1
    388              }
    389          
    390              esdhc_init_ptr = esdhc_device_ptr->INIT;
   \                     ??SDHC_ioctl_2: (+1)
   \   00000028   0x6809             LDR      R1,[R1, #+0]
   \   0000002A   0x9108             STR      R1,[SP, #+32]
    391              if (NULL == esdhc_init_ptr)
   \   0000002C   0x9908             LDR      R1,[SP, #+32]
   \   0000002E   0x2900             CMP      R1,#+0
   \   00000030   0xD102             BNE.N    ??SDHC_ioctl_3
    392              {
    393                  return IO_ERROR_DEVICE_INVALID;
   \   00000032   0xF640 0x200B      MOVW     R0,#+2571
   \   00000036   0xE30B             B.N      ??SDHC_ioctl_1
    394              }
    395          
    396              switch (cmd)
   \                     ??SDHC_ioctl_3: (+1)
   \   00000038   0x1EC0             SUBS     R0,R0,#+3
   \   0000003A   0xF000 0x82F0      BEQ.W    ??SDHC_ioctl_4
   \   0000003E   0x1F80             SUBS     R0,R0,#+6
   \   00000040   0xF000 0x82E5      BEQ.W    ??SDHC_ioctl_5
   \   00000044   0xF241 0x21F8      MOVW     R1,#+4856
   \   00000048   0x1A40             SUBS     R0,R0,R1
   \   0000004A   0xD018             BEQ.N    ??SDHC_ioctl_6
   \   0000004C   0x1E40             SUBS     R0,R0,#+1
   \   0000004E   0xF000 0x81C8      BEQ.W    ??SDHC_ioctl_7
   \   00000052   0x1E40             SUBS     R0,R0,#+1
   \   00000054   0xF000 0x82AD      BEQ.W    ??SDHC_ioctl_8
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0xF000 0x81CD      BEQ.W    ??SDHC_ioctl_9
   \   0000005E   0x1E40             SUBS     R0,R0,#+1
   \   00000060   0xF000 0x81E2      BEQ.W    ??SDHC_ioctl_10
   \   00000064   0x1E40             SUBS     R0,R0,#+1
   \   00000066   0xF000 0x8252      BEQ.W    ??SDHC_ioctl_11
   \   0000006A   0x1E40             SUBS     R0,R0,#+1
   \   0000006C   0xF000 0x8268      BEQ.W    ??SDHC_ioctl_12
   \   00000070   0x1E40             SUBS     R0,R0,#+1
   \   00000072   0xF000 0x8222      BEQ.W    ??SDHC_ioctl_13
   \   00000076   0x1E40             SUBS     R0,R0,#+1
   \   00000078   0xF000 0x8229      BEQ.W    ??SDHC_ioctl_14
   \   0000007C   0xE2E5             B.N      ??SDHC_ioctl_15
    397              {
    398              case IO_IOCTL_ESDHC_INIT:
    399          
    400                  result = SDHC_init (esdhc_info_ptr, &K60_SDHC0_init);
   \                     ??SDHC_ioctl_6: (+1)
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable5_30
   \   00000082   0x4648             MOV      R0,R9
   \   00000084   0x.... 0x....      BL       SDHC_init
   \   00000088   0x0005             MOVS     R5,R0
    401                  if (ESDHC_OK != result)
   \   0000008A   0x2D00             CMP      R5,#+0
   \   0000008C   0xF040 0x82DF      BNE.W    ??SDHC_ioctl_16
    402                  {
    403                      break;
    404                  }
    405          
    406                  mem = FALSE;
   \                     ??SDHC_ioctl_17: (+1)
   \   00000090   0x2700             MOVS     R7,#+0
    407                  io = FALSE;
   \   00000092   0xF05F 0x0800      MOVS     R8,#+0
    408                  mmc = FALSE;
   \   00000096   0xF05F 0x0A00      MOVS     R10,#+0
    409                  ceata = FALSE;
   \   0000009A   0xF05F 0x0B00      MOVS     R11,#+0
    410                  hc = FALSE;
   \   0000009E   0x2400             MOVS     R4,#+0
    411                  mp = FALSE;
   \   000000A0   0x2000             MOVS     R0,#+0
    412          
    413                  /* CMD0 - Go to idle - reset card */
    414                  command.COMMAND = ESDHC_CMD0;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF88D 0x0000      STRB     R0,[SP, #+0]
    415                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xF88D 0x0001      STRB     R0,[SP, #+1]
    416                  command.ARGUMENT = 0;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x9001             STR      R0,[SP, #+4]
    417                  command.READ = FALSE;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xF88D 0x0008      STRB     R0,[SP, #+8]
    418                  command.BLOCKS = 0;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x9003             STR      R0,[SP, #+12]
    419                  if (SDHC_send_command (&command))
   \   000000BC   0x4668             MOV      R0,SP
   \   000000BE   0x.... 0x....      BL       SDHC_send_command
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD001             BEQ.N    ??SDHC_ioctl_18
    420                  {
    421                      result = ESDHC_ERROR_INIT_FAILED;
   \   000000C6   0x2501             MOVS     R5,#+1
    422                      break;
   \   000000C8   0xE2C1             B.N      ??SDHC_ioctl_16
    423                  }
    424          
    425                  //DELAY_MS(1100);
    426                  for(int xx = 0; xx < 1100; xx++)
   \                     ??SDHC_ioctl_18: (+1)
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xE005             B.N      ??SDHC_ioctl_19
    427                    for(int yy = 0; yy < 150000; yy++) ;
   \                     ??SDHC_ioctl_20: (+1)
   \   000000CE   0x1C49             ADDS     R1,R1,#+1
   \                     ??SDHC_ioctl_21: (+1)
   \   000000D0   0x.... 0x....      LDR.W    R2,??DataTable5_31  ;; 0x249f0
   \   000000D4   0x4291             CMP      R1,R2
   \   000000D6   0xDBFA             BLT.N    ??SDHC_ioctl_20
   \   000000D8   0x1C40             ADDS     R0,R0,#+1
   \                     ??SDHC_ioctl_19: (+1)
   \   000000DA   0xF240 0x414C      MOVW     R1,#+1100
   \   000000DE   0x4288             CMP      R0,R1
   \   000000E0   0xDA01             BGE.N    ??SDHC_ioctl_22
   \   000000E2   0x2100             MOVS     R1,#+0
   \   000000E4   0xE7F4             B.N      ??SDHC_ioctl_21
    428                  /* CMD8 - Send interface condition - check HC support */
    429                  command.COMMAND = ESDHC_CMD8;
   \                     ??SDHC_ioctl_22: (+1)
   \   000000E6   0x2008             MOVS     R0,#+8
   \   000000E8   0xF88D 0x0000      STRB     R0,[SP, #+0]
    430                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xF88D 0x0001      STRB     R0,[SP, #+1]
    431                  command.ARGUMENT = 0x000001AA;
   \   000000F2   0xF44F 0x70D5      MOV      R0,#+426
   \   000000F6   0x9001             STR      R0,[SP, #+4]
    432                  command.READ = FALSE;
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xF88D 0x0008      STRB     R0,[SP, #+8]
    433                  command.BLOCKS = 0;
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0x9003             STR      R0,[SP, #+12]
    434                  val = SDHC_send_command (&command);
   \   00000102   0x4668             MOV      R0,SP
   \   00000104   0x.... 0x....      BL       SDHC_send_command
   \   00000108   0x0006             MOVS     R6,R0
    435          
    436                  if (val == 0)
   \   0000010A   0x2E00             CMP      R6,#+0
   \   0000010C   0xD106             BNE.N    ??SDHC_ioctl_23
    437                  {
    438                      // SDHC Card
    439                      if (command.RESPONSE[0] != command.ARGUMENT)
   \   0000010E   0x9804             LDR      R0,[SP, #+16]
   \   00000110   0x9901             LDR      R1,[SP, #+4]
   \   00000112   0x4288             CMP      R0,R1
   \   00000114   0xD001             BEQ.N    ??SDHC_ioctl_24
    440                      {
    441                          result = ESDHC_ERROR_INIT_FAILED;
   \   00000116   0x2501             MOVS     R5,#+1
    442                          break;
   \   00000118   0xE299             B.N      ??SDHC_ioctl_16
    443                      }
    444                      hc = TRUE;
   \                     ??SDHC_ioctl_24: (+1)
   \   0000011A   0x2401             MOVS     R4,#+1
    445                  }
    446          
    447                  mp = TRUE;
   \                     ??SDHC_ioctl_23: (+1)
   \   0000011C   0x2001             MOVS     R0,#+1
    448          
    449                  if (mp)
   \   0000011E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000120   0x2800             CMP      R0,#+0
   \   00000122   0xF000 0x80E8      BEQ.W    ??SDHC_ioctl_25
    450                  {
    451                      /* CMD55 - Application specific command - check MMC */
    452                      command.COMMAND = ESDHC_CMD55;
   \   00000126   0x2037             MOVS     R0,#+55
   \   00000128   0xF88D 0x0000      STRB     R0,[SP, #+0]
    453                      command.TYPE = ESDHC_TYPE_NORMAL;
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    454                      command.ARGUMENT = 0;
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0x9001             STR      R0,[SP, #+4]
    455                      command.READ = FALSE;
   \   00000136   0x2000             MOVS     R0,#+0
   \   00000138   0xF88D 0x0008      STRB     R0,[SP, #+8]
    456                      command.BLOCKS = 0;
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0x9003             STR      R0,[SP, #+12]
    457                      val = SDHC_send_command (&command);
   \   00000140   0x4668             MOV      R0,SP
   \   00000142   0x.... 0x....      BL       SDHC_send_command
   \   00000146   0x0006             MOVS     R6,R0
    458                      if (val > 0)
   \   00000148   0x2E01             CMP      R6,#+1
   \   0000014A   0xDB01             BLT.N    ??SDHC_ioctl_26
    459                      {
    460                          result = ESDHC_ERROR_INIT_FAILED;
   \   0000014C   0x2501             MOVS     R5,#+1
    461                          break;
   \   0000014E   0xE27E             B.N      ??SDHC_ioctl_16
    462                      }
    463                      if (val < 0)
   \                     ??SDHC_ioctl_26: (+1)
   \   00000150   0x2E00             CMP      R6,#+0
   \   00000152   0xD565             BPL.N    ??SDHC_ioctl_27
    464                      {
    465                          /* MMC or CE-ATA */
    466                          io = FALSE;
   \   00000154   0xF05F 0x0800      MOVS     R8,#+0
    467                          mem = FALSE;
   \   00000158   0x2700             MOVS     R7,#+0
    468                          hc = FALSE;
   \   0000015A   0x2400             MOVS     R4,#+0
    469          
    470                          /* CMD1 - Send operating conditions - check HC */
    471                          command.COMMAND = ESDHC_CMD1;
   \   0000015C   0x2001             MOVS     R0,#+1
   \   0000015E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    472                          command.TYPE = ESDHC_TYPE_NORMAL;
   \   00000162   0x2000             MOVS     R0,#+0
   \   00000164   0xF88D 0x0001      STRB     R0,[SP, #+1]
    473                          command.ARGUMENT = 0x40300000;
   \   00000168   0x.... 0x....      LDR.W    R0,??DataTable5_32  ;; 0x40300000
   \   0000016C   0x9001             STR      R0,[SP, #+4]
    474                          command.READ = FALSE;
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0xF88D 0x0008      STRB     R0,[SP, #+8]
    475                          command.BLOCKS = 0;
   \   00000174   0x2000             MOVS     R0,#+0
   \   00000176   0x9003             STR      R0,[SP, #+12]
    476                          if (SDHC_send_command (&command))
   \   00000178   0x4668             MOV      R0,SP
   \   0000017A   0x.... 0x....      BL       SDHC_send_command
   \   0000017E   0x2800             CMP      R0,#+0
   \   00000180   0xD001             BEQ.N    ??SDHC_ioctl_28
    477                          {
    478                              result = ESDHC_ERROR_INIT_FAILED;
   \   00000182   0x2501             MOVS     R5,#+1
    479                              break;
   \   00000184   0xE263             B.N      ??SDHC_ioctl_16
    480                          }
    481                          if (0x20000000 == (command.RESPONSE[0] & 0x60000000))
   \                     ??SDHC_ioctl_28: (+1)
   \   00000186   0x9804             LDR      R0,[SP, #+16]
   \   00000188   0xF010 0x40C0      ANDS     R0,R0,#0x60000000
   \   0000018C   0xF1B0 0x5F00      CMP      R0,#+536870912
   \   00000190   0xD100             BNE.N    ??SDHC_ioctl_29
    482                          {
    483                              hc = TRUE;
   \   00000192   0x2401             MOVS     R4,#+1
    484                          }
    485                          mmc = TRUE;
   \                     ??SDHC_ioctl_29: (+1)
   \   00000194   0xF05F 0x0A01      MOVS     R10,#+1
    486          
    487                          /* CMD39 - Fast IO - check CE-ATA signature CE */
    488                          command.COMMAND = ESDHC_CMD39;
   \   00000198   0x2027             MOVS     R0,#+39
   \   0000019A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    489                          command.TYPE = ESDHC_TYPE_NORMAL;
   \   0000019E   0x2000             MOVS     R0,#+0
   \   000001A0   0xF88D 0x0001      STRB     R0,[SP, #+1]
    490                          command.ARGUMENT = 0x0C00;
   \   000001A4   0xF44F 0x6040      MOV      R0,#+3072
   \   000001A8   0x9001             STR      R0,[SP, #+4]
    491                          command.READ = FALSE;
   \   000001AA   0x2000             MOVS     R0,#+0
   \   000001AC   0xF88D 0x0008      STRB     R0,[SP, #+8]
    492                          command.BLOCKS = 0;
   \   000001B0   0x2000             MOVS     R0,#+0
   \   000001B2   0x9003             STR      R0,[SP, #+12]
    493                          if (SDHC_send_command (&command))
   \   000001B4   0x4668             MOV      R0,SP
   \   000001B6   0x.... 0x....      BL       SDHC_send_command
   \   000001BA   0x2800             CMP      R0,#+0
   \   000001BC   0xD001             BEQ.N    ??SDHC_ioctl_30
    494                          {
    495                              result = ESDHC_ERROR_INIT_FAILED;
   \   000001BE   0x2501             MOVS     R5,#+1
    496                              break;
   \   000001C0   0xE245             B.N      ??SDHC_ioctl_16
    497                          }
    498                          if (0xCE == (command.RESPONSE[0] >> 8) & 0xFF)
   \                     ??SDHC_ioctl_30: (+1)
   \   000001C2   0x9804             LDR      R0,[SP, #+16]
   \   000001C4   0x0A00             LSRS     R0,R0,#+8
   \   000001C6   0x28CE             CMP      R0,#+206
   \   000001C8   0xD101             BNE.N    ??SDHC_ioctl_31
   \   000001CA   0x2001             MOVS     R0,#+1
   \   000001CC   0xE000             B.N      ??SDHC_ioctl_32
   \                     ??SDHC_ioctl_31: (+1)
   \   000001CE   0x2000             MOVS     R0,#+0
   \                     ??SDHC_ioctl_32: (+1)
   \   000001D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001D2   0x2800             CMP      R0,#+0
   \   000001D4   0xF000 0x808F      BEQ.W    ??SDHC_ioctl_25
    499                          {
    500                              /* CMD39 - Fast IO - check CE-ATA signature AA */
    501                              command.COMMAND = ESDHC_CMD39;
   \   000001D8   0x2027             MOVS     R0,#+39
   \   000001DA   0xF88D 0x0000      STRB     R0,[SP, #+0]
    502                              command.TYPE = ESDHC_TYPE_NORMAL;
   \   000001DE   0x2000             MOVS     R0,#+0
   \   000001E0   0xF88D 0x0001      STRB     R0,[SP, #+1]
    503                              command.ARGUMENT = 0x0D00;
   \   000001E4   0xF44F 0x6050      MOV      R0,#+3328
   \   000001E8   0x9001             STR      R0,[SP, #+4]
    504                              command.READ = FALSE;
   \   000001EA   0x2000             MOVS     R0,#+0
   \   000001EC   0xF88D 0x0008      STRB     R0,[SP, #+8]
    505                              command.BLOCKS = 0;
   \   000001F0   0x2000             MOVS     R0,#+0
   \   000001F2   0x9003             STR      R0,[SP, #+12]
    506                              if (SDHC_send_command (&command))
   \   000001F4   0x4668             MOV      R0,SP
   \   000001F6   0x.... 0x....      BL       SDHC_send_command
   \   000001FA   0x2800             CMP      R0,#+0
   \   000001FC   0xD001             BEQ.N    ??SDHC_ioctl_33
    507                              {
    508                                  result = ESDHC_ERROR_INIT_FAILED;
   \   000001FE   0x2501             MOVS     R5,#+1
    509                                  break;
   \   00000200   0xE225             B.N      ??SDHC_ioctl_16
    510                              }
    511                              if (0xAA == (command.RESPONSE[0] >> 8) & 0xFF)
   \                     ??SDHC_ioctl_33: (+1)
   \   00000202   0x9804             LDR      R0,[SP, #+16]
   \   00000204   0x0A00             LSRS     R0,R0,#+8
   \   00000206   0x28AA             CMP      R0,#+170
   \   00000208   0xD101             BNE.N    ??SDHC_ioctl_34
   \   0000020A   0x2001             MOVS     R0,#+1
   \   0000020C   0xE000             B.N      ??SDHC_ioctl_35
   \                     ??SDHC_ioctl_34: (+1)
   \   0000020E   0x2000             MOVS     R0,#+0
   \                     ??SDHC_ioctl_35: (+1)
   \   00000210   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000212   0x2800             CMP      R0,#+0
   \   00000214   0xD06F             BEQ.N    ??SDHC_ioctl_25
    512                              {
    513                                  mmc = FALSE;
   \   00000216   0xF05F 0x0A00      MOVS     R10,#+0
    514                                  ceata = TRUE;
   \   0000021A   0xF05F 0x0B01      MOVS     R11,#+1
   \   0000021E   0xE06A             B.N      ??SDHC_ioctl_25
    515                              }
    516                          }
    517                      }
    518                      else
    519                      {
    520                          /* SD */
    521                          /* ACMD41 - Send Operating Conditions */
    522                          command.COMMAND = ESDHC_ACMD41;
   \                     ??SDHC_ioctl_27: (+1)
   \   00000220   0x2069             MOVS     R0,#+105
   \   00000222   0xF88D 0x0000      STRB     R0,[SP, #+0]
    523                          command.TYPE = ESDHC_TYPE_NORMAL;
   \   00000226   0x2000             MOVS     R0,#+0
   \   00000228   0xF88D 0x0001      STRB     R0,[SP, #+1]
    524                          command.ARGUMENT = 0;
   \   0000022C   0x2000             MOVS     R0,#+0
   \   0000022E   0x9001             STR      R0,[SP, #+4]
    525                          command.READ = FALSE;
   \   00000230   0x2000             MOVS     R0,#+0
   \   00000232   0xF88D 0x0008      STRB     R0,[SP, #+8]
    526                          command.BLOCKS = 0;
   \   00000236   0x2000             MOVS     R0,#+0
   \   00000238   0x9003             STR      R0,[SP, #+12]
    527                          if (SDHC_send_command (&command))
   \   0000023A   0x4668             MOV      R0,SP
   \   0000023C   0x.... 0x....      BL       SDHC_send_command
   \   00000240   0x2800             CMP      R0,#+0
   \   00000242   0xD001             BEQ.N    ??SDHC_ioctl_36
    528                          {
    529                              result = ESDHC_ERROR_INIT_FAILED;
   \   00000244   0x2501             MOVS     R5,#+1
    530                              break;
   \   00000246   0xE202             B.N      ??SDHC_ioctl_16
    531                          }
    532                          if (command.RESPONSE[0] & 0x300000)
   \                     ??SDHC_ioctl_36: (+1)
   \   00000248   0x9804             LDR      R0,[SP, #+16]
   \   0000024A   0xF410 0x1F40      TST      R0,#0x300000
   \   0000024E   0xD052             BEQ.N    ??SDHC_ioctl_25
    533                          {
    534                              val = 0;
   \   00000250   0x2600             MOVS     R6,#+0
    535                              do
    536                              {
    537                                  //DELAY_MS(BSP_ALARM_RESOLUTION);
    538                                  for(int xx = 0; xx < BSP_ALARM_RESOLUTION; xx++)
   \                     ??SDHC_ioctl_37: (+1)
   \   00000252   0x2000             MOVS     R0,#+0
   \   00000254   0xE005             B.N      ??SDHC_ioctl_38
    539                                    for(int yy = 0; yy < 150000; yy++) ;
   \                     ??SDHC_ioctl_39: (+1)
   \   00000256   0x1C49             ADDS     R1,R1,#+1
   \                     ??SDHC_ioctl_40: (+1)
   \   00000258   0x.... 0x....      LDR.W    R2,??DataTable5_31  ;; 0x249f0
   \   0000025C   0x4291             CMP      R1,R2
   \   0000025E   0xDBFA             BLT.N    ??SDHC_ioctl_39
   \   00000260   0x1C40             ADDS     R0,R0,#+1
   \                     ??SDHC_ioctl_38: (+1)
   \   00000262   0x280A             CMP      R0,#+10
   \   00000264   0xDA01             BGE.N    ??SDHC_ioctl_41
   \   00000266   0x2100             MOVS     R1,#+0
   \   00000268   0xE7F6             B.N      ??SDHC_ioctl_40
    540                                  val++;
   \                     ??SDHC_ioctl_41: (+1)
   \   0000026A   0x1C76             ADDS     R6,R6,#+1
    541          
    542                                  /* CMD55 + ACMD41 - Send OCR */
    543                                  command.COMMAND = ESDHC_CMD55;
   \   0000026C   0x2037             MOVS     R0,#+55
   \   0000026E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    544                                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   00000272   0x2000             MOVS     R0,#+0
   \   00000274   0xF88D 0x0001      STRB     R0,[SP, #+1]
    545                                  command.ARGUMENT = 0;
   \   00000278   0x2000             MOVS     R0,#+0
   \   0000027A   0x9001             STR      R0,[SP, #+4]
    546                                  command.READ = FALSE;
   \   0000027C   0x2000             MOVS     R0,#+0
   \   0000027E   0xF88D 0x0008      STRB     R0,[SP, #+8]
    547                                  command.BLOCKS = 0;
   \   00000282   0x2000             MOVS     R0,#+0
   \   00000284   0x9003             STR      R0,[SP, #+12]
    548                                  if (SDHC_send_command (&command))
   \   00000286   0x4668             MOV      R0,SP
   \   00000288   0x.... 0x....      BL       SDHC_send_command
   \   0000028C   0x2800             CMP      R0,#+0
   \   0000028E   0xD10C             BNE.N    ??SDHC_ioctl_42
    549                                  {
    550                                      result = ESDHC_ERROR_INIT_FAILED;
    551                                      break;
    552                                  }
    553          
    554                                  command.COMMAND = ESDHC_ACMD41;
   \                     ??SDHC_ioctl_43: (+1)
   \   00000290   0x2069             MOVS     R0,#+105
   \   00000292   0xF88D 0x0000      STRB     R0,[SP, #+0]
    555                                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   00000296   0x2000             MOVS     R0,#+0
   \   00000298   0xF88D 0x0001      STRB     R0,[SP, #+1]
    556                                  if (hc)
   \   0000029C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000029E   0x2C00             CMP      R4,#+0
   \   000002A0   0xD005             BEQ.N    ??SDHC_ioctl_44
    557                                  {
    558                                      command.ARGUMENT = 0x40300000;
   \   000002A2   0x.... 0x....      LDR.W    R0,??DataTable5_32  ;; 0x40300000
   \   000002A6   0x9001             STR      R0,[SP, #+4]
   \   000002A8   0xE004             B.N      ??SDHC_ioctl_45
    559                                  }
   \                     ??SDHC_ioctl_42: (+1)
   \   000002AA   0x2501             MOVS     R5,#+1
   \   000002AC   0xE013             B.N      ??SDHC_ioctl_46
    560                                  else
    561                                  {
    562                                      command.ARGUMENT = 0x00300000;
   \                     ??SDHC_ioctl_44: (+1)
   \   000002AE   0xF45F 0x1040      MOVS     R0,#+3145728
   \   000002B2   0x9001             STR      R0,[SP, #+4]
    563                                  }
    564                                  command.READ = FALSE;
   \                     ??SDHC_ioctl_45: (+1)
   \   000002B4   0x2000             MOVS     R0,#+0
   \   000002B6   0xF88D 0x0008      STRB     R0,[SP, #+8]
    565                                  command.BLOCKS = 0;
   \   000002BA   0x2000             MOVS     R0,#+0
   \   000002BC   0x9003             STR      R0,[SP, #+12]
    566                                  if (SDHC_send_command (&command))
   \   000002BE   0x4668             MOV      R0,SP
   \   000002C0   0x.... 0x....      BL       SDHC_send_command
   \   000002C4   0x2800             CMP      R0,#+0
   \   000002C6   0xD105             BNE.N    ??SDHC_ioctl_47
    567                                  {
    568                                      result = ESDHC_ERROR_INIT_FAILED;
    569                                      break;
    570                                  }
    571                              }
    572                              while ((0 == (command.RESPONSE[0] & 0x80000000)) && (val < BSP_ALARM_FREQUENCY));
   \                     ??SDHC_ioctl_48: (+1)
   \   000002C8   0x9804             LDR      R0,[SP, #+16]
   \   000002CA   0x2800             CMP      R0,#+0
   \   000002CC   0xD403             BMI.N    ??SDHC_ioctl_46
   \   000002CE   0x2E64             CMP      R6,#+100
   \   000002D0   0xDBBF             BLT.N    ??SDHC_ioctl_37
   \   000002D2   0xE000             B.N      ??SDHC_ioctl_46
   \                     ??SDHC_ioctl_47: (+1)
   \   000002D4   0x2501             MOVS     R5,#+1
    573                              if (ESDHC_OK != result)
   \                     ??SDHC_ioctl_46: (+1)
   \   000002D6   0x2D00             CMP      R5,#+0
   \   000002D8   0xF040 0x81B9      BNE.W    ??SDHC_ioctl_16
    574                              {
    575                                  break;
    576                              }
    577                              if (val >= BSP_ALARM_FREQUENCY)
   \                     ??SDHC_ioctl_49: (+1)
   \   000002DC   0x2E64             CMP      R6,#+100
   \   000002DE   0xDB01             BLT.N    ??SDHC_ioctl_50
    578                              {
    579                                  hc = FALSE;
   \   000002E0   0x2400             MOVS     R4,#+0
   \   000002E2   0xE008             B.N      ??SDHC_ioctl_25
    580                              }
    581                              else
    582                              {
    583                                  mem = TRUE;
   \                     ??SDHC_ioctl_50: (+1)
   \   000002E4   0x2701             MOVS     R7,#+1
    584                                  if (hc)
   \   000002E6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002E8   0x2C00             CMP      R4,#+0
   \   000002EA   0xD004             BEQ.N    ??SDHC_ioctl_25
    585                                  {
    586                                      hc = FALSE;
   \   000002EC   0x2400             MOVS     R4,#+0
    587                                      if (command.RESPONSE[0] & 0x40000000)
   \   000002EE   0x9804             LDR      R0,[SP, #+16]
   \   000002F0   0x0040             LSLS     R0,R0,#+1
   \   000002F2   0xD500             BPL.N    ??SDHC_ioctl_25
    588                                      {
    589                                          hc = TRUE;
   \   000002F4   0x2401             MOVS     R4,#+1
    590                                      }
    591                                  }
    592                              }
    593                          }
    594                      }
    595                  }
    596          
    597          
    598                  if (mmc)
   \                     ??SDHC_ioctl_25: (+1)
   \   000002F6   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000002FA   0xF1BA 0x0F00      CMP      R10,#+0
   \   000002FE   0xD002             BEQ.N    ??SDHC_ioctl_51
    599                  {
    600                      esdhc_info_ptr->CARD = ESDHC_CARD_MMC;
   \   00000300   0x2007             MOVS     R0,#+7
   \   00000302   0xF8C9 0x0000      STR      R0,[R9, #+0]
    601                  }
    602                  if (ceata)
   \                     ??SDHC_ioctl_51: (+1)
   \   00000306   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000030A   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000030E   0xD002             BEQ.N    ??SDHC_ioctl_52
    603                  {
    604                      esdhc_info_ptr->CARD = ESDHC_CARD_CEATA;
   \   00000310   0x2008             MOVS     R0,#+8
   \   00000312   0xF8C9 0x0000      STR      R0,[R9, #+0]
    605                  }
    606                  if (io)
   \                     ??SDHC_ioctl_52: (+1)
   \   00000316   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000031A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000031E   0xD002             BEQ.N    ??SDHC_ioctl_53
    607                  {
    608                      esdhc_info_ptr->CARD = ESDHC_CARD_SDIO;
   \   00000320   0x2004             MOVS     R0,#+4
   \   00000322   0xF8C9 0x0000      STR      R0,[R9, #+0]
    609                  }
    610                  if (mem)
   \                     ??SDHC_ioctl_53: (+1)
   \   00000326   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000328   0x2F00             CMP      R7,#+0
   \   0000032A   0xD008             BEQ.N    ??SDHC_ioctl_54
    611                  {
    612                      esdhc_info_ptr->CARD = ESDHC_CARD_SD;
   \   0000032C   0x2002             MOVS     R0,#+2
   \   0000032E   0xF8C9 0x0000      STR      R0,[R9, #+0]
    613                      if (hc)
   \   00000332   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000334   0x2C00             CMP      R4,#+0
   \   00000336   0xD002             BEQ.N    ??SDHC_ioctl_54
    614                      {
    615                          esdhc_info_ptr->CARD = ESDHC_CARD_SDHC;
   \   00000338   0x2003             MOVS     R0,#+3
   \   0000033A   0xF8C9 0x0000      STR      R0,[R9, #+0]
    616                      }
    617                  }
    618                  if (io && mem)
   \                     ??SDHC_ioctl_54: (+1)
   \   0000033E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000342   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000346   0xD00B             BEQ.N    ??SDHC_ioctl_55
   \   00000348   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000034A   0x2F00             CMP      R7,#+0
   \   0000034C   0xD008             BEQ.N    ??SDHC_ioctl_55
    619                  {
    620                      esdhc_info_ptr->CARD = ESDHC_CARD_SDCOMBO;
   \   0000034E   0x2005             MOVS     R0,#+5
   \   00000350   0xF8C9 0x0000      STR      R0,[R9, #+0]
    621                      if (hc)
   \   00000354   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000356   0x2C00             CMP      R4,#+0
   \   00000358   0xD002             BEQ.N    ??SDHC_ioctl_55
    622                      {
    623                          esdhc_info_ptr->CARD = ESDHC_CARD_SDHCCOMBO;
   \   0000035A   0x2006             MOVS     R0,#+6
   \   0000035C   0xF8C9 0x0000      STR      R0,[R9, #+0]
    624                      }
    625                  }
    626          
    627                  /* De-Init GPIO */
    628                  PORTE_PCR(0) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D1  */
   \                     ??SDHC_ioctl_55: (+1)
   \   00000360   0x2000             MOVS     R0,#+0
   \   00000362   0x.... 0x....      LDR.W    R1,??DataTable5_10  ;; 0x4004d000
   \   00000366   0x6008             STR      R0,[R1, #+0]
    629                  PORTE_PCR(1) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D0  */
   \   00000368   0x2000             MOVS     R0,#+0
   \   0000036A   0x.... 0x....      LDR.W    R1,??DataTable5_11  ;; 0x4004d004
   \   0000036E   0x6008             STR      R0,[R1, #+0]
    630                  PORTE_PCR(2) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          /* ESDHC.CLK */
   \   00000370   0x2000             MOVS     R0,#+0
   \   00000372   0x.... 0x....      LDR.W    R1,??DataTable5_12  ;; 0x4004d008
   \   00000376   0x6008             STR      R0,[R1, #+0]
    631                  PORTE_PCR(3) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.CMD */
   \   00000378   0x2000             MOVS     R0,#+0
   \   0000037A   0x.... 0x....      LDR.W    R1,??DataTable5_13  ;; 0x4004d00c
   \   0000037E   0x6008             STR      R0,[R1, #+0]
    632                  PORTE_PCR(4) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D3  */
   \   00000380   0x2000             MOVS     R0,#+0
   \   00000382   0x.... 0x....      LDR.W    R1,??DataTable5_14  ;; 0x4004d010
   \   00000386   0x6008             STR      R0,[R1, #+0]
    633                  PORTE_PCR(5) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D2  */
   \   00000388   0x2000             MOVS     R0,#+0
   \   0000038A   0x.... 0x....      LDR.W    R1,??DataTable5_15  ;; 0x4004d014
   \   0000038E   0x6008             STR      R0,[R1, #+0]
    634          
    635                  /* Set the ESDHC default baud rate */
    636                  //SDHC_set_baudrate (esdhc_init_ptr->CLOCK_SPEED, esdhc_init_ptr->BAUD_RATE);
    637                  SDHC_set_baudrate (core_clk_khz_sd * 1000, esdhc_init_ptr->BAUD_RATE);
   \   00000390   0x9808             LDR      R0,[SP, #+32]
   \   00000392   0x6841             LDR      R1,[R0, #+4]
   \   00000394   0x.... 0x....      LDR.W    R0,??DataTable5_9
   \   00000398   0x6800             LDR      R0,[R0, #+0]
   \   0000039A   0xF44F 0x727A      MOV      R2,#+1000
   \   0000039E   0x4350             MULS     R0,R2,R0
   \   000003A0   0x.... 0x....      BL       SDHC_set_baudrate
    638          
    639                  /* Init GPIO again */
    640                  PORTE_PCR(0) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D1  */
   \   000003A4   0xF240 0x4043      MOVW     R0,#+1091
   \   000003A8   0x....             LDR.N    R1,??DataTable5_10  ;; 0x4004d000
   \   000003AA   0x6008             STR      R0,[R1, #+0]
    641                  PORTE_PCR(1) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D0  */
   \   000003AC   0xF240 0x4043      MOVW     R0,#+1091
   \   000003B0   0x....             LDR.N    R1,??DataTable5_11  ;; 0x4004d004
   \   000003B2   0x6008             STR      R0,[R1, #+0]
    642                  PORTE_PCR(2) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          /* ESDHC.CLK */
   \   000003B4   0xF44F 0x6088      MOV      R0,#+1088
   \   000003B8   0x....             LDR.N    R1,??DataTable5_12  ;; 0x4004d008
   \   000003BA   0x6008             STR      R0,[R1, #+0]
    643                  PORTE_PCR(3) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.CMD */
   \   000003BC   0xF240 0x4043      MOVW     R0,#+1091
   \   000003C0   0x....             LDR.N    R1,??DataTable5_13  ;; 0x4004d00c
   \   000003C2   0x6008             STR      R0,[R1, #+0]
    644                  PORTE_PCR(4) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D3  */
   \   000003C4   0xF240 0x4043      MOVW     R0,#+1091
   \   000003C8   0x....             LDR.N    R1,??DataTable5_14  ;; 0x4004d010
   \   000003CA   0x6008             STR      R0,[R1, #+0]
    645                  PORTE_PCR(5) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D2  */
   \   000003CC   0xF240 0x4043      MOVW     R0,#+1091
   \   000003D0   0x....             LDR.N    R1,??DataTable5_15  ;; 0x4004d014
   \   000003D2   0x6008             STR      R0,[R1, #+0]
    646          
    647                  /* Enable clock gate to SDHC module */
    648                  SIM_SCGC3 |= SIM_SCGC3_SDHC_MASK;
   \   000003D4   0x....             LDR.N    R0,??DataTable5_16  ;; 0x40048030
   \   000003D6   0x6800             LDR      R0,[R0, #+0]
   \   000003D8   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   000003DC   0x....             LDR.N    R1,??DataTable5_16  ;; 0x40048030
   \   000003DE   0x6008             STR      R0,[R1, #+0]
    649          
    650                  break;
   \   000003E0   0xE135             B.N      ??SDHC_ioctl_16
    651              case IO_IOCTL_ESDHC_SEND_COMMAND:
    652                  val = SDHC_send_command ((ESDHC_COMMAND_STRUCT_PTR)param32_ptr);
   \                     ??SDHC_ioctl_7: (+1)
   \   000003E2   0x0020             MOVS     R0,R4
   \   000003E4   0x.... 0x....      BL       SDHC_send_command
   \   000003E8   0x0006             MOVS     R6,R0
    653                  if (val > 0)
   \   000003EA   0x2E01             CMP      R6,#+1
   \   000003EC   0xDB00             BLT.N    ??SDHC_ioctl_56
    654                  {
    655                      result = ESDHC_ERROR_COMMAND_FAILED;
   \   000003EE   0x2502             MOVS     R5,#+2
    656                  }
    657                  if (val < 0)
   \                     ??SDHC_ioctl_56: (+1)
   \   000003F0   0x2E00             CMP      R6,#+0
   \   000003F2   0xD500             BPL.N    ??SDHC_ioctl_57
    658                  {
    659                      result = ESDHC_ERROR_COMMAND_TIMEOUT;
   \   000003F4   0x2503             MOVS     R5,#+3
    660                  }
    661                  break;
   \                     ??SDHC_ioctl_57: (+1)
   \   000003F6   0xE12A             B.N      ??SDHC_ioctl_16
    662              case IO_IOCTL_ESDHC_GET_BAUDRATE:
    663                  if (NULL == param32_ptr)
   \                     ??SDHC_ioctl_9: (+1)
   \   000003F8   0x2C00             CMP      R4,#+0
   \   000003FA   0xD101             BNE.N    ??SDHC_ioctl_58
    664                  {
    665                      result = BRTOS_INVALID_PARAMETER;
   \   000003FC   0x250C             MOVS     R5,#+12
   \   000003FE   0xE012             B.N      ??SDHC_ioctl_59
    666                  }
    667                  else
    668                  {
    669                      /* Get actual baudrate */
    670                      val = ((SDHC_SYSCTL & SDHC_SYSCTL_SDCLKFS_MASK) >> SDHC_SYSCTL_SDCLKFS_SHIFT) << 1;
   \                     ??SDHC_ioctl_58: (+1)
   \   00000400   0x....             LDR.N    R0,??DataTable5  ;; 0x400b102c
   \   00000402   0x6806             LDR      R6,[R0, #+0]
   \   00000404   0x09F6             LSRS     R6,R6,#+7
   \   00000406   0xF416 0x76FF      ANDS     R6,R6,#0x1FE
    671                      val *= ((SDHC_SYSCTL & SDHC_SYSCTL_DVS_MASK) >> SDHC_SYSCTL_DVS_SHIFT) + 1;
   \   0000040A   0x....             LDR.N    R0,??DataTable5  ;; 0x400b102c
   \   0000040C   0x6800             LDR      R0,[R0, #+0]
   \   0000040E   0xF3C0 0x1003      UBFX     R0,R0,#+4,#+4
   \   00000412   0x1C40             ADDS     R0,R0,#+1
   \   00000414   0x4346             MULS     R6,R0,R6
    672                      //*param32_ptr = (uint32)((esdhc_init_ptr->CLOCK_SPEED) / val);
    673                      *param32_ptr = (uint32)((core_clk_khz_sd * 1000) / val);
   \   00000416   0x....             LDR.N    R0,??DataTable5_9
   \   00000418   0x6801             LDR      R1,[R0, #+0]
   \   0000041A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000041E   0x4341             MULS     R1,R0,R1
   \   00000420   0xFBB1 0xF0F6      UDIV     R0,R1,R6
   \   00000424   0x6020             STR      R0,[R4, #+0]
    674                  }
    675                  break;
   \                     ??SDHC_ioctl_59: (+1)
   \   00000426   0xE112             B.N      ??SDHC_ioctl_16
    676              case IO_IOCTL_ESDHC_SET_BAUDRATE:
    677                  if (NULL == param32_ptr)
   \                     ??SDHC_ioctl_10: (+1)
   \   00000428   0x2C00             CMP      R4,#+0
   \   0000042A   0xD101             BNE.N    ??SDHC_ioctl_60
    678                  {
    679                      result = BRTOS_INVALID_PARAMETER;
   \   0000042C   0x250C             MOVS     R5,#+12
   \   0000042E   0xE043             B.N      ??SDHC_ioctl_61
    680                  }
    681                  else if (0 == (*param32_ptr))
   \                     ??SDHC_ioctl_60: (+1)
   \   00000430   0x6820             LDR      R0,[R4, #+0]
   \   00000432   0x2800             CMP      R0,#+0
   \   00000434   0xD101             BNE.N    ??SDHC_ioctl_62
    682                  {
    683                      result = BRTOS_INVALID_PARAMETER;
   \   00000436   0x250C             MOVS     R5,#+12
   \   00000438   0xE03E             B.N      ??SDHC_ioctl_61
    684                  }
    685                  else
    686                  {
    687                      if (! SDHC_is_running())
   \                     ??SDHC_ioctl_62: (+1)
   \   0000043A   0x.... 0x....      BL       SDHC_is_running
   \   0000043E   0x2800             CMP      R0,#+0
   \   00000440   0xD138             BNE.N    ??SDHC_ioctl_63
    688                      {
    689                          /* De-Init GPIO */
    690                          PORTE_PCR(0) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D1  */
   \   00000442   0x2000             MOVS     R0,#+0
   \   00000444   0x....             LDR.N    R1,??DataTable5_10  ;; 0x4004d000
   \   00000446   0x6008             STR      R0,[R1, #+0]
    691                          PORTE_PCR(1) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D0  */
   \   00000448   0x2000             MOVS     R0,#+0
   \   0000044A   0x....             LDR.N    R1,??DataTable5_11  ;; 0x4004d004
   \   0000044C   0x6008             STR      R0,[R1, #+0]
    692                          PORTE_PCR(2) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          /* ESDHC.CLK */
   \   0000044E   0x2000             MOVS     R0,#+0
   \   00000450   0x....             LDR.N    R1,??DataTable5_12  ;; 0x4004d008
   \   00000452   0x6008             STR      R0,[R1, #+0]
    693                          PORTE_PCR(3) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.CMD */
   \   00000454   0x2000             MOVS     R0,#+0
   \   00000456   0x....             LDR.N    R1,??DataTable5_13  ;; 0x4004d00c
   \   00000458   0x6008             STR      R0,[R1, #+0]
    694                          PORTE_PCR(4) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D3  */
   \   0000045A   0x2000             MOVS     R0,#+0
   \   0000045C   0x....             LDR.N    R1,??DataTable5_14  ;; 0x4004d010
   \   0000045E   0x6008             STR      R0,[R1, #+0]
    695                          PORTE_PCR(5) = 0 & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D2  */
   \   00000460   0x2000             MOVS     R0,#+0
   \   00000462   0x....             LDR.N    R1,??DataTable5_15  ;; 0x4004d014
   \   00000464   0x6008             STR      R0,[R1, #+0]
    696          
    697                          /* Set closest baudrate */
    698                          //SDHC_set_baudrate (esdhc_init_ptr->CLOCK_SPEED, *param32_ptr);
    699                          SDHC_set_baudrate (core_clk_khz_sd * 1000, *param32_ptr);
   \   00000466   0x6821             LDR      R1,[R4, #+0]
   \   00000468   0x....             LDR.N    R0,??DataTable5_9
   \   0000046A   0x6800             LDR      R0,[R0, #+0]
   \   0000046C   0xF44F 0x727A      MOV      R2,#+1000
   \   00000470   0x4350             MULS     R0,R2,R0
   \   00000472   0x.... 0x....      BL       SDHC_set_baudrate
    700          
    701                          /* Init GPIO again */
    702                          PORTE_PCR(0) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D1  */
   \   00000476   0xF240 0x4043      MOVW     R0,#+1091
   \   0000047A   0x....             LDR.N    R1,??DataTable5_10  ;; 0x4004d000
   \   0000047C   0x6008             STR      R0,[R1, #+0]
    703                          PORTE_PCR(1) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D0  */
   \   0000047E   0xF240 0x4043      MOVW     R0,#+1091
   \   00000482   0x....             LDR.N    R1,??DataTable5_11  ;; 0x4004d004
   \   00000484   0x6008             STR      R0,[R1, #+0]
    704                          PORTE_PCR(2) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          /* ESDHC.CLK */
   \   00000486   0xF44F 0x6088      MOV      R0,#+1088
   \   0000048A   0x....             LDR.N    R1,??DataTable5_12  ;; 0x4004d008
   \   0000048C   0x6008             STR      R0,[R1, #+0]
    705                          PORTE_PCR(3) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.CMD */
   \   0000048E   0xF240 0x4043      MOVW     R0,#+1091
   \   00000492   0x....             LDR.N    R1,??DataTable5_13  ;; 0x4004d00c
   \   00000494   0x6008             STR      R0,[R1, #+0]
    706                          PORTE_PCR(4) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D3  */
   \   00000496   0xF240 0x4043      MOVW     R0,#+1091
   \   0000049A   0x....             LDR.N    R1,??DataTable5_14  ;; 0x4004d010
   \   0000049C   0x6008             STR      R0,[R1, #+0]
    707                          PORTE_PCR(5) = 0xFFFF & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D2  */
   \   0000049E   0xF240 0x4043      MOVW     R0,#+1091
   \   000004A2   0x....             LDR.N    R1,??DataTable5_15  ;; 0x4004d014
   \   000004A4   0x6008             STR      R0,[R1, #+0]
    708          
    709                          /* Enable clock gate to SDHC module */
    710                          SIM_SCGC3 |= SIM_SCGC3_SDHC_MASK;
   \   000004A6   0x....             LDR.N    R0,??DataTable5_16  ;; 0x40048030
   \   000004A8   0x6800             LDR      R0,[R0, #+0]
   \   000004AA   0xF450 0x3000      ORRS     R0,R0,#0x20000
   \   000004AE   0x....             LDR.N    R1,??DataTable5_16  ;; 0x40048030
   \   000004B0   0x6008             STR      R0,[R1, #+0]
   \   000004B2   0xE001             B.N      ??SDHC_ioctl_61
    711                      }
    712                      else
    713                      {
    714                          result = IO_ERROR_DEVICE_BUSY;
   \                     ??SDHC_ioctl_63: (+1)
   \   000004B4   0xF640 0x250A      MOVW     R5,#+2570
    715                      }
    716                  }
    717                  break;
   \                     ??SDHC_ioctl_61: (+1)
   \   000004B8   0xE0C9             B.N      ??SDHC_ioctl_16
    718              case IO_IOCTL_ESDHC_GET_BLOCK_SIZE:
    719                  if (NULL == param32_ptr)
   \                     ??SDHC_ioctl_13: (+1)
   \   000004BA   0x2C00             CMP      R4,#+0
   \   000004BC   0xD101             BNE.N    ??SDHC_ioctl_64
    720                  {
    721                      result = BRTOS_INVALID_PARAMETER;
   \   000004BE   0x250C             MOVS     R5,#+12
   \   000004C0   0xE004             B.N      ??SDHC_ioctl_65
    722                  }
    723                  else
    724                  {
    725                      /* Get actual ESDHC block size */
    726                      *param32_ptr = (SDHC_BLKATTR & SDHC_BLKATTR_BLKSIZE_MASK) >> SDHC_BLKATTR_BLKSIZE_SHIFT;
   \                     ??SDHC_ioctl_64: (+1)
   \   000004C2   0x....             LDR.N    R0,??DataTable5_5  ;; 0x400b1004
   \   000004C4   0x6800             LDR      R0,[R0, #+0]
   \   000004C6   0x04C0             LSLS     R0,R0,#+19       ;; ZeroExtS R0,R0,#+19,#+19
   \   000004C8   0x0CC0             LSRS     R0,R0,#+19
   \   000004CA   0x6020             STR      R0,[R4, #+0]
    727                  }
    728                  break;
   \                     ??SDHC_ioctl_65: (+1)
   \   000004CC   0xE0BF             B.N      ??SDHC_ioctl_16
    729              case IO_IOCTL_ESDHC_SET_BLOCK_SIZE:
    730                  if (NULL == param32_ptr)
   \                     ??SDHC_ioctl_14: (+1)
   \   000004CE   0x2C00             CMP      R4,#+0
   \   000004D0   0xD101             BNE.N    ??SDHC_ioctl_66
    731                  {
    732                      result = BRTOS_INVALID_PARAMETER;
   \   000004D2   0x250C             MOVS     R5,#+12
   \   000004D4   0xE01A             B.N      ??SDHC_ioctl_67
    733                  }
    734                  else
    735                  {
    736                      /* Set actual ESDHC block size */
    737                      if (! SDHC_is_running())
   \                     ??SDHC_ioctl_66: (+1)
   \   000004D6   0x.... 0x....      BL       SDHC_is_running
   \   000004DA   0x2800             CMP      R0,#+0
   \   000004DC   0xD114             BNE.N    ??SDHC_ioctl_68
    738                      {
    739                          if (*param32_ptr > 0x0FFF)
   \   000004DE   0x6820             LDR      R0,[R4, #+0]
   \   000004E0   0xF5B0 0x5F80      CMP      R0,#+4096
   \   000004E4   0xD301             BCC.N    ??SDHC_ioctl_69
    740                          {
    741                              result = BRTOS_INVALID_PARAMETER;
   \   000004E6   0x250C             MOVS     R5,#+12
   \   000004E8   0xE010             B.N      ??SDHC_ioctl_67
    742                          }
    743                          else
    744                          {
    745                              SDHC_BLKATTR &= (~ SDHC_BLKATTR_BLKSIZE_MASK);
   \                     ??SDHC_ioctl_69: (+1)
   \   000004EA   0x....             LDR.N    R0,??DataTable5_5  ;; 0x400b1004
   \   000004EC   0x6800             LDR      R0,[R0, #+0]
   \   000004EE   0x0B40             LSRS     R0,R0,#+13
   \   000004F0   0x0340             LSLS     R0,R0,#+13
   \   000004F2   0x....             LDR.N    R1,??DataTable5_5  ;; 0x400b1004
   \   000004F4   0x6008             STR      R0,[R1, #+0]
    746                              SDHC_BLKATTR |= SDHC_BLKATTR_BLKSIZE(*param32_ptr);
   \   000004F6   0x....             LDR.N    R0,??DataTable5_5  ;; 0x400b1004
   \   000004F8   0x6800             LDR      R0,[R0, #+0]
   \   000004FA   0x6821             LDR      R1,[R4, #+0]
   \   000004FC   0x04C9             LSLS     R1,R1,#+19       ;; ZeroExtS R1,R1,#+19,#+19
   \   000004FE   0x0CC9             LSRS     R1,R1,#+19
   \   00000500   0x4308             ORRS     R0,R1,R0
   \   00000502   0x....             LDR.N    R1,??DataTable5_5  ;; 0x400b1004
   \   00000504   0x6008             STR      R0,[R1, #+0]
   \   00000506   0xE001             B.N      ??SDHC_ioctl_67
    747                          }
    748                      }
    749                      else
    750                      {
    751                          result = IO_ERROR_DEVICE_BUSY;
   \                     ??SDHC_ioctl_68: (+1)
   \   00000508   0xF640 0x250A      MOVW     R5,#+2570
    752                      }
    753                  }
    754                  break;
   \                     ??SDHC_ioctl_67: (+1)
   \   0000050C   0xE09F             B.N      ??SDHC_ioctl_16
    755              case IO_IOCTL_ESDHC_GET_BUS_WIDTH:
    756                  if (NULL == param32_ptr)
   \                     ??SDHC_ioctl_11: (+1)
   \   0000050E   0x2C00             CMP      R4,#+0
   \   00000510   0xD101             BNE.N    ??SDHC_ioctl_70
    757                  {
    758                      result = BRTOS_INVALID_PARAMETER;
   \   00000512   0x250C             MOVS     R5,#+12
   \   00000514   0xE013             B.N      ??SDHC_ioctl_71
    759                  }
    760                  else
    761                  {
    762                      /* Get actual ESDHC bus width */
    763                      val = (SDHC_PROCTL & SDHC_PROCTL_DTW_MASK) >> SDHC_PROCTL_DTW_SHIFT;
   \                     ??SDHC_ioctl_70: (+1)
   \   00000516   0x....             LDR.N    R0,??DataTable5_6  ;; 0x400b1028
   \   00000518   0x6800             LDR      R0,[R0, #+0]
   \   0000051A   0xF3C0 0x0641      UBFX     R6,R0,#+1,#+2
    764                      if (ESDHC_PROCTL_DTW_1BIT == val)
   \   0000051E   0x2E00             CMP      R6,#+0
   \   00000520   0xD102             BNE.N    ??SDHC_ioctl_72
    765                      {
    766                          *param32_ptr = ESDHC_BUS_WIDTH_1BIT;
   \   00000522   0x2000             MOVS     R0,#+0
   \   00000524   0x6020             STR      R0,[R4, #+0]
   \   00000526   0xE00A             B.N      ??SDHC_ioctl_71
    767                      }
    768                      else if (ESDHC_PROCTL_DTW_4BIT == val)
   \                     ??SDHC_ioctl_72: (+1)
   \   00000528   0x2E01             CMP      R6,#+1
   \   0000052A   0xD102             BNE.N    ??SDHC_ioctl_73
    769                      {
    770                          *param32_ptr = ESDHC_BUS_WIDTH_4BIT;
   \   0000052C   0x2001             MOVS     R0,#+1
   \   0000052E   0x6020             STR      R0,[R4, #+0]
   \   00000530   0xE005             B.N      ??SDHC_ioctl_71
    771                      }
    772                      else if (ESDHC_PROCTL_DTW_8BIT == val)
   \                     ??SDHC_ioctl_73: (+1)
   \   00000532   0x2E10             CMP      R6,#+16
   \   00000534   0xD102             BNE.N    ??SDHC_ioctl_74
    773                      {
    774                          *param32_ptr = ESDHC_BUS_WIDTH_8BIT;
   \   00000536   0x2002             MOVS     R0,#+2
   \   00000538   0x6020             STR      R0,[R4, #+0]
   \   0000053A   0xE000             B.N      ??SDHC_ioctl_71
    775                      }
    776                      else
    777                      {
    778                          result = ESDHC_ERROR_INVALID_BUS_WIDTH;
   \                     ??SDHC_ioctl_74: (+1)
   \   0000053C   0x2505             MOVS     R5,#+5
    779                      }
    780                  }
    781                  break;
   \                     ??SDHC_ioctl_71: (+1)
   \   0000053E   0xE086             B.N      ??SDHC_ioctl_16
    782              case IO_IOCTL_ESDHC_SET_BUS_WIDTH:
    783                  if (NULL == param32_ptr)
   \                     ??SDHC_ioctl_12: (+1)
   \   00000540   0x2C00             CMP      R4,#+0
   \   00000542   0xD101             BNE.N    ??SDHC_ioctl_75
    784                  {
    785                      result = BRTOS_INVALID_PARAMETER;
   \   00000544   0x250C             MOVS     R5,#+12
   \   00000546   0xE033             B.N      ??SDHC_ioctl_76
    786                  }
    787                  else
    788                  {
    789                      /* Set actual ESDHC bus width */
    790                      if (! SDHC_is_running())
   \                     ??SDHC_ioctl_75: (+1)
   \   00000548   0x.... 0x....      BL       SDHC_is_running
   \   0000054C   0x2800             CMP      R0,#+0
   \   0000054E   0xD12D             BNE.N    ??SDHC_ioctl_77
    791                      {
    792                          if (ESDHC_BUS_WIDTH_1BIT == *param32_ptr)
   \   00000550   0x6820             LDR      R0,[R4, #+0]
   \   00000552   0x2800             CMP      R0,#+0
   \   00000554   0xD10A             BNE.N    ??SDHC_ioctl_78
    793                          {
    794                              SDHC_PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   00000556   0x....             LDR.N    R0,??DataTable5_6  ;; 0x400b1028
   \   00000558   0x6800             LDR      R0,[R0, #+0]
   \   0000055A   0xF030 0x0006      BICS     R0,R0,#0x6
   \   0000055E   0x....             LDR.N    R1,??DataTable5_6  ;; 0x400b1028
   \   00000560   0x6008             STR      R0,[R1, #+0]
    795                              SDHC_PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_1BIT);
   \   00000562   0x....             LDR.N    R0,??DataTable5_6  ;; 0x400b1028
   \   00000564   0x6800             LDR      R0,[R0, #+0]
   \   00000566   0x....             LDR.N    R1,??DataTable5_6  ;; 0x400b1028
   \   00000568   0x6008             STR      R0,[R1, #+0]
   \   0000056A   0xE021             B.N      ??SDHC_ioctl_76
    796                          }
    797                          else if (ESDHC_BUS_WIDTH_4BIT == *param32_ptr)
   \                     ??SDHC_ioctl_78: (+1)
   \   0000056C   0x6820             LDR      R0,[R4, #+0]
   \   0000056E   0x2801             CMP      R0,#+1
   \   00000570   0xD10C             BNE.N    ??SDHC_ioctl_79
    798                          {
    799                              SDHC_PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   00000572   0x....             LDR.N    R0,??DataTable5_6  ;; 0x400b1028
   \   00000574   0x6800             LDR      R0,[R0, #+0]
   \   00000576   0xF030 0x0006      BICS     R0,R0,#0x6
   \   0000057A   0x....             LDR.N    R1,??DataTable5_6  ;; 0x400b1028
   \   0000057C   0x6008             STR      R0,[R1, #+0]
    800                              SDHC_PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_4BIT);
   \   0000057E   0x....             LDR.N    R0,??DataTable5_6  ;; 0x400b1028
   \   00000580   0x6800             LDR      R0,[R0, #+0]
   \   00000582   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000586   0x....             LDR.N    R1,??DataTable5_6  ;; 0x400b1028
   \   00000588   0x6008             STR      R0,[R1, #+0]
   \   0000058A   0xE011             B.N      ??SDHC_ioctl_76
    801                          }
    802                          else if (ESDHC_BUS_WIDTH_8BIT == *param32_ptr)
   \                     ??SDHC_ioctl_79: (+1)
   \   0000058C   0x6820             LDR      R0,[R4, #+0]
   \   0000058E   0x2802             CMP      R0,#+2
   \   00000590   0xD10A             BNE.N    ??SDHC_ioctl_80
    803                          {
    804                              SDHC_PROCTL &= (~ SDHC_PROCTL_DTW_MASK);
   \   00000592   0x....             LDR.N    R0,??DataTable5_6  ;; 0x400b1028
   \   00000594   0x6800             LDR      R0,[R0, #+0]
   \   00000596   0xF030 0x0006      BICS     R0,R0,#0x6
   \   0000059A   0x....             LDR.N    R1,??DataTable5_6  ;; 0x400b1028
   \   0000059C   0x6008             STR      R0,[R1, #+0]
    805                              SDHC_PROCTL |= SDHC_PROCTL_DTW(ESDHC_PROCTL_DTW_8BIT);
   \   0000059E   0x....             LDR.N    R0,??DataTable5_6  ;; 0x400b1028
   \   000005A0   0x6800             LDR      R0,[R0, #+0]
   \   000005A2   0x....             LDR.N    R1,??DataTable5_6  ;; 0x400b1028
   \   000005A4   0x6008             STR      R0,[R1, #+0]
   \   000005A6   0xE003             B.N      ??SDHC_ioctl_76
    806                          }
    807                          else
    808                          {
    809                              result = ESDHC_ERROR_INVALID_BUS_WIDTH;
   \                     ??SDHC_ioctl_80: (+1)
   \   000005A8   0x2505             MOVS     R5,#+5
   \   000005AA   0xE001             B.N      ??SDHC_ioctl_76
    810                          }
    811                      }
    812                      else
    813                      {
    814                          result = IO_ERROR_DEVICE_BUSY;
   \                     ??SDHC_ioctl_77: (+1)
   \   000005AC   0xF640 0x250A      MOVW     R5,#+2570
    815                      }
    816                  }
    817                  break;
   \                     ??SDHC_ioctl_76: (+1)
   \   000005B0   0xE04D             B.N      ??SDHC_ioctl_16
    818              case IO_IOCTL_ESDHC_GET_CARD:
    819                  if (NULL == param32_ptr)
   \                     ??SDHC_ioctl_8: (+1)
   \   000005B2   0x2C00             CMP      R4,#+0
   \   000005B4   0xD101             BNE.N    ??SDHC_ioctl_81
    820                  {
    821                      result = BRTOS_INVALID_PARAMETER;
   \   000005B6   0x250C             MOVS     R5,#+12
   \   000005B8   0xE028             B.N      ??SDHC_ioctl_82
    822                  }
    823                  else
    824                  {
    825                      /* 80 clocks to update levels */
    826                      SDHC_SYSCTL |= SDHC_SYSCTL_INITA_MASK;
   \                     ??SDHC_ioctl_81: (+1)
   \   000005BA   0x....             LDR.N    R0,??DataTable5  ;; 0x400b102c
   \   000005BC   0x6800             LDR      R0,[R0, #+0]
   \   000005BE   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   000005C2   0x....             LDR.N    R1,??DataTable5  ;; 0x400b102c
   \   000005C4   0x6008             STR      R0,[R1, #+0]
    827                      while (SDHC_SYSCTL & SDHC_SYSCTL_INITA_MASK)
   \                     ??SDHC_ioctl_83: (+1)
   \   000005C6   0x....             LDR.N    R0,??DataTable5  ;; 0x400b102c
   \   000005C8   0x6800             LDR      R0,[R0, #+0]
   \   000005CA   0x0100             LSLS     R0,R0,#+4
   \   000005CC   0xD4FB             BMI.N    ??SDHC_ioctl_83
    828                          { };
    829          
    830                      /* Update and return actual card status */
    831                      if (SDHC_IRQSTAT & SDHC_IRQSTAT_CRM_MASK)
   \   000005CE   0x....             LDR.N    R0,??DataTable5_2  ;; 0x400b1030
   \   000005D0   0x6800             LDR      R0,[R0, #+0]
   \   000005D2   0x0600             LSLS     R0,R0,#+24
   \   000005D4   0xD508             BPL.N    ??SDHC_ioctl_84
    832                      {
    833                          SDHC_IRQSTAT |= SDHC_IRQSTAT_CRM_MASK;
   \   000005D6   0x....             LDR.N    R0,??DataTable5_2  ;; 0x400b1030
   \   000005D8   0x6800             LDR      R0,[R0, #+0]
   \   000005DA   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000005DE   0x....             LDR.N    R1,??DataTable5_2  ;; 0x400b1030
   \   000005E0   0x6008             STR      R0,[R1, #+0]
    834                          esdhc_info_ptr->CARD = ESDHC_CARD_NONE;
   \   000005E2   0x2000             MOVS     R0,#+0
   \   000005E4   0xF8C9 0x0000      STR      R0,[R9, #+0]
    835                      }
    836                      if (SDHC_PRSSTAT & SDHC_PRSSTAT_CINS_MASK)
   \                     ??SDHC_ioctl_84: (+1)
   \   000005E8   0x....             LDR.N    R0,??DataTable5_1  ;; 0x400b1024
   \   000005EA   0x6800             LDR      R0,[R0, #+0]
   \   000005EC   0x03C0             LSLS     R0,R0,#+15
   \   000005EE   0xD507             BPL.N    ??SDHC_ioctl_85
    837                      {
    838                          if (ESDHC_CARD_NONE == esdhc_info_ptr->CARD)
   \   000005F0   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000005F4   0x2800             CMP      R0,#+0
   \   000005F6   0xD106             BNE.N    ??SDHC_ioctl_86
    839                          {
    840                              esdhc_info_ptr->CARD = ESDHC_CARD_UNKNOWN;
   \   000005F8   0x2001             MOVS     R0,#+1
   \   000005FA   0xF8C9 0x0000      STR      R0,[R9, #+0]
   \   000005FE   0xE002             B.N      ??SDHC_ioctl_86
    841                          }
    842                      }
    843                      else
    844                      {
    845                          esdhc_info_ptr->CARD = ESDHC_CARD_NONE;
   \                     ??SDHC_ioctl_85: (+1)
   \   00000600   0x2000             MOVS     R0,#+0
   \   00000602   0xF8C9 0x0000      STR      R0,[R9, #+0]
    846                      }
    847                      *param32_ptr = esdhc_info_ptr->CARD;
   \                     ??SDHC_ioctl_86: (+1)
   \   00000606   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   0000060A   0x6020             STR      R0,[R4, #+0]
    848                  }
    849                  break;
   \                     ??SDHC_ioctl_82: (+1)
   \   0000060C   0xE01F             B.N      ??SDHC_ioctl_16
    850              case IO_IOCTL_DEVICE_IDENTIFY:
    851                  /* Get ESDHC device parameters */
    852                  param32_ptr[IO_IOCTL_ID_PHY_ELEMENT]  = IO_DEV_TYPE_PHYS_ESDHC;
   \                     ??SDHC_ioctl_5: (+1)
   \   0000060E   0x201C             MOVS     R0,#+28
   \   00000610   0x6020             STR      R0,[R4, #+0]
    853                  param32_ptr[IO_IOCTL_ID_LOG_ELEMENT]  = IO_DEV_TYPE_LOGICAL_MFS;
   \   00000612   0x2004             MOVS     R0,#+4
   \   00000614   0x6060             STR      R0,[R4, #+4]
    854                  param32_ptr[IO_IOCTL_ID_ATTR_ELEMENT] = IO_ESDHC_ATTRIBS;
   \   00000616   0xF44F 0x701E      MOV      R0,#+632
   \   0000061A   0x60A0             STR      R0,[R4, #+8]
    855                  /*
    856                  if (esdhc_fd_ptr->FLAGS & IO_O_RDONLY)
    857                  {
    858                      param32_ptr[IO_IOCTL_ID_ATTR_ELEMENT] &= (~ IO_DEV_ATTR_WRITE);
    859                  }
    860                  */
    861                  break;
   \   0000061C   0xE017             B.N      ??SDHC_ioctl_16
    862              case IO_IOCTL_FLUSH_OUTPUT:
    863                  /* Wait for transfer complete */
    864                  SDHC_status_wait (SDHC_IRQSTAT_TC_MASK);
   \                     ??SDHC_ioctl_4: (+1)
   \   0000061E   0x2002             MOVS     R0,#+2
   \   00000620   0x.... 0x....      BL       SDHC_status_wait
    865                  if (SDHC_IRQSTAT & (SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK))
   \   00000624   0x....             LDR.N    R0,??DataTable5_2  ;; 0x400b1030
   \   00000626   0x6800             LDR      R0,[R0, #+0]
   \   00000628   0xF410 0x0FE0      TST      R0,#0x700000
   \   0000062C   0xD006             BEQ.N    ??SDHC_ioctl_87
    866                  {
    867                      SDHC_IRQSTAT |= SDHC_IRQSTAT_DEBE_MASK | SDHC_IRQSTAT_DCE_MASK | SDHC_IRQSTAT_DTOE_MASK;
   \   0000062E   0x....             LDR.N    R0,??DataTable5_2  ;; 0x400b1030
   \   00000630   0x6800             LDR      R0,[R0, #+0]
   \   00000632   0xF450 0x00E0      ORRS     R0,R0,#0x700000
   \   00000636   0x....             LDR.N    R1,??DataTable5_2  ;; 0x400b1030
   \   00000638   0x6008             STR      R0,[R1, #+0]
    868                      result = ESDHC_ERROR_DATA_TRANSFER;
   \   0000063A   0x2504             MOVS     R5,#+4
    869                  }
    870                  SDHC_IRQSTAT |= SDHC_IRQSTAT_TC_MASK | SDHC_IRQSTAT_BRR_MASK | SDHC_IRQSTAT_BWR_MASK;
   \                     ??SDHC_ioctl_87: (+1)
   \   0000063C   0x....             LDR.N    R0,??DataTable5_2  ;; 0x400b1030
   \   0000063E   0x6800             LDR      R0,[R0, #+0]
   \   00000640   0xF050 0x0032      ORRS     R0,R0,#0x32
   \   00000644   0x....             LDR.N    R1,??DataTable5_2  ;; 0x400b1030
   \   00000646   0x6008             STR      R0,[R1, #+0]
    871                  break;
   \   00000648   0xE001             B.N      ??SDHC_ioctl_16
    872              default:
    873                  result = IO_ERROR_INVALID_IOCTL_CMD;
   \                     ??SDHC_ioctl_15: (+1)
   \   0000064A   0xF640 0x2509      MOVW     R5,#+2569
    874                  break;
    875              }
    876              return result;
   \                     ??SDHC_ioctl_16: (+1)
   \   0000064E   0x0028             MOVS     R0,R5
   \                     ??SDHC_ioctl_1: (+1)
   \   00000650   0xB009             ADD      SP,SP,#+36
   \   00000652   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    877          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x400B102C         DC32     0x400b102c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x400B1024         DC32     0x400b1024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x400B1030         DC32     0x400b1030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x01008000         DC32     0x1008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x400B10C0         DC32     0x400b10c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x400B1004         DC32     0x400b1004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x400B1028         DC32     0x400b1028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x400B1044         DC32     0x400b1044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x0005CC60         DC32     0x5cc60

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     core_clk_khz_sd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x4004D004         DC32     0x4004d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x4004D008         DC32     0x4004d008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x4004D00C         DC32     0x4004d00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x4004D010         DC32     0x4004d010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x4004D014         DC32     0x4004d014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_17:
   \   00000000   0x007F00B3         DC32     0x7f00b3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_18:
   \   00000000   0x400B1034         DC32     0x400b1034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_19:
   \   00000000   0x........         DC32     ESDHC_COMMAND_XFERTYP

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_20:
   \   00000000   0x400B1008         DC32     0x400b1008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_21:
   \   00000000   0x400B1000         DC32     0x400b1000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_22:
   \   00000000   0x400B100C         DC32     0x400b100c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_23:
   \   00000000   0x000E0001         DC32     0xe0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_24:
   \   00000000   0x400B1010         DC32     0x400b1010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_25:
   \   00000000   0x400B1014         DC32     0x400b1014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_26:
   \   00000000   0x400B1018         DC32     0x400b1018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_27:
   \   00000000   0x400B101C         DC32     0x400b101c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_28:
   \   00000000   0x........         DC32     SDHC_Info

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_29:
   \   00000000   0x........         DC32     SDHC_Device

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_30:
   \   00000000   0x........         DC32     K60_SDHC0_init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_31:
   \   00000000   0x000249F0         DC32     0x249f0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_32:
   \   00000000   0x40300000         DC32     0x40300000

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SDHC_init
         8   -> SDHC_set_baudrate
      72   SDHC_ioctl
        72   -> SDHC_init
        72   -> SDHC_is_running
        72   -> SDHC_send_command
        72   -> SDHC_set_baudrate
        72   -> SDHC_status_wait
       0   SDHC_is_running
      16   SDHC_send_command
        16   -> SDHC_status_wait
      16   SDHC_set_baudrate
       0   SDHC_status_wait


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_20
       4  ??DataTable5_21
       4  ??DataTable5_22
       4  ??DataTable5_23
       4  ??DataTable5_24
       4  ??DataTable5_25
       4  ??DataTable5_26
       4  ??DataTable5_27
       4  ??DataTable5_28
       4  ??DataTable5_29
       4  ??DataTable5_3
       4  ??DataTable5_30
       4  ??DataTable5_31
       4  ??DataTable5_32
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
     256  ESDHC_COMMAND_XFERTYP
       8  K60_SDHC0_init
      20  SDHC_Card
       8  SDHC_Device
     516  SDHC_Info
       4  SDHC_Init
     252  SDHC_init
    1622  SDHC_ioctl
      24  SDHC_is_running
     388  SDHC_send_command
     156  SDHC_set_baudrate
      16  SDHC_status_wait
       4  core_clk_khz_sd

 
   548 bytes in section .bss
     4 bytes in section .data
   264 bytes in section .rodata
 2 590 bytes in section .text
 
 2 590 bytes of CODE  memory
   264 bytes of CONST memory
   552 bytes of DATA  memory

Errors: none
Warnings: 1
